2020-04-17 10:15:30.945 INFO  [restartedMain]com.wcj.BlogApplication.logStarting:55 -Starting BlogApplication on LAPTOP-SF80F1HO with PID 41044 (D:\MyBlog\blog\target\classes started by 邬成军 in D:\MyBlog\blog)
2020-04-17 10:15:30.951 INFO  [restartedMain]com.wcj.BlogApplication.logStartupProfileInfo:655 -The following profiles are active: pro
2020-04-17 10:15:31.000 INFO  [restartedMain]o.s.b.devtools.env.DevToolsPropertyDefaultsPostProcessor.logTo:225 -Devtools property defaults active! Set 'spring.devtools.add-properties' to 'false' to disable
2020-04-17 10:15:31.000 INFO  [restartedMain]o.s.b.devtools.env.DevToolsPropertyDefaultsPostProcessor.logTo:225 -For additional web related logging consider setting the 'logging.level.web' property to 'DEBUG'
2020-04-17 10:15:31.825 INFO  [restartedMain]o.s.d.repository.config.RepositoryConfigurationDelegate.registerRepositoriesIn:127 -Bootstrapping Spring Data MongoDB repositories in DEFAULT mode.
2020-04-17 10:15:31.922 INFO  [restartedMain]o.s.d.repository.config.RepositoryConfigurationDelegate.registerRepositoriesIn:187 -Finished Spring Data repository scanning in 90ms. Found 4 MongoDB repository interfaces.
2020-04-17 10:15:32.333 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'shiroConfig' of type [com.wcj.config.ShiroConfig$$EnhancerBySpringCGLIB$$f1dd38d9] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:32.355 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'hashedCredentialsMatcher' of type [org.apache.shiro.authc.credential.HashedCredentialsMatcher] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:32.383 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mybatis-org.mybatis.spring.boot.autoconfigure.MybatisProperties' of type [org.mybatis.spring.boot.autoconfigure.MybatisProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:32.394 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration' of type [org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration$$EnhancerBySpringCGLIB$$4e8f3a80] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:32.400 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceAutoConfigure' of type [com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceAutoConfigure$$EnhancerBySpringCGLIB$$3566dec2] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:32.404 INFO  [restartedMain]c.a.d.s.boot.autoconfigure.DruidDataSourceAutoConfigure.dataSource:56 -Init DruidDataSource
2020-04-17 10:15:32.455 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'spring.datasource-org.springframework.boot.autoconfigure.jdbc.DataSourceProperties' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:32.483 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'com.alibaba.druid.spring.boot.autoconfigure.stat.DruidFilterConfiguration' of type [com.alibaba.druid.spring.boot.autoconfigure.stat.DruidFilterConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:32.511 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'statFilter' of type [com.alibaba.druid.filter.stat.StatFilter] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:35.920 INFO  [restartedMain]com.alibaba.druid.pool.DruidDataSource.init:930 -{dataSource-1} inited
2020-04-17 10:15:35.921 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'dataSource' of type [com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceWrapper] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:35.994 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:36.386 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'sqlSessionFactory' of type [org.apache.ibatis.session.defaults.DefaultSqlSessionFactory] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:36.397 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'sqlSessionTemplate' of type [org.mybatis.spring.SqlSessionTemplate] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:36.406 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'adminMapper' of type [org.mybatis.spring.mapper.MapperFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:36.412 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'adminMapper' of type [com.sun.proxy.$Proxy92] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:36.418 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'adminServiceImpl' of type [com.wcj.service.impl.AdminServiceImpl] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:36.427 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'userMapper' of type [org.mybatis.spring.mapper.MapperFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:36.430 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'userMapper' of type [com.sun.proxy.$Proxy95] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:36.461 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#72450783' of type [org.springframework.beans.factory.config.PropertiesFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:36.466 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#72450783' of type [java.util.Properties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:36.508 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#2791f16e' of type [org.springframework.data.repository.core.support.PropertiesBasedNamedQueries] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:36.514 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#23868dc6' of type [org.springframework.data.repository.core.support.RepositoryFragmentsFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:36.519 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#23868dc6' of type [org.springframework.data.repository.core.support.RepositoryComposition$RepositoryFragments] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:36.544 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'spring.data.mongodb-org.springframework.boot.autoconfigure.mongo.MongoProperties' of type [org.springframework.boot.autoconfigure.mongo.MongoProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:36.546 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.data.mongo.MongoDbFactoryDependentConfiguration' of type [org.springframework.boot.autoconfigure.data.mongo.MongoDbFactoryDependentConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:36.549 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.data.mongo.MongoDbFactoryConfiguration' of type [org.springframework.boot.autoconfigure.data.mongo.MongoDbFactoryConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:36.553 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration' of type [org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:36.655 INFO  [restartedMain]org.mongodb.driver.cluster.info:71 -Cluster created with settings {hosts=[121.199.34.159:27017], mode=MULTIPLE, requiredClusterType=UNKNOWN, serverSelectionTimeout='30000 ms', maxWaitQueueSize=500}
2020-04-17 10:15:36.656 INFO  [restartedMain]org.mongodb.driver.cluster.info:71 -Adding discovered server 121.199.34.159:27017 to client view of cluster
2020-04-17 10:15:36.758 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongo' of type [com.mongodb.MongoClient] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:36.778 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongoDbFactory' of type [org.springframework.data.mongodb.core.SimpleMongoDbFactory] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:36.798 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.data.mongo.MongoDataConfiguration' of type [org.springframework.boot.autoconfigure.data.mongo.MongoDataConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:36.900 INFO  [cluster-ClusterId{value='5e99114899add37bb08e3d67', description='null'}-121.199.34.159:27017]org.mongodb.driver.connection.info:71 -Opened connection [connectionId{localValue:1, serverValue:286}] to 121.199.34.159:27017
2020-04-17 10:15:36.955 INFO  [cluster-ClusterId{value='5e99114899add37bb08e3d67', description='null'}-121.199.34.159:27017]org.mongodb.driver.cluster.info:71 -Monitor thread successfully connected to server with description ServerDescription{address=121.199.34.159:27017, type=STANDALONE, state=CONNECTED, ok=true, version=ServerVersion{versionList=[4, 2, 5]}, minWireVersion=0, maxWireVersion=8, maxDocumentSize=16777216, logicalSessionTimeoutMinutes=30, roundTripTimeNanos=50497600}
2020-04-17 10:15:36.958 INFO  [cluster-ClusterId{value='5e99114899add37bb08e3d67', description='null'}-121.199.34.159:27017]org.mongodb.driver.cluster.info:71 -Discovered cluster type of STANDALONE
2020-04-17 10:15:37.036 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongoCustomConversions' of type [org.springframework.data.mongodb.core.convert.MongoCustomConversions] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:37.104 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongoMappingContext' of type [org.springframework.data.mongodb.core.mapping.MongoMappingContext] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:37.224 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mappingMongoConverter' of type [org.springframework.data.mongodb.core.convert.MappingMongoConverter] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:37.378 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongoTemplate' of type [org.springframework.data.mongodb.core.MongoTemplate] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:37.940 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'blogCollectionDao' of type [org.springframework.data.mongodb.repository.support.MongoRepositoryFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:37.979 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'blogCollectionDao' of type [com.sun.proxy.$Proxy110] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:38.064 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'typeMapper' of type [org.mybatis.spring.mapper.MapperFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:38.067 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'typeMapper' of type [com.sun.proxy.$Proxy112] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:38.074 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#3174e5c5' of type [org.springframework.beans.factory.config.PropertiesFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:38.075 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#3174e5c5' of type [java.util.Properties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:38.078 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#55d58c37' of type [org.springframework.data.repository.core.support.PropertiesBasedNamedQueries] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:38.081 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#1df6ccab' of type [org.springframework.data.repository.core.support.RepositoryFragmentsFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:38.082 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#1df6ccab' of type [org.springframework.data.repository.core.support.RepositoryComposition$RepositoryFragments] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:38.120 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'commentDao' of type [org.springframework.data.mongodb.repository.support.MongoRepositoryFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:38.122 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'commentDao' of type [com.sun.proxy.$Proxy116] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:38.240 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'userServiceImpl' of type [com.wcj.service.impl.UserServiceImpl] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:38.295 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'adminRealm' of type [com.wcj.realm.AdminRealm] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:38.422 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'securityManager' of type [org.apache.shiro.web.mgt.DefaultWebSecurityManager] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-17 10:15:39.275 INFO  [restartedMain]o.s.boot.web.embedded.tomcat.TomcatWebServer.initialize:92 -Tomcat initialized with port(s): 1000 (http)
2020-04-17 10:15:39.294 INFO  [restartedMain]org.apache.coyote.http11.Http11NioProtocol.log:173 -Initializing ProtocolHandler ["http-nio-1000"]
2020-04-17 10:15:39.295 INFO  [restartedMain]org.apache.catalina.core.StandardService.log:173 -Starting service [Tomcat]
2020-04-17 10:15:39.296 INFO  [restartedMain]org.apache.catalina.core.StandardEngine.log:173 -Starting Servlet engine: [Apache Tomcat/9.0.31]
2020-04-17 10:15:39.301 INFO  [restartedMain]org.apache.catalina.core.AprLifecycleListener.log:173 -Loaded APR based Apache Tomcat Native library [1.2.23] using APR version [1.7.0].
2020-04-17 10:15:39.302 INFO  [restartedMain]org.apache.catalina.core.AprLifecycleListener.log:173 -APR capabilities: IPv6 [true], sendfile [true], accept filters [false], random [true].
2020-04-17 10:15:39.302 INFO  [restartedMain]org.apache.catalina.core.AprLifecycleListener.log:173 -APR/OpenSSL configuration: useAprConnector [false], useOpenSSL [true]
2020-04-17 10:15:39.323 INFO  [restartedMain]org.apache.catalina.core.AprLifecycleListener.log:173 -OpenSSL successfully initialized [OpenSSL 1.1.1c  28 May 2019]
2020-04-17 10:15:39.594 INFO  [restartedMain]o.a.catalina.core.ContainerBase.[Tomcat].[localhost].[/].log:173 -Initializing Spring embedded WebApplicationContext
2020-04-17 10:15:39.594 INFO  [restartedMain]org.springframework.web.context.ContextLoader.prepareWebApplicationContext:284 -Root WebApplicationContext: initialization completed in 8593 ms
2020-04-17 10:15:39.858 INFO  [restartedMain]o.s.boot.devtools.autoconfigure.OptionalLiveReloadServer.startServer:58 -LiveReload server is running on port 35729
2020-04-17 10:15:42.192 INFO  [restartedMain]org.apache.coyote.http11.Http11NioProtocol.log:173 -Starting ProtocolHandler ["http-nio-1000"]
2020-04-17 10:15:42.249 INFO  [restartedMain]o.s.boot.web.embedded.tomcat.TomcatWebServer.start:204 -Tomcat started on port(s): 1000 (http) with context path ''
2020-04-17 10:15:42.254 INFO  [restartedMain]com.wcj.BlogApplication.logStarted:61 -Started BlogApplication in 11.875 seconds (JVM running for 13.658)
2020-04-17 10:16:03.265 INFO  [http-nio-1000-exec-2]o.a.catalina.core.ContainerBase.[Tomcat].[localhost].[/].log:173 -Initializing Spring DispatcherServlet 'dispatcherServlet'
2020-04-17 10:16:03.265 INFO  [http-nio-1000-exec-2]org.springframework.web.servlet.DispatcherServlet.initServletBean:525 -Initializing Servlet 'dispatcherServlet'
2020-04-17 10:16:03.286 INFO  [http-nio-1000-exec-2]org.springframework.web.servlet.DispatcherServlet.initServletBean:547 -Completed initialization in 20 ms
2020-04-17 10:16:03.328 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /admin/getInfo
2020-04-17 10:16:03.328 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /rotation-picture/listFront
2020-04-17 10:16:03.328 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-17 10:16:03.328 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-17 10:16:03.330 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-17 10:16:03.330 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-17 10:16:03.333 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.RotationPictureController.getRotationPictureListFront
2020-04-17 10:16:03.333 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.AdminController.getInfo
2020-04-17 10:16:03.334 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-17 10:16:03.334 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-17 10:16:03.427 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/list
2020-04-17 10:16:03.428 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-17 10:16:03.428 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-17 10:16:03.428 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogList
2020-04-17 10:16:03.429 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=15, totalPage=0, totalCount=0, list=[], params={}, sortColumn=created_time, sortMethod=DESC)]
2020-04-17 10:16:03.506 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/recommendRead
2020-04-17 10:16:03.506 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listFront
2020-04-17 10:16:03.507 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/getTotal
2020-04-17 10:16:03.507 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-17 10:16:03.507 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-17 10:16:03.507 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-17 10:16:03.507 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-17 10:16:03.508 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-17 10:16:03.508 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.recommendRead
2020-04-17 10:16:03.508 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-17 10:16:03.508 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-17 10:16:03.508 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeLists
2020-04-17 10:16:03.508 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getTotal
2020-04-17 10:16:03.509 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-17 10:16:03.509 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-17 10:16:03.514 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 187
2020-04-17 10:16:03.516 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 189
2020-04-17 10:16:03.608 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 102
2020-04-17 10:16:03.616 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":15,"msg":"操作成功!"}
2020-04-17 10:16:03.618 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 112
2020-04-17 10:16:03.618 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 112
2020-04-17 10:16:03.624 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"header":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMSKACehsAACHOzTvceE295.jpg","id":1,"name":"小屋","signature":"时光好不经用，转眼已是半生","username":"admin"},"msg":"操作成功!"}
2020-04-17 10:16:03.625 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"createdTime":"2020-04-09 13:31:10","enable":1,"rotationId":3,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PI5KAYzGaAAGfH751PIw644.jpg"},{"createdTime":"2020-04-09 13:31:20","enable":1,"rotationId":4,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PI6aAZIz1AASCO4hlpJI295.jpg"},{"createdTime":"2020-04-09 13:37:02","enable":1,"rotationId":9,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJPyAbm8fAAG9gfO8lxE28.jpeg"},{"createdTime":"2020-04-09 13:41:30","enable":1,"rotationId":10,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJgeAeG8wAAS2pjJC5QU547.jpg"},{"createdTime":"2020-04-09 13:41:38","enable":1,"rotationId":11,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhGAQFZbAAP2OOBWb6k310.jpg"},{"createdTime":"2020-04-09 13:41:50","enable":1,"rotationId":12,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhyABMZCAAG7doyXiM8109.jpg"},{"createdTime":"2020-04-09 13:41:59","enable":1,"rotationId":13,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJiWAL7BoAARW3_O3ISw651.jpg"}],"msg":"操作成功!"}
2020-04-17 10:16:03.627 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":1,"typeName":"Linux"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":2,"typeName":"Docker"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"SpringBoot"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":4,"typeName":"Mybatis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":5,"typeName":"爬虫"},{"deleted":0,"enable":1,"typeBlogCount":2,"typeId":6,"typeName":"博客开发和维护总结"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":7,"typeName":"CSS"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"JavaScript"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Vue"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":10,"typeName":"随笔"},{"deleted":0,"enable":1,"typeBlogCount":9,"typeId":11,"typeName":"java面试篇"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":12,"typeName":"算法题"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":13,"typeName":"JDK源码阅读"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":14,"typeName":"redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":15,"typeName":"MongoDB"}],"msg":"操作成功!"}
2020-04-17 10:16:03.633 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1247745014683947008","blogRead":21,"blogTitle":"博客开发总结（一）-----之数据库设计篇","createdTime":"2020-04-08 04:36:07","typeName":"博客开发和维护总结"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1248605157059497984","blogRead":17,"blogTitle":"面试（二）------之JAVA基础篇","createdTime":"2020-04-10 13:34:02","typeName":"java面试篇"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1247867141693128704","blogRead":7,"blogTitle":"闲谈前后端分离开发","createdTime":"2020-04-08 12:41:25","typeName":"随笔"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1248224512563068928","blogRead":7,"blogTitle":"面试（一）------之JVM篇","createdTime":"2020-04-09 12:21:30","typeName":"java面试篇"},{"blogCollection":0,"blogComment":1,"blogGoods":0,"blogId":"1250774653945802752","blogRead":5,"blogTitle":"面试（八）------之分布式缓存的原理及应用","createdTime":"2020-04-16 13:14:51","typeName":"java面试篇"}],"msg":"操作成功!"}
2020-04-17 10:16:04.142 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /link/list
2020-04-17 10:16:04.142 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /music/listFront
2020-04-17 10:16:04.143 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-17 10:16:04.144 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-17 10:16:04.144 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-17 10:16:04.144 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-17 10:16:04.145 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.LinkController.getLinkList
2020-04-17 10:16:04.145 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.MusicController.getMusicList
2020-04-17 10:16:04.145 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-17 10:16:04.145 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-17 10:16:04.257 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 115
2020-04-17 10:16:04.263 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 121
2020-04-17 10:16:04.263 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"artist":"周深","cover":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMh2AFeEFAAAZaWcYmAM180.jpg","id":1,"lrc":"[00:00.37]周深 - 直破穹苍 (《斗破苍穹》动画第三季主题曲)\n[00:02.79]作词：冥凰\n[00:03.86]作曲：李建衡\n[00:05.19]编曲：崔博源、李建衡\n[00:07.13]人声录制：徐威@上海V-Studio\n[00:09.23]监唱：徐威@上海V-Studio\n[00:11.38]混音：周天澈@Studio21A\n[00:24.13]有没有想过 穿越这片沙漠\n[00:32.21]前方是什么\n[00:35.16]是就此陨落\n[00:37.97]还是抓牢命运脉搏\n[00:45.38]他曾经 爱过 恨过 痛过\n[00:51.07]直到望见远处那抹焰火\n[00:56.73]也许这 是祸 是过 是错\n[01:02.41]仍不害怕 去烧灼\n[01:08.50]管那六合八荒 斗一场\n[01:14.06]焰分噬浪谁能抗\n[01:19.28]漫却这漫漫险关 莫登攀\n[01:24.88]他欲乘风 直破穹苍\n[01:43.04]太多的纠葛 太多悲欢离合\n[01:51.39]要人太执着\n[01:54.21]该如何选择\n[01:57.02]才能看清是非漩涡\n[02:04.58]他曾经 哭过 泪过 笑过\n[02:10.16]直到紧握手心那抹焰火\n[02:15.77]走遍这 荒山 大漠 湖泊\n[02:21.49]仍不退缩 去冲破\n[02:27.44]管那龙潭虎穴 斗一场\n[02:32.72]生死福祸也跌宕\n[02:38.28]漫却他太多如果 都过往\n[02:43.86]还来惊诧 满堂\n[02:50.00]管那六合八荒 斗一场\n[02:55.22]焰分噬浪谁能抗\n[03:00.85]漫却这漫漫险关 莫登攀\n[03:06.51]他欲乘风 直破穹苍","name":"直破苍穹","url":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMlWAC1FrAr8ypaThmW479.flac"},{"artist":"冷鸢","cover":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMnWAa32EAABwmk6a5Cs834.jpg","id":2,"lrc":"你是信的开头诗的内容\n童话的结尾\n你是理所当然的奇迹\n你是月色真美\n你是圣诞老人送给我\n好孩子的礼物\n你是三千美丽世界里\n我的一瓢水\n所以让我再靠近一点点\n因为你太温暖\n我会再变得坚强一点点\n因为你太柔软\n交换无名指金色的契约\n给彼此岁月\n说好从今以后都牵着手\n因为要走很远\n你是我万水千山的冒险\n要找的标记点\n你是分割我人生的线\n又将它们相连\n你是前世千次的回眸\n虔诚牵的手\n你是其余所有的一切\n是我的世界\n所以请你再闪亮一点点\n尽管我太平凡\n我会再变得柔软一点点\n因为你太敏感\n交换无名指金色的契约\n给彼此岁月\n说好从今以后都牵着手\n不管要走多远\n让我再靠近一点点\n因为你太温暖\n我会再变得坚强一点点\n因为你太柔软\n交换无名指金色的契约\n给彼此岁月\n说好从今以后都牵着手\n因为要走很远","name":"勾指起誓","url":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMomAGXdvAHZQ_9pwL9c866.mp3"}],"msg":"操作成功!"}
2020-04-17 10:16:04.268 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"createdTime":"2020-04-08 02:11:26","linkId":1,"linkName":"百度","linkUrl":"www.baidu.com","updateTime":"2020-04-08 02:11:26","version":1}],"msg":"操作成功!"}
2020-04-17 10:16:04.364 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 937
2020-04-17 10:16:04.385 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogContent":"<h2>问题描述：</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; <strong>之前还没有注意到，直到最近两天写博客的时候，发现博客的创建时间信息和实际时间对不上号，总是早了八个小时，一开始以为是项目中没有配置时区的问题，所以看了一下项目的配置，结果发现数据库连接中加入了\"serverTimezone=GMT%2B8\"；所以想到的是不是哪个地方配置了什么，导致servrTimezone的配</strong><strong>置失效了，然后又试了一下网上提供的两种方法，很幸运的都失败了哈哈，之后就考虑到是不是mysql数据库本身的时区问题，然后修改了mysql本身的时区解决了这个问题。在这里总结一下</strong></p>\n<h2><strong>问题的具体情况（以添加一篇博客为例）</strong></h2>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 我这里添加博客的时候，前台传回来的数据中只有博客的内容，标题等信息，并不包括创建时间的信息，而后台进行数据保存逻辑的时候，也并没有往实体中的createdTime字段添加new Date（）信息，而是让数据库的ceated_time字段根据当前时间自动生成时间信息（<span style=\"background-color: #ffcc00;\">因此不是根据数据库自动生成时间信息的小伙伴</span>，</strong><strong><span style=\"background-color: #ffcc00;\">只需要看看常用解决办法即可</span>）</strong></p>\n<h2><strong>常用解决办法</strong></h2>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;一，在数据库连接url中加入serverTimezone=GMT%2B8,如下：</strong></p>\n<pre class=\"language-markup\"><code>url: jdbc:mysql://localhost:3306/blog?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>二，springboot项目中也可以在yml文件中进行如下配置：</strong></p>\n<pre class=\"language-markup\"><code>spring:\n   jackson:\n      time-zone: GMT+8</code></pre>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 三，相对比较麻烦，也是不建议使用的一种方法（要是实体类很多，怕是添加起来会很难受的哦），即在实体类的时间字段上添加注解如下：</strong></p>\n<pre class=\"language-markup\"><code>@JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\",timezone = \"GMT+8\")\n    private String createdTime;</code></pre>\n<h2><strong>我的解决办法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;因为博主试了上面的所有办法，发现都无效，因此就考虑到是不是mysql数据库本身的时区问题，然后一测试，发现果然是这样的。博主的项目是部署在docker上的，因此详细步骤可能不具备参考性，这里挑重点的说：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;首先，命令行进入mysql：mysql&nbsp; -uroot&nbsp; &nbsp;-p&nbsp; 回车，然后输入mysql的密码进入mysql。<span style=\"background-color: #ffcc00;\">注意进入到mysql之后输入命令都要以；结尾或者\\g结尾哦</span></strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;然后：select now();&nbsp; &nbsp;查看mysql的当前时间，到这里和当前的真实时间对比一下就知道是否是mysql本身的时区问题了（下面是该命令显示界面，然后我发现果然是mysql的问题）</strong></p>\n<pre class=\"language-markup\"><code>mysql&gt; select now();\n+---------------------+\n| now()               |\n+---------------------+\n| 2020-04-16 14:24:38 |\n+---------------------+\n</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>之后，在查看mysql的时区变量：show&nbsp; variables like&nbsp; \"%time_zone%\";&nbsp; （这里就发现了问题，mysql这里默认采用的UTC，及世界通用时间，正好这个时间比北京东八区的时间少了八个小时）</strong></p>\n<pre class=\"language-markup\"><code>mysql&gt; show variables like \"%time_zone\";\n+------------------+--------+\n| Variable_name    | Value  |\n+------------------+--------+\n| system_time_zone | UTC    |\n| time_zone        | SYSTEM |\n+------------------+--------+</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>修改mysql的时区</strong></p>\n<pre class=\"language-markup\"><code>mysql&gt; set global time_zone = '+08:00';\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql&gt; set time_zone = '+08:00';\nQuery OK, 0 affected (0.00 sec)</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; <strong>再刷新一下即可：</strong></p>\n<pre class=\"language-markup\"><code>mysql&gt; flush privileges;\nQuery OK, 0 rows affected (0.02 sec)</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>最后，再查看一下当前的时区设置：show&nbsp; varibales like \"%time_zone%\";&nbsp; 发现已经在UTC时间基础上加了8个小时</strong></p>\n<pre class=\"language-markup\"><code>+------------------+--------+\n| Variable_name    | Value  |\n+------------------+--------+\n| system_time_zone | UTC    |\n| time_zone        | +08:00 |\n+------------------+--------+</code></pre>\n<p>&nbsp;</p>\n<h1>水平有限，如果不对，可以探讨交流啦！</h1>","blogGoods":0,"blogId":"1250802898447667200","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6YdI6ARhHKAAMyt4z7zK450.jpeg","blogRead":4,"blogRemark":"项目中的时区问题","blogTitle":"项目中的时区问题","createdTime":"2020-04-16 23:07:05","typeName":"博客开发和维护总结","updateTime":"2020-04-16 23:14:46"},{"blogCollection":0,"blogComment":1,"blogContent":"<h2><strong>一，分布式缓存</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;进程内缓存：对于用户信息，热点数据等信息，访问比较频繁，我们将其存放进入缓存，用户查询数据的时候直接从内存种读取，而不需要从数据库查询，既降低了数据库的负载，同时又提升了查询效率。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;分布式缓存：对于单点web应用，我们使用进程内缓存就足够了，但是对于分布式系统，数据库是部署在多个服务器上分布式数据库，缓存则是部署在多个服务器上的分布式缓存，并且缓存数据存在备份，当一个缓存服务挂掉之后，可以立即启用备份的缓存进行工作（高可用）。</strong></p>\n<h2><strong>二， redis的基本数据类型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;String，hash，List，Set，Zset</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;基本数据类型的基本命令见redis篇：<a href=\"http://localhost:1002/info/1249588251598041088\">http://localhost:1002/info/1249588251598041088</a></strong></p>\n<h2><strong>三，redis管道</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;客户端发出一个redis命令请求之后，会监控socket，客户端处于阻塞状态，直到服务器端返回结果，客户端才可以继续发出下一个请求。且在分布式系统中，redis是部署在不同的服务器上，这样服务器之间的数据传输还会有一定的延迟，redis的性能瓶颈就是在网络延迟上 。redis管道机制，即客户端发出一个请求之</strong><strong>后，可以不等服务器端返回结果就发送下一个请求，然后批量的接收服务器端返回的结果。这样客户端批量发出请求，服务器端接</strong><strong>收到批量请</strong><strong>求之后，进行处理返回批量数据。这样提高了redis的性能。</strong></p>\n<h2><strong>四，redis事务</strong></h2>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>基本命令（multi开启事务，exec执行事务，discard取消事务，watch监听某个key的变化，unwatch取消监听所有key的变化）</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;事务基本流程：客户端执行multi命令开启事务</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;客户端提交命令到事务</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;redis将客户端请求放入事务队列等待</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;服务器返回QURUD，表明命令已经进入事务</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;客户端通过exec执行事务</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;执行事务的过程中，如果有某个命令错误，则其它命令继续执行，不会回滚。</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;服务器端向客户端返回事务的执行结果</strong></p>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong></p>\n<h2><strong>五， redis的发布，订阅</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;发布者向频道发布消息，订阅者从频道获取消息（<span style=\"background-color: #ffcc00;\">有待补充</span>）</strong></p>\n<h2><strong>六，redis集群数据复制原理</strong></h2>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;从数据库（slave）发出数据同步请求SYNC给主数据库（master）</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;主数据库接收到从数据库的请求，进行快照，并将快照期间的命令缓存起来，生成.rdb文件</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;主数据库将.rdb文件发送给从数据库</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;从数据库接收到.rdb文件，载入文件进入本地</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;从数据库执行快照，将数据写入内存，即初始化</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;从数据库初始化完成后，主数据接收到写请求之后，会将写请求发送给从数据库，实现数据的一致性</strong></p>\n<h2><strong>七，</strong><strong>redis持久化</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;redis持久化有rdb和aof两种，rdb即采用快照的方式，每隔一定的时间，进行依次数据的快照，对于大数据集的数据处理较快，但是对于数据的完整性要求较低。aof方式是采用日志的形式，将写操作的命令都存于aof文件中，启动服务的时候直接将aof中的命令按顺序执行用以构建原始数据集，但是速度较慢，</strong><strong>且aof文件的大小要比rdb文件大。如果两种方式都开启，则启动服务的时候默认采用aof的方式进行数据恢复。</strong></p>\n<h2><strong>八， redis的集群模式及工作原理</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;主从模式：中心化，所有的写请求都发送到主数据库，读操作分发给从数据库，分担主句库的压力。但是缺陷很明显，如果主数据库宕机，则从数据库必须要阻塞等待，或者手动切换从数据库为主数据库？</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;哨兵模式：即主数据库宕机，自动选举从数据库。设置一个哨兵监视集群的运行状态，如果主数据库宕机，哨兵会依据投票机制从数据库中选举出一个主数据替换宕机的主数据库。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;集群模式：redis集群实现了redis的数据分片和数据复制能力。数据分片能够让我们对redis进行横向扩展，提升集群的吞吐量。数据复制能力，在一些节点挂掉之后，集群仍然能够对外提供服务。</strong></p>\n<h2><strong>九，redis整合springboot见redis篇</strong></h2>\n<h2><strong>十，分布式缓存设计的核心问题</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;缓存预热：用户请求数据前先将数据保存到缓存中。通常的方法是系统启动加载，定时加载</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;缓存更新：即当数据发生变化的时候，对缓存中的数据进行更改</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;缓存淘汰策略：FIFO（先进先出，即先淘汰时间长远的缓存），LRU（最近最少使用，即判断缓存最近被使用的时间，淘汰离被使用时间最远时间的缓存），LFU（最不经常使用，即在一段时间内，被使用次数最少的缓存淘汰）</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;缓存雪崩：即缓存中同一时间有大量的数据失效，导致用户请求直接访问数据库，增大数据库的负荷，导致数据库宕机甚至整个系统的崩溃。</strong><strong>&nbsp;设置随机的失效时间，缓存更新，请求加锁</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;缓存穿透：即请求一条缓存中没有的数据，则会直接访问数据库，如果同一时间大量不存在的key访问缓存，就会都去访问数据库，导致数据库宕机。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;布隆过滤器：即用户请求访问缓存之前先经过布隆过滤器，如果发现数据库和缓存中都不存在该数据，则拒绝该请求。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;cache&nbsp; null：即如果访问的数据请求返回为null，则对null值也进行缓存，只不过需要给它设置一个短暂的失效时间这样在接收到相同的请求的时候，从缓存中读取返回null，不会访问数据库</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;缓存降级：当读操作增加的时候，我们先从缓存中读取，等到数据库恢复正常再从数据库读取</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;当写操作增加的时候，我们先从写入缓存，然后再异步的写入数据库。</strong></p>\n<p>&nbsp;</p>\n<h1><strong>水平有限，如有错误，还望指出！</strong></h1>","blogGoods":0,"blogId":"1250774653945802752","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6YWj2AQzPpAABXKIA7NHQ430.jpg","blogRead":5,"blogRemark":"面试（八）------之分布式缓存的原理及应用","blogTitle":"面试（八）------之分布式缓存的原理及应用","createdTime":"2020-04-16 13:14:51","typeName":"java面试篇","updateTime":"2020-04-16 23:08:07"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，存储引擎</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;MyIASM：MySQL默认的存储引擎，不支持事务，行级锁和外键。因此插入和更新操作需要锁定整个表，效率较低。二查询操作是直接查询文件的OFFSET，因而效率较快，高于InnoDB（InnoDB寻址要先映射到块，再映射到行）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;InnoDB：为MySQL提供了事务支持，回滚，崩溃修复能力，多版本并发控制，事务安全。InnoDB的底层数据结构采用的是B+树（即非叶子节点仅存储索引信息，不存储数据，数据都被存放再叶子节点上，所有的叶子节点构成一个顺序链表）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;TokuDB：底层数据结构为Fractal Tree，和InnoDB的B+树很像，但是Fractal Tree除了每个指针都指向孩子节点，孩子节点还带有一个message&nbsp; Buffer（用来缓存更新操作的），每次的插入操作只需要到message Buffer就可以返回了，不需要走到叶子节点。（写入速度很快）<br /></strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;Memory：Memory因为其数据都是存放再内存中，所以读的速度很快，通常使用hash索引来做数据索引。缺点是一旦服务关闭，数据就会丢失。</strong></p>\n<h2><strong>二，创建索引的原则</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;选择唯一性索引：因为唯一性索引使用hash算法实现，能够快速的定位到一条数据</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;为经常需要分组，联合，排序，作为查询条件的列设置索引</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;限制索引的数量：因为索引越多，更新表的数据越慢</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;尽量使用数据量少的索引：因为索引值过长，占用的磁盘空间九会很多，查询速度会受影响</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;尽量使用前缀来索引：如果索引的字段很长，则不但会影响索引的大小，还会降低索引的执行效率</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;删除不经常使用的索引</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;选择区分度高的列作为索引：数据重复少</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;索引列不能参与计算：带函数的查询不建议参与索引</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;尽量扩展现有索引：联合索引的查询效率要远高于多个独立索引</strong></p>\n<h2><strong>三，数据库三范式</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;一范式：即该列的数据是不可再拆分的最小的数据单元。例如：address列：中国北京，美国纽约。这种就违背了第一范式，因为address可以拆分为国家country和城市city</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;二范式：基于一范式，非主键列不能存在对主键列的部分依赖。即每张表都单独描述一个事务。例如：一张表中既有订单表编号，订单数，产品编号，产品数，则就不符合第二范式，应该将其拆分为两个表，订单表和产品表</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;三范式：基于一范式和二范式，非主键列不能存在对其它非主键列的传递依赖。例如：除了订单编号，顾客还依赖于表中的顾客编号，这时候就应该删除顾客编号。</strong></p>\n<h2><strong>四，数据库事务</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：数据库事务即一系列的基本操作，这些基本操作要么全部执行，要不都不执行，是一个完整的逻辑单元。数据库事务具备ACID特性：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;A（原子性）：即数据库事务是一个完整逻辑单元，其中的基本操作要么全部执行，要么全部不执行</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;C（一致性）：即事务执行完毕后（无论是正常执行完毕还是异常退出），数据都要保持一致的状态。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;I（隔离性）：即更新数据的事务都是并发执行的，不存在任意一个事务以任意的方法影响其它事务</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;D（永久性）：即事务执行完毕后，更新的数据要持久化到永久性存储中</strong></p>\n<h2><strong>五，存储过程</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：存储过程指的就是一组用于完成特定功能的SQL语句集</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;优化思路：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;尽量利用SQL语句代替一些小循环，例如聚合函数，平均函数等。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;中间结果存放于临时表中，并加索引</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;少使用游标：因为SQL是集合语言，对集合运算有较高的性能，但是游标是过程运算</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;事务越短越好：SQL&nbsp; Server支持并发操作，如果事务过长或者隔离级别过高，会造成并发操作的阻塞，死锁，导致查询慢 。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;使用try-catch处理异常</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;尽量不要将查询语句放入到循环中，避免过度消耗系统资源</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>触发器：是一种自动执行的程序，一般是当数据发生变化后执行一系列的操作</strong></p>\n<h2><strong>六，数据库并发策略（前面的总结中有总结过，这里不作详细展开，具体参照并发编程篇）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;乐观锁</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;悲观锁</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;时间戳（类似版本号机制）</strong></p>\n<h2><strong>七，数据库锁</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;行级锁：锁住数据库中的一行数据，不允许其它事务进行修改。例如增删改查等操作都使用了行级锁</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;表级锁：给整张表加锁，分为共享读锁和独占写锁。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;页级锁：行级锁冲突少，加锁慢；表级锁冲突多，加锁快，页级锁介于两者之间</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;基于Redis的分布式锁：利用redis的setnx命令，如果不存在一个key则插入，返回1；如果已存在一个key，则不做任何操作，返回0。获取锁：即使用此命令，如果返回0表示锁正在被使用，获取失败，如果返回1则获取到锁</strong></p>\n<h2><strong>八，数据库分表</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;垂直分表：即根据功能模块的不同，表的关联程度将表分于不同的库中</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;水平分表：即当一个表中的数据量较大时，按照表的某种规则，将不同数据分到相同表的不同库中</strong></p>\n<h2>九，CAP</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>概述：即一个分布式系统中的一致性（C），可用性（A），分区容错性（P）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;一致性：即同一时间不同数据备份，数据是否保持一致</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;可用性：即当集群的某些节点故障，集群是否可以正常的提供服务（高可用性）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;分区容错性：即当某些时刻数据无法保持一致性，即分区了，这个时候我们就需要在C和A之间进行权衡</strong></p>\n<h2><strong>十，两阶段提交协议和三阶段提交协议</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;两阶段提交协议（准备阶段prepare，提交阶段commit）：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 准备阶段：即协调者给每一个参与者发送一个prepare消息，参与者接收到之后要么返回false，要么立即执行本地事务进行日志的redo和undo但不进行提交</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 提交阶段：即协调者根据参与者反馈的消息，如果参与者反馈失败或者超时，则给每个参与者发送消息中止提交或者进行回滚操作。否则，进行提交操作</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 缺点：第一，参与者的任务都是阻塞进行的；第二，比较中心化，如果协调者出现故障，则参与者进入阻塞状态；第三，数据不一致，即如果协调者在给每个参与者发送commit过程中突然出现故障，导致部分参与者没有接收到commit，则将会导致数据不一致的情况；第四，如果协调者进行发送commit时出现</strong><strong>故障，而唯一接收commit的参与者也出现故障，则将会出现事务状态未知的情况。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;三阶段提交协议（在二阶段提交协议基础上进行完善）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;增加了超时机制：即如果协调者长时间未接受到参与者的反馈，则认为参与者执行失败</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;在准备和提交阶段之前都加了预准备阶段，保证参与者状态的一致。（canCommit，preCommit，doCommit）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;canCommit：即协调者发送commit消息给所有的参与者，参与者如果可以执行就返回yes，不能返回no</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; preCommit：即协调者根据参与者的反馈，如果所有的参与者都可以进行正常提交，则预执行事务；如果有参与者反馈no或者反馈超时，就执行事务的中断。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;doCommit：提交事务</strong></p>\n<h2><strong>十一，分布式事务</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;传统事务：即遵循ACID特性</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;柔性事务：阿里巴巴提出的，基于CAD和BASE。BASE理论是CAD理论的延伸，包括基本可用，柔韧状态，最终一致性</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;两阶段提交型：指的就是分布式事务的两阶段提交</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;补偿性：例如事务A开启事务，事务B参与事务，如果事务A和事务B都能够正常执行事务，则事务执行完毕。如果事务出现故障，则事务B回滚，但是这时候事务A已经提交，所以需要有一种补偿机制，让事务A反操作回到执行事务A之前的状态。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;异步确保型（没怎么读懂，因为还没学到分布式的太多东西，后面补充）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;最大努力通知型（没怎么读懂，后面补充）</strong></p>\n<p>&nbsp;</p>\n<h1><strong>水平有限，如果错误还望指出！</strong></h1>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1250704122190073856","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6YGImARpJnAADh1C7LBxU514.jpg","blogRead":0,"blogRemark":"面试（七）-----数据库及分布式事务","blogTitle":"面试（七）-----数据库及分布式事务","createdTime":"2020-04-16 08:34:35","typeName":"java面试篇","updateTime":"2020-04-16 08:35:14"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，OSI七层网络模型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;物理层：主要用于定义物理设备的标准，发送比特流</strong><strong style=\"font-size: 14px;\">数据链路层：主要用于对数据包中的MAC地址进行解析和封装。这一层的数据单位叫做帧</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;网络层：主要用于对数据包中的ip地址进行解析和封装，这一层的数据单位叫做数据包。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;传输层：定义传输的协议和端口，进行的数据的分段，重组和传输。TCP传输控制协议，适用于对可靠性要求高，数据量大的传输。UDP适用于对可靠性要求不高，数据量不大的传输。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;会话层：用于再传输层的基础上建立连接和管理会话。比如登录，断点续传，数据粘包和分包。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;表示层：用于对接收到的数据进行解析，将计算机识别的信息转换成人也能够识别的信息。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;应用层：构建具体应用</strong></p>\n<h2><strong>二，TCP/IP四层网络模型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：TCP/IP并不是指tcp和ip协议，而是指因特网中的TCP/IP协议簇，分为四层网络模型：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;网络接口层：用来定义主机间的连通协议</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;网络层：用于数据的传输，路由及地址的解析，确保数据能够发送到任何网络的目标上。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;传输层：使源端和目的端的相同实体能够进行通信</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;应用层：负责具体应用协议的定义</strong></p>\n<h2><strong>三，TCP三次握手/四次挥手</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：客户端和服务器之间建立连接之前需要进行三次沟通，称为&ldquo;三次握手&rdquo;；客户端和服务器之间断开连接之前，会进行四次沟通，称为&ldquo;四次挥手&rdquo;。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;三次握手：客户端发送连接请求的标识位SYN给服务器端，进入SYN-SEND状态，请求建立连接；服务器端接收到请求之后，返回一个SYN+ACK报文，进入SYN-RECV状态；客户端接收到请求之后，回应一个ACK报文，至此，三次握手完毕，客户端与服务器端之间的TCP连接已建立，可以进行数据传输。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;四次挥手：客户端和服务器端断开连接要进行四次挥手是因为TCP的关闭是半关闭造成的，即TCP连接是全双工的（即数据可以在两个方向上同时进行交换），因此想要关闭连接，就必须每个方向进行单独关闭。（客户端主动断开连接和服务器端主动断开连接），这里以客户端主动断开连接为例：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;客户端数据传输完毕之后，发送一个释放连接的标识位FIN=1给服务器端，请求断开客户端到服务器端之间的连接操作，进入FIN-WAIT-1状态；</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;服务器端接收到请求之后，返回一个ACK报文给客户端，表</strong><strong>示已经接收到其断开连接的请求，然后释放客户端到服务器端的连接，服务器端进入CLOSE-WAIT状态，客户端接收到请求后进入FIN-WAIT-2状态；</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;服务器端在将待传输到客户端的数据传输完毕之前，发出一个中断连接的标识位FIN=1给客户端，请求客户端中端服务器端到客户端的连接操作，进入进入LAST-ACK状态，等待客户端的最终确认；</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;客户端接收到服务器端的断开连接请求之后，回应一个ACK，表示接收到断开连接请求，随后等待计时器设置的时间后，断开连接。</strong></p>\n<h2><strong>四，HTTP协议</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;概述：http协议是一种无状态的协议，即客户端和服务器端不需要建立持久的连接，客户端发出请求后，服务器端接收到请求，处理数据返回应答之后，连接关闭。http协议遵循请求（Request）和应答（Response）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;传输流程：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 地址解析：通过域名系统DNS获取请求地址的协议，主机名，端口号，对象路径</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 封装HTTP数据包：根据解析出来的请求协议，主机名，端口号，对象路径和本机信息封装出HTTP数据包</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 封装TCP数据包：将HTTP数据包进一步封装成TCP数据包</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;建立TCP连接：利用三次握手协议建立客户端和服务器端的TCP连接</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 客户端发送请求：客户端发送一个请求给服务器端</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 服务器端响应：服务器端接收到客户端发送的请求之后，进行数据处理，返回响应</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;服务器关闭TCP连接：服务器返回应答之后，关闭TCP连接。如果在服务器返回的应答中加上connection：keep-alive，则返回应答后不会关闭TCP连接，下一次浏览器发送请求的时候仍然可以使用该连接（减少了响应时间和带宽资源的消耗）。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;HTTP中常见的状态码：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;20x表示成功，30x表示重定向，40x表示客户端错误，50x表示服务器错误</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;100（继续），101（切换协议），200（成功），201（created创建），202（accepted创建），203（未授权），204（无内容），205（重置内容），206（部分内容）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;300（多种选择），301（永久移动），302（临时移动），303（查看其它位置），304（未修改），305（使用代理），306（未使用），307（临时重定向），308（永久重定向）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;400（客户端请求错误），401（未授权），402（待付款），403（禁止访问），404（未发现），405（不允许使用该方法），406（无法接受），407（需要使用代理身份），408（请求超时），409（冲突），410（已失效），413（请求实体过长），414（请求地址过长），415（媒体类型不支持）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;500（内部服务器错误），501（未实现），502（网关错误），503（服务不可用），504（网关超时），505(Http版本不支持)</strong></p>\n<h2>五，HTTPS</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>概述：HTTPS是在http的基础上增加了SSL协议以保证传输数据的安全性，因为HTTP传输数据使用的明文传输，不安全。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;HTTPS加密流程：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 客户端和服务器端建立TCP连接之后，发送一个请求证书的请求</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 服务器端接收到请求之后，返回应答并且返回证书信息</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 客户端接收到证书之后，进行确认，如果确认正确，则生成密钥</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 客户端将密钥发送给服务器端，服务器端接收到之后利用私钥进行解密</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 经过上面的步骤，客户端和服务器端之间的数传传输就可以进行加密传输了</strong></p>\n<h2><strong>六，CDN原理（待补充）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：CDN即基于分布在不同的地方的机房服务器，通过中心平台的负载均衡，内容分发和任务调度让用户就近获取所需要的内容，降低网络延时，提升用户体验。</strong></p>\n<h2><strong>七，七层负载均衡和四层负载均衡</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;四层负载均衡：即利用ip和端口号，根据负载均衡的配置和分发策略将请求分发给真实服务器</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;七层负载均衡：利用请求的URL或者主机名接受所有用户的请求，然后将其分发给真实服务器</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;区别：四层负载均衡只能根据ip和端口号进行请求的分发，但是七层负载均衡根据URL可以根据具体的请求信息进行分发，例如一个ip下面有多个具体的请求，/user,/business等。四层负载均衡将该ip或者端口号下的所有请求都分配给一台服务器进行处理，但是七层负载均衡可以根据不同的路径信息，将/user分配给一台真实</strong><strong>服务器，将/business分配给一台真实服务器。（Nginx既支持四层负载均衡，又支持七层负载均衡）</strong></p>\n<h2><strong>八，负载均衡算法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;轮询均衡：将请求均等的分发到1-n台服务器上，用于各台服务器之间的软硬件设备没有差距的情况下。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;权重轮询均衡：即根据权重的不同，将不同数量的请求轮询分发到不同的服务器上</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;随即均衡：即将请求随机分发到服务器上</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;权重随即均衡：即根据权重的不同，将请求随机分发到服务器上</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;响应速度均衡：即根据服务器的响应速度，将请求分发到请求速度最快的服务器上</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;最少连接数均衡：即在服务器内部维护一个记录服务器处理连接数量的计数器，将请求分发到连接数最少的服务器上。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;处理能力均衡：将请求分发给内部负荷最轻的服务器</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;DNS响应均衡：不同中心机房的均衡设备接收到域名解析请求时，都进行域名解析，然后返回给客户端，客户端连接第一个返回应答的服务器，忽略其它的均衡设备。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;散列算法均衡：即通过一次性散列算法将相同参数的请求分发到一台服务器上，长期稳定的为客户端进行服务</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;IP地址散列均衡：将来自同一客户端的请求分发到同一台服务器</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;URL散列：将相同URL的请求分发到同一台服务器</strong></p>\n<h2><strong>九，Nginx的反向代理和负载均衡</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;正向代理：即客户端找代理服务器取寻找真实服务器，真实服务器并不知道客户端的ip和端口，因此可以隐藏客户端真实ip和端口</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;反向代理：即服务器找代理服务器去跟客户端打交道，在客户端眼中，代理服务器就是服务器，它并不知道真实服务器是谁</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;负载均衡：即通过Nginx，根据负载均衡的配置和分发策略将不同的请求交给不同的服务器进行处理。</strong></p>\n<p>&nbsp;</p>\n<h1><strong>水平有限，如有错误，还望指出！</strong></h1>","blogGoods":0,"blogId":"1250622112591376384","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6XzDGALH67AABkNXEA3-0043.jpg","blogRead":2,"blogRemark":"面试（六）------之网络与负载均衡","blogTitle":"面试（六）------之网络与负载均衡","createdTime":"2020-04-16 03:08:42","typeName":"java面试篇","updateTime":"2020-04-16 03:09:55"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，二分查找算法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：二分查找算法又称为折半查找算法，待查找的序列必须已经是有序的，每次取序列的中间值与查找值进行比较，若相等则返回；若中间值小于查找值，则在中间值右侧序列中进行查找；若中间值大于查找值，则在中间值左侧序列中进行查找。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现如下：</strong></p>\n<pre class=\"language-java\"><code>public static int binarySearch(int[] arr,int low,int high,int key){\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(arr[mid]==key){\n                return mid;\n            }else if(arr[mid]&lt;key){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        return -1;\n    }</code></pre>\n<h2><strong>二，冒泡排序（这里以升序为例）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：冒泡排序即对于一个无序序列，从第一个元素开始，依次比较相邻的元素，如果前一个元素大于后一个元素，则交换位置，这样一趟比较下来，就确定出最大值。直到整个序列有序为止</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现如下：</strong></p>\n<pre class=\"language-java\"><code>public static void bubbleSort(int[] arr){\n        for (int i = arr.length-1; i &gt;=0 ; i--) {\n            for (int j = 0; j &lt; i; j++) {\n                if(arr[j]&gt;arr[j+1]){\n                    swap(arr,j,j+1);\n                }\n            }\n        }\n    }\n    /**\n     * 交换元素\n     * @param arr\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] arr,int i,int j){\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }</code></pre>\n<h2>三，插入排序（升序为例）</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>概述：即默认无序序列中的第一个元素有序，随后每次排列有序序列后的一个元素，将其排列进入前面的有序序列，同时保证有序序列的有序性即可。（类似于我们打扑克牌时，每拿一张从后往前比较大小，放入正确的位置）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现如下：</strong></p>\n<pre class=\"language-java\"><code>public static void insertSort(int[] arr){\n        for (int i = 1; i &lt; arr.length; i++) {\n            for (int j = i; j &gt;=0; j--) {\n                if(arr[j]&lt;arr[j-1]){\n                    swap(arr,i,j);\n                }\n            }\n        }\n    }\n\n    /**\n     * 交换元素\n     * @param arr\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] arr,int i,int j){\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }</code></pre>\n<h2>四，快速排序（升序为例）</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>概述：在一个无序序列中，取一个基准值，通常取第一个元素为基准值。然后从最右边依次查找，找到第一个比基准值小的元素，与其交换位置；再从最左边查找，查找到第一个比基准值大的元素，与其交换位置。直到从左往右查找的索引等于从右往左查找的索引，结束一次循环，重复以上过程分别比较左右两标的序列，直到整个</strong></p>\n<p><strong>有序为止。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;JAVA代码实现如下：</strong></p>\n<pre class=\"language-java\"><code>public static void quickSort(int[] arr,int low,int high){\n        int base = arr[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //先从右往左查找第一个比基准值小的元素\n            while(R&gt;L&amp;&amp;arr[R]&gt;=base){\n                R--;\n            }\n            if(arr[R]&lt;base){\n             swap(arr,L,R);\n            }\n            //再从左往右查找第一个比基准值大的元素\n            while(R&gt;L&amp;&amp;arr[L]&lt;=base){\n                L++;\n            }\n            if(arr[L]&gt;base){\n                swap(arr,L,R);\n            }\n        }\n        //递归左右序列\n        if(L&gt;low) {\n            quickSort(arr,low,L-1);\n        }\n        if(R&lt;high) {\n            quickSort(arr,R+1,high);\n        }\n    }\n\n    /**\n     * 交换元素\n     * @param arr\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] arr,int i,int j){\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }</code></pre>\n<h2>五，希尔排序（升序为例，以初始dk为length/3+1）</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>概述：希尔排序又称增量排序，是优化的插入排序，即有一个增量dk，根据增量dk将无序序列分为若干个子序列，分别对子序列进行插入排序，每进行完一趟排序，更改增量，直到增量dk为1时，则对整个序列再进行依次插入排序。希尔排序，当增量dk大的时候，因为序列数据较少，排序较快；而当增量dk小的时候，又因为序列</strong></p>\n<p><strong>中的数据已经基本有序了，因而排序也较快。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;JAVA代码实现：为例</strong></p>\n<pre class=\"language-java\"><code>public static void sort(int[] arr){\n\n        int dk = arr.length/3+1;\n        while(dk!=1){\n            shellSort(arr,dk);\n            dk = dk/3+1;\n        }\n        if(dk==1){\n            shellSort(arr,dk);\n        }\n    }\n\n    public static void shellSort(int[] arr,int dk){\n        for (int i = dk; i &lt;arr.length ; i++) {\n            if(arr[i]&lt;arr[i-dk]){\n                swap(arr,i,i-dk);\n            }\n        }\n    }\n\n    /**\n     * 交换元素\n     * @param arr\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] arr,int i,int j){\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }</code></pre>\n<h2><strong>六，归并排序</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：归并排序采用的是典型的分治思想，即先分解，然后再归并。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n     * 先分\n     * @param arr\n     */\n    public static void sortProcess(int[] arr,int L,int R){\n        if(L==R){\n            return;\n        }\n        int mid = (L+R)/2;\n        sortProcess(arr,L,mid);\n        sortProcess(arr,mid+1,R);\n        merge(arr,L,mid,R);\n    }\n\n    /**\n     * 分治中的治\n     * @param arr\n     * @param L\n     * @param mid\n     * @param R\n     */\n    public static void merge(int[] arr,int L,int mid,int R){\n        int[] help = new int[R-L+1];\n        int p1 = L;\n        int p2 = mid+1;\n        int i =0;\n        while(p1&lt;=mid&amp;&amp;p2&lt;=R){\n            help[i++] = arr[p1]&gt;arr[p2]?arr[p2++]:arr[p1++];\n        }\n        while(p1&lt;=mid){\n            help[i++] = arr[p1++];\n        }\n        while(p2&lt;=R){\n            help[i++] = arr[p2++];\n        }\n        //将数组help复制回原数组（注意一定要有这一步，不然无法保证元素比较后的大小顺序性）\n        for (int j = 0; j &lt; help.length; j++) {\n            arr[L+j] = help[j];\n        }\n        System.out.println(Arrays.toString(arr));\n    }</code></pre>\n<h2>七，桶排序算法</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>概述：先找出无序序列中的最大值和最小值，然后根据最大值和最小值计算桶的个数并且初始化桶，然后将每个元素加入到对应的桶中，对每个桶进行排序，再整合桶中的数据即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>JAVA代码如下：</strong></p>\n<pre class=\"language-java\"><code>public static void bucketSort(int[] arr){\n\n        int k = 0;\n        //找出无序序列中的最大值和最小值\n        int max = Integer.MIN_VALUE;\n        int min = Integer.MAX_VALUE;\n        for (int i : arr) {\n            max = Math.max(max,i);\n            min = Math.min(min,i);\n        }\n\n        //根据最大值和最小值确定桶\n        int bucketNum = (max-min)/arr.length+1;\n        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = new ArrayList&lt;&gt;(bucketNum);\n        for (int i = 0; i &lt; bucketNum; i++) {\n            bucketArr.add(new ArrayList&lt;&gt;());\n        }\n\n        //遍历序列中的数据，将其分配进入不同的桶\n        for (int i=0;i&lt;arr.length;i++) {\n            int num = (arr[i]-min)/arr.length;\n            bucketArr.get(num).add(arr[i]);\n        }\n\n        //对每个桶都进行排序\n        for (ArrayList&lt;Integer&gt; bucket : bucketArr) {\n            Collections.sort(bucket);\n        }\n\n        //将桶中的数据按照顺序复制回原数组\n        for (ArrayList&lt;Integer&gt; bucket : bucketArr) {\n            for (Integer integer : bucket) {\n                arr[k++] = integer;\n            }\n        }\n    }</code></pre>\n<h2>八，基数排序（这里以高位优先为例）</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>概述：基数排序是一种优化的桶排序，但是基数排序只能排序整型数据。先要统一数据的位数，位数不够的前面添0，然后按照从低位到高位的位数顺序依据位数上数字的大小进行排序，最终得到一个有序序列。 &nbsp;</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码如下：</strong></p>\n<pre class=\"language-java\"><code>public static void radixSort(int[] arr){\n        //指数\n        int exp = 1;\n\n        //查找数组中的最大值\n        int max= Integer.MIN_VALUE;\n        for (int i : arr) {\n            max = Math.max(max,i);\n        }\n\n        //按照低位到高位的顺序依次排序\n        for (exp=1;(max/exp)&gt;0;exp*=10){\n            int[] temp = new int[arr.length];\n            //初始化桶\n            int[] buckets = new int[10];\n            //统计每个桶中数据的次数\n            for (int i = 0; i &lt; arr.length; i++) {\n                buckets[(arr[i]/exp)%10]++;\n            }\n\n            //更改buckets[i]\n            for (int i = 1; i &lt; buckets.length; i++) {\n                buckets[i]+=buckets[i-1];\n            }\n\n            //将数据存储到临时数组temp中\n            for (int i = 0; i &lt; arr.length; i++) {\n                temp[buckets[(arr[i]/exp)%10]-1] = arr[i];\n                buckets[(arr[i]/exp)%10]--;\n            }\n\n            //将临时数组的数据复制到原数组\n            System.arraycopy(temp,0,arr,0,arr.length);\n        }\n    }</code></pre>\n<h2><strong>九，其它算法（对于最短路径算法和回溯算法后面会单列出来）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;剪枝算法，最短路径算法，回溯算法</strong></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1250364779516665856","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6W3IWAZhjCAACsl_OYPcQ410.jpg","blogRead":2,"blogRemark":"面试（五）------之算法","blogTitle":"面试（五）------之算法","createdTime":"2020-04-15 10:06:09","typeName":"java面试篇","updateTime":"2020-04-16 08:26:53"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，栈及其JAVA实现</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：栈是一种先进后出的数据结构，对栈顶元素的添加，删除等操作较快，但是对于栈内的元素操作很慢</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA实现：实现需要定义栈的数据结构，写栈的入栈，出栈，获取栈顶元素的方法，如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n * 基于数组实现栈\n * @author wcj\n * @Date 2020/4/14 20:59\n * @Version 1.0\n */\npublic class StackExample&lt;E&gt; {\n\n    /**\n     * 站的深度\n     */\n    private int maxSize;\n    /**\n     * 存储数据的数组\n     */\n    private Object[] data;\n    /**\n     * 栈顶指针\n     */\n    private int top = -1;\n\n    /**\n     * 默认栈的深度为10\n     */\n    public StackExample(){\n        this(10);\n    }\n\n    /**\n     * 用户自定义栈的深度\n     * @param initialSize\n     */\n    public StackExample(int initialSize){\n        if(initialSize&gt;=0){\n            this.maxSize = initialSize;\n            this.data = new  Object[initialSize];\n            this.top = -1;\n        }else{\n            throw new RuntimeException(\"初始化栈的深度不能小于0!\");\n        }\n    }\n\n    /**\n     * 入栈操作\n     * @param e\n     * @return\n     */\n    public Boolean push(E e){\n        if(top == maxSize-1){\n            throw new RuntimeException(\"栈已满,不能入栈\");\n        }else{\n            data[++top] = e;\n        }\n        return true;\n    }\n\n    /**\n     * 出栈操作\n     * @return\n     */\n    public E pop(){\n        if(top==-1){\n            throw new RuntimeException(\"栈空，不能出栈！\");\n        }else{\n            return (E) data[top--];\n        }\n    }\n\n    /**\n     * 获取栈顶元素\n     * @return\n     */\n    public E peak(){\n        if(top==-1){\n            throw new RuntimeException(\"栈空异常！\");\n        }else{\n            return (E) data[top];\n        }\n    }  </code></pre>\n<h2><strong>二，队列极其JAVA实现</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：队列是一种先进先出的数据结构，对队头和队尾的操作简单，但是队内元素的操作复杂。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA实现：定义队列的数据结构，队列的出队，入队，获取队头元素。代码如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n * 基于数组实现队列\n * @author wcj\n * @Date 2020/4/14 21:14\n * @Version 1.0\n */\npublic class QueueExample&lt;E&gt; {\n\n    /**\n     * 队列长度\n     */\n    private int maxSize;\n    /**\n     * 存储数据数组\n     */\n    private Object[] data;\n    /**\n     * 队头指针\n     */\n    private int front;\n    /**\n     * 队尾指针\n     */\n    private int rear;\n\n    /**\n     * 默认构造器\n     */\n    public QueueExample(){\n        this(10);\n    }\n    /**\n     * 用户自定义队列长度构造器\n     * @param initialSize\n     */\n    public QueueExample(int initialSize){\n        if(initialSize&gt;=0){\n            this.maxSize = initialSize;\n            data = new Object[initialSize];\n            front = rear = 0;\n        }else{\n            throw new RuntimeException(\"初始化队列长度不能小于0！\");\n        }\n    }\n\n    /**\n     * 入队操作\n     * @param e\n     * @return\n     */\n    public Boolean add(E e){\n        if(rear == maxSize){\n            throw new RuntimeException(\"队列已满，无法入队!\");\n        }else{\n            data[rear++] = e;\n        }\n        return true;\n    }\n\n    /**\n     * 出队操作\n     * @return\n     */\n    public E poll(){\n        if(front==rear){\n            throw new RuntimeException(\"队空，无元素可出队！\");\n        }else{\n            E e = (E) data[front];\n            data[front] = null;\n            return e;\n        }\n    }\n\n    /**\n     * 获取队头元素\n     * @return\n     */\n    public E peek(){\n        if(front==rear){\n            throw new RuntimeException(\"队空，无元素可出队!\");\n        }else{\n            return (E) data[front];\n        }\n    }\n}\n</code></pre>\n<h2><strong>三，链表及其JAVA实现</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：链表是由一系列数据节点组成的数据结构，节点可以动态生成。对于元素的增加，删除操作快，查询操作慢</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;这里主要讲述几种有代表性的链表：单向链表，双向链表，双向循环链表</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;单链表的JAVA实现：数据结构定义，添加节点，删除节点，查找节点，代码如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n * 单向链表\n * @author wcj\n * @Date 2020/4/14 21:32\n * @Version 1.0\n */\npublic class SingleLinkedList {\n\n    /**\n     * 链表长度\n     */\n    private int length;\n    /**\n     * 链表头节点\n     */\n    private Node head;\n\n    public SingleLinkedList(){\n        this.length = 0;\n        this.head = null;\n    }\n    /**\n     * 内部类声明每个链表节点\n     * 每个节点包括数据域和指向下一个节点的指针\n     */\n    private class Node{\n        private Object data;\n        private Node next;\n        public Node(Object data){\n            this.data = data;\n        }\n    }\n\n    /**\n     * 插入节点（这里使用头插法）\n     * @param obj\n     * @return\n     */\n    public Boolean add(Object obj){\n        Node node = new Node(obj);\n        if(length==0){\n            head = node;\n        }else{\n            node.next= head;\n            head = node;\n        }\n        length++;\n        return true;\n    }\n\n    /**\n     * 删除某个节点\n     * 先对链表进行判空处理\n     * 然后找到要删除的节点\n     * 最后进行删除\n     * @param obj\n     * @return\n     */\n    public Boolean delete(Object obj){\n        if(length==0){\n            throw new RuntimeException(\"链表为空，无节点可删除!\");\n        }else{\n            Node prev = head;\n            Node current = head;\n            //查找待删除元素\n            while(!current.data.equals(obj)){\n                if(current.next==null){\n                    return false;\n                }else{\n                    prev = current;\n                    current = current.next;\n                }\n            }\n            prev.next = current.next;\n            length--;\n        }\n        return true;\n    }\n\n    /**\n     * 获取某个元素\n     * @param obj\n     * @return\n     */\n    public Object find(Object obj){\n        if(length==0){\n            throw new RuntimeException(\"链表为空\");\n        }else{\n            Node current = head;\n            while(current.data.equals(obj)){\n                if(current.next==null){\n                    return null;\n                }else{\n                    current = current.next;\n                }\n            }\n            return current.data;\n        }\n    }\n}\n</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>双向链表的JAVA实现：定义数据结构，头插法，尾插法，删除头部节点，删除尾部节点（这里只写尾插节点和删除尾部节点），代码如下：</strong></p>\n<pre class=\"language-java\"><code>import com.sun.org.apache.xpath.internal.operations.Bool;\n\n/**\n * 单向循环链表\n * @author wcj\n * @Date 2020/4/14 22:05\n * @Version 1.0\n */\npublic class CircleLinkedList {\n\n    /**\n     * 链表长度\n     */\n    private int length;\n    /**\n     * 头节点\n     */\n    private Node head;\n    /**\n     * 尾节点\n     */\n    private Node tail;\n\n    /**\n     * 初始化构造方法\n     */\n    public CircleLinkedList(){\n        this.length = 0;\n        this.head=this.tail = null;\n    }\n\n    /**\n     * 内部类实现的链表节点\n     */\n    private class Node{\n        private Object data;\n        private Node prev;\n        private Node next;\n        public Node(Object data){\n            this.data = data;\n        }\n    }\n\n    /**\n     * 尾插节点\n     * @param obj\n     * @return\n     */\n    public Boolean addTail(Object obj){\n        Node node = new Node(obj);\n        if(length==0){\n            head = tail= node;\n            length++;\n        }else{\n            tail.next = node;\n            node.prev = tail;\n            tail = node;\n            length++;\n        }\n        return true;\n    }\n\n    /**\n     * 删除尾部节点\n     * @return\n     */\n    public Boolean delTail(){\n        Node temp = tail;\n        if(length==0){\n            throw new RuntimeException(\"链表为空!\");\n        }else{\n            tail = tail.prev;\n            tail.next = null;\n            length--;\n        }\n        return true;\n    }\n}\n</code></pre>\n<h2><strong>四，散列表</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：有一张表M，一个映射函数f(key)，如果对于任意一个key，都有一个函数指与表中的内存地址相对应，则M就为散列表，f(key)就为散列函数。散列函数存储key-value键值对形式的数据，直接生成key与表中地址值的映射，因此查询非常迅速。同时散列表也经常被用于信息安全，用于加密操作。</strong></p>\n<h2><strong>五，二叉排序树</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：二叉查找树又成为二叉搜索树，二叉查找树</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;特征：根节点左边的数据小于根节点，根节点右边的数据大于根节点，且其左右子树还是二叉排序树</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现：定义数据结构，插入操作，删除操作，查找操作，代码如下：</strong></p>\n<pre class=\"language-java\"><code>package interviewFour.example4;\n\n/**\n * 二叉排序树\n * @author wcj\n * @Date 2020/4/14 17:17\n * @Version 1.0\n */\npublic class Node {\n\n    private Node root = null;\n    private int value;\n    private Node left;\n    private Node right;\n\n    public Node(){}\n\n    public Node(int value, Node left, Node right){\n        this.value = value;\n        this.left = left;\n        this.right = right;\n    }\n\n    public Node(int value){\n        this.left = null;\n        this.right = null;\n        this.value = value;\n    }\n\n    public int getValue() {\n        return value;\n    }\n\n    public void setValue(int value) {\n        this.value = value;\n    }\n\n    public Node getLeft() {\n        return left;\n    }\n\n    public void setLeft(Node left) {\n        this.left = left;\n    }\n\n    public Node getRight() {\n        return right;\n    }\n\n    public void setRight(Node right) {\n        this.right = right;\n    }\n\n    /**\n     * 插入节点\n     * @param value\n     * @return\n     */\n    public Boolean insert(int value){\n        //root代表根节点\n        Node p = root;\n        Node prev = null;\n        //创建一个节点\n        Node node = new Node(value);\n        //寻找节点的插入位置\n        while(p!=null){\n            prev = p;\n            if(value==p.getValue()){\n                return false;\n            }else if(value&lt;p.getValue()){\n                p = p.getLeft();\n            }else{\n                p = p.getRight();\n            }\n        }\n        if(root==null){\n            root = node;\n        }else if(value&lt;prev.getValue()){\n            prev.setLeft(node);\n        }else{\n            prev.setRight(node);\n        }\n        return true;\n    }\n\n    /**\n     * 删除某个节点\n     * 分为三种情况，待删除节点为叶子节点，则直接删除\n     * 待删除节点只有左子树或者右子树，则用左子树或者右子树替代当前节点位置\n     * 待删除节点即有左子树又有右子树，则寻找左子树最大节点或者右子树最小节点顶替当前节点(这里使用左子树的最大节点)\n     * @param value\n     * @return\n     */\n    public void deleteBST(int value){\n        deleteBST(root,value);\n    }\n\n    /**\n     * 递归删除左子树，或者右子树，或者根节点\n     * @param root\n     * @param value\n     * @return\n     */\n    public Boolean deleteBST(Node root,int value){\n        if(root==null){\n            return false;\n        }else{\n            if(root.getValue()==value){\n                delete(root);\n            }else if(value&lt;root.getValue()){\n                deleteBST(root.getLeft(),value);\n            }else{\n                deleteBST(root.getRight(),value);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * 分情况执行具体的删除逻辑\n     * @param node\n     * @return\n     */\n    public Boolean delete(Node node){\n        if(node.getLeft()==null){\n            node = node.getRight();\n        }else if(node.getRight()==null){\n            node = node.getLeft();\n        }else{\n            Node temp = node;\n            Node s = node;\n            //转向左子树，向右走到底\n            s = s.getLeft();\n            //寻找替换待删除节点的节点\n            while(s!=null){\n                temp = s;\n                s = s.getRight();\n            }\n            node.setValue(temp.getValue());\n            if(temp!=node){\n                node.setLeft(temp.getLeft());\n            }else{\n                node.setRight(temp.getRight());\n            }\n        }\n        return true;\n    }\n\n    /**\n     * 在二叉查找树中找到对应节点\n     * @param value\n     * @return\n     */\n    public Boolean searchBTS(int value){\n        Node node = root;\n        if(node==null){\n            throw new RuntimeException(\"无此节点！\");\n        }else{\n            if(value==node.getValue()){\n                return true;\n            }else if(value&lt;node.getValue()){\n                node = node.getLeft();\n            }else{\n                node = node.getRight();\n            }\n        }\n        return false;\n    }\n}\n</code></pre>\n<h2>&nbsp;</h2>\n<h2><strong>六，红黑树</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 概述：红黑树是一种特化的自平衡二叉排序树，即其左右子树的深度差可以超过1。（详细的插入等操作过段时间会补充）</strong></p>\n<h2><strong>七，图，位图</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;图的知识：定义，有向图/无向图，邻接矩阵/邻接表，BFS/DFS，位图的话没怎么搞清楚。</strong></p>\n<h2>&nbsp;</h2>","blogGoods":0,"blogId":"1250068950784536576","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6VyQCAX-J_AACqF70d5gI039.jpg","blogRead":1,"blogRemark":"面试（四）------之数据结构篇","blogTitle":"面试（四）------之数据结构篇","createdTime":"2020-04-14 14:30:37","typeName":"java面试篇","updateTime":"2020-04-14 14:30:58"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，线程上下文切换</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>cpu利用时间片轮询的方式来为每个任务都分配一定的时间片，任务的执行过程中保存任务的状态。任务状态的保存和在加载就叫做上下文切换。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>进程：</strong>指的是一个运行中的程序实例，一个进程中可以有多个线程，并且与进程共享同样的内存和系统资源</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong> 上下文：</strong>指的是寄存器和程序计数器保存的线程的信息</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>寄存器：</strong>指的是内存中很小但是运行速度很快的一块区域（相对于RAM外部内存）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>程序计数器：</strong>一种寄存器，用来保存当前执行指令的位置或者下一个待执行指令的位置</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>上下文切换：</strong>上下文切换指的是操作系统的内核在cpu上对进程或者线程的切换。上下文信息保存在进程控制块中（PCB）。流程如下：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;挂起当前进程，将进程的上下文信息保存在进程控制块中；</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;在进程控制块中寻找下一个任务的上下文信息。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;恢复进程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>上下文切换的原因：</strong>第一，任务正常执行完毕，调度下一个任务；第二，线程出现I/O阻塞，被挂起，cpu调度下一个任务；第三，线程等待同步锁，获取socket通知等，被挂起，cpu调度下一个任务；第四，用户调用sleep方法，让出cpu；第五，硬件中断</p>\n<h2><strong>二，JAVA阻塞队列</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>阻塞队列的是调度当前队列的线程处于阻塞状态</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 消费者阻塞：如果队列为空，则消费者线程被挂起，处于阻塞状态，当有新数据进入队列，则消费者线程被唤醒，消费数据</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 生产者阻塞：如果队列数据已满，则生产者线程挂起，处于阻塞状态，当队列有空闲位置，生产者线程被唤醒，生产数据。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞队列的主要操作：</strong>插入操作和移除（获取）操作</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>插入操作：</strong>add(e)，有空间则插入，无空间报异常；offer(e),有空间则插入，无空间返回false；offer(e,time,unit),有空间插入，无空间等待time时间，若超时返回false；put(e),有空间插入，无空间则线程挂起处于阻塞直到有空间</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>移除操作：</strong>poll(e),有值返回值，无值返回null;poll(e,time,unit),有值返回值，无值等待time时间，超时返回null;take(e),有值返回值，无值等待新数据进入再立即返回；drainTo(collection&lt;Object&gt;)批量移除，提高获取效率</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞队列的实现：</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong> ArrayBlockingQueue：</strong>基于数组的有界阻塞队列，按照先进先出顺序对元素进行排序</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>LinkedBlockingQueue：</strong>基于链表的有界阻塞队列，队头队尾采用不两个不同的锁控制数据同步，并发性高</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>PriorityBlockingQueue：</strong>基于优先级的无界队列，默认升序排列，可以自定义排序规则，根据优先级访问数据。但是有数据优先级一样的情况</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>DelayQueue：</strong>支持延时的队列，即从队列中取数据时等待一定的时间才能获取元素。可以用于缓存系统的设计，设计过期时间，也可以用来设置定时调度任务，即如果能够从队列中获取，说明到了任务的调度时间。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>SynchronousQueue</strong>：没怎么读懂（<span style=\"background-color: #ffff00;\">记得补充</span>！）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>LinkedTransferQueue：</strong>基于链表的无界阻塞队列，多了transfer方法(如果消费者等待，直接将任务从生产者传递给消费者，无消费者等待，则将任务加到队尾直到被消费才返回)和tryTransfer（与transfer一致，只不过不管有没有消费者等待获取都会立即返回tryTransfer（e,time,unit）（与tryTransfer一致，只不过设置了超时时间）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>LinkedBlockingDeque：</strong>基于链表的双向阻塞队列，可以在两端同时进行读写操作，提高了队列的操作效率。</p>\n<h2><strong>三，并发关键字</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;CountDownLatch：</strong>适用于一个主线程等待子线程完成任务之后执行（原理：设置一个程序计数器，计数器的值为子线程的个数，子线程并发执行，每个子线程执行完毕后，调用CountDown方法，将其计数器的值减去1，值为0时，唤醒主线程执行）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>CyclicBarrier：</strong>即当所有线程到达一个状态共同执行。await（）方法：确保所有线程到达Barrier状态才执行；await（time,unit）：设置一个超时时间，超过这个时间，执行达到Barrier状态的线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>Semaphore：</strong>因为其限制了多线程访问资源的线程个数，所以适用于多线程并发访问有限资源的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>volatile：</strong>直接用来修饰变量，是一种比Synchronized更加轻量级的机制，用于多线程共享同一变量，可以同时对其进行读写操作。当多个线程共享变量的时候，读取变量将其从内存复制到cpu缓存中，然后线程对其操作进行修改，这样再多cpu的情况下，有可能出现线程修改原数据造成数据不一致的情况，使用volatile关键字直接将线程修改的变量存入内存，解决这个问题。</p>\n<h2><strong>四，多线程共享数据</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>多线程共享数据主要通过共享内存实现，而共享内存的可见性，有序性，原子性已经由JVM和锁解决。理想情况下我们需要解决同步和互斥的问题（<span style=\"background-color: #ffff00;\">怎么解决的有待考证！</span>）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>解决方法一：</strong>将数据抽象成一个类，将对数据的操作封装成类中的方法</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解决方法二：</strong>将Runnable对象作为一个内部类，将共享数据作为这个类的成员变量</p>\n<h2><strong>五，ConcurrentHashmap并发</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ConcurrentHashmap使用了减小锁粒度，这里具体为分段锁的思想优化了锁，因为如果直接对hashmap进行加锁，锁太大，而且同一时刻只能有一个线程操作hashmap，并发性能较差</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;实现原理：</strong>即内部采用分段锁思想，将hashmap分为多个segment，每次读取数据的时候，对数据所在的segment进行加锁，这样只要保证每个segment线程安全，就可以保证整个hashmap线程安全</p>\n<h2><strong>六，JAVA中的线程调度</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;抢占式调度：</strong>即线程对cpu资源进行抢占，这种策略下每个线程抢占到cpu资源的概率是相等的，这样就不会一个线程阻塞造成整个系统阻塞的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>协同式调度：</strong>即一个线程使用完cpu资源之后通知cpu调度下一个任务，适用于多线程交替执行任务。因为如果一个线程阻塞可能会造成整个系统阻塞甚至崩溃</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>JAVA采用的是抢占式调度，但同时又尽可能的保证公平性（即为每个线程分配优先级不同的cpu时间片）</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>&nbsp;线程让出cpu的情况</strong>：第一，线程调用yield方法；第二，I/O阻塞，socket等待等；第三，等待同步锁；第四，正常执行完毕</p>\n<h2>七，进程调度算法</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>优先调度算法：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;先来先服务调度算法：</strong>即遵循先来先被分配cpu资源运行的原则</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>短作业调度算法：</strong>即预估作业的时间长短，优先调度时间短的任务，可能会导致长时间大任务很长时间无法被调度 &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>高优先权调度算法：即每个任务会预先被分配优先级</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;非抢占式优先调度算法：</strong>按照优先级的高低一次分配cpu资源运行</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>抢占式优先调度算法：</strong>按照优先级的高低分配cpu资源运行，但是如果任务再运行过程中有优先级更高的任务加入，则将其cpu资源临时回收分配给紧急任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>高响应比调度算法：</strong>动态调度，即作业时间短，则优先级高；等待时间长，则优先级高。前者遵循短作业调度算法，后者遵循先来先服务原则。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>时间片轮转调度算法：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;时间片轮转法：</strong>按照任务再队列中的顺序进行调度</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>多级反馈队列调度算法：</strong>即再时间片轮转法的基础上维护了就绪队列，默认第一队列优先级高，先调度第一队列的任务，如果再分配的cpu时间片内未完成则将其加入第二队列队尾，以此类推直到其执行完毕。只有第1 -（n-1）队列为空，才会调度第n队列的任务，而且当前任务执行时，如</p>\n<p>果有优先级高的任务进来，会抢占其cpu资源。</p>\n<h2><strong>八，CAS</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>即比较和交换，CAS（V,E,N）三个参数，只有当V=E的时候才会将V设置为N。如果V!=E，则说明数据已经被其它线程修改，不做任何操作</p>\n<h2><strong>九，ABA问题</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>概述：</strong>即当1线程从V中取出A时，2线程也从中取出1，修改为B，再修改为A。而1线程仍然修改成功，实际上修改过程中V的实际值已经发生改变，只不过1没有发觉。解决这种问题，常采用乐观锁的版本号机制。</p>\n<h2><strong>另外有AQS问题没怎么读懂，下次完善！</strong></h2>\n<p>&nbsp;</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</p>","blogGoods":0,"blogId":"1249742755949817856","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6UmSuAdB35AABzd_wnH78043.jpg","blogRead":1,"blogRemark":"面试（三）------之并发编程篇（下）","blogTitle":"面试（三）------之并发编程篇（下）","createdTime":"2020-04-13 16:54:26","typeName":"java面试篇","updateTime":"2020-04-13 16:54:43"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，redis简介</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>redis是NoSQL型系统之一，与之相似的还有Memcache，用来存储key-value这种键值型数据。相比于Memcache而言，redis不仅可以做临时缓存，还可以做数据持久化，将数据定时的存入硬盘或者将命令追加到日志文件当中。而Memcache只能做临时缓存，因而现在基本上已经被redis完全取代。redis的读写速度非常快，官方给出的数据是读110000次/s，写81000次/s；而且redis支持多种数据类型，例如String，list，hash，set，zset；redis支持主从复制（集群），进行数据持久化；还支持过期时间，事务等。</p>\n<h2><strong>二，redis的安装与启动（docker环境下）</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;docker安装完毕后，安装redis：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第一步：拉取redis镜像，docker&nbsp; pull&nbsp; redis</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第二步：启动redis，docker&nbsp; &nbsp;run&nbsp; &nbsp;redis&nbsp; &nbsp;</p>\n<p><strong>三，基本知识串讲</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>单进程单线程：redis只有一个进程，且内部为单线程，这样做的优势是不存在线程安全问题，且不需要进行线程间的切换，提高了性能，而且多线程可能会涉及到锁。劣势是无法发挥多核cpu的优势，不过可以通过开启搭建多个redis实例实现</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>redis中默认有16个数据库（0-15），可以通过select n来进行数据库之间的切换</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;常用的基本命令：flushDB（清空当前数据库），flushAll（清空所有数据库），dbSize（查看有多少数据库）</p>\n<h2><strong>四，redis基本数据类型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;string：</strong>字符串类型，数据库中存储Map&lt;String,String&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>list：</strong>列表数组类型，数据库中存储Map&lt;String,List&lt;Object&gt;&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>hash：</strong>哈希类型，数据库中存储Map&lt;String,Map&lt;Object,Object&gt;&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>set：</strong>集合类型，其中元素无序，数据库中存储Map&lt;String,Set&lt;Object,Object&gt;&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>Zset：</strong>有序集合类型，每个元素都有一个可用于排序的权重</p>\n<h2><strong>五，redis相关命令（这里详解一些常用的命令，不常用的一笔带过）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;string：</strong>(1)set&nbsp; key&nbsp; value,插入一条数据&nbsp; （2）mset&nbsp; key value...批量插入 （3）setnx&nbsp; key value&nbsp; 若无则插入（4）get&nbsp; key&nbsp; 获取某条数据&nbsp; （5）mget keys 批量获取&nbsp; （6）getrange key&nbsp; 0 -1获取数据库全部数据&nbsp; （7）incr age 递增&nbsp; (8) incrby&nbsp; age&nbsp; 10&nbsp; 递增 age 步长为10（9）decr&nbsp; age&nbsp; 递减&nbsp; （10）decrby&nbsp; age&nbsp; 10 步长递减&nbsp; &nbsp;（11）del&nbsp; key&nbsp; 删除某条数据&nbsp; <span style=\"background-color: #ffff00;\">（12）exists&nbsp; key&nbsp; 判断是否存在某个key&nbsp; &nbsp;(13)expire&nbsp; key&nbsp; 10&nbsp; 设置过期时间（单位为秒）&nbsp; （14）pexpire&nbsp; key&nbsp; 1000 设置过期时间，单位为毫秒&nbsp; （15）persist key删除过期时间 （</span><span style=\"background-color: #ffff00;\">16）ttl&nbsp; key&nbsp; 查看过期时间</span></p>\n<p><span style=\"background-color: #ffff00;\">&nbsp;<span style=\"background-color: #ffffff;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>list：&nbsp;&nbsp;</strong>（1）lpush&nbsp; key&nbsp; value 左插入一条数据&nbsp; &nbsp;（2）lpush mylist&nbsp; key&nbsp; value....批量左插入&nbsp; （3）rpush&nbsp; key value 右插入一条数据&nbsp; (4)rpush&nbsp; mylist&nbsp; key value...右批量插入&nbsp; （5）lrange&nbsp; mylist&nbsp; 0&nbsp; -1&nbsp; 取出数据集合&nbsp; （6）lpop mylist 左弹出集合中第一条数据&nbsp; （7）rpop&nbsp; </span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">mylist&nbsp; 右弹出集合中第一条数据&nbsp; （8）llen&nbsp; mylist&nbsp; 获取数据集合长度lrem&nbsp; mylist&nbsp; count&nbsp; value&nbsp; （count&gt;0,从表头开始搜索，移除count个与值与value相等的元素；count&lt;0,表尾开始；count=0，移除所有值与value相等的元素） （9）linsert mylist&nbsp; before/after&nbsp; a&nbsp; 在a元素前或后插入。</span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">(10) lpoplpush&nbsp; list&nbsp; list1 转移列表的元素到另一个列表</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>hash：</strong>（1）hset&nbsp; key&nbsp; &nbsp;val-key&nbsp; val-val&nbsp; 插入一条数据&nbsp; （2）hset&nbsp; myhash&nbsp; name&nbsp; xxx&nbsp; 用于给哈希表中的字段赋值，不存在则创建哈希表赋值，存在则覆盖旧值&nbsp; (3) hget&nbsp; &nbsp;myhash&nbsp; name&nbsp; 取哈希表中某个值&nbsp; （4）hmset&nbsp; myhash name&nbsp; xxx age xxx&nbsp; 批量插入字段&nbsp; （5）hmget</span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">批量获取 （6）hgetall&nbsp; myhash&nbsp; 获取哈希表中所有值&nbsp; (7)&nbsp; hexisets myhash&nbsp; name&nbsp; 判断哈希表中是否存在name字段&nbsp; （8）hsetnx&nbsp; myhash score 100 若存在则不插入，若不存在则插入数据&nbsp; （9）hincrby&nbsp; myhash id 1/hdecrby&nbsp; myhash id&nbsp; 10 递增递减 （10）hdel&nbsp; myhash name&nbsp; </span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">删除&nbsp; （11）hkeys&nbsp; myhash&nbsp; 只取key值&nbsp; （12）hvals&nbsp; myhash&nbsp; 只取value值&nbsp; （13）hlen&nbsp; myhash 获取哈希表长度</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>set：</strong>（1）sadd myset&nbsp; redis&nbsp; 添加一条数据&nbsp; （2）smembers myset&nbsp; 获取数据集合&nbsp; （3）srem&nbsp; myset&nbsp; set1&nbsp; 删除set1&nbsp; （4）sismember myset&nbsp; set1 判断set中是否存在set1&nbsp; (5)srandmember&nbsp; key count&nbsp; 随机获取count个元素（6）spop&nbsp; 从集合中弹出一个元素</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>zset：</strong>之后补充</span></span></p>\n<h2><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">六，redis配置文件（常见配置）</span></span></strong></h2>\n<p><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;daemonize no：</span></span></strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">redis默认不是以守护进程的方式运行的，可以更改为yes启用守护进程（即后台运行）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>pidfile&nbsp; /var/run/redis.pid&nbsp; :</strong>启用守护进程后，默认将pid写入/var/run/redis.pid文件，可以更改</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>port&nbsp; 6379 ：</strong>redis默认端口</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp; &nbsp; &nbsp; &nbsp; <strong>bind&nbsp; 127.0.0.1：</strong>绑定的主机地址</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\"> &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>timeout&nbsp; 300</strong><strong>：</strong>redis客户端闲置多长时间后关闭连接，改为0的话，表示关闭该功能</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>loglevel&nbsp; verbose：</strong>默认日志级别（还有debug，notice，warning）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>database 16：</strong>redis默认有16个数据库可以修改</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>save&nbsp; 900&nbsp; 1/save&nbsp; 300&nbsp; 10/save&nbsp; 60&nbsp; 10000：&nbsp;</strong>表示一定时间内有多少条数据发生修改，就将其同步到数据文件一次，例如第一个表示15分钟内有一条数据发生改变就同步</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>rdbcompression yes&nbsp; ：</strong>表示数据存储到本地数据库时是否进行压缩</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>dbfilename&nbsp; dump.rdb：</strong>指定本地数据库文件名</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>dir&nbsp; /...../redis安装目录/bin ：</strong>本地数据库存放目录，默认在redis安装目录的bin目录下</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>slaveof&nbsp; &nbsp;masterip&nbsp; masterport ：</strong>设置当本机为从机时，它的主机的ip和端口</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>masterauth&nbsp; &lt;master-password&gt;：</strong>当master服务设置了密码时，slav服务连接master的密码</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>requirepass&nbsp; foobared：</strong>默认关闭redis连接需要密码，当给redis设置了密码，就需要打开</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>maxclients&nbsp; &nbsp;128：</strong>redis同一时间最大连接客户端的数量</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>appendonly&nbsp; &nbsp;no：</strong>是否开启aof持久化，默认不开启，采用rdb</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>appendfilename&nbsp; appendonlu.aof：</strong>指定aof持久化的文件名</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>appendfsync&nbsp; everysec :</strong>指定更新日志条件，默认每秒更新一次（还有no，指等操作系统进行数据缓存到磁盘，快；always指每次更新操作后都手动写入磁盘，慢但安全）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;虚拟机方面的配置暂不说明</span></span></p>\n<h2><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">七，redis持久化</span></span></strong></h2>\n<p><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;概述：</span></span></strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">redis持久化主要有两种方式，即rdb和aof</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>rdb：</strong>适用于大数据集的恢复，数据的备份，但是因为设置周期时间进行数据的快照，所以如果redis宕机，可能会丢失最后一个写操作的数据，因为数据完整性较差。数据保存在dump.db文件中，只需要移动到redis安装目录，重启即可恢复数据</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>aof：</strong>适用于对数据的完整性要求较高的情况，因为可以设置不同的持久化策略，例如每秒保存一次，这样即时redis宕机，也只会丢失最后一秒的数据。但是因为其日志文件存储的是写入命令，因而其文件大小要大于rdb的数据文件，且每次重启，都要从头执行数据文件中的命令，因而恢复速度也</span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">要慢于rdb。</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>注意：</strong>当rdb和aof同时开启的时候，redis重启，默认会采用aof的形式进行数据的重新构建</span></span></p>\n<h2><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">八，redis事务</span></span></strong></h2>\n<p><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;概述：</span></span></strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">什么是事务？事务即是一系列的命令要买全部执行，要么全部回滚</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <strong>常用命令：</strong>multi(启动事务)，discard（取消事务）,exec（执行事务块内命令）,watch key(监控某个key的变化)，unwatch（取消对所有key的监控）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>注意：</strong>redis的事务中在命令本身出错的情况下会造成命令的全部回滚，但是在命令无错，执行某个命令的时候发生异常的时候，则谁的错，谁停止（这一点和mysql是不同的）</span></span></p>\n<h2><strong>九，redis的主从复制</strong></h2>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>redis的主从复制，即主机数据更新后根据我们设置的策略将数据同步到从机上，主机以写为主，从机以读为主<strong>。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 使用：</strong>配主不配从，在从机中使用slaveof&nbsp; 主机ip&nbsp; &nbsp;主机端口配置从机，但是这种配置方式当redis重启之后就会失效，如果想要redis重启仍然可用，则需要配置redis.conf配置文件中的slaveof&nbsp; masterip&nbsp; masterport。这种配置方式的问题所在，中心化只有一台极其支持写操作，如果主机宕机，则从机等待，且从机宕机重启后不会跟上大部队（即重启后变为主机）。当然我们可以采用命令slave&nbsp; no&nbsp; one 使从机反客为主，成为主机。但是这种手动操作太过麻烦。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>哨兵模式：</strong>即配置之后，如果主机宕机，则哨兵会自动根据投票规则在从机中进行选举，从而产生新的主机顶替。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>主从复制的缺点：</strong>因为所有的写操作都是子主机上进行，从而在同步到从机上，所以存在着一定的延迟，当系统繁忙或者从机数量较多的时候，这种问题就更加明显。</p>\n<h2><strong>十，redis集群</strong></h2>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;概述：</strong>集群是一种去中心化的模式，与中心化模式不同的是，中心化模式中如果主服务挂掉了，那么服务就挂掉了。但是集群模式下，没有主路由，每个节点自身都可以成为路由</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;redis集群：即配置多台主机，多台从机，不同的主机中有不同的槽点，当执行数据写入时，会根据crc16算法计算出数据的槽点，从而将数据存入到对应的主机中，并同步到与其对应的从机中</p>\n<p>&nbsp;</p>\n<h1>水平有限，如有错误，还望指出！</h1>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1249588251598041088","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6UCU-ALIMAAACFuGw0Y70739.jpg","blogRead":3,"blogRemark":"redis基础（一）","blogTitle":"redis基础（一）","createdTime":"2020-04-13 06:40:30","typeName":"redis","updateTime":"2020-04-16 13:15:50"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，JAVA线程的创建方式</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>JAVA线程的创建有四种方式，分别为，继承Thread类，实现Runable接口，实现Callable&lt;Class&gt;接口，基于线程池。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>1，继承Thread方式：创建一个类继承Thread类，创建类的实例对象，调用start方法，继而执行线程的run（）方法，代码如下：</strong></p>\n<pre class=\"language-java\"><code>public class NewThread extends Thread{\n    public static void main(String[] args) {\n        NewThread thread = new NewThread();\n        thread.start();\n    }\n    @Override\n    public void run(){\n        System.out.println(\"create  a  new thread by Thread!\");\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>2，当子类已经继承了一个类，这时候就没法再继承Thread类了，这时候就可以实现Runable接口，实例化类的线程实例，创建Thread实例传入类的实例，执行start方法，继而执行run（）方法代码如下：</strong></p>\n<p>&nbsp;</p>\n<pre class=\"language-java\"><code>public class ThreadExample2 implements Runnable {\n    public static void main(String[] args) {\n        ThreadExample2 threadExample2 = new ThreadExample2();\n        Thread thread = new Thread(threadExample2);\n        thread.start();\n    }\n    @Override\n    public void run() {\n        System.out.println(\"create a new thread by Runnable!\");\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，有些情况下，我们需要再一个主线程中并发多个子线程执行同一个任务，然后回收子线程的返回值整理汇总，这时候就需要实现Callable&lt;Class&gt;接口，重写其call（）方法，用于计算结果。然床创建一个线程池用于提交线程，继而执行call方法，并且创建一个Future的list用于接收子线程逻辑代码即call方法的返回，最终遍历list，得到想要的返回值，如下：</strong></p>\n<pre class=\"language-java\"><code>public class ThreadExample3 implements Callable&lt;String&gt; {\n\n    private String name;\n\n    public ThreadExample3(String name){\n        this.name = name;\n    }\n\n    @Override\n    public String call() throws Exception {\n        return name;\n    }\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        ExecutorService pool = Executors.newFixedThreadPool(3);\n        List&lt;Future&gt; list = new ArrayList&lt;&gt;();\n        for(int i=0;i&lt;3;i++){\n            ThreadExample3 threadExample3 = new ThreadExample3(i+\"\");\n            Future future =pool.submit(threadExample3);\n            System.out.println(future.get().toString()+\" is running\");\n            list.add(future);\n        }\n        pool.shutdown();\n        for (Future future : list) {\n            System.out.println(\"currentThread's result is \"+future.get().toString());\n        }\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，基于线程池创建线程</strong></p>\n<pre class=\"language-java\"><code>public class ThreadExample4 {\n    public static void main(String[] args){\n        ExecutorService pool = Executors.newFixedThreadPool(3);\n        for(int i=0;i&lt;3;i++){\n            pool.execute(new Runnable() {\n                @Override\n                public void run() {\n                    System.out.println(\"thread  is running by FixedThreadPool\");\n                }\n            });\n        }\n        pool.shutdown();\n    }\n}</code></pre>\n<h2>二，线程池的工作原理</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong> &nbsp;1，概述：</strong>JVM根据用户提供的参数创建一定数量的线程任务，将其放入队列中，线程创建之后启动这些任务，如果线程的数量大于核心线程数量（用户设置的线程数量），则超出数量的线程排在队列中等待，当有线程任务执行完毕后，线程池调度器就会发现有可用可用线程，继而从队列中取出任务继续执行<strong>。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; </strong><strong>2，线程复用：</strong>（参见JDK源码解读，这里只做简单描述），由前可知，JVM会根据用户提供的参数创建一定数量的线程任务，且将其添加到任务队列中。JVM通过start（）方法创建一个线程之后， 会相应的为其创建一个任务队列，线程会不停的查看任务队列，如果任务队列中有任务，则调用run方法，执行，这样就达到了一次start（）创建线程，多次使用，完成线程复用的任务。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>3，线程池的核心组件和核心类（见JDK源码分类中关于线程的总结）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; </strong><strong>4，JAVA线程的工作流程：</strong>线程池刚被创建的时候，只是向系统申请一个执行线程队列和管理线程池的线程资源，当调用execute方法之后，执行下列流程：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果正在运行的线程数量小于corePoolSize（核心线程数量，即用户定义的的线程数量），则立即创建线程执行线程任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果正在运行的线程数量大于或等于corePoolSize，则将超过数量的线程加入到阻塞队列中</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在阻塞队列已满且线程数量小于MaximumPoolSize（即线程池能够容纳的最大线程数），线程池会创建非核心线程立即执行任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在阻塞队列已满且线程数量大于或等于MaximumPoolSize的时候，线程池会拒绝该线程任务且抛出异常</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在线程任务执行完毕之后，会将其从任务队列中移除，从队列中取出下一个线程任务执行</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在线程处于空闲状态且空闲时间超过KeepAliveTime，且线程数量大于corePoolSize的时候，会停止该线程，这样在没有任务的时候，线程池中的线程数始终维持在corePoolSize。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，线程池的拒绝策略：</strong>分为四种，分别为AbortPolicy，CallerRunsPolicy，DiscardOldestPolicy，DiscardPolicy</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; AbortPolicy：直接抛出异常，阻止线程运行，源码如下：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</p>\n<pre class=\"language-java\"><code>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n            throw new RejectedExecutionException(\"Task \" + r.toString() +\n                                                 \" rejected from \" +\n                                                 e.toString());\n        }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CallerRunsPolicy：如果线程任务没有关闭，则尝试执行该线程任务，源码如下：</p>\n<pre class=\"language-java\"><code>* @param r the runnable task requested to be executed\n* @param e the executor attempting to execute this task\n*/\npublic void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n     if (!e.isShutdown()) {\n         r.run()\n     }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DiscardOldestPolicy：移除任务队列中最早进入的线程任务，执行当前任务线程，源码如下：</p>\n<pre class=\"language-java\"><code>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n       if (!e.isShutdown()) {\n           e.getQueue().poll();\n           e.execute(r);\n       }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DiscardPolicy：直接丢弃线程任务，不做任何处理</p>\n<h2><strong>三，五种常用的线程池</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;newCachedThreadPool（可缓存线程池）：</strong>当线程池创建线程的时候如果发现有可复用的线程（执行完任务，且未关闭的线程），则直接复用，如果没有则创建新线程。可缓存线程池可以高效的利用执行任务时间短的线程，提高系统的性能，且线程池中的线程如果空闲时间超过60s，则会被终止且从缓存中移除，这样可缓存线程池不会占用系统资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>newFixedThreadPool（固定大小的线程池）：</strong>即线程池中的线程是初始化固定的，当任务线程大于线程池中线程数量时，任务线程就会进入阻塞队列等待。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newScheduledThreadPool（可做任务调度的线程池）：</strong>即可以设置线程执行的停顿时间和执行周期，进行定期定时的执行某个任务。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newSingleThreadPool（单个线程的线程池）:&nbsp;</strong>即线程池中永远只有一个线程进行工作，如果下称停止或者异常，则线程池创建新的线程替代当前线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newWorkStealingPool（足够大小的线程池）：</strong>即创建足够数量的线程的线程池，保证更快的进行运算，提高效率。</p>\n<h2><strong>四，线程的生命周期</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;线程的生命周期大致分为五个阶段：新建（new），就绪（Runnable），运行（Running），阻塞（Blocked），死亡（Dead）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;新建：</strong>即使用new创建一个线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>就绪：</strong>调用start方法，</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>运行：</strong>即线程获取cpu资源，执行run（）方法，进入运行状态，运行状态的线程如果调用yield（线程让步方法）或者失去cpu资源，都会导致线程重新回到就绪态；如果调用sleep方法，I/O阻塞，等待同步锁，等待通知以及suspend挂起都会导致线程进入阻塞态。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞：</strong>即线程被放入Blocked池。阻塞状态的线程如果结束了sleep方法，I/O方法返回，获取同步锁，收到通知或者resume都会导致其重新进入就绪态，与其它线程竞争cpu时间片。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>死亡：</strong>线程正常执行完run（）或者call（）方法，或者执行stop方法，或者发生异常或者错误都会导致线程死亡。（stop方法会导致锁混乱和死锁，不建议使用）</p>\n<h2><strong>五，线程的基本方法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;wait（线程等待）：</strong>会让线程进入WAITING状态，并且会释放对象的锁。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>sleep（线程睡眠）：</strong>会让线程进入睡眠，进入TIMED_WAITING状态，但是不会释放对象锁，睡眠时间到了之后，再次恢复运行状态</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>yield（线程让步）:</strong>&nbsp; 当前线程会让出其占有的cpu资源，重新回到就绪态和其它线程竞争cpu时间片</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>interrupt（线程终端）:&nbsp;&nbsp;</strong>中断当前线程，但是并不会导致其停止，只是改变其内部的终端标识位，在使用了thread.sleep()之后使用该方法，会导致抛出异常，且我们可以利用中断标识位进行线程的安全退出</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>join（线程加入）：</strong>即将当前线程进入阻塞态，等待下一个线程执行完毕后进入就绪态，重新竞争锁资源。通常用于主线程下面执行子线程，需要主线程阻塞，等待子线程执行完毕后返回其结果给主线程，主线程再执行的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>notify（线程唤醒）/notifyAll：</strong>前者随机唤醒一个等待线程，后者全部唤醒</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>setDaemon（守护线程）:</strong>级别较低的线程，用于后台运行，服务用户用户线程，例如垃圾收集线程就是典型的守护线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>sleep方法和wait方法的区别：</strong>前者属于Thread，后者属于Object，前者不会释放锁资源，后者会释放锁资源</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>start方法和run方法：</strong>start方法只是创建一个线程，并没有运行，run方法时执行线程的真正代码逻辑。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>线程退出的方式：</strong>见四中最后一条</p>\n<h2><strong>六，JAVA中的锁（知识比较杂乱）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述:JAVA中的锁是为了保护数据的一致性。按照不同的标准可分为乐观锁和悲观锁，公平锁和非公平锁，共享锁和独占锁，偏向锁，轻量级锁，重量级锁，自旋锁，可重入锁。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;乐观锁：</strong>即认为每次读取数据都不会被修改，当修改操作的时候再判断当前数据是否被修改，未修改则修改，若已被修改，则返回失败状态。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>悲观锁：</strong>即认为每次读取数据都会被修改，因而每次读取数据都对其进行加锁，这样只有当前用户可以修改，其它用户阻塞等待直到当前用户修改完毕释放锁资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>自旋锁：</strong>即有些线程任务的执行很短，很快就可以释放锁资源，为了避免在这种情况下竞争线程仍然进行内核态和用户态之间的转换，因而让线程自旋（即等一会），如果有可用锁，则获取，减少了线程在用户态和内核态之间切换的时间损耗。提高了性能（优势）。当然线程自旋是占用cpu资源的，因而需要设置一个自旋的最大等待时间，如果超过此时间，则线程退出自旋模式。对于线程竞争锁资源激烈的情况，自旋有可能会导致cpu资源的损耗（劣势）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>公平锁和非公平锁：</strong>即根据线程竞争锁资源的机制判定，一般如果依据先到先得的原则，则位公平锁；如果依据就近原则，则位非公平锁。公平锁相比于非公平锁会更加耗费性能，因为要维护一个线程任务丢列，根据线程任务在队列中的顺序分配锁资源，因而不常用。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>可重入锁：</strong>又被称为递归锁，即该锁可以然后线程对其进行多次的加锁操作。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>偏向锁：</strong>当线程获取到锁的时候，用来消除线程的锁重入的开销（看起来是偏袒这个线程）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>共享锁和独占锁：</strong>共享锁即多线程共享锁资源（典型例子，读锁）；独占锁即当前锁只能有一个线程获取，其它线程阻塞</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>轻量级锁：</strong>没有多线程竞争的前提下，减少重量级锁的使用提高性能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>重量级锁：</strong>基于操作系统的互斥量而实现的锁，会导致进程在用户态和内核态之间切换，耗费性能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>synchronized：独占式悲观锁，可重入锁，非公平锁，重量级锁。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 作用范围：</strong>作用于成员变量和非静态方法，相当于锁住的是对象的实例，即this对象</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;作用于静态方法，相当于锁住的是class实例</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;作用域代码块，相当于锁住的代码块中的对象</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>实现原理：</strong>内部包括ContentionList（锁竞争队列），EntryList（竞争候选列表），WaitSet（等待集合），OnDeck（竞争候选者），Owner，!Owner，其中ContentionList是用来存放竞争锁资源的线程。EntryList是用来存放有资格竞争锁资源的线程。调用wait方法后放入WaitSet中，onDeck指的是同一时刻，只有一个线程竞争锁资源，Owner指的是得到锁资源的线程，!Owner指的是线程执行完毕，释放锁资源的线程。需要注意的是线程首先采用的都是自旋模式获取锁资源，如果自旋获取不到再加入ContentionList，而且Owner状态的线程并不是直接把锁资源交给onDeck状态线程，而是给它竞争锁资源的权利，因而onDeck状态的线程还需要跟自旋线程竞争锁资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>ReentrantLock：独占式，可重入锁，并且可以实现公平锁和非公平锁，重量级锁。</strong></p>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;用法：</strong>lock()加锁，后跟try代码块，finally中进行释放锁unlock()</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;避免死锁的方法：</strong>响应中断（即可以根据情况中断对锁资源的请求），可轮询锁（tryLock（）即尝试获取锁，如果有可用锁则获取返回true，没有则返回。和lock（）的区别在于lock获取锁资源如果没有则一直等待直到获取到锁资源），定时所（tryLock（time,unit）即再一定时间内如果有可用锁，且线程未中断则获取锁，否则禁用当前线程。）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>Semaphore（信号量）:</strong>机制和ReentrantLock类似</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ReadWriteLock（读写锁）：</strong>如果系统要求支持多线程共享读，但不能多线程写，使用读锁；如果要求同一时刻只能有一个线程写，写的过程中不能读取该共享数据，则使用写锁。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; <strong>分段锁：</strong>一种思想，将数据分段加锁，例如ConcurrentHashMap</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;死锁：</strong>即线程之间互相共享资源会导致死锁</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; <strong>锁优化：</strong>第一，减少锁的持有时间；第二：减小锁粒度，例如分段锁；第三：锁分离，例如读写锁；第四：锁粗化，放置锁粒度太小，造成频繁加锁释放锁；第五：锁消除，消除程序代码不规范而造成的乱用了锁</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>\n<h1>水平有限，如果错误，还望指出！</h1>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;</p>","blogGoods":0,"blogId":"1249313090567143424","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6TCO-AEYrKAACh3H-d2Gc645.jpg","blogRead":4,"blogRemark":"面试（三）------之并发编程篇（上）","blogTitle":"面试（三）------之并发编程篇（上）","createdTime":"2020-04-12 12:27:07","typeName":"java面试篇","updateTime":"2020-04-12 12:57:17"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，集合</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，List：</strong>list是java中一种有序的集合，下有三个实现类，分别为ArrayList，Vector，LinkedList</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ArrayList：基于数组实现，增删慢，查询快，线程不安全。因为其基于数组实现，所以查询的时候可以直接根据数组的索引下标进行快速查询，但是进行增删操作的时候，需要将待增删元素后的元素全部移动，因而效率较低。且ArrayList创建时不需要分配初始大小，其空间不够的时候，会自动创建一个更大的list，然后复制数据。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Vector：基于数组实现，和ArrayList一样增删慢，查询快。但是线程安全，因为同一时间只支持一个线程对Vector进行写操作，然而因为要进行频繁的加锁和释放锁的操作，所以效率要低于ArrayList。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; LinkedList：基于双向链表实现，增删快，查询慢。因为基于链表实现，增删元素的时候，只需要改变元素的指针即可，改动较小，效率较高。然而进行查询操作的时候，需要从链表头部进行遍历，因而效率较低。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，Queue：</strong>队列，满足先进先出，种类较多。（不作详细解释）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，set：</strong>具有独一无二的特性，常用来存储无序且不重复的元素，对象相等的本质是hashcode的值相同，而如果想要比较两个对象是否相等，需要重写对象的hashcode方法和equals方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;hashset：基于hashTable实现，无序。存放的是对象的散列值，即通过hashcode计算得到的值</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;treeset：基于二叉树实现，即其中的对象按照一定的排序方式进行排列（升序，降序），每次添加对象的时候，都会进行排序，将其插入指定位置。基本的数据类型例如Integer，String等可以使用treeset默认的排序方法，而自定义数据类型需要实现compareable接口，实现compareTo方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;LinkHashSet：继承自hashset，只不过使用双向链表记录数据的顺序。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，map：</strong>一种键值对形式的集合</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;hashmap：基于数组+链表实现，增删改查操作快，但是每次遍历hashmap元素的顺序无法保证且线程不安全。如果想要其线程安全，可以使用synchronizedMap和ConcurrentHashmap，hashmap的内部是数组，数组中的每一个元素又是一个单向链表，链表中的每个元素嵌套一个Entry实例，其中包括Key，Value，Hash值，指向下一个节点的next。每次查询的时候，可以根据元素的hash值很快定位所在数组，但是定位之后需要遍历链表查找元素，因而时间复杂度为O（n），但是Java8之后对其进行了优化，将其改为了数组+链表或红黑树的结构，即当链表中的元素大于8个的时候，链表会转换为红黑树（红黑树是一种特化的二叉平衡树，因为其左右子树的深度差可以大于1），这样查询的时间复杂度就缩短到了O（logN）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ConcurrentHashmap：采用分段锁的思想进行并发操作，因而使线程安全的。由多个Segment组成，只要保证每个Segment线程安全就可以保证全局线程安全。ConcurrentHashmap的默认Segment即并发度为16，可以在初始化的时候修改，但是初始化之后不能再修改。每个Segment内部的实现和hashmap一样&middot;。Java8之后也和hashmap进行了一样的优化。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;HashTable：线程安全，即同一时刻只能有一个线程对其进行操作，并发度不如ConcurrentHashmap。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;TreeMap：基于二叉树数据结构实现，实现了SortedMap，默认按照键值的升序进行排列。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;LinkedHashMap：Hashmap的子类，只不过使用链表保存元素的插入顺序。使用迭代器遍历的时候按照插入顺序遍历。</p>\n<p><strong>二，异常分类及处理</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;1，异常分类：</strong>Throwable是所有异常类的父类，其下有error和Exception，Error下有AwtError，ThreadDeath；Exception下有RuntimeException和CheckedException。</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</strong>对于Error类异常通常是由内部错误和资源耗尽造成的，无法在程序运行期间对其进行捕获和处理，对于这类错误我们只能记录错误的原因和终止程序。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; Exception中的RuntimeException异常（运行时异常）：这类异常是我们程序中异常处理的核心，可以在程序中进行捕获并处理。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Exception中的CheckedException异常（检查异常）：这类异常时程序中需要强制捕获的异常，通常有IO异常，SQL异常等等。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，异常处理：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>异常处理有两种方式：抛出异常和捕获异常</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;抛出异常有三种方法：throws，throw，系统自动抛出。其中throws是作用在方法上，后面跟的是可能产生的异常类。throw是作用在方法内部，后面跟的是具体的异常对象。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 捕获异常：即使用try{}catch语句进行捕获</p>\n<p><strong>三，反射机制</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，什么叫做反射机制？</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>即在程序运行的过程中，可以获取类的属性和方法，并且可以调用任意一个类的方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，反射机制的使用</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 首先，获取类的class对象，有三种方式，className.getClass()，类对象.class，Class.forName(\"类路径\")，其中最后一种最为安全，性能最好。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 然后利用反射的API可以实现对类中信息的操作，例如getDeclareFields（），getDeclareMethods（），getConstroctors（）等等。反射创建类的对像有两种方法，一，class.newInstance()初始化一个类实例；二，先获取其构造器，然后利用构造器初始化一个实例。利用反射调用类的方法：先获取方法，然后调用method.invoke()执行方法。</p>\n<p><strong>四，注解</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，四种元注解：</strong>@Target（指定注解的使用范围），@Retention（定义注解的保留级别，有三级，SOURCE源程序中保存，CLASS文件中保存，RUNTIME运行时保存），@Documented（可以工具文档化），@Inherited（<span style=\"background-color: #ffff00;\">这个没怎么看懂</span>）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，注解使用示例：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>第一步，定义注解接口</p>\n<pre class=\"language-java\"><code>@Target(ElementType.FIELD)  \n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface FruitProvider {\n\n    //id\n    public int id() default  -1;\n\n    //供应商名称\n    public String name() default \"\";\n\n    //供应商地址\n    public String address() default \"\";\n\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 第二步，使用注解</p>\n<pre class=\"language-java\"><code>public class Apple {\n\n    @FruitProvider(id = 1,name = \"红富士苹果\",address = \"陕西\")\n    private String appleProvider;\n\n    public String getAppleProvider() {\n        return appleProvider;\n    }\n\n    public void setAppleProvider(String appleProvider) {\n        this.appleProvider = appleProvider;\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第三步，定义注解处理器</p>\n<pre class=\"language-java\"><code>public class FruitInfoUtil {\n    public static void getFruitInfo(Class&lt;?&gt; clazz) {\n        String strFruitProvider = \"供应商信息:\";\n        Field[] declaredFields = clazz.getDeclaredFields();\n        for (int i = 0; i &lt; declaredFields.length; i++) {\n            if (declaredFields[i].isAnnotationPresent(FruitProvider.class)) {\n                FruitProvider annotation = declaredFields[i].getAnnotation(FruitProvider.class);\n                strFruitProvider += annotation.id() + \",\" + annotation.name() + \",\" + annotation.address();\n                System.out.println(strFruitProvider);\n            }\n        }\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第四步，主方法入口</p>\n<pre class=\"language-java\"><code>public class FruitRun {\n    public static void main(String[] args) {\n        FruitInfoUtil.getFruitInfo(Apple.class);\n    }\n}</code></pre>\n<p><strong>五，内部类</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 1，静态内部类：</strong>即在类的内部定义的静态类，静态内部类可以访问外部了的静态变量和方法，外部也可以通过outClassName.innerClassName调用内部类</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2，成员内部类：</strong>在类的内部定义的没有用static修饰的内部类，使用方式和静态内部类一样。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>3，成员内部类：</strong>即一个类只在一个方法中使用，则完全可以将这个类定义为这个方法的内部类，即局部内部类，局部内部类可以实现真正的对外隐藏</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>4，匿名内部类：</strong>通常用于继承一个类或者实现一个接口的时候，使用new关键字定义，例如:Person person = new Student(){new Pupil(){}}</p>\n<p><strong>六，泛型</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 1，为什么要使用泛型：</strong>其根本目的是为了实现代码的复用，举个开发中常见的例子，我们需要定义返回类Result，返回类中包含状态码code，信息msg，以及数据data（任意类型），这个时候我们就需要使用泛型，因为我们返回的数据类型有各种vo，pojo类对象，list等。这时候泛型类result就可以被各种对象使用，实现代码的复用，简化开发。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>2，泛型标记和泛型限定：</strong>E表示集合中的元素，K表示键值，V表示value，N表示数值类型，T表示任意类型（包含基础类型，所有的对象类型），？（不确定的java类型）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>泛型限定：</strong>向上限定，&lt;?&nbsp; extends T&gt;，向下限定，&lt;? super&nbsp; T&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; <strong>3，泛型方法：</strong>即参数类型定义为泛型类型，以便于接收不同类型的参数，做出不同的处理。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>4，泛型类：</strong>例如public class Pair&lt;T&gt;{private T data;}</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>5，泛型接口：</strong>与放泛型类类似</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>6，类型擦除：</strong>即在泛型编译的过程中，会将泛型类型替换为限定类型的操作</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>7，明确的一点：</strong>虚拟机在运行程序的过程中，内部是没有泛型的，只有普通的类和方法。</p>\n<p><strong>7，序列化：</strong>序列化是为了确保对象及其状态的持久化</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>序列化的使用：</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </strong>首先，实现序列化接口java.io.Serializble</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 然后，声明序列化ID，通常private static final&nbsp; long&nbsp; serialVersionUid&nbsp; = ***</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 因为序列化是保证对象及其状态的持久化，而静态变量是不属于对象，属于类本身的，所以序列化无法保存静态变量。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果需要序列化父类变量，则父类也要实现Serializable接口</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t'ransient修饰的属性不会序列化</p>\n<p>&nbsp;</p>\n<h2>水平有限，如有错误，还望指出！</h2>","blogGoods":0,"blogId":"1248605157059497984","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6QdaWAWQpnAAD6cIgEnVw521.png","blogRead":17,"blogRemark":"面试（二）------之JAVA基础篇","blogTitle":"面试（二）------之JAVA基础篇","createdTime":"2020-04-10 13:34:02","typeName":"java面试篇","updateTime":"2020-04-12 09:07:59"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，Linux的发展历史</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; </strong>1965年之前，电脑并不像现在这么普遍，除了军事机构和研究即构，一般人基本接触不到电脑，而且那时候的一台大型主机最多也就只能支持30台终端。为了解决数量问题，1965年之后，由贝尔实验室，麻省理工学院以及通用电气一起放弃了Multics项目，准备让大型主机能够支持300台终端，但是在开发过程中，进度缓慢，最终由于资金的短缺，贝尔实验室推出了研究。1969年，从这个项目中退出的Ken Thompson在家无聊，为了让电脑能够运行&ldquo;星际旅行&rdquo;游戏，因而趁着妻子回家探亲的一个月，独自写出了Unix操作系统的原型（！！！！牛批）。1970年，这个人以BCPL语言为基础，又写出了很接近硬件的B语言，并且用B语言写出了第一个Unix操作系统。但是由于B语言的跨平台性比较差，为了解决这个问题。Dennis Ritchie和Ken Thompson决定以B语言为基础开发一种新的语言，1972年，Dennis Ritchie最终设计出了一种新语言，他以BCPL的第二个字母命名，也就是我们后来熟知的C语言。随后两人便迫不及待的用C语言重现Unix操作系统。Unix系统起初开源，但是在Unix7之后，由于政策的变化，代码闭源化，因而大学中不能使用Unix的源代码进行教学。Andrew S. Tanenbaum教授为了能够让学生更好的理解代码细节，在完全不使用任何源代码的情况下开发除了Minix---小型Unix。但是因为其只用于教学，功能并不强大，因而Torvalds以此为基础，开发除了Linux，但是起初Linux并不支持Unix，最终经过全世界网友的帮助，最终让其能够兼容各种硬件。</p>\n<p><strong>二，文件和目录</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; 1，windows和linux的区别：</strong>我们熟知的windows系统，它的文件系统是分盘符的，盘符下的文件构成一个树形结构，但是Linux文件系统没有盘符，所有文件目录都在根目录/之下</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;<strong>2，Linux需要记住的目录：</strong>/bin（存放系统命令的目录），/sbin（只有超级管理员能访问的命令文件目录），/root（存放和root用户相关文件的目录），/etc（存放系统配置文件的目录），/usr（存放系统共享资源的目录），/opt（存放安装的第三方软件的目录，通常在/usr/local下）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;<strong>3，文件权限：</strong>Linux中的文件权限有读（r，可用于数字4表示），写操作（w，可用数字2表示），执行权限（x，可用数字1表示）</p>\n<p><strong>三，常用命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，ls：</strong>列出目录中的所有目录和文件名&nbsp; -a（列出所有，包括隐藏文件和目录），-l（以列表形式列出所有），-h（人性化列出，需要配合-l使用，即文件大小转换为我们熟知的kb，mb等），-d（显示当前目录属性），命令可以联合使用，例如-al，-lh等等。&nbsp;&nbsp;&nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，cd：</strong>用于切换目录，需知（.和..是相对路径，.表示当前目录，..表示上级目录；/表示绝对路径），cd ~（切换到root目录），cd - （切换到前一次切换的目录）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，clear：</strong>清屏</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，pwd：</strong>显示当前所在目录</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，mkdir：</strong>创建目录，-p（如果目录存在则不创建，如果不存在则创建目录再创建自目录），可以一次性创建多级目录，例如：mkdir&nbsp; -p test/test1</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，touch：</strong>创建空文件</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>7，cp：</strong>复制，-r（递归复制目录下的文件目录信息），-i(提示是否覆盖)，-v（显示复制进度）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>8，mv：</strong>移动文件，不过经常用来给文件进行重命名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>9，rm：</strong>删除目录或者文件，-r（递归删除），-f（强制删除），-v（显示删除进度）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>10，cat：</strong>查看文件内部信息</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>11，ln：</strong>文件创建链接，ln 源文件 目标链接文件（创建硬链接，硬链接和源文件大小相同，修改同步，但是删除不同步，使用较少），ln -s（创建软连接，相当于我们平时创建快捷方式，使用较多）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>12，which：</strong>搜索命令所在位置，例如：which&nbsp; &nbsp;ls</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>13，find：</strong>搜索文件所在位置&nbsp; 例如：find&nbsp; &nbsp;test.conf</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>14，grep：</strong>文件内容搜索，例如：grep &ldquo;想要搜索的内容&rdquo;&nbsp; 源文件</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>15，tar：</strong>归档命令，-c（打包成.tar文件），-z（打包的同时压缩），-v（打包的同时显示进度），-f（放在最后，后面跟.tar.gz），-x(解压)，常用：tar -zcvf&nbsp; <em><strong>.tar.gz&nbsp; &nbsp; ;&nbsp; &nbsp; tar -zxvf</strong> tar.gz</em> -C&nbsp; 指定解压目录&nbsp;&nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;还有more，head，tail等命令，不过这些不常用。</p>\n<p><strong>四，用户权限命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，whoami：</strong>查看当前账户的用户名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，who：</strong>查看当前登录用户</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，exit：</strong>退出登录</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，adduser/useradd：</strong>添加用户，-d（指定用户主目录），-g（指定用户用户组），-m（自动建立目录），默认情况下用户主目录和用户组名都和用户名一样</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，passwd：</strong>只有root用户才能使用，用于修改用户密码</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，userdel：</strong>删除用户，默认不删除用户的主目录，-r（删除用户主目录）</p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;7，su：</strong>切换账户</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>8，groupadd/groupdel：</strong>添加用户组和删除用户组</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>9，groups：</strong>查看用户所在用户组，例如：groups&nbsp; 用户名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>10，usermod：</strong>修改用户所在用户组，例如：usermod&nbsp; 用户组名 用户名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>11，chmod：</strong>修改文件权限，例如：chmod&nbsp; 777&nbsp; test</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>12，chown：</strong>修改文件所有者，例如：chown&nbsp; &nbsp;用户&nbsp; 文件名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>13，chgrp：</strong>修改文件所在组，例如：chgrp&nbsp; 组名&nbsp; 文件名</p>\n<p><strong>五，系统命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，cal：</strong>查看日历</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，date：</strong>查看时间，可以设置格式，例如：date '+<span class=\"ql-token hljs-built_in\">%Y</span>-<span class=\"ql-token hljs-built_in\">%m</span>-<span class=\"ql-token hljs-built_in\">%d</span> <span class=\"ql-token hljs-built_in\">%H</span>:<span class=\"ql-token hljs-built_in\">%M</span>:<span class=\"ql-token hljs-built_in\">%S</span>'</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，ps：</strong>查看线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，kill：</strong>杀死线程，-9（强制杀死）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，查看网卡信息：</strong>centos6：ifconfig ；centos7：ip addr</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，ping：</strong>查看网址或者链接的连通性</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>7，防火墙：</strong>centos6：service&nbsp; iptables&nbsp; status（查看防火墙状态），service&nbsp; &nbsp;iptables&nbsp; &nbsp;start(开启),service&nbsp; iptables&nbsp; stop(关闭);centos7:firewall-cmd&nbsp; --state（查看防火墙状态），systemctl&nbsp; start&nbsp; firewalld.service(启动)，systemctl&nbsp; &nbsp;stop&nbsp; firewalld.service（关闭）</p>\n<p><strong>六，网络命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，wget：</strong>下载，例如：wget&nbsp; &nbsp;链接地址</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，yum：</strong>下载安装</p>\n<p><strong>七，vim（这里只说几个常用的命令）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;</strong>vim有三种模式：命令模式，插入模式，编辑模式&nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;vim&nbsp; 文件名：进入文件，且处于命令模式；iao任意一键进入插入模式（i表示在贯标之前插入，a光标之后插入，o在下一行插入），：进入编辑模式</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;命令：set:nu显示行号，set:nonu不显示行号；/strinng，向后搜索字符串，？string向后搜索字符串；：w保存，：wq保存并退出，：q不保存退出</p>","blogGoods":0,"blogId":"1248500061625745408","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6QE92AaLPoAADG_98SpI0054.jpg","blogRead":1,"blogRemark":"Linux基本命令总结","blogTitle":"Linux基本命令","createdTime":"2020-04-10 06:36:25","typeName":"Linux","updateTime":"2020-04-10 06:36:52"},{"blogCollection":0,"blogComment":0,"blogContent":"<p style=\"text-align: left;\"><strong>一，JVM运行机制</strong></p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;jvm即java虚拟机，一共由四个部分组成，分别是类加载器子系统，运行时数据区（程序计数器，本地方法区，jvm栈，方法区，jvm堆），执行引擎（即时编译器，垃圾收集器），本地接口库。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;一个java源程序的运行先是经过编译器将其编译成字节码文件（class文件），然后通过类加载器子系统将其加载进入jvm&mdash;&mdash;&gt;程序运行过程中，运行时数据区存放程序运行过程产生的数据&mdash;&mdash;&gt;执行引擎中的垃圾收集器收集程序运行过程中创建的不再使用的对象，即时编译器将程序的字节码文件编译成机器码&mdash;&mdash;&gt;然后本地接口库利用机器码调用本地方法库中的方法，和操作系统实现交互。</p>\n<pre><strong>二，多线程</strong></pre>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;</strong>在多核操作系统中，jvm支持一个进程中同时并发执行多个线程，且这些线程和本地操作系统的线程相对应。当jvm中的对象初始化，内存空间分配等一系列准备工作完成之后，会调用操作系统中的接口创建一个原生线程，原生线程初始化完毕后，会调用java线程的run（）方法执行该线程，线程结束之后，jvm会释放原生线程和java线程资源。</p>\n<p><strong>三，JVM的内存区域</strong></p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM的内存区域主要分为线程私有区域（程序计数器，本地方法区，JVM栈），线程共享区（方法区，JVM堆）和直接内存。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;程序计数器：线程私有区域，无内存溢出，用来记录程序运行过程中的字节码指令地址，如果是Native方法，则程序计数器为空。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM栈：线程私有区域，用来描述java程序的运行过程，java程序运行每次运行的时候，都会创建一个栈帧，方法的执行和返回对应着栈帧的入栈和出栈操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;本地方法区：线程私有区域，和JVM栈的功能一样，只不过是用来记录Native方法的运行过程。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM堆：线程共享区，主要用来存放程序运行过程中产生的数据，同时也是垃圾收集器进行垃圾回收的主要区域。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;方法区：也被称为永久代，用来存放常量，静态变量，类信息等等。</p>\n<p><strong>四，JVM的运行时内存</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>JVM的运行时内存又被称为JVM堆，因为JVM的GC算法使用的是分代收集算法，所以JVM堆按照GC标准可以分为三个区域分别为：新生代，老年代，永久代。其中新生代占1/3，老年代占2/3，永久代很少，</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;新生代：存放短生命周期，小对象的区域。新生代又分为Eden区，ServivorTo区，ServivorFrom区，区域的GC算法采用复制算法。Eden区是用来存放新创建的对象（大对象除外），ServivorTo区是用来保存MinorGC幸存下来的对象，ServivorFrom区是用来将上一次MinorGC幸存下来的对象作为下一次MinorGC的扫描对象。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;老年代：存放长生命周期的大对象，区域的GC算法采用标记整理算法</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;永久代：主要用来存放class和meta数据信息的。程序运行过程中不会进行永久代的垃圾回收，这也就导致永久代区域的数据会越来越多，最终造成内存溢出。java8之后永久代已经被元数据区取代，元数据区和永久代的功能都是一样的，但是最大的不同在于永久代区域依赖于虚拟机的内存大小，因而可以存储的class，meta信息非常有限。但是元数据区依赖的是本地操作系统，因而不会受到虚拟机内存的限制。</p>\n<p><strong>五，垃圾回收与算法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;(1)垃圾回收：</strong>Jvm的垃圾回收判定依赖于两种方法，引用计数法和可达性分析法。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;引用计数法：即如果想要在程序中使用对象，就必须赋予一个引用，这样在对象赋予引用的时候将其引用计数加1，删除一个引用时，将对象引用计数减1，如果引用计数为0，就说明该对象已经不使用，作为垃圾。但是引用计数法存在一个缺陷，即循环引用的问题，如果两个对象相互引用，则这两个对象的引用计数永远都不会为0，造成对象无法被回收。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;可达性分析法：即先创建一些根节点对象ROOTS，然后通过这些根节点对象向下搜索，如果一个对象到任意一个ROOTS之间都没有可达路径，在经过两次标记（下文解释为什么进行两次标记），还是没有可达路径，则说明该对象可回收。</p>\n<p>&nbsp;&nbsp; &nbsp;<strong>（2）GC算法：</strong>常见的GC算法有四种，分别为标记清除算法，复制算法，标记整理算法，分代收集算法</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;标记清除算法：即在进行垃圾回收前，对所有对象进行一次标记，标记可回收的对象，然后进行清理即可。但是标记清除算法在清除回收对象之后，并不会对堆内存进行整理，这样的话如果内存中的对象大部分为小对象，清理之后就会导致没有大片连续的内存空间，即造成了内存碎片化，这样大对象存储的时候就无法找到相应的完整连续内存。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;复制算法：即将内存分为两块同等大小的区域，区域1和区域2，创建的新对象都存储在区域1中，当区域1中的内存占满之后，会对内存中的所有对象进行一次标记，标记存活的对象，将存活的对象复制到区域2，这时区域1中的对象都是可回收对象，回收区域1中的所有对象即可。但是复制算法也存在着一定的缺陷，即每次都只能使用一半的内存空间，造成了大量的内存浪费。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;标记整理算法：即结合标记清除算法和复制算法的优点，先对所有的对象进行标记，标记存活的对象，将存活的对象复制到内存的另一端，然后清除当前端的对象即可。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;分代收集算法：前面的三种算法，都无法按照对象的类型进行收集，分代收集算法正是解决这个问题，按照对象的不同类型采用不同的GC算法。以JVM的分代收集算法为例，JVM的堆内存分为新生代，老年代，永久代。新生代又分为Eden区，ServivorTo区和ServivorFrom区。新生代因为其存储生</p>\n<p>命周期短的小对象，GC比较频繁，所以采用复制算法。程序运行过程中创建的对象都存储在Eden区（大对象除外，大对象直接复制到老年代区域）。当Eden区的内存不够的时候进行MinorGC，然后将Eden区和ServivorFrom区的存活对象都复制到ServivorTo区，然后将ServivorTo区和ServivorFrom</p>\n<p>区进行交换，再次进行MinorGC。老年代因为存放的都是生命周期长的大对象，因而进行GC的不会太频繁，且清除的对象并不会太多，因而采用标记整理算法。老年代每次进行MajorGC之前都会先进行一次MinorGC，当MinorGC之后新生代的内存仍然不够的时候，将对象复制到老年代进行MajorGC。</p>\n<p>永久代区域主要回收常量，无用class等。</p>\n<p><strong>六，JAVA中的四种引用类型</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;强引用类型<strong>：</strong>即把对象赋给一个引用变量，强引用的对象一定为可达状态，所以不会进行垃圾回收。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;软引用类型：通过SoftReference类实现，当内存不够的时候对其进行GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;弱引用类型：只有弱引用类型的对象，一定会被GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;虚引用类型：虚引用对象主要是用来跟踪对象的GC状态</p>\n<p><strong>七，分代收集算法和分区收集算法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>分代收集算法：新生代因其存放大量短生命周期小对象，且GC频繁，所以采用复制算法。老年代因其存放长生命周期大对象，且GC不平凡，所以采用标记整理算法。永久代，回收常量，类信息等。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;分区收集算法：即将堆内存区域分为大小不同的区，可以按照不同的区进行快速垃圾回收，减少系统的停顿时间。然后再以并行的方式逐步完成整个GC。</p>\n<p><strong>八，垃圾收集器</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>新生代区域：Serial垃圾收集器，单线程复制算法，因为单线程无需进行线程之间的交互和切换，所以效率非常高，是JVM默认的client模式下的默认垃圾回收策略，工作期间需要暂停其它所有的线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ParNew垃圾收集器，多线程复制算法，跟单线程Serial一样，是JVM默认的server模式下的垃圾回收策略，工作期间需要暂停所有其它线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Parallel Scavenge垃圾收集器：多线程复制算法，不同的是优先考虑系统吞吐量，可以利用更高效的利用CPU完成GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;老年代区域：Serial Old垃圾收集器，单线程标记整理算法，同新生代的Serial功能一样，只是采取的算法不同而已。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Parallel Old垃圾收集器：多线程标记整理算法，优先考虑了系统的吞吐量，其次考虑停顿时间。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CMS,多线程标记清除算法，优先考虑系统GC时的停顿时间，且过程分为四步（<span style=\"background-color: #ffff00;\">解释上文的可达性分析中的两次标记</span>，第一步：标记GC ROOTS可达对象，暂停其它工作线程；第二步：和用户线程一起工作，跟踪GC ROOTS；第三步，因为第二步用户进程没有暂停，所以有些对象状态</p>\n<p>可能发生了改变，重新进行标记；第四步，清除不可达对象）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; G1垃圾收集器，多线程标记整理算法，将内存分区，与CMS相比，一方面不会产生内存碎片，一方面，可以精确的控制系统停顿时间。</p>\n<p><strong>九，JAVA的网络编程模型</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;</strong>阻塞I/O模型：即用户线程发出I/O请求之后，内核会检查数据是否准备就绪，这时候用户线程始终处于阻塞状态等待数据准备就绪。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;非阻塞I/O模型：即用户线程不断的给内核发出I/O请求，内核接受到I/O请求之后会返回一个状态，如果数据准备就绪，就将数据复制进入用户线程，如果数据没有准备好，返回一个false，用户线程无需阻塞，可以去处理其它事情，而当数据准备好了且刚好用户线程发起I/O请求进行操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;多路复用I/O模型：多路复用I/O模型通过一个Selector线程轮询Socket的状态，如果Socket有读写事件，则进行I/O操作。此模型的优势在于可以更好的处理连接数众多但消息体不大的情况下。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;信号驱动I/O模型：即用户线程发出一个I/O请求，系统会为该请求创建一个信号函数，用户请求可继续执行其它业务逻辑，当内核数据准备就绪之后会返回给用户线程一个信号，用户线程接收到之后进行I/O操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;异步I/O模型：用户线程给内核发起一个asynchronous read操作，内核接收到之后，返回其请求是否成功，然后等待数据准备成功之后复制到用户线程。整个过程中请求的发起和数据读取都在内核中进行，最终发送一个信号告知用户线程I/O操作已经完成，用户直接使用数据就行。（说实话个人感</p>\n<p>觉和信号驱动很像）</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;java NIO：没怎么读懂（<span style=\"background-color: #993300;\">记得补充！</span>）</p>\n<p><strong>十，JVM的类加载机制</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>JVM类加载分为五个阶段：加载，验证，准备，解析，初始化</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;加载：即将class文件加载到JVM中，且创建class对象，封装其数据结构。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;验证：对class文件进行验证，确保符合JVM的标准，保证JVM的安全。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;准备：即方法区中给类变量分配空间和赋初值。static修改的会在初始化阶段赋值，final修饰的会在准备阶段赋值。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;解析：即将常量池中的引用替换为直接引用</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;初始化：执行类构造器进行初始化。（因为内部流程不是很清楚，所以对于其几种不进行初始化的情况不做说明）</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;类加载器：JVM提供了三种类加载器，启动类加载器（/lib），扩展类加载器(/lib/ext)，应用程序类加载器(classpath)。还可以再应用程序类加载器自定义类加载器。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;双亲委派机制：即当一个类接收到类加载请求的时候，不会自己进行加载，而是将其加载请求委派给其父类加载器，这样一路委派，最终加载请求都会委派到启动类加载器.启动类加载器接收到加载请求之后会去lib目录下寻找相关的class文件，若找不到，则将其加载请求再委培给子类加载器，一路委</p>\n<p>派，直到能够加载。</p>\n<p>&nbsp;</p>\n<h2>水平有限，若发现有误，还望指出！</h2>","blogGoods":0,"blogId":"1248224512563068928","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PEz6AUs0lAAB4ISeFCt8304.jpg","blogRead":7,"blogRemark":"面试（一）------之JVM篇","blogTitle":"面试（一）------之JVM篇","createdTime":"2020-04-09 12:21:30","typeName":"java面试篇","updateTime":"2020-04-12 12:45:18"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，css之弹性布局</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，</strong>何为弹性布局？</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 弹性布局是css的一种新的布局方式，所谓&ldquo;弹性布局&rdquo;，即页面随着不同设备的屏幕大小拉伸会自适应页面的大小。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，</strong>弹性布局的两种主要元素，container（弹性容器），item（弹性子元素），一个弹性容器中可以放入多个弹性子元素，元素之间是可以进行嵌套的，弹性子元素也可以设置为弹性容器，里面再嵌套弹性子元素。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，</strong>弹性布局的基本属性</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （1）display：flex，声明容器为弹性布局</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （2）flex-direction：声明弹性容器内部元素的排列方式，默认为row。row（横向布局），row-reverse（横向布局，但是元素反方向码），column（纵向布局），column-reverse（纵向布局，但是元素反着码）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （3）flex-wrap：声明弹性盒子中的元素是否可以换行，默认为nowrap（不换行），wrap（换行），wrap-reverse（换行，但是反着码）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （4）align-items：设置容器中元素在纵轴方向上的对齐方式，默认为stretch（即如果不设置子元素高度，则默认拉伸至于容器同宽度），flex-start（子元素位于容器的开始位置），flex-end（子元素位于容器的结尾处），center（元素依纵轴方向居中），baseline（元素位于容器基线，不过没怎么用过，所以不是很清楚）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （5）justify-content（设置元素在主轴上的对齐方式），默认为flex-start（元素从容器主轴开始位置码），flex-end（元素从容器主轴结尾处码），center（元素位于主轴居中处），space-between（元素布局在容器的两端），space-around（元素布局在容器两端，但是元素前后都留有空白）因为项目中大多数只使用了对于容器的操作，对于容器中元素的操作很少，所以这里只介绍这点。谢谢阅读！</p>","blogGoods":0,"blogId":"1248135765829918720","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6OwJOAYOmCAACSMXNdKeQ941.jpg","blogRead":2,"blogRemark":"CSS----之flex弹性布局","blogTitle":"CSS----之flex弹性布局","createdTime":"2020-04-09 06:28:51","typeName":"CSS","updateTime":"2020-04-10 13:46:01"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，前后端分离开发优势</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，</strong>项目开发过程中，前后端完全解耦，前端只需要负责页面的实现，只需要通过接口拿数据。后端不需要管页面的跳转，只需要负责接口的编写</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，</strong>前后端人员有更多的精力去负责自己的工作，前端人员可以将更多的精力投放在页面的编写，页面的美化，页面特效的制作和用户体验上；而后端人员可以将更多的精力放在接口代码的优化，sql优化，jvm调优上面</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，</strong>前后端分离的项目部署的时候，前端项目往往都是部署在nginx服务器上，而前后端不分离的项目往往都是部署再一台服务器上。因此前后端分离项目大大降低了服务器的负担</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>4，</strong>前后端不分离的项目使用模板引擎例如freemaker，thymeleaf等，前后端人员交流起来较为困难。且前端项目使用原生的DOM操作，极大的增加了前端工作人员的工作量。而前后端分离项目前端通常都是用各种ui框架，框架采用MVVM模式，极大的减轻了前端工作人员的工作量</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，</strong>前后端分离开发，前端可以通过easy-mock来伪造接口数据进行测试，后端人员可以通过postman进行接口测试，开发效率大大提升。</p>","blogGoods":0,"blogId":"1247867141693128704","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NxmWAR3lsAAB7Q44XPGk369.jpg","blogRead":7,"blogRemark":"前后端分离开发的优势所在","blogTitle":"闲谈前后端分离开发","createdTime":"2020-04-08 12:41:25","typeName":"随笔","updateTime":"2020-04-10 13:45:56"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，数据库设计--表的命名规范等</strong></p>\n<p>（1），统一采用bl_开头对表进行命名</p>\n<p>（2），对于数据比较重要的表统一添加四个字段，分别为：created_time(创建时间),update_time(修改时间),version(版本号),deleted(删除字段)</p>\n<p>（3），数据库表的字段尽量都设置为NOT_NULL</p>\n<p>（4），数据库中表varchar类型字段需要设置长度的尽量设置为2<sup>n</sup>-1</p>\n<p>（5），因为博客系统分为前台展示界面和后台管理，所以对于有些表，例如bl_type（博客类型表），bl_music（音乐表）等设置了enable（启用字段）</p>\n<p><strong>二，上述第二条--四个字段的解释</strong></p>\n<p>（1），为什么要设置created_time和update_time字段：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;其一，从数据库的通用性上来说，设计这两个字段是必要的，但也需要根据业务的需要来合理添加这两个字段，因为无用的字段会浪费空间，性能，影响系统的运行。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 其二，大部分的应用都有需要根据时间进行排序的功能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 其三，当系统发生异常的时候，我们可以通过这两个字段对异常进行排查和定位。</p>\n<p>（2），为什么要设置version字段：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 1，version字段含义：字段的含义与其字面意思一样，代表版本，在这里作为乐观锁进行使用，从而保证不会出现脏数据的情况。下面解释一下什么叫乐观锁，以及乐观锁和悲观锁</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 2，乐观锁：总是假定最好的情况，即每次用户调用接口从数据库中取出数据到修改数据前的过程中，不会有其它用户对当前数据进行修改，这样在当前用户修改数据的时候，利用版本机制即判断取出的version字段和当前数据库该条数据的version字段是否相等来判断该条数据是否已经被修改，如果未修改，则予以修改（且version字段递增），如果已经修改，则提示用户更新失败。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 悲观锁：总是假定最坏的情况，即每次用户调用接口从数据库取出数据的时候，都认为该条数据会被修改，因此每次取出数据都对数据进行加锁处理，只允许当前用户进行修改，其它用户阻塞，直到当前用户修改完毕。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3，为什么使用乐观锁而不使用悲观锁：因为悲观锁比较浪费性能</p>\n<p>（3），为什么设置deleted字段：deleted字段在这里作为一个逻辑删除字段（0否1是），何为逻辑删除，即执行删除操作操作的时候，不会真正的删除数据库中的数据，而是将deleted字段设置为1即可。&nbsp;这样如果用户出现误删的操作，可以通过数据库修改该字段进行数据的恢复。</p>\n<p><strong>三，上述第三条--数据库表字段尽量设置为NOT_NULL</strong></p>\n<p>（1），数据库表字段尽量设置为NOT_NULL：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 1，有些人可能认为设置为NULL相比于NOT_NULL不是更节省空间吗？但是实际上不是这样的，设计为NULL相比于NOT_NULL要多占用一个字节的空间</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 2，设计为NOT_NULL，这样在做查询的时候能够更好的避免空指针异常，且发生该类错误的时候能够更好的进行排查</p>\n<p><strong>四，上述第四条--表varchar类型字段长度尽量设置为2<sup>n</sup>-1</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>因为计算机只识别二进制，且有一定的范围，例如2<sup>8</sup>，在计算机中的范围为-128~127,因此对于varchar字段长度来说，如果设置为255，则正好是一个字节，而如果设置为256，则占用两个字节，这样会浪费计算机的内存空间，因此数据库varchar类型字段的长度最好设置为2<sup>n</sup>-1</p>\n<p><strong>五，上述第五条--对于设置enable字段的解释</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>enable字段，字面意思启用，在这里表明是否启用（0否1是），因为系统分为前台博客页面和后台管理，对于这两个不同的前端项目，后台可以通过启用字段来控制内容在前台博客页面的展示与否，与deleted字段不同的是，如果执行删除操作，那么我们只能通过手动修改数据库中的字段进行数据的恢复，且如果执行删除操作，则该数据在前台博客页面和后台管理页面都无法看见。但是如果将数据弃用（即修改enable字段值为1），则表明该数据被弃用，在前台博客页面无法显示，但是在后台管理页面可以看见，且无需通过手动修改数据库来恢复数据，可以在后台管理页面操作启用数据。</p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1247745014683947008","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NVHmAfuv6AADVlotocVo322.jpg","blogRead":21,"blogRemark":"博客开发总结（一）-----之数据库设计篇","blogTitle":"博客开发总结（一）-----之数据库设计篇","createdTime":"2020-04-08 04:36:07","typeName":"博客开发和维护总结","updateTime":"2020-04-12 12:57:33"}],"pageSize":15,"params":{},"sortColumn":"created_time","sortMethod":"DESC","totalCount":15,"totalPage":1},"msg":"操作成功!"}
2020-04-17 10:16:10.149 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /comment/getComment/1249742755949817856
2020-04-17 10:16:10.149 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/getGoods/1249742755949817856
2020-04-17 10:16:10.150 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /comment/getCommentGoods/1249742755949817856
2020-04-17 10:16:10.150 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/read/1249742755949817856
2020-04-17 10:16:10.150 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/getCollection/1249742755949817856
2020-04-17 10:16:10.150 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-17 10:16:10.150 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-17 10:16:10.150 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-17 10:16:10.150 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-17 10:16:10.150 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-17 10:16:10.150 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-17 10:16:10.150 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-17 10:16:10.150 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-17 10:16:10.150 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.CommentController.getComment
2020-04-17 10:16:10.150 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-17 10:16:10.150 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-17 10:16:10.150 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.CommentController.getCommentGoods
2020-04-17 10:16:10.150 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[1249742755949817856]
2020-04-17 10:16:10.150 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getCollection
2020-04-17 10:16:10.151 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getGoods
2020-04-17 10:16:10.151 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.readBlog
2020-04-17 10:16:10.151 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[1249742755949817856]
2020-04-17 10:16:10.151 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[1249742755949817856]
2020-04-17 10:16:10.151 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[1249742755949817856]
2020-04-17 10:16:10.151 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[1249742755949817856]
2020-04-17 10:16:10.306 ERROR [http-nio-1000-exec-6]o.a.c.c.C.[Tomcat].[localhost].[/].[dispatcherServlet].log:175 -Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.NullPointerException] with root cause
java.lang.NullPointerException: null
	at com.wcj.service.impl.BlogServiceImpl.getCollection(BlogServiceImpl.java:279)
	at com.wcj.service.impl.BlogServiceImpl$$FastClassBySpringCGLIB$$428136bb.invoke(<generated>)
	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)
	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:685)
	at com.wcj.service.impl.BlogServiceImpl$$EnhancerBySpringCGLIB$$4fa08134.getCollection(<generated>)
	at com.wcj.controller.BlogController.getCollection(BlogController.java:206)
	at com.wcj.controller.BlogController$$FastClassBySpringCGLIB$$39c39313.invoke(<generated>)
	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:769)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)
	at org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor.invoke(MethodBeforeAdviceInterceptor.java:56)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)
	at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:88)
	at com.wcj.aspect.LogAspect.doAround(LogAspect.java:63)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:644)
	at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:633)
	at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:70)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)
	at org.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:55)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)
	at org.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:62)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)
	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:95)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)
	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:689)
	at com.wcj.controller.BlogController$$EnhancerBySpringCGLIB$$1ae7ca4c.getCollection(<generated>)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:106)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:879)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:112)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.shiro.web.servlet.ProxiedFilterChain.doFilter(ProxiedFilterChain.java:61)
	at org.apache.shiro.web.servlet.AdviceFilter.executeChain(AdviceFilter.java:108)
	at org.apache.shiro.web.servlet.AdviceFilter.doFilterInternal(AdviceFilter.java:137)
	at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:125)
	at org.apache.shiro.web.servlet.ProxiedFilterChain.doFilter(ProxiedFilterChain.java:66)
	at org.apache.shiro.web.servlet.AbstractShiroFilter.executeChain(AbstractShiroFilter.java:449)
	at org.apache.shiro.web.servlet.AbstractShiroFilter$1.call(AbstractShiroFilter.java:365)
	at org.apache.shiro.subject.support.SubjectCallable.doCall(SubjectCallable.java:90)
	at org.apache.shiro.subject.support.SubjectCallable.call(SubjectCallable.java:83)
	at org.apache.shiro.subject.support.DelegatingSubject.execute(DelegatingSubject.java:383)
	at org.apache.shiro.web.servlet.AbstractShiroFilter.doFilterInternal(AbstractShiroFilter.java:362)
	at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:125)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:367)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1639)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.lang.Thread.run(Thread.java:745)
2020-04-17 10:16:10.306 ERROR [http-nio-1000-exec-3]o.a.c.c.C.[Tomcat].[localhost].[/].[dispatcherServlet].log:175 -Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.NullPointerException] with root cause
java.lang.NullPointerException: null
	at com.wcj.service.impl.BlogServiceImpl.getGoods(BlogServiceImpl.java:243)
	at com.wcj.service.impl.BlogServiceImpl$$FastClassBySpringCGLIB$$428136bb.invoke(<generated>)
	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)
	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:685)
	at com.wcj.service.impl.BlogServiceImpl$$EnhancerBySpringCGLIB$$4fa08134.getGoods(<generated>)
	at com.wcj.controller.BlogController.getGoods(BlogController.java:178)
	at com.wcj.controller.BlogController$$FastClassBySpringCGLIB$$39c39313.invoke(<generated>)
	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:769)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)
	at org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor.invoke(MethodBeforeAdviceInterceptor.java:56)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)
	at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:88)
	at com.wcj.aspect.LogAspect.doAround(LogAspect.java:63)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:644)
	at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:633)
	at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:70)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)
	at org.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:55)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)
	at org.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:62)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)
	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:95)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)
	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:689)
	at com.wcj.controller.BlogController$$EnhancerBySpringCGLIB$$1ae7ca4c.getGoods(<generated>)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:106)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:879)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:112)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.shiro.web.servlet.ProxiedFilterChain.doFilter(ProxiedFilterChain.java:61)
	at org.apache.shiro.web.servlet.AdviceFilter.executeChain(AdviceFilter.java:108)
	at org.apache.shiro.web.servlet.AdviceFilter.doFilterInternal(AdviceFilter.java:137)
	at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:125)
	at org.apache.shiro.web.servlet.ProxiedFilterChain.doFilter(ProxiedFilterChain.java:66)
	at org.apache.shiro.web.servlet.AbstractShiroFilter.executeChain(AbstractShiroFilter.java:449)
	at org.apache.shiro.web.servlet.AbstractShiroFilter$1.call(AbstractShiroFilter.java:365)
	at org.apache.shiro.subject.support.SubjectCallable.doCall(SubjectCallable.java:90)
	at org.apache.shiro.subject.support.SubjectCallable.call(SubjectCallable.java:83)
	at org.apache.shiro.subject.support.DelegatingSubject.execute(DelegatingSubject.java:383)
	at org.apache.shiro.web.servlet.AbstractShiroFilter.doFilterInternal(AbstractShiroFilter.java:362)
	at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:125)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:367)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1639)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.lang.Thread.run(Thread.java:745)
2020-04-17 10:16:10.316 ERROR [http-nio-1000-exec-6]com.wcj.advice.BlogExceptionHandler.exceptionHandler:28 -统一异常处理,
com.wcj.exception.BlogException: 当前帐号未登录!
	at com.wcj.interceptor.LoginInterceptor.preHandle(LoginInterceptor.java:48)
	at org.springframework.web.servlet.HandlerExecutionChain.applyPreHandle(HandlerExecutionChain.java:141)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1035)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:712)
	at org.apache.catalina.core.ApplicationDispatcher.processRequest(ApplicationDispatcher.java:461)
	at org.apache.catalina.core.ApplicationDispatcher.doForward(ApplicationDispatcher.java:384)
	at org.apache.catalina.core.ApplicationDispatcher.forward(ApplicationDispatcher.java:312)
	at org.apache.catalina.core.StandardHostValve.custom(StandardHostValve.java:394)
	at org.apache.catalina.core.StandardHostValve.status(StandardHostValve.java:253)
	at org.apache.catalina.core.StandardHostValve.throwable(StandardHostValve.java:348)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:173)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:367)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1639)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.lang.Thread.run(Thread.java:745)
2020-04-17 10:16:10.316 ERROR [http-nio-1000-exec-3]com.wcj.advice.BlogExceptionHandler.exceptionHandler:28 -统一异常处理,
com.wcj.exception.BlogException: 当前帐号未登录!
	at com.wcj.interceptor.LoginInterceptor.preHandle(LoginInterceptor.java:48)
	at org.springframework.web.servlet.HandlerExecutionChain.applyPreHandle(HandlerExecutionChain.java:141)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1035)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:712)
	at org.apache.catalina.core.ApplicationDispatcher.processRequest(ApplicationDispatcher.java:461)
	at org.apache.catalina.core.ApplicationDispatcher.doForward(ApplicationDispatcher.java:384)
	at org.apache.catalina.core.ApplicationDispatcher.forward(ApplicationDispatcher.java:312)
	at org.apache.catalina.core.StandardHostValve.custom(StandardHostValve.java:394)
	at org.apache.catalina.core.StandardHostValve.status(StandardHostValve.java:253)
	at org.apache.catalina.core.StandardHostValve.throwable(StandardHostValve.java:348)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:173)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:367)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1639)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.lang.Thread.run(Thread.java:745)
2020-04-17 10:16:10.344 INFO  [http-nio-1000-exec-10]org.mongodb.driver.connection.info:71 -Opened connection [connectionId{localValue:2, serverValue:287}] to 121.199.34.159:27017
2020-04-17 10:16:10.354 INFO  [http-nio-1000-exec-4]org.mongodb.driver.connection.info:71 -Opened connection [connectionId{localValue:3, serverValue:288}] to 121.199.34.159:27017
2020-04-17 10:16:10.405 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 256
2020-04-17 10:16:10.406 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[],"msg":"操作成功!"}
2020-04-17 10:16:10.463 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 313
2020-04-17 10:16:10.463 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[],"msg":"操作成功!"}
2020-04-17 10:16:10.519 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 369
2020-04-17 10:16:10.520 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，线程上下文切换</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>cpu利用时间片轮询的方式来为每个任务都分配一定的时间片，任务的执行过程中保存任务的状态。任务状态的保存和在加载就叫做上下文切换。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>进程：</strong>指的是一个运行中的程序实例，一个进程中可以有多个线程，并且与进程共享同样的内存和系统资源</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong> 上下文：</strong>指的是寄存器和程序计数器保存的线程的信息</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>寄存器：</strong>指的是内存中很小但是运行速度很快的一块区域（相对于RAM外部内存）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>程序计数器：</strong>一种寄存器，用来保存当前执行指令的位置或者下一个待执行指令的位置</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>上下文切换：</strong>上下文切换指的是操作系统的内核在cpu上对进程或者线程的切换。上下文信息保存在进程控制块中（PCB）。流程如下：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;挂起当前进程，将进程的上下文信息保存在进程控制块中；</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;在进程控制块中寻找下一个任务的上下文信息。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;恢复进程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>上下文切换的原因：</strong>第一，任务正常执行完毕，调度下一个任务；第二，线程出现I/O阻塞，被挂起，cpu调度下一个任务；第三，线程等待同步锁，获取socket通知等，被挂起，cpu调度下一个任务；第四，用户调用sleep方法，让出cpu；第五，硬件中断</p>\n<h2><strong>二，JAVA阻塞队列</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>阻塞队列的是调度当前队列的线程处于阻塞状态</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 消费者阻塞：如果队列为空，则消费者线程被挂起，处于阻塞状态，当有新数据进入队列，则消费者线程被唤醒，消费数据</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 生产者阻塞：如果队列数据已满，则生产者线程挂起，处于阻塞状态，当队列有空闲位置，生产者线程被唤醒，生产数据。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞队列的主要操作：</strong>插入操作和移除（获取）操作</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>插入操作：</strong>add(e)，有空间则插入，无空间报异常；offer(e),有空间则插入，无空间返回false；offer(e,time,unit),有空间插入，无空间等待time时间，若超时返回false；put(e),有空间插入，无空间则线程挂起处于阻塞直到有空间</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>移除操作：</strong>poll(e),有值返回值，无值返回null;poll(e,time,unit),有值返回值，无值等待time时间，超时返回null;take(e),有值返回值，无值等待新数据进入再立即返回；drainTo(collection&lt;Object&gt;)批量移除，提高获取效率</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞队列的实现：</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong> ArrayBlockingQueue：</strong>基于数组的有界阻塞队列，按照先进先出顺序对元素进行排序</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>LinkedBlockingQueue：</strong>基于链表的有界阻塞队列，队头队尾采用不两个不同的锁控制数据同步，并发性高</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>PriorityBlockingQueue：</strong>基于优先级的无界队列，默认升序排列，可以自定义排序规则，根据优先级访问数据。但是有数据优先级一样的情况</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>DelayQueue：</strong>支持延时的队列，即从队列中取数据时等待一定的时间才能获取元素。可以用于缓存系统的设计，设计过期时间，也可以用来设置定时调度任务，即如果能够从队列中获取，说明到了任务的调度时间。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>SynchronousQueue</strong>：没怎么读懂（<span style=\"background-color: #ffff00;\">记得补充</span>！）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>LinkedTransferQueue：</strong>基于链表的无界阻塞队列，多了transfer方法(如果消费者等待，直接将任务从生产者传递给消费者，无消费者等待，则将任务加到队尾直到被消费才返回)和tryTransfer（与transfer一致，只不过不管有没有消费者等待获取都会立即返回tryTransfer（e,time,unit）（与tryTransfer一致，只不过设置了超时时间）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>LinkedBlockingDeque：</strong>基于链表的双向阻塞队列，可以在两端同时进行读写操作，提高了队列的操作效率。</p>\n<h2><strong>三，并发关键字</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;CountDownLatch：</strong>适用于一个主线程等待子线程完成任务之后执行（原理：设置一个程序计数器，计数器的值为子线程的个数，子线程并发执行，每个子线程执行完毕后，调用CountDown方法，将其计数器的值减去1，值为0时，唤醒主线程执行）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>CyclicBarrier：</strong>即当所有线程到达一个状态共同执行。await（）方法：确保所有线程到达Barrier状态才执行；await（time,unit）：设置一个超时时间，超过这个时间，执行达到Barrier状态的线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>Semaphore：</strong>因为其限制了多线程访问资源的线程个数，所以适用于多线程并发访问有限资源的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>volatile：</strong>直接用来修饰变量，是一种比Synchronized更加轻量级的机制，用于多线程共享同一变量，可以同时对其进行读写操作。当多个线程共享变量的时候，读取变量将其从内存复制到cpu缓存中，然后线程对其操作进行修改，这样再多cpu的情况下，有可能出现线程修改原数据造成数据不一致的情况，使用volatile关键字直接将线程修改的变量存入内存，解决这个问题。</p>\n<h2><strong>四，多线程共享数据</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>多线程共享数据主要通过共享内存实现，而共享内存的可见性，有序性，原子性已经由JVM和锁解决。理想情况下我们需要解决同步和互斥的问题（<span style=\"background-color: #ffff00;\">怎么解决的有待考证！</span>）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>解决方法一：</strong>将数据抽象成一个类，将对数据的操作封装成类中的方法</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解决方法二：</strong>将Runnable对象作为一个内部类，将共享数据作为这个类的成员变量</p>\n<h2><strong>五，ConcurrentHashmap并发</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ConcurrentHashmap使用了减小锁粒度，这里具体为分段锁的思想优化了锁，因为如果直接对hashmap进行加锁，锁太大，而且同一时刻只能有一个线程操作hashmap，并发性能较差</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;实现原理：</strong>即内部采用分段锁思想，将hashmap分为多个segment，每次读取数据的时候，对数据所在的segment进行加锁，这样只要保证每个segment线程安全，就可以保证整个hashmap线程安全</p>\n<h2><strong>六，JAVA中的线程调度</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;抢占式调度：</strong>即线程对cpu资源进行抢占，这种策略下每个线程抢占到cpu资源的概率是相等的，这样就不会一个线程阻塞造成整个系统阻塞的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>协同式调度：</strong>即一个线程使用完cpu资源之后通知cpu调度下一个任务，适用于多线程交替执行任务。因为如果一个线程阻塞可能会造成整个系统阻塞甚至崩溃</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>JAVA采用的是抢占式调度，但同时又尽可能的保证公平性（即为每个线程分配优先级不同的cpu时间片）</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>&nbsp;线程让出cpu的情况</strong>：第一，线程调用yield方法；第二，I/O阻塞，socket等待等；第三，等待同步锁；第四，正常执行完毕</p>\n<h2>七，进程调度算法</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>优先调度算法：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;先来先服务调度算法：</strong>即遵循先来先被分配cpu资源运行的原则</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>短作业调度算法：</strong>即预估作业的时间长短，优先调度时间短的任务，可能会导致长时间大任务很长时间无法被调度 &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>高优先权调度算法：即每个任务会预先被分配优先级</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;非抢占式优先调度算法：</strong>按照优先级的高低一次分配cpu资源运行</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>抢占式优先调度算法：</strong>按照优先级的高低分配cpu资源运行，但是如果任务再运行过程中有优先级更高的任务加入，则将其cpu资源临时回收分配给紧急任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>高响应比调度算法：</strong>动态调度，即作业时间短，则优先级高；等待时间长，则优先级高。前者遵循短作业调度算法，后者遵循先来先服务原则。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>时间片轮转调度算法：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;时间片轮转法：</strong>按照任务再队列中的顺序进行调度</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>多级反馈队列调度算法：</strong>即再时间片轮转法的基础上维护了就绪队列，默认第一队列优先级高，先调度第一队列的任务，如果再分配的cpu时间片内未完成则将其加入第二队列队尾，以此类推直到其执行完毕。只有第1 -（n-1）队列为空，才会调度第n队列的任务，而且当前任务执行时，如</p>\n<p>果有优先级高的任务进来，会抢占其cpu资源。</p>\n<h2><strong>八，CAS</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>即比较和交换，CAS（V,E,N）三个参数，只有当V=E的时候才会将V设置为N。如果V!=E，则说明数据已经被其它线程修改，不做任何操作</p>\n<h2><strong>九，ABA问题</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>概述：</strong>即当1线程从V中取出A时，2线程也从中取出1，修改为B，再修改为A。而1线程仍然修改成功，实际上修改过程中V的实际值已经发生改变，只不过1没有发觉。解决这种问题，常采用乐观锁的版本号机制。</p>\n<h2><strong>另外有AQS问题没怎么读懂，下次完善！</strong></h2>\n<p>&nbsp;</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</p>","blogGoods":0,"blogId":"1249742755949817856","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6UmSuAdB35AABzd_wnH78043.jpg","blogRead":2,"blogRemark":"面试（三）------之并发编程篇（下）","blogTitle":"面试（三）------之并发编程篇（下）","createdTime":"2020-04-13 16:54:26","typeName":"java面试篇","updateTime":"2020-04-13 16:54:43"},"msg":"操作成功!"}
2020-04-17 10:46:49.537 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /rotation-picture/listFront
2020-04-17 10:46:49.543 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-17 10:46:49.544 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/list
2020-04-17 10:46:49.544 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-17 10:46:49.544 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-17 10:46:49.544 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-17 10:46:49.544 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.RotationPictureController.getRotationPictureListFront
2020-04-17 10:46:49.545 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogList
2020-04-17 10:46:49.545 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-17 10:46:49.545 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=15, totalPage=0, totalCount=0, list=[], params={}, sortColumn=created_time, sortMethod=DESC)]
2020-04-17 10:46:51.689 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 2153
2020-04-17 10:46:51.690 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"createdTime":"2020-04-09 13:31:10","enable":1,"rotationId":3,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PI5KAYzGaAAGfH751PIw644.jpg"},{"createdTime":"2020-04-09 13:31:20","enable":1,"rotationId":4,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PI6aAZIz1AASCO4hlpJI295.jpg"},{"createdTime":"2020-04-09 13:37:02","enable":1,"rotationId":9,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJPyAbm8fAAG9gfO8lxE28.jpeg"},{"createdTime":"2020-04-09 13:41:30","enable":1,"rotationId":10,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJgeAeG8wAAS2pjJC5QU547.jpg"},{"createdTime":"2020-04-09 13:41:38","enable":1,"rotationId":11,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhGAQFZbAAP2OOBWb6k310.jpg"},{"createdTime":"2020-04-09 13:41:50","enable":1,"rotationId":12,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhyABMZCAAG7doyXiM8109.jpg"},{"createdTime":"2020-04-09 13:41:59","enable":1,"rotationId":13,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJiWAL7BoAARW3_O3ISw651.jpg"}],"msg":"操作成功!"}
2020-04-17 10:46:53.006 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 3462
2020-04-17 10:46:53.009 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogContent":"<h2>问题描述：</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; <strong>之前还没有注意到，直到最近两天写博客的时候，发现博客的创建时间信息和实际时间对不上号，总是早了八个小时，一开始以为是项目中没有配置时区的问题，所以看了一下项目的配置，结果发现数据库连接中加入了\"serverTimezone=GMT%2B8\"；所以想到的是不是哪个地方配置了什么，导致servrTimezone的配</strong><strong>置失效了，然后又试了一下网上提供的两种方法，很幸运的都失败了哈哈，之后就考虑到是不是mysql数据库本身的时区问题，然后修改了mysql本身的时区解决了这个问题。在这里总结一下</strong></p>\n<h2><strong>问题的具体情况（以添加一篇博客为例）</strong></h2>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 我这里添加博客的时候，前台传回来的数据中只有博客的内容，标题等信息，并不包括创建时间的信息，而后台进行数据保存逻辑的时候，也并没有往实体中的createdTime字段添加new Date（）信息，而是让数据库的ceated_time字段根据当前时间自动生成时间信息（<span style=\"background-color: #ffcc00;\">因此不是根据数据库自动生成时间信息的小伙伴</span>，</strong><strong><span style=\"background-color: #ffcc00;\">只需要看看常用解决办法即可</span>）</strong></p>\n<h2><strong>常用解决办法</strong></h2>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;一，在数据库连接url中加入serverTimezone=GMT%2B8,如下：</strong></p>\n<pre class=\"language-markup\"><code>url: jdbc:mysql://localhost:3306/blog?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>二，springboot项目中也可以在yml文件中进行如下配置：</strong></p>\n<pre class=\"language-markup\"><code>spring:\n   jackson:\n      time-zone: GMT+8</code></pre>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 三，相对比较麻烦，也是不建议使用的一种方法（要是实体类很多，怕是添加起来会很难受的哦），即在实体类的时间字段上添加注解如下：</strong></p>\n<pre class=\"language-markup\"><code>@JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\",timezone = \"GMT+8\")\n    private String createdTime;</code></pre>\n<h2><strong>我的解决办法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;因为博主试了上面的所有办法，发现都无效，因此就考虑到是不是mysql数据库本身的时区问题，然后一测试，发现果然是这样的。博主的项目是部署在docker上的，因此详细步骤可能不具备参考性，这里挑重点的说：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;首先，命令行进入mysql：mysql&nbsp; -uroot&nbsp; &nbsp;-p&nbsp; 回车，然后输入mysql的密码进入mysql。<span style=\"background-color: #ffcc00;\">注意进入到mysql之后输入命令都要以；结尾或者\\g结尾哦</span></strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;然后：select now();&nbsp; &nbsp;查看mysql的当前时间，到这里和当前的真实时间对比一下就知道是否是mysql本身的时区问题了（下面是该命令显示界面，然后我发现果然是mysql的问题）</strong></p>\n<pre class=\"language-markup\"><code>mysql&gt; select now();\n+---------------------+\n| now()               |\n+---------------------+\n| 2020-04-16 14:24:38 |\n+---------------------+\n</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>之后，在查看mysql的时区变量：show&nbsp; variables like&nbsp; \"%time_zone%\";&nbsp; （这里就发现了问题，mysql这里默认采用的UTC，及世界通用时间，正好这个时间比北京东八区的时间少了八个小时）</strong></p>\n<pre class=\"language-markup\"><code>mysql&gt; show variables like \"%time_zone\";\n+------------------+--------+\n| Variable_name    | Value  |\n+------------------+--------+\n| system_time_zone | UTC    |\n| time_zone        | SYSTEM |\n+------------------+--------+</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>修改mysql的时区</strong></p>\n<pre class=\"language-markup\"><code>mysql&gt; set global time_zone = '+08:00';\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql&gt; set time_zone = '+08:00';\nQuery OK, 0 affected (0.00 sec)</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; <strong>再刷新一下即可：</strong></p>\n<pre class=\"language-markup\"><code>mysql&gt; flush privileges;\nQuery OK, 0 rows affected (0.02 sec)</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>最后，再查看一下当前的时区设置：show&nbsp; varibales like \"%time_zone%\";&nbsp; 发现已经在UTC时间基础上加了8个小时</strong></p>\n<pre class=\"language-markup\"><code>+------------------+--------+\n| Variable_name    | Value  |\n+------------------+--------+\n| system_time_zone | UTC    |\n| time_zone        | +08:00 |\n+------------------+--------+</code></pre>\n<p>&nbsp;</p>\n<h1>水平有限，如果不对，可以探讨交流啦！</h1>","blogGoods":0,"blogId":"1250802898447667200","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6YdI6ARhHKAAMyt4z7zK450.jpeg","blogRead":4,"blogRemark":"项目中的时区问题","blogTitle":"项目中的时区问题","createdTime":"2020-04-16 23:07:05","typeName":"博客开发和维护总结","updateTime":"2020-04-16 23:14:46"},{"blogCollection":0,"blogComment":1,"blogContent":"<h2><strong>一，分布式缓存</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;进程内缓存：对于用户信息，热点数据等信息，访问比较频繁，我们将其存放进入缓存，用户查询数据的时候直接从内存种读取，而不需要从数据库查询，既降低了数据库的负载，同时又提升了查询效率。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;分布式缓存：对于单点web应用，我们使用进程内缓存就足够了，但是对于分布式系统，数据库是部署在多个服务器上分布式数据库，缓存则是部署在多个服务器上的分布式缓存，并且缓存数据存在备份，当一个缓存服务挂掉之后，可以立即启用备份的缓存进行工作（高可用）。</strong></p>\n<h2><strong>二， redis的基本数据类型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;String，hash，List，Set，Zset</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;基本数据类型的基本命令见redis篇：<a href=\"http://localhost:1002/info/1249588251598041088\">http://localhost:1002/info/1249588251598041088</a></strong></p>\n<h2><strong>三，redis管道</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;客户端发出一个redis命令请求之后，会监控socket，客户端处于阻塞状态，直到服务器端返回结果，客户端才可以继续发出下一个请求。且在分布式系统中，redis是部署在不同的服务器上，这样服务器之间的数据传输还会有一定的延迟，redis的性能瓶颈就是在网络延迟上 。redis管道机制，即客户端发出一个请求之</strong><strong>后，可以不等服务器端返回结果就发送下一个请求，然后批量的接收服务器端返回的结果。这样客户端批量发出请求，服务器端接</strong><strong>收到批量请</strong><strong>求之后，进行处理返回批量数据。这样提高了redis的性能。</strong></p>\n<h2><strong>四，redis事务</strong></h2>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>基本命令（multi开启事务，exec执行事务，discard取消事务，watch监听某个key的变化，unwatch取消监听所有key的变化）</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;事务基本流程：客户端执行multi命令开启事务</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;客户端提交命令到事务</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;redis将客户端请求放入事务队列等待</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;服务器返回QURUD，表明命令已经进入事务</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;客户端通过exec执行事务</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;执行事务的过程中，如果有某个命令错误，则其它命令继续执行，不会回滚。</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;服务器端向客户端返回事务的执行结果</strong></p>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong></p>\n<h2><strong>五， redis的发布，订阅</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;发布者向频道发布消息，订阅者从频道获取消息（<span style=\"background-color: #ffcc00;\">有待补充</span>）</strong></p>\n<h2><strong>六，redis集群数据复制原理</strong></h2>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;从数据库（slave）发出数据同步请求SYNC给主数据库（master）</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;主数据库接收到从数据库的请求，进行快照，并将快照期间的命令缓存起来，生成.rdb文件</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;主数据库将.rdb文件发送给从数据库</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;从数据库接收到.rdb文件，载入文件进入本地</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;从数据库执行快照，将数据写入内存，即初始化</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;从数据库初始化完成后，主数据接收到写请求之后，会将写请求发送给从数据库，实现数据的一致性</strong></p>\n<h2><strong>七，</strong><strong>redis持久化</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;redis持久化有rdb和aof两种，rdb即采用快照的方式，每隔一定的时间，进行依次数据的快照，对于大数据集的数据处理较快，但是对于数据的完整性要求较低。aof方式是采用日志的形式，将写操作的命令都存于aof文件中，启动服务的时候直接将aof中的命令按顺序执行用以构建原始数据集，但是速度较慢，</strong><strong>且aof文件的大小要比rdb文件大。如果两种方式都开启，则启动服务的时候默认采用aof的方式进行数据恢复。</strong></p>\n<h2><strong>八， redis的集群模式及工作原理</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;主从模式：中心化，所有的写请求都发送到主数据库，读操作分发给从数据库，分担主句库的压力。但是缺陷很明显，如果主数据库宕机，则从数据库必须要阻塞等待，或者手动切换从数据库为主数据库？</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;哨兵模式：即主数据库宕机，自动选举从数据库。设置一个哨兵监视集群的运行状态，如果主数据库宕机，哨兵会依据投票机制从数据库中选举出一个主数据替换宕机的主数据库。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;集群模式：redis集群实现了redis的数据分片和数据复制能力。数据分片能够让我们对redis进行横向扩展，提升集群的吞吐量。数据复制能力，在一些节点挂掉之后，集群仍然能够对外提供服务。</strong></p>\n<h2><strong>九，redis整合springboot见redis篇</strong></h2>\n<h2><strong>十，分布式缓存设计的核心问题</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;缓存预热：用户请求数据前先将数据保存到缓存中。通常的方法是系统启动加载，定时加载</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;缓存更新：即当数据发生变化的时候，对缓存中的数据进行更改</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;缓存淘汰策略：FIFO（先进先出，即先淘汰时间长远的缓存），LRU（最近最少使用，即判断缓存最近被使用的时间，淘汰离被使用时间最远时间的缓存），LFU（最不经常使用，即在一段时间内，被使用次数最少的缓存淘汰）</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;缓存雪崩：即缓存中同一时间有大量的数据失效，导致用户请求直接访问数据库，增大数据库的负荷，导致数据库宕机甚至整个系统的崩溃。</strong><strong>&nbsp;设置随机的失效时间，缓存更新，请求加锁</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;缓存穿透：即请求一条缓存中没有的数据，则会直接访问数据库，如果同一时间大量不存在的key访问缓存，就会都去访问数据库，导致数据库宕机。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;布隆过滤器：即用户请求访问缓存之前先经过布隆过滤器，如果发现数据库和缓存中都不存在该数据，则拒绝该请求。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;cache&nbsp; null：即如果访问的数据请求返回为null，则对null值也进行缓存，只不过需要给它设置一个短暂的失效时间这样在接收到相同的请求的时候，从缓存中读取返回null，不会访问数据库</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;缓存降级：当读操作增加的时候，我们先从缓存中读取，等到数据库恢复正常再从数据库读取</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;当写操作增加的时候，我们先从写入缓存，然后再异步的写入数据库。</strong></p>\n<p>&nbsp;</p>\n<h1><strong>水平有限，如有错误，还望指出！</strong></h1>","blogGoods":0,"blogId":"1250774653945802752","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6YWj2AQzPpAABXKIA7NHQ430.jpg","blogRead":5,"blogRemark":"面试（八）------之分布式缓存的原理及应用","blogTitle":"面试（八）------之分布式缓存的原理及应用","createdTime":"2020-04-16 13:14:51","typeName":"java面试篇","updateTime":"2020-04-16 23:08:07"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，存储引擎</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;MyIASM：MySQL默认的存储引擎，不支持事务，行级锁和外键。因此插入和更新操作需要锁定整个表，效率较低。二查询操作是直接查询文件的OFFSET，因而效率较快，高于InnoDB（InnoDB寻址要先映射到块，再映射到行）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;InnoDB：为MySQL提供了事务支持，回滚，崩溃修复能力，多版本并发控制，事务安全。InnoDB的底层数据结构采用的是B+树（即非叶子节点仅存储索引信息，不存储数据，数据都被存放再叶子节点上，所有的叶子节点构成一个顺序链表）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;TokuDB：底层数据结构为Fractal Tree，和InnoDB的B+树很像，但是Fractal Tree除了每个指针都指向孩子节点，孩子节点还带有一个message&nbsp; Buffer（用来缓存更新操作的），每次的插入操作只需要到message Buffer就可以返回了，不需要走到叶子节点。（写入速度很快）<br /></strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;Memory：Memory因为其数据都是存放再内存中，所以读的速度很快，通常使用hash索引来做数据索引。缺点是一旦服务关闭，数据就会丢失。</strong></p>\n<h2><strong>二，创建索引的原则</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;选择唯一性索引：因为唯一性索引使用hash算法实现，能够快速的定位到一条数据</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;为经常需要分组，联合，排序，作为查询条件的列设置索引</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;限制索引的数量：因为索引越多，更新表的数据越慢</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;尽量使用数据量少的索引：因为索引值过长，占用的磁盘空间九会很多，查询速度会受影响</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;尽量使用前缀来索引：如果索引的字段很长，则不但会影响索引的大小，还会降低索引的执行效率</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;删除不经常使用的索引</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;选择区分度高的列作为索引：数据重复少</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;索引列不能参与计算：带函数的查询不建议参与索引</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;尽量扩展现有索引：联合索引的查询效率要远高于多个独立索引</strong></p>\n<h2><strong>三，数据库三范式</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;一范式：即该列的数据是不可再拆分的最小的数据单元。例如：address列：中国北京，美国纽约。这种就违背了第一范式，因为address可以拆分为国家country和城市city</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;二范式：基于一范式，非主键列不能存在对主键列的部分依赖。即每张表都单独描述一个事务。例如：一张表中既有订单表编号，订单数，产品编号，产品数，则就不符合第二范式，应该将其拆分为两个表，订单表和产品表</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;三范式：基于一范式和二范式，非主键列不能存在对其它非主键列的传递依赖。例如：除了订单编号，顾客还依赖于表中的顾客编号，这时候就应该删除顾客编号。</strong></p>\n<h2><strong>四，数据库事务</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：数据库事务即一系列的基本操作，这些基本操作要么全部执行，要不都不执行，是一个完整的逻辑单元。数据库事务具备ACID特性：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;A（原子性）：即数据库事务是一个完整逻辑单元，其中的基本操作要么全部执行，要么全部不执行</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;C（一致性）：即事务执行完毕后（无论是正常执行完毕还是异常退出），数据都要保持一致的状态。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;I（隔离性）：即更新数据的事务都是并发执行的，不存在任意一个事务以任意的方法影响其它事务</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;D（永久性）：即事务执行完毕后，更新的数据要持久化到永久性存储中</strong></p>\n<h2><strong>五，存储过程</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：存储过程指的就是一组用于完成特定功能的SQL语句集</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;优化思路：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;尽量利用SQL语句代替一些小循环，例如聚合函数，平均函数等。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;中间结果存放于临时表中，并加索引</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;少使用游标：因为SQL是集合语言，对集合运算有较高的性能，但是游标是过程运算</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;事务越短越好：SQL&nbsp; Server支持并发操作，如果事务过长或者隔离级别过高，会造成并发操作的阻塞，死锁，导致查询慢 。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;使用try-catch处理异常</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;尽量不要将查询语句放入到循环中，避免过度消耗系统资源</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>触发器：是一种自动执行的程序，一般是当数据发生变化后执行一系列的操作</strong></p>\n<h2><strong>六，数据库并发策略（前面的总结中有总结过，这里不作详细展开，具体参照并发编程篇）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;乐观锁</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;悲观锁</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;时间戳（类似版本号机制）</strong></p>\n<h2><strong>七，数据库锁</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;行级锁：锁住数据库中的一行数据，不允许其它事务进行修改。例如增删改查等操作都使用了行级锁</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;表级锁：给整张表加锁，分为共享读锁和独占写锁。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;页级锁：行级锁冲突少，加锁慢；表级锁冲突多，加锁快，页级锁介于两者之间</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;基于Redis的分布式锁：利用redis的setnx命令，如果不存在一个key则插入，返回1；如果已存在一个key，则不做任何操作，返回0。获取锁：即使用此命令，如果返回0表示锁正在被使用，获取失败，如果返回1则获取到锁</strong></p>\n<h2><strong>八，数据库分表</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;垂直分表：即根据功能模块的不同，表的关联程度将表分于不同的库中</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;水平分表：即当一个表中的数据量较大时，按照表的某种规则，将不同数据分到相同表的不同库中</strong></p>\n<h2>九，CAP</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>概述：即一个分布式系统中的一致性（C），可用性（A），分区容错性（P）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;一致性：即同一时间不同数据备份，数据是否保持一致</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;可用性：即当集群的某些节点故障，集群是否可以正常的提供服务（高可用性）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;分区容错性：即当某些时刻数据无法保持一致性，即分区了，这个时候我们就需要在C和A之间进行权衡</strong></p>\n<h2><strong>十，两阶段提交协议和三阶段提交协议</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;两阶段提交协议（准备阶段prepare，提交阶段commit）：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 准备阶段：即协调者给每一个参与者发送一个prepare消息，参与者接收到之后要么返回false，要么立即执行本地事务进行日志的redo和undo但不进行提交</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 提交阶段：即协调者根据参与者反馈的消息，如果参与者反馈失败或者超时，则给每个参与者发送消息中止提交或者进行回滚操作。否则，进行提交操作</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 缺点：第一，参与者的任务都是阻塞进行的；第二，比较中心化，如果协调者出现故障，则参与者进入阻塞状态；第三，数据不一致，即如果协调者在给每个参与者发送commit过程中突然出现故障，导致部分参与者没有接收到commit，则将会导致数据不一致的情况；第四，如果协调者进行发送commit时出现</strong><strong>故障，而唯一接收commit的参与者也出现故障，则将会出现事务状态未知的情况。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;三阶段提交协议（在二阶段提交协议基础上进行完善）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;增加了超时机制：即如果协调者长时间未接受到参与者的反馈，则认为参与者执行失败</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;在准备和提交阶段之前都加了预准备阶段，保证参与者状态的一致。（canCommit，preCommit，doCommit）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;canCommit：即协调者发送commit消息给所有的参与者，参与者如果可以执行就返回yes，不能返回no</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; preCommit：即协调者根据参与者的反馈，如果所有的参与者都可以进行正常提交，则预执行事务；如果有参与者反馈no或者反馈超时，就执行事务的中断。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;doCommit：提交事务</strong></p>\n<h2><strong>十一，分布式事务</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;传统事务：即遵循ACID特性</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;柔性事务：阿里巴巴提出的，基于CAD和BASE。BASE理论是CAD理论的延伸，包括基本可用，柔韧状态，最终一致性</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;两阶段提交型：指的就是分布式事务的两阶段提交</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;补偿性：例如事务A开启事务，事务B参与事务，如果事务A和事务B都能够正常执行事务，则事务执行完毕。如果事务出现故障，则事务B回滚，但是这时候事务A已经提交，所以需要有一种补偿机制，让事务A反操作回到执行事务A之前的状态。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;异步确保型（没怎么读懂，因为还没学到分布式的太多东西，后面补充）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;最大努力通知型（没怎么读懂，后面补充）</strong></p>\n<p>&nbsp;</p>\n<h1><strong>水平有限，如果错误还望指出！</strong></h1>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1250704122190073856","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6YGImARpJnAADh1C7LBxU514.jpg","blogRead":0,"blogRemark":"面试（七）-----数据库及分布式事务","blogTitle":"面试（七）-----数据库及分布式事务","createdTime":"2020-04-16 08:34:35","typeName":"java面试篇","updateTime":"2020-04-16 08:35:14"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，OSI七层网络模型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;物理层：主要用于定义物理设备的标准，发送比特流</strong><strong style=\"font-size: 14px;\">数据链路层：主要用于对数据包中的MAC地址进行解析和封装。这一层的数据单位叫做帧</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;网络层：主要用于对数据包中的ip地址进行解析和封装，这一层的数据单位叫做数据包。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;传输层：定义传输的协议和端口，进行的数据的分段，重组和传输。TCP传输控制协议，适用于对可靠性要求高，数据量大的传输。UDP适用于对可靠性要求不高，数据量不大的传输。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;会话层：用于再传输层的基础上建立连接和管理会话。比如登录，断点续传，数据粘包和分包。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;表示层：用于对接收到的数据进行解析，将计算机识别的信息转换成人也能够识别的信息。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;应用层：构建具体应用</strong></p>\n<h2><strong>二，TCP/IP四层网络模型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：TCP/IP并不是指tcp和ip协议，而是指因特网中的TCP/IP协议簇，分为四层网络模型：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;网络接口层：用来定义主机间的连通协议</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;网络层：用于数据的传输，路由及地址的解析，确保数据能够发送到任何网络的目标上。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;传输层：使源端和目的端的相同实体能够进行通信</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;应用层：负责具体应用协议的定义</strong></p>\n<h2><strong>三，TCP三次握手/四次挥手</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：客户端和服务器之间建立连接之前需要进行三次沟通，称为&ldquo;三次握手&rdquo;；客户端和服务器之间断开连接之前，会进行四次沟通，称为&ldquo;四次挥手&rdquo;。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;三次握手：客户端发送连接请求的标识位SYN给服务器端，进入SYN-SEND状态，请求建立连接；服务器端接收到请求之后，返回一个SYN+ACK报文，进入SYN-RECV状态；客户端接收到请求之后，回应一个ACK报文，至此，三次握手完毕，客户端与服务器端之间的TCP连接已建立，可以进行数据传输。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;四次挥手：客户端和服务器端断开连接要进行四次挥手是因为TCP的关闭是半关闭造成的，即TCP连接是全双工的（即数据可以在两个方向上同时进行交换），因此想要关闭连接，就必须每个方向进行单独关闭。（客户端主动断开连接和服务器端主动断开连接），这里以客户端主动断开连接为例：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;客户端数据传输完毕之后，发送一个释放连接的标识位FIN=1给服务器端，请求断开客户端到服务器端之间的连接操作，进入FIN-WAIT-1状态；</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;服务器端接收到请求之后，返回一个ACK报文给客户端，表</strong><strong>示已经接收到其断开连接的请求，然后释放客户端到服务器端的连接，服务器端进入CLOSE-WAIT状态，客户端接收到请求后进入FIN-WAIT-2状态；</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;服务器端在将待传输到客户端的数据传输完毕之前，发出一个中断连接的标识位FIN=1给客户端，请求客户端中端服务器端到客户端的连接操作，进入进入LAST-ACK状态，等待客户端的最终确认；</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;客户端接收到服务器端的断开连接请求之后，回应一个ACK，表示接收到断开连接请求，随后等待计时器设置的时间后，断开连接。</strong></p>\n<h2><strong>四，HTTP协议</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;概述：http协议是一种无状态的协议，即客户端和服务器端不需要建立持久的连接，客户端发出请求后，服务器端接收到请求，处理数据返回应答之后，连接关闭。http协议遵循请求（Request）和应答（Response）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;传输流程：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 地址解析：通过域名系统DNS获取请求地址的协议，主机名，端口号，对象路径</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 封装HTTP数据包：根据解析出来的请求协议，主机名，端口号，对象路径和本机信息封装出HTTP数据包</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 封装TCP数据包：将HTTP数据包进一步封装成TCP数据包</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;建立TCP连接：利用三次握手协议建立客户端和服务器端的TCP连接</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 客户端发送请求：客户端发送一个请求给服务器端</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 服务器端响应：服务器端接收到客户端发送的请求之后，进行数据处理，返回响应</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;服务器关闭TCP连接：服务器返回应答之后，关闭TCP连接。如果在服务器返回的应答中加上connection：keep-alive，则返回应答后不会关闭TCP连接，下一次浏览器发送请求的时候仍然可以使用该连接（减少了响应时间和带宽资源的消耗）。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;HTTP中常见的状态码：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;20x表示成功，30x表示重定向，40x表示客户端错误，50x表示服务器错误</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;100（继续），101（切换协议），200（成功），201（created创建），202（accepted创建），203（未授权），204（无内容），205（重置内容），206（部分内容）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;300（多种选择），301（永久移动），302（临时移动），303（查看其它位置），304（未修改），305（使用代理），306（未使用），307（临时重定向），308（永久重定向）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;400（客户端请求错误），401（未授权），402（待付款），403（禁止访问），404（未发现），405（不允许使用该方法），406（无法接受），407（需要使用代理身份），408（请求超时），409（冲突），410（已失效），413（请求实体过长），414（请求地址过长），415（媒体类型不支持）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;500（内部服务器错误），501（未实现），502（网关错误），503（服务不可用），504（网关超时），505(Http版本不支持)</strong></p>\n<h2>五，HTTPS</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>概述：HTTPS是在http的基础上增加了SSL协议以保证传输数据的安全性，因为HTTP传输数据使用的明文传输，不安全。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;HTTPS加密流程：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 客户端和服务器端建立TCP连接之后，发送一个请求证书的请求</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 服务器端接收到请求之后，返回应答并且返回证书信息</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 客户端接收到证书之后，进行确认，如果确认正确，则生成密钥</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 客户端将密钥发送给服务器端，服务器端接收到之后利用私钥进行解密</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 经过上面的步骤，客户端和服务器端之间的数传传输就可以进行加密传输了</strong></p>\n<h2><strong>六，CDN原理（待补充）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：CDN即基于分布在不同的地方的机房服务器，通过中心平台的负载均衡，内容分发和任务调度让用户就近获取所需要的内容，降低网络延时，提升用户体验。</strong></p>\n<h2><strong>七，七层负载均衡和四层负载均衡</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;四层负载均衡：即利用ip和端口号，根据负载均衡的配置和分发策略将请求分发给真实服务器</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;七层负载均衡：利用请求的URL或者主机名接受所有用户的请求，然后将其分发给真实服务器</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;区别：四层负载均衡只能根据ip和端口号进行请求的分发，但是七层负载均衡根据URL可以根据具体的请求信息进行分发，例如一个ip下面有多个具体的请求，/user,/business等。四层负载均衡将该ip或者端口号下的所有请求都分配给一台服务器进行处理，但是七层负载均衡可以根据不同的路径信息，将/user分配给一台真实</strong><strong>服务器，将/business分配给一台真实服务器。（Nginx既支持四层负载均衡，又支持七层负载均衡）</strong></p>\n<h2><strong>八，负载均衡算法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;轮询均衡：将请求均等的分发到1-n台服务器上，用于各台服务器之间的软硬件设备没有差距的情况下。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;权重轮询均衡：即根据权重的不同，将不同数量的请求轮询分发到不同的服务器上</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;随即均衡：即将请求随机分发到服务器上</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;权重随即均衡：即根据权重的不同，将请求随机分发到服务器上</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;响应速度均衡：即根据服务器的响应速度，将请求分发到请求速度最快的服务器上</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;最少连接数均衡：即在服务器内部维护一个记录服务器处理连接数量的计数器，将请求分发到连接数最少的服务器上。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;处理能力均衡：将请求分发给内部负荷最轻的服务器</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;DNS响应均衡：不同中心机房的均衡设备接收到域名解析请求时，都进行域名解析，然后返回给客户端，客户端连接第一个返回应答的服务器，忽略其它的均衡设备。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;散列算法均衡：即通过一次性散列算法将相同参数的请求分发到一台服务器上，长期稳定的为客户端进行服务</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;IP地址散列均衡：将来自同一客户端的请求分发到同一台服务器</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;URL散列：将相同URL的请求分发到同一台服务器</strong></p>\n<h2><strong>九，Nginx的反向代理和负载均衡</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;正向代理：即客户端找代理服务器取寻找真实服务器，真实服务器并不知道客户端的ip和端口，因此可以隐藏客户端真实ip和端口</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;反向代理：即服务器找代理服务器去跟客户端打交道，在客户端眼中，代理服务器就是服务器，它并不知道真实服务器是谁</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;负载均衡：即通过Nginx，根据负载均衡的配置和分发策略将不同的请求交给不同的服务器进行处理。</strong></p>\n<p>&nbsp;</p>\n<h1><strong>水平有限，如有错误，还望指出！</strong></h1>","blogGoods":0,"blogId":"1250622112591376384","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6XzDGALH67AABkNXEA3-0043.jpg","blogRead":2,"blogRemark":"面试（六）------之网络与负载均衡","blogTitle":"面试（六）------之网络与负载均衡","createdTime":"2020-04-16 03:08:42","typeName":"java面试篇","updateTime":"2020-04-16 03:09:55"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，二分查找算法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：二分查找算法又称为折半查找算法，待查找的序列必须已经是有序的，每次取序列的中间值与查找值进行比较，若相等则返回；若中间值小于查找值，则在中间值右侧序列中进行查找；若中间值大于查找值，则在中间值左侧序列中进行查找。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现如下：</strong></p>\n<pre class=\"language-java\"><code>public static int binarySearch(int[] arr,int low,int high,int key){\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(arr[mid]==key){\n                return mid;\n            }else if(arr[mid]&lt;key){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        return -1;\n    }</code></pre>\n<h2><strong>二，冒泡排序（这里以升序为例）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：冒泡排序即对于一个无序序列，从第一个元素开始，依次比较相邻的元素，如果前一个元素大于后一个元素，则交换位置，这样一趟比较下来，就确定出最大值。直到整个序列有序为止</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现如下：</strong></p>\n<pre class=\"language-java\"><code>public static void bubbleSort(int[] arr){\n        for (int i = arr.length-1; i &gt;=0 ; i--) {\n            for (int j = 0; j &lt; i; j++) {\n                if(arr[j]&gt;arr[j+1]){\n                    swap(arr,j,j+1);\n                }\n            }\n        }\n    }\n    /**\n     * 交换元素\n     * @param arr\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] arr,int i,int j){\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }</code></pre>\n<h2>三，插入排序（升序为例）</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>概述：即默认无序序列中的第一个元素有序，随后每次排列有序序列后的一个元素，将其排列进入前面的有序序列，同时保证有序序列的有序性即可。（类似于我们打扑克牌时，每拿一张从后往前比较大小，放入正确的位置）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现如下：</strong></p>\n<pre class=\"language-java\"><code>public static void insertSort(int[] arr){\n        for (int i = 1; i &lt; arr.length; i++) {\n            for (int j = i; j &gt;=0; j--) {\n                if(arr[j]&lt;arr[j-1]){\n                    swap(arr,i,j);\n                }\n            }\n        }\n    }\n\n    /**\n     * 交换元素\n     * @param arr\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] arr,int i,int j){\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }</code></pre>\n<h2>四，快速排序（升序为例）</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>概述：在一个无序序列中，取一个基准值，通常取第一个元素为基准值。然后从最右边依次查找，找到第一个比基准值小的元素，与其交换位置；再从最左边查找，查找到第一个比基准值大的元素，与其交换位置。直到从左往右查找的索引等于从右往左查找的索引，结束一次循环，重复以上过程分别比较左右两标的序列，直到整个</strong></p>\n<p><strong>有序为止。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;JAVA代码实现如下：</strong></p>\n<pre class=\"language-java\"><code>public static void quickSort(int[] arr,int low,int high){\n        int base = arr[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //先从右往左查找第一个比基准值小的元素\n            while(R&gt;L&amp;&amp;arr[R]&gt;=base){\n                R--;\n            }\n            if(arr[R]&lt;base){\n             swap(arr,L,R);\n            }\n            //再从左往右查找第一个比基准值大的元素\n            while(R&gt;L&amp;&amp;arr[L]&lt;=base){\n                L++;\n            }\n            if(arr[L]&gt;base){\n                swap(arr,L,R);\n            }\n        }\n        //递归左右序列\n        if(L&gt;low) {\n            quickSort(arr,low,L-1);\n        }\n        if(R&lt;high) {\n            quickSort(arr,R+1,high);\n        }\n    }\n\n    /**\n     * 交换元素\n     * @param arr\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] arr,int i,int j){\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }</code></pre>\n<h2>五，希尔排序（升序为例，以初始dk为length/3+1）</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>概述：希尔排序又称增量排序，是优化的插入排序，即有一个增量dk，根据增量dk将无序序列分为若干个子序列，分别对子序列进行插入排序，每进行完一趟排序，更改增量，直到增量dk为1时，则对整个序列再进行依次插入排序。希尔排序，当增量dk大的时候，因为序列数据较少，排序较快；而当增量dk小的时候，又因为序列</strong></p>\n<p><strong>中的数据已经基本有序了，因而排序也较快。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;JAVA代码实现：为例</strong></p>\n<pre class=\"language-java\"><code>public static void sort(int[] arr){\n\n        int dk = arr.length/3+1;\n        while(dk!=1){\n            shellSort(arr,dk);\n            dk = dk/3+1;\n        }\n        if(dk==1){\n            shellSort(arr,dk);\n        }\n    }\n\n    public static void shellSort(int[] arr,int dk){\n        for (int i = dk; i &lt;arr.length ; i++) {\n            if(arr[i]&lt;arr[i-dk]){\n                swap(arr,i,i-dk);\n            }\n        }\n    }\n\n    /**\n     * 交换元素\n     * @param arr\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] arr,int i,int j){\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }</code></pre>\n<h2><strong>六，归并排序</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：归并排序采用的是典型的分治思想，即先分解，然后再归并。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n     * 先分\n     * @param arr\n     */\n    public static void sortProcess(int[] arr,int L,int R){\n        if(L==R){\n            return;\n        }\n        int mid = (L+R)/2;\n        sortProcess(arr,L,mid);\n        sortProcess(arr,mid+1,R);\n        merge(arr,L,mid,R);\n    }\n\n    /**\n     * 分治中的治\n     * @param arr\n     * @param L\n     * @param mid\n     * @param R\n     */\n    public static void merge(int[] arr,int L,int mid,int R){\n        int[] help = new int[R-L+1];\n        int p1 = L;\n        int p2 = mid+1;\n        int i =0;\n        while(p1&lt;=mid&amp;&amp;p2&lt;=R){\n            help[i++] = arr[p1]&gt;arr[p2]?arr[p2++]:arr[p1++];\n        }\n        while(p1&lt;=mid){\n            help[i++] = arr[p1++];\n        }\n        while(p2&lt;=R){\n            help[i++] = arr[p2++];\n        }\n        //将数组help复制回原数组（注意一定要有这一步，不然无法保证元素比较后的大小顺序性）\n        for (int j = 0; j &lt; help.length; j++) {\n            arr[L+j] = help[j];\n        }\n        System.out.println(Arrays.toString(arr));\n    }</code></pre>\n<h2>七，桶排序算法</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>概述：先找出无序序列中的最大值和最小值，然后根据最大值和最小值计算桶的个数并且初始化桶，然后将每个元素加入到对应的桶中，对每个桶进行排序，再整合桶中的数据即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>JAVA代码如下：</strong></p>\n<pre class=\"language-java\"><code>public static void bucketSort(int[] arr){\n\n        int k = 0;\n        //找出无序序列中的最大值和最小值\n        int max = Integer.MIN_VALUE;\n        int min = Integer.MAX_VALUE;\n        for (int i : arr) {\n            max = Math.max(max,i);\n            min = Math.min(min,i);\n        }\n\n        //根据最大值和最小值确定桶\n        int bucketNum = (max-min)/arr.length+1;\n        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = new ArrayList&lt;&gt;(bucketNum);\n        for (int i = 0; i &lt; bucketNum; i++) {\n            bucketArr.add(new ArrayList&lt;&gt;());\n        }\n\n        //遍历序列中的数据，将其分配进入不同的桶\n        for (int i=0;i&lt;arr.length;i++) {\n            int num = (arr[i]-min)/arr.length;\n            bucketArr.get(num).add(arr[i]);\n        }\n\n        //对每个桶都进行排序\n        for (ArrayList&lt;Integer&gt; bucket : bucketArr) {\n            Collections.sort(bucket);\n        }\n\n        //将桶中的数据按照顺序复制回原数组\n        for (ArrayList&lt;Integer&gt; bucket : bucketArr) {\n            for (Integer integer : bucket) {\n                arr[k++] = integer;\n            }\n        }\n    }</code></pre>\n<h2>八，基数排序（这里以高位优先为例）</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>概述：基数排序是一种优化的桶排序，但是基数排序只能排序整型数据。先要统一数据的位数，位数不够的前面添0，然后按照从低位到高位的位数顺序依据位数上数字的大小进行排序，最终得到一个有序序列。 &nbsp;</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码如下：</strong></p>\n<pre class=\"language-java\"><code>public static void radixSort(int[] arr){\n        //指数\n        int exp = 1;\n\n        //查找数组中的最大值\n        int max= Integer.MIN_VALUE;\n        for (int i : arr) {\n            max = Math.max(max,i);\n        }\n\n        //按照低位到高位的顺序依次排序\n        for (exp=1;(max/exp)&gt;0;exp*=10){\n            int[] temp = new int[arr.length];\n            //初始化桶\n            int[] buckets = new int[10];\n            //统计每个桶中数据的次数\n            for (int i = 0; i &lt; arr.length; i++) {\n                buckets[(arr[i]/exp)%10]++;\n            }\n\n            //更改buckets[i]\n            for (int i = 1; i &lt; buckets.length; i++) {\n                buckets[i]+=buckets[i-1];\n            }\n\n            //将数据存储到临时数组temp中\n            for (int i = 0; i &lt; arr.length; i++) {\n                temp[buckets[(arr[i]/exp)%10]-1] = arr[i];\n                buckets[(arr[i]/exp)%10]--;\n            }\n\n            //将临时数组的数据复制到原数组\n            System.arraycopy(temp,0,arr,0,arr.length);\n        }\n    }</code></pre>\n<h2><strong>九，其它算法（对于最短路径算法和回溯算法后面会单列出来）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;剪枝算法，最短路径算法，回溯算法</strong></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1250364779516665856","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6W3IWAZhjCAACsl_OYPcQ410.jpg","blogRead":2,"blogRemark":"面试（五）------之算法","blogTitle":"面试（五）------之算法","createdTime":"2020-04-15 10:06:09","typeName":"java面试篇","updateTime":"2020-04-16 08:26:53"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，栈及其JAVA实现</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：栈是一种先进后出的数据结构，对栈顶元素的添加，删除等操作较快，但是对于栈内的元素操作很慢</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA实现：实现需要定义栈的数据结构，写栈的入栈，出栈，获取栈顶元素的方法，如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n * 基于数组实现栈\n * @author wcj\n * @Date 2020/4/14 20:59\n * @Version 1.0\n */\npublic class StackExample&lt;E&gt; {\n\n    /**\n     * 站的深度\n     */\n    private int maxSize;\n    /**\n     * 存储数据的数组\n     */\n    private Object[] data;\n    /**\n     * 栈顶指针\n     */\n    private int top = -1;\n\n    /**\n     * 默认栈的深度为10\n     */\n    public StackExample(){\n        this(10);\n    }\n\n    /**\n     * 用户自定义栈的深度\n     * @param initialSize\n     */\n    public StackExample(int initialSize){\n        if(initialSize&gt;=0){\n            this.maxSize = initialSize;\n            this.data = new  Object[initialSize];\n            this.top = -1;\n        }else{\n            throw new RuntimeException(\"初始化栈的深度不能小于0!\");\n        }\n    }\n\n    /**\n     * 入栈操作\n     * @param e\n     * @return\n     */\n    public Boolean push(E e){\n        if(top == maxSize-1){\n            throw new RuntimeException(\"栈已满,不能入栈\");\n        }else{\n            data[++top] = e;\n        }\n        return true;\n    }\n\n    /**\n     * 出栈操作\n     * @return\n     */\n    public E pop(){\n        if(top==-1){\n            throw new RuntimeException(\"栈空，不能出栈！\");\n        }else{\n            return (E) data[top--];\n        }\n    }\n\n    /**\n     * 获取栈顶元素\n     * @return\n     */\n    public E peak(){\n        if(top==-1){\n            throw new RuntimeException(\"栈空异常！\");\n        }else{\n            return (E) data[top];\n        }\n    }  </code></pre>\n<h2><strong>二，队列极其JAVA实现</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：队列是一种先进先出的数据结构，对队头和队尾的操作简单，但是队内元素的操作复杂。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA实现：定义队列的数据结构，队列的出队，入队，获取队头元素。代码如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n * 基于数组实现队列\n * @author wcj\n * @Date 2020/4/14 21:14\n * @Version 1.0\n */\npublic class QueueExample&lt;E&gt; {\n\n    /**\n     * 队列长度\n     */\n    private int maxSize;\n    /**\n     * 存储数据数组\n     */\n    private Object[] data;\n    /**\n     * 队头指针\n     */\n    private int front;\n    /**\n     * 队尾指针\n     */\n    private int rear;\n\n    /**\n     * 默认构造器\n     */\n    public QueueExample(){\n        this(10);\n    }\n    /**\n     * 用户自定义队列长度构造器\n     * @param initialSize\n     */\n    public QueueExample(int initialSize){\n        if(initialSize&gt;=0){\n            this.maxSize = initialSize;\n            data = new Object[initialSize];\n            front = rear = 0;\n        }else{\n            throw new RuntimeException(\"初始化队列长度不能小于0！\");\n        }\n    }\n\n    /**\n     * 入队操作\n     * @param e\n     * @return\n     */\n    public Boolean add(E e){\n        if(rear == maxSize){\n            throw new RuntimeException(\"队列已满，无法入队!\");\n        }else{\n            data[rear++] = e;\n        }\n        return true;\n    }\n\n    /**\n     * 出队操作\n     * @return\n     */\n    public E poll(){\n        if(front==rear){\n            throw new RuntimeException(\"队空，无元素可出队！\");\n        }else{\n            E e = (E) data[front];\n            data[front] = null;\n            return e;\n        }\n    }\n\n    /**\n     * 获取队头元素\n     * @return\n     */\n    public E peek(){\n        if(front==rear){\n            throw new RuntimeException(\"队空，无元素可出队!\");\n        }else{\n            return (E) data[front];\n        }\n    }\n}\n</code></pre>\n<h2><strong>三，链表及其JAVA实现</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：链表是由一系列数据节点组成的数据结构，节点可以动态生成。对于元素的增加，删除操作快，查询操作慢</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;这里主要讲述几种有代表性的链表：单向链表，双向链表，双向循环链表</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;单链表的JAVA实现：数据结构定义，添加节点，删除节点，查找节点，代码如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n * 单向链表\n * @author wcj\n * @Date 2020/4/14 21:32\n * @Version 1.0\n */\npublic class SingleLinkedList {\n\n    /**\n     * 链表长度\n     */\n    private int length;\n    /**\n     * 链表头节点\n     */\n    private Node head;\n\n    public SingleLinkedList(){\n        this.length = 0;\n        this.head = null;\n    }\n    /**\n     * 内部类声明每个链表节点\n     * 每个节点包括数据域和指向下一个节点的指针\n     */\n    private class Node{\n        private Object data;\n        private Node next;\n        public Node(Object data){\n            this.data = data;\n        }\n    }\n\n    /**\n     * 插入节点（这里使用头插法）\n     * @param obj\n     * @return\n     */\n    public Boolean add(Object obj){\n        Node node = new Node(obj);\n        if(length==0){\n            head = node;\n        }else{\n            node.next= head;\n            head = node;\n        }\n        length++;\n        return true;\n    }\n\n    /**\n     * 删除某个节点\n     * 先对链表进行判空处理\n     * 然后找到要删除的节点\n     * 最后进行删除\n     * @param obj\n     * @return\n     */\n    public Boolean delete(Object obj){\n        if(length==0){\n            throw new RuntimeException(\"链表为空，无节点可删除!\");\n        }else{\n            Node prev = head;\n            Node current = head;\n            //查找待删除元素\n            while(!current.data.equals(obj)){\n                if(current.next==null){\n                    return false;\n                }else{\n                    prev = current;\n                    current = current.next;\n                }\n            }\n            prev.next = current.next;\n            length--;\n        }\n        return true;\n    }\n\n    /**\n     * 获取某个元素\n     * @param obj\n     * @return\n     */\n    public Object find(Object obj){\n        if(length==0){\n            throw new RuntimeException(\"链表为空\");\n        }else{\n            Node current = head;\n            while(current.data.equals(obj)){\n                if(current.next==null){\n                    return null;\n                }else{\n                    current = current.next;\n                }\n            }\n            return current.data;\n        }\n    }\n}\n</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>双向链表的JAVA实现：定义数据结构，头插法，尾插法，删除头部节点，删除尾部节点（这里只写尾插节点和删除尾部节点），代码如下：</strong></p>\n<pre class=\"language-java\"><code>import com.sun.org.apache.xpath.internal.operations.Bool;\n\n/**\n * 单向循环链表\n * @author wcj\n * @Date 2020/4/14 22:05\n * @Version 1.0\n */\npublic class CircleLinkedList {\n\n    /**\n     * 链表长度\n     */\n    private int length;\n    /**\n     * 头节点\n     */\n    private Node head;\n    /**\n     * 尾节点\n     */\n    private Node tail;\n\n    /**\n     * 初始化构造方法\n     */\n    public CircleLinkedList(){\n        this.length = 0;\n        this.head=this.tail = null;\n    }\n\n    /**\n     * 内部类实现的链表节点\n     */\n    private class Node{\n        private Object data;\n        private Node prev;\n        private Node next;\n        public Node(Object data){\n            this.data = data;\n        }\n    }\n\n    /**\n     * 尾插节点\n     * @param obj\n     * @return\n     */\n    public Boolean addTail(Object obj){\n        Node node = new Node(obj);\n        if(length==0){\n            head = tail= node;\n            length++;\n        }else{\n            tail.next = node;\n            node.prev = tail;\n            tail = node;\n            length++;\n        }\n        return true;\n    }\n\n    /**\n     * 删除尾部节点\n     * @return\n     */\n    public Boolean delTail(){\n        Node temp = tail;\n        if(length==0){\n            throw new RuntimeException(\"链表为空!\");\n        }else{\n            tail = tail.prev;\n            tail.next = null;\n            length--;\n        }\n        return true;\n    }\n}\n</code></pre>\n<h2><strong>四，散列表</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：有一张表M，一个映射函数f(key)，如果对于任意一个key，都有一个函数指与表中的内存地址相对应，则M就为散列表，f(key)就为散列函数。散列函数存储key-value键值对形式的数据，直接生成key与表中地址值的映射，因此查询非常迅速。同时散列表也经常被用于信息安全，用于加密操作。</strong></p>\n<h2><strong>五，二叉排序树</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：二叉查找树又成为二叉搜索树，二叉查找树</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;特征：根节点左边的数据小于根节点，根节点右边的数据大于根节点，且其左右子树还是二叉排序树</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现：定义数据结构，插入操作，删除操作，查找操作，代码如下：</strong></p>\n<pre class=\"language-java\"><code>package interviewFour.example4;\n\n/**\n * 二叉排序树\n * @author wcj\n * @Date 2020/4/14 17:17\n * @Version 1.0\n */\npublic class Node {\n\n    private Node root = null;\n    private int value;\n    private Node left;\n    private Node right;\n\n    public Node(){}\n\n    public Node(int value, Node left, Node right){\n        this.value = value;\n        this.left = left;\n        this.right = right;\n    }\n\n    public Node(int value){\n        this.left = null;\n        this.right = null;\n        this.value = value;\n    }\n\n    public int getValue() {\n        return value;\n    }\n\n    public void setValue(int value) {\n        this.value = value;\n    }\n\n    public Node getLeft() {\n        return left;\n    }\n\n    public void setLeft(Node left) {\n        this.left = left;\n    }\n\n    public Node getRight() {\n        return right;\n    }\n\n    public void setRight(Node right) {\n        this.right = right;\n    }\n\n    /**\n     * 插入节点\n     * @param value\n     * @return\n     */\n    public Boolean insert(int value){\n        //root代表根节点\n        Node p = root;\n        Node prev = null;\n        //创建一个节点\n        Node node = new Node(value);\n        //寻找节点的插入位置\n        while(p!=null){\n            prev = p;\n            if(value==p.getValue()){\n                return false;\n            }else if(value&lt;p.getValue()){\n                p = p.getLeft();\n            }else{\n                p = p.getRight();\n            }\n        }\n        if(root==null){\n            root = node;\n        }else if(value&lt;prev.getValue()){\n            prev.setLeft(node);\n        }else{\n            prev.setRight(node);\n        }\n        return true;\n    }\n\n    /**\n     * 删除某个节点\n     * 分为三种情况，待删除节点为叶子节点，则直接删除\n     * 待删除节点只有左子树或者右子树，则用左子树或者右子树替代当前节点位置\n     * 待删除节点即有左子树又有右子树，则寻找左子树最大节点或者右子树最小节点顶替当前节点(这里使用左子树的最大节点)\n     * @param value\n     * @return\n     */\n    public void deleteBST(int value){\n        deleteBST(root,value);\n    }\n\n    /**\n     * 递归删除左子树，或者右子树，或者根节点\n     * @param root\n     * @param value\n     * @return\n     */\n    public Boolean deleteBST(Node root,int value){\n        if(root==null){\n            return false;\n        }else{\n            if(root.getValue()==value){\n                delete(root);\n            }else if(value&lt;root.getValue()){\n                deleteBST(root.getLeft(),value);\n            }else{\n                deleteBST(root.getRight(),value);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * 分情况执行具体的删除逻辑\n     * @param node\n     * @return\n     */\n    public Boolean delete(Node node){\n        if(node.getLeft()==null){\n            node = node.getRight();\n        }else if(node.getRight()==null){\n            node = node.getLeft();\n        }else{\n            Node temp = node;\n            Node s = node;\n            //转向左子树，向右走到底\n            s = s.getLeft();\n            //寻找替换待删除节点的节点\n            while(s!=null){\n                temp = s;\n                s = s.getRight();\n            }\n            node.setValue(temp.getValue());\n            if(temp!=node){\n                node.setLeft(temp.getLeft());\n            }else{\n                node.setRight(temp.getRight());\n            }\n        }\n        return true;\n    }\n\n    /**\n     * 在二叉查找树中找到对应节点\n     * @param value\n     * @return\n     */\n    public Boolean searchBTS(int value){\n        Node node = root;\n        if(node==null){\n            throw new RuntimeException(\"无此节点！\");\n        }else{\n            if(value==node.getValue()){\n                return true;\n            }else if(value&lt;node.getValue()){\n                node = node.getLeft();\n            }else{\n                node = node.getRight();\n            }\n        }\n        return false;\n    }\n}\n</code></pre>\n<h2>&nbsp;</h2>\n<h2><strong>六，红黑树</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 概述：红黑树是一种特化的自平衡二叉排序树，即其左右子树的深度差可以超过1。（详细的插入等操作过段时间会补充）</strong></p>\n<h2><strong>七，图，位图</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;图的知识：定义，有向图/无向图，邻接矩阵/邻接表，BFS/DFS，位图的话没怎么搞清楚。</strong></p>\n<h2>&nbsp;</h2>","blogGoods":0,"blogId":"1250068950784536576","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6VyQCAX-J_AACqF70d5gI039.jpg","blogRead":1,"blogRemark":"面试（四）------之数据结构篇","blogTitle":"面试（四）------之数据结构篇","createdTime":"2020-04-14 14:30:37","typeName":"java面试篇","updateTime":"2020-04-14 14:30:58"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，线程上下文切换</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>cpu利用时间片轮询的方式来为每个任务都分配一定的时间片，任务的执行过程中保存任务的状态。任务状态的保存和在加载就叫做上下文切换。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>进程：</strong>指的是一个运行中的程序实例，一个进程中可以有多个线程，并且与进程共享同样的内存和系统资源</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong> 上下文：</strong>指的是寄存器和程序计数器保存的线程的信息</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>寄存器：</strong>指的是内存中很小但是运行速度很快的一块区域（相对于RAM外部内存）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>程序计数器：</strong>一种寄存器，用来保存当前执行指令的位置或者下一个待执行指令的位置</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>上下文切换：</strong>上下文切换指的是操作系统的内核在cpu上对进程或者线程的切换。上下文信息保存在进程控制块中（PCB）。流程如下：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;挂起当前进程，将进程的上下文信息保存在进程控制块中；</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;在进程控制块中寻找下一个任务的上下文信息。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;恢复进程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>上下文切换的原因：</strong>第一，任务正常执行完毕，调度下一个任务；第二，线程出现I/O阻塞，被挂起，cpu调度下一个任务；第三，线程等待同步锁，获取socket通知等，被挂起，cpu调度下一个任务；第四，用户调用sleep方法，让出cpu；第五，硬件中断</p>\n<h2><strong>二，JAVA阻塞队列</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>阻塞队列的是调度当前队列的线程处于阻塞状态</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 消费者阻塞：如果队列为空，则消费者线程被挂起，处于阻塞状态，当有新数据进入队列，则消费者线程被唤醒，消费数据</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 生产者阻塞：如果队列数据已满，则生产者线程挂起，处于阻塞状态，当队列有空闲位置，生产者线程被唤醒，生产数据。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞队列的主要操作：</strong>插入操作和移除（获取）操作</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>插入操作：</strong>add(e)，有空间则插入，无空间报异常；offer(e),有空间则插入，无空间返回false；offer(e,time,unit),有空间插入，无空间等待time时间，若超时返回false；put(e),有空间插入，无空间则线程挂起处于阻塞直到有空间</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>移除操作：</strong>poll(e),有值返回值，无值返回null;poll(e,time,unit),有值返回值，无值等待time时间，超时返回null;take(e),有值返回值，无值等待新数据进入再立即返回；drainTo(collection&lt;Object&gt;)批量移除，提高获取效率</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞队列的实现：</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong> ArrayBlockingQueue：</strong>基于数组的有界阻塞队列，按照先进先出顺序对元素进行排序</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>LinkedBlockingQueue：</strong>基于链表的有界阻塞队列，队头队尾采用不两个不同的锁控制数据同步，并发性高</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>PriorityBlockingQueue：</strong>基于优先级的无界队列，默认升序排列，可以自定义排序规则，根据优先级访问数据。但是有数据优先级一样的情况</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>DelayQueue：</strong>支持延时的队列，即从队列中取数据时等待一定的时间才能获取元素。可以用于缓存系统的设计，设计过期时间，也可以用来设置定时调度任务，即如果能够从队列中获取，说明到了任务的调度时间。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>SynchronousQueue</strong>：没怎么读懂（<span style=\"background-color: #ffff00;\">记得补充</span>！）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>LinkedTransferQueue：</strong>基于链表的无界阻塞队列，多了transfer方法(如果消费者等待，直接将任务从生产者传递给消费者，无消费者等待，则将任务加到队尾直到被消费才返回)和tryTransfer（与transfer一致，只不过不管有没有消费者等待获取都会立即返回tryTransfer（e,time,unit）（与tryTransfer一致，只不过设置了超时时间）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>LinkedBlockingDeque：</strong>基于链表的双向阻塞队列，可以在两端同时进行读写操作，提高了队列的操作效率。</p>\n<h2><strong>三，并发关键字</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;CountDownLatch：</strong>适用于一个主线程等待子线程完成任务之后执行（原理：设置一个程序计数器，计数器的值为子线程的个数，子线程并发执行，每个子线程执行完毕后，调用CountDown方法，将其计数器的值减去1，值为0时，唤醒主线程执行）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>CyclicBarrier：</strong>即当所有线程到达一个状态共同执行。await（）方法：确保所有线程到达Barrier状态才执行；await（time,unit）：设置一个超时时间，超过这个时间，执行达到Barrier状态的线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>Semaphore：</strong>因为其限制了多线程访问资源的线程个数，所以适用于多线程并发访问有限资源的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>volatile：</strong>直接用来修饰变量，是一种比Synchronized更加轻量级的机制，用于多线程共享同一变量，可以同时对其进行读写操作。当多个线程共享变量的时候，读取变量将其从内存复制到cpu缓存中，然后线程对其操作进行修改，这样再多cpu的情况下，有可能出现线程修改原数据造成数据不一致的情况，使用volatile关键字直接将线程修改的变量存入内存，解决这个问题。</p>\n<h2><strong>四，多线程共享数据</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>多线程共享数据主要通过共享内存实现，而共享内存的可见性，有序性，原子性已经由JVM和锁解决。理想情况下我们需要解决同步和互斥的问题（<span style=\"background-color: #ffff00;\">怎么解决的有待考证！</span>）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>解决方法一：</strong>将数据抽象成一个类，将对数据的操作封装成类中的方法</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解决方法二：</strong>将Runnable对象作为一个内部类，将共享数据作为这个类的成员变量</p>\n<h2><strong>五，ConcurrentHashmap并发</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ConcurrentHashmap使用了减小锁粒度，这里具体为分段锁的思想优化了锁，因为如果直接对hashmap进行加锁，锁太大，而且同一时刻只能有一个线程操作hashmap，并发性能较差</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;实现原理：</strong>即内部采用分段锁思想，将hashmap分为多个segment，每次读取数据的时候，对数据所在的segment进行加锁，这样只要保证每个segment线程安全，就可以保证整个hashmap线程安全</p>\n<h2><strong>六，JAVA中的线程调度</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;抢占式调度：</strong>即线程对cpu资源进行抢占，这种策略下每个线程抢占到cpu资源的概率是相等的，这样就不会一个线程阻塞造成整个系统阻塞的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>协同式调度：</strong>即一个线程使用完cpu资源之后通知cpu调度下一个任务，适用于多线程交替执行任务。因为如果一个线程阻塞可能会造成整个系统阻塞甚至崩溃</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>JAVA采用的是抢占式调度，但同时又尽可能的保证公平性（即为每个线程分配优先级不同的cpu时间片）</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>&nbsp;线程让出cpu的情况</strong>：第一，线程调用yield方法；第二，I/O阻塞，socket等待等；第三，等待同步锁；第四，正常执行完毕</p>\n<h2>七，进程调度算法</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>优先调度算法：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;先来先服务调度算法：</strong>即遵循先来先被分配cpu资源运行的原则</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>短作业调度算法：</strong>即预估作业的时间长短，优先调度时间短的任务，可能会导致长时间大任务很长时间无法被调度 &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>高优先权调度算法：即每个任务会预先被分配优先级</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;非抢占式优先调度算法：</strong>按照优先级的高低一次分配cpu资源运行</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>抢占式优先调度算法：</strong>按照优先级的高低分配cpu资源运行，但是如果任务再运行过程中有优先级更高的任务加入，则将其cpu资源临时回收分配给紧急任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>高响应比调度算法：</strong>动态调度，即作业时间短，则优先级高；等待时间长，则优先级高。前者遵循短作业调度算法，后者遵循先来先服务原则。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>时间片轮转调度算法：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;时间片轮转法：</strong>按照任务再队列中的顺序进行调度</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>多级反馈队列调度算法：</strong>即再时间片轮转法的基础上维护了就绪队列，默认第一队列优先级高，先调度第一队列的任务，如果再分配的cpu时间片内未完成则将其加入第二队列队尾，以此类推直到其执行完毕。只有第1 -（n-1）队列为空，才会调度第n队列的任务，而且当前任务执行时，如</p>\n<p>果有优先级高的任务进来，会抢占其cpu资源。</p>\n<h2><strong>八，CAS</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>即比较和交换，CAS（V,E,N）三个参数，只有当V=E的时候才会将V设置为N。如果V!=E，则说明数据已经被其它线程修改，不做任何操作</p>\n<h2><strong>九，ABA问题</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>概述：</strong>即当1线程从V中取出A时，2线程也从中取出1，修改为B，再修改为A。而1线程仍然修改成功，实际上修改过程中V的实际值已经发生改变，只不过1没有发觉。解决这种问题，常采用乐观锁的版本号机制。</p>\n<h2><strong>另外有AQS问题没怎么读懂，下次完善！</strong></h2>\n<p>&nbsp;</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</p>","blogGoods":0,"blogId":"1249742755949817856","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6UmSuAdB35AABzd_wnH78043.jpg","blogRead":2,"blogRemark":"面试（三）------之并发编程篇（下）","blogTitle":"面试（三）------之并发编程篇（下）","createdTime":"2020-04-13 16:54:26","typeName":"java面试篇","updateTime":"2020-04-17 10:16:11"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，redis简介</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>redis是NoSQL型系统之一，与之相似的还有Memcache，用来存储key-value这种键值型数据。相比于Memcache而言，redis不仅可以做临时缓存，还可以做数据持久化，将数据定时的存入硬盘或者将命令追加到日志文件当中。而Memcache只能做临时缓存，因而现在基本上已经被redis完全取代。redis的读写速度非常快，官方给出的数据是读110000次/s，写81000次/s；而且redis支持多种数据类型，例如String，list，hash，set，zset；redis支持主从复制（集群），进行数据持久化；还支持过期时间，事务等。</p>\n<h2><strong>二，redis的安装与启动（docker环境下）</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;docker安装完毕后，安装redis：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第一步：拉取redis镜像，docker&nbsp; pull&nbsp; redis</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第二步：启动redis，docker&nbsp; &nbsp;run&nbsp; &nbsp;redis&nbsp; &nbsp;</p>\n<p><strong>三，基本知识串讲</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>单进程单线程：redis只有一个进程，且内部为单线程，这样做的优势是不存在线程安全问题，且不需要进行线程间的切换，提高了性能，而且多线程可能会涉及到锁。劣势是无法发挥多核cpu的优势，不过可以通过开启搭建多个redis实例实现</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>redis中默认有16个数据库（0-15），可以通过select n来进行数据库之间的切换</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;常用的基本命令：flushDB（清空当前数据库），flushAll（清空所有数据库），dbSize（查看有多少数据库）</p>\n<h2><strong>四，redis基本数据类型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;string：</strong>字符串类型，数据库中存储Map&lt;String,String&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>list：</strong>列表数组类型，数据库中存储Map&lt;String,List&lt;Object&gt;&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>hash：</strong>哈希类型，数据库中存储Map&lt;String,Map&lt;Object,Object&gt;&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>set：</strong>集合类型，其中元素无序，数据库中存储Map&lt;String,Set&lt;Object,Object&gt;&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>Zset：</strong>有序集合类型，每个元素都有一个可用于排序的权重</p>\n<h2><strong>五，redis相关命令（这里详解一些常用的命令，不常用的一笔带过）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;string：</strong>(1)set&nbsp; key&nbsp; value,插入一条数据&nbsp; （2）mset&nbsp; key value...批量插入 （3）setnx&nbsp; key value&nbsp; 若无则插入（4）get&nbsp; key&nbsp; 获取某条数据&nbsp; （5）mget keys 批量获取&nbsp; （6）getrange key&nbsp; 0 -1获取数据库全部数据&nbsp; （7）incr age 递增&nbsp; (8) incrby&nbsp; age&nbsp; 10&nbsp; 递增 age 步长为10（9）decr&nbsp; age&nbsp; 递减&nbsp; （10）decrby&nbsp; age&nbsp; 10 步长递减&nbsp; &nbsp;（11）del&nbsp; key&nbsp; 删除某条数据&nbsp; <span style=\"background-color: #ffff00;\">（12）exists&nbsp; key&nbsp; 判断是否存在某个key&nbsp; &nbsp;(13)expire&nbsp; key&nbsp; 10&nbsp; 设置过期时间（单位为秒）&nbsp; （14）pexpire&nbsp; key&nbsp; 1000 设置过期时间，单位为毫秒&nbsp; （15）persist key删除过期时间 （</span><span style=\"background-color: #ffff00;\">16）ttl&nbsp; key&nbsp; 查看过期时间</span></p>\n<p><span style=\"background-color: #ffff00;\">&nbsp;<span style=\"background-color: #ffffff;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>list：&nbsp;&nbsp;</strong>（1）lpush&nbsp; key&nbsp; value 左插入一条数据&nbsp; &nbsp;（2）lpush mylist&nbsp; key&nbsp; value....批量左插入&nbsp; （3）rpush&nbsp; key value 右插入一条数据&nbsp; (4)rpush&nbsp; mylist&nbsp; key value...右批量插入&nbsp; （5）lrange&nbsp; mylist&nbsp; 0&nbsp; -1&nbsp; 取出数据集合&nbsp; （6）lpop mylist 左弹出集合中第一条数据&nbsp; （7）rpop&nbsp; </span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">mylist&nbsp; 右弹出集合中第一条数据&nbsp; （8）llen&nbsp; mylist&nbsp; 获取数据集合长度lrem&nbsp; mylist&nbsp; count&nbsp; value&nbsp; （count&gt;0,从表头开始搜索，移除count个与值与value相等的元素；count&lt;0,表尾开始；count=0，移除所有值与value相等的元素） （9）linsert mylist&nbsp; before/after&nbsp; a&nbsp; 在a元素前或后插入。</span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">(10) lpoplpush&nbsp; list&nbsp; list1 转移列表的元素到另一个列表</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>hash：</strong>（1）hset&nbsp; key&nbsp; &nbsp;val-key&nbsp; val-val&nbsp; 插入一条数据&nbsp; （2）hset&nbsp; myhash&nbsp; name&nbsp; xxx&nbsp; 用于给哈希表中的字段赋值，不存在则创建哈希表赋值，存在则覆盖旧值&nbsp; (3) hget&nbsp; &nbsp;myhash&nbsp; name&nbsp; 取哈希表中某个值&nbsp; （4）hmset&nbsp; myhash name&nbsp; xxx age xxx&nbsp; 批量插入字段&nbsp; （5）hmget</span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">批量获取 （6）hgetall&nbsp; myhash&nbsp; 获取哈希表中所有值&nbsp; (7)&nbsp; hexisets myhash&nbsp; name&nbsp; 判断哈希表中是否存在name字段&nbsp; （8）hsetnx&nbsp; myhash score 100 若存在则不插入，若不存在则插入数据&nbsp; （9）hincrby&nbsp; myhash id 1/hdecrby&nbsp; myhash id&nbsp; 10 递增递减 （10）hdel&nbsp; myhash name&nbsp; </span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">删除&nbsp; （11）hkeys&nbsp; myhash&nbsp; 只取key值&nbsp; （12）hvals&nbsp; myhash&nbsp; 只取value值&nbsp; （13）hlen&nbsp; myhash 获取哈希表长度</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>set：</strong>（1）sadd myset&nbsp; redis&nbsp; 添加一条数据&nbsp; （2）smembers myset&nbsp; 获取数据集合&nbsp; （3）srem&nbsp; myset&nbsp; set1&nbsp; 删除set1&nbsp; （4）sismember myset&nbsp; set1 判断set中是否存在set1&nbsp; (5)srandmember&nbsp; key count&nbsp; 随机获取count个元素（6）spop&nbsp; 从集合中弹出一个元素</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>zset：</strong>之后补充</span></span></p>\n<h2><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">六，redis配置文件（常见配置）</span></span></strong></h2>\n<p><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;daemonize no：</span></span></strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">redis默认不是以守护进程的方式运行的，可以更改为yes启用守护进程（即后台运行）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>pidfile&nbsp; /var/run/redis.pid&nbsp; :</strong>启用守护进程后，默认将pid写入/var/run/redis.pid文件，可以更改</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>port&nbsp; 6379 ：</strong>redis默认端口</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp; &nbsp; &nbsp; &nbsp; <strong>bind&nbsp; 127.0.0.1：</strong>绑定的主机地址</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\"> &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>timeout&nbsp; 300</strong><strong>：</strong>redis客户端闲置多长时间后关闭连接，改为0的话，表示关闭该功能</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>loglevel&nbsp; verbose：</strong>默认日志级别（还有debug，notice，warning）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>database 16：</strong>redis默认有16个数据库可以修改</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>save&nbsp; 900&nbsp; 1/save&nbsp; 300&nbsp; 10/save&nbsp; 60&nbsp; 10000：&nbsp;</strong>表示一定时间内有多少条数据发生修改，就将其同步到数据文件一次，例如第一个表示15分钟内有一条数据发生改变就同步</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>rdbcompression yes&nbsp; ：</strong>表示数据存储到本地数据库时是否进行压缩</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>dbfilename&nbsp; dump.rdb：</strong>指定本地数据库文件名</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>dir&nbsp; /...../redis安装目录/bin ：</strong>本地数据库存放目录，默认在redis安装目录的bin目录下</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>slaveof&nbsp; &nbsp;masterip&nbsp; masterport ：</strong>设置当本机为从机时，它的主机的ip和端口</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>masterauth&nbsp; &lt;master-password&gt;：</strong>当master服务设置了密码时，slav服务连接master的密码</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>requirepass&nbsp; foobared：</strong>默认关闭redis连接需要密码，当给redis设置了密码，就需要打开</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>maxclients&nbsp; &nbsp;128：</strong>redis同一时间最大连接客户端的数量</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>appendonly&nbsp; &nbsp;no：</strong>是否开启aof持久化，默认不开启，采用rdb</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>appendfilename&nbsp; appendonlu.aof：</strong>指定aof持久化的文件名</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>appendfsync&nbsp; everysec :</strong>指定更新日志条件，默认每秒更新一次（还有no，指等操作系统进行数据缓存到磁盘，快；always指每次更新操作后都手动写入磁盘，慢但安全）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;虚拟机方面的配置暂不说明</span></span></p>\n<h2><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">七，redis持久化</span></span></strong></h2>\n<p><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;概述：</span></span></strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">redis持久化主要有两种方式，即rdb和aof</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>rdb：</strong>适用于大数据集的恢复，数据的备份，但是因为设置周期时间进行数据的快照，所以如果redis宕机，可能会丢失最后一个写操作的数据，因为数据完整性较差。数据保存在dump.db文件中，只需要移动到redis安装目录，重启即可恢复数据</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>aof：</strong>适用于对数据的完整性要求较高的情况，因为可以设置不同的持久化策略，例如每秒保存一次，这样即时redis宕机，也只会丢失最后一秒的数据。但是因为其日志文件存储的是写入命令，因而其文件大小要大于rdb的数据文件，且每次重启，都要从头执行数据文件中的命令，因而恢复速度也</span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">要慢于rdb。</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>注意：</strong>当rdb和aof同时开启的时候，redis重启，默认会采用aof的形式进行数据的重新构建</span></span></p>\n<h2><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">八，redis事务</span></span></strong></h2>\n<p><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;概述：</span></span></strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">什么是事务？事务即是一系列的命令要买全部执行，要么全部回滚</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <strong>常用命令：</strong>multi(启动事务)，discard（取消事务）,exec（执行事务块内命令）,watch key(监控某个key的变化)，unwatch（取消对所有key的监控）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>注意：</strong>redis的事务中在命令本身出错的情况下会造成命令的全部回滚，但是在命令无错，执行某个命令的时候发生异常的时候，则谁的错，谁停止（这一点和mysql是不同的）</span></span></p>\n<h2><strong>九，redis的主从复制</strong></h2>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>redis的主从复制，即主机数据更新后根据我们设置的策略将数据同步到从机上，主机以写为主，从机以读为主<strong>。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 使用：</strong>配主不配从，在从机中使用slaveof&nbsp; 主机ip&nbsp; &nbsp;主机端口配置从机，但是这种配置方式当redis重启之后就会失效，如果想要redis重启仍然可用，则需要配置redis.conf配置文件中的slaveof&nbsp; masterip&nbsp; masterport。这种配置方式的问题所在，中心化只有一台极其支持写操作，如果主机宕机，则从机等待，且从机宕机重启后不会跟上大部队（即重启后变为主机）。当然我们可以采用命令slave&nbsp; no&nbsp; one 使从机反客为主，成为主机。但是这种手动操作太过麻烦。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>哨兵模式：</strong>即配置之后，如果主机宕机，则哨兵会自动根据投票规则在从机中进行选举，从而产生新的主机顶替。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>主从复制的缺点：</strong>因为所有的写操作都是子主机上进行，从而在同步到从机上，所以存在着一定的延迟，当系统繁忙或者从机数量较多的时候，这种问题就更加明显。</p>\n<h2><strong>十，redis集群</strong></h2>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;概述：</strong>集群是一种去中心化的模式，与中心化模式不同的是，中心化模式中如果主服务挂掉了，那么服务就挂掉了。但是集群模式下，没有主路由，每个节点自身都可以成为路由</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;redis集群：即配置多台主机，多台从机，不同的主机中有不同的槽点，当执行数据写入时，会根据crc16算法计算出数据的槽点，从而将数据存入到对应的主机中，并同步到与其对应的从机中</p>\n<p>&nbsp;</p>\n<h1>水平有限，如有错误，还望指出！</h1>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1249588251598041088","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6UCU-ALIMAAACFuGw0Y70739.jpg","blogRead":3,"blogRemark":"redis基础（一）","blogTitle":"redis基础（一）","createdTime":"2020-04-13 06:40:30","typeName":"redis","updateTime":"2020-04-16 13:15:50"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，JAVA线程的创建方式</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>JAVA线程的创建有四种方式，分别为，继承Thread类，实现Runable接口，实现Callable&lt;Class&gt;接口，基于线程池。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>1，继承Thread方式：创建一个类继承Thread类，创建类的实例对象，调用start方法，继而执行线程的run（）方法，代码如下：</strong></p>\n<pre class=\"language-java\"><code>public class NewThread extends Thread{\n    public static void main(String[] args) {\n        NewThread thread = new NewThread();\n        thread.start();\n    }\n    @Override\n    public void run(){\n        System.out.println(\"create  a  new thread by Thread!\");\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>2，当子类已经继承了一个类，这时候就没法再继承Thread类了，这时候就可以实现Runable接口，实例化类的线程实例，创建Thread实例传入类的实例，执行start方法，继而执行run（）方法代码如下：</strong></p>\n<p>&nbsp;</p>\n<pre class=\"language-java\"><code>public class ThreadExample2 implements Runnable {\n    public static void main(String[] args) {\n        ThreadExample2 threadExample2 = new ThreadExample2();\n        Thread thread = new Thread(threadExample2);\n        thread.start();\n    }\n    @Override\n    public void run() {\n        System.out.println(\"create a new thread by Runnable!\");\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，有些情况下，我们需要再一个主线程中并发多个子线程执行同一个任务，然后回收子线程的返回值整理汇总，这时候就需要实现Callable&lt;Class&gt;接口，重写其call（）方法，用于计算结果。然床创建一个线程池用于提交线程，继而执行call方法，并且创建一个Future的list用于接收子线程逻辑代码即call方法的返回，最终遍历list，得到想要的返回值，如下：</strong></p>\n<pre class=\"language-java\"><code>public class ThreadExample3 implements Callable&lt;String&gt; {\n\n    private String name;\n\n    public ThreadExample3(String name){\n        this.name = name;\n    }\n\n    @Override\n    public String call() throws Exception {\n        return name;\n    }\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        ExecutorService pool = Executors.newFixedThreadPool(3);\n        List&lt;Future&gt; list = new ArrayList&lt;&gt;();\n        for(int i=0;i&lt;3;i++){\n            ThreadExample3 threadExample3 = new ThreadExample3(i+\"\");\n            Future future =pool.submit(threadExample3);\n            System.out.println(future.get().toString()+\" is running\");\n            list.add(future);\n        }\n        pool.shutdown();\n        for (Future future : list) {\n            System.out.println(\"currentThread's result is \"+future.get().toString());\n        }\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，基于线程池创建线程</strong></p>\n<pre class=\"language-java\"><code>public class ThreadExample4 {\n    public static void main(String[] args){\n        ExecutorService pool = Executors.newFixedThreadPool(3);\n        for(int i=0;i&lt;3;i++){\n            pool.execute(new Runnable() {\n                @Override\n                public void run() {\n                    System.out.println(\"thread  is running by FixedThreadPool\");\n                }\n            });\n        }\n        pool.shutdown();\n    }\n}</code></pre>\n<h2>二，线程池的工作原理</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong> &nbsp;1，概述：</strong>JVM根据用户提供的参数创建一定数量的线程任务，将其放入队列中，线程创建之后启动这些任务，如果线程的数量大于核心线程数量（用户设置的线程数量），则超出数量的线程排在队列中等待，当有线程任务执行完毕后，线程池调度器就会发现有可用可用线程，继而从队列中取出任务继续执行<strong>。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; </strong><strong>2，线程复用：</strong>（参见JDK源码解读，这里只做简单描述），由前可知，JVM会根据用户提供的参数创建一定数量的线程任务，且将其添加到任务队列中。JVM通过start（）方法创建一个线程之后， 会相应的为其创建一个任务队列，线程会不停的查看任务队列，如果任务队列中有任务，则调用run方法，执行，这样就达到了一次start（）创建线程，多次使用，完成线程复用的任务。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>3，线程池的核心组件和核心类（见JDK源码分类中关于线程的总结）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; </strong><strong>4，JAVA线程的工作流程：</strong>线程池刚被创建的时候，只是向系统申请一个执行线程队列和管理线程池的线程资源，当调用execute方法之后，执行下列流程：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果正在运行的线程数量小于corePoolSize（核心线程数量，即用户定义的的线程数量），则立即创建线程执行线程任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果正在运行的线程数量大于或等于corePoolSize，则将超过数量的线程加入到阻塞队列中</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在阻塞队列已满且线程数量小于MaximumPoolSize（即线程池能够容纳的最大线程数），线程池会创建非核心线程立即执行任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在阻塞队列已满且线程数量大于或等于MaximumPoolSize的时候，线程池会拒绝该线程任务且抛出异常</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在线程任务执行完毕之后，会将其从任务队列中移除，从队列中取出下一个线程任务执行</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在线程处于空闲状态且空闲时间超过KeepAliveTime，且线程数量大于corePoolSize的时候，会停止该线程，这样在没有任务的时候，线程池中的线程数始终维持在corePoolSize。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，线程池的拒绝策略：</strong>分为四种，分别为AbortPolicy，CallerRunsPolicy，DiscardOldestPolicy，DiscardPolicy</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; AbortPolicy：直接抛出异常，阻止线程运行，源码如下：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</p>\n<pre class=\"language-java\"><code>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n            throw new RejectedExecutionException(\"Task \" + r.toString() +\n                                                 \" rejected from \" +\n                                                 e.toString());\n        }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CallerRunsPolicy：如果线程任务没有关闭，则尝试执行该线程任务，源码如下：</p>\n<pre class=\"language-java\"><code>* @param r the runnable task requested to be executed\n* @param e the executor attempting to execute this task\n*/\npublic void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n     if (!e.isShutdown()) {\n         r.run()\n     }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DiscardOldestPolicy：移除任务队列中最早进入的线程任务，执行当前任务线程，源码如下：</p>\n<pre class=\"language-java\"><code>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n       if (!e.isShutdown()) {\n           e.getQueue().poll();\n           e.execute(r);\n       }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DiscardPolicy：直接丢弃线程任务，不做任何处理</p>\n<h2><strong>三，五种常用的线程池</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;newCachedThreadPool（可缓存线程池）：</strong>当线程池创建线程的时候如果发现有可复用的线程（执行完任务，且未关闭的线程），则直接复用，如果没有则创建新线程。可缓存线程池可以高效的利用执行任务时间短的线程，提高系统的性能，且线程池中的线程如果空闲时间超过60s，则会被终止且从缓存中移除，这样可缓存线程池不会占用系统资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>newFixedThreadPool（固定大小的线程池）：</strong>即线程池中的线程是初始化固定的，当任务线程大于线程池中线程数量时，任务线程就会进入阻塞队列等待。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newScheduledThreadPool（可做任务调度的线程池）：</strong>即可以设置线程执行的停顿时间和执行周期，进行定期定时的执行某个任务。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newSingleThreadPool（单个线程的线程池）:&nbsp;</strong>即线程池中永远只有一个线程进行工作，如果下称停止或者异常，则线程池创建新的线程替代当前线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newWorkStealingPool（足够大小的线程池）：</strong>即创建足够数量的线程的线程池，保证更快的进行运算，提高效率。</p>\n<h2><strong>四，线程的生命周期</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;线程的生命周期大致分为五个阶段：新建（new），就绪（Runnable），运行（Running），阻塞（Blocked），死亡（Dead）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;新建：</strong>即使用new创建一个线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>就绪：</strong>调用start方法，</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>运行：</strong>即线程获取cpu资源，执行run（）方法，进入运行状态，运行状态的线程如果调用yield（线程让步方法）或者失去cpu资源，都会导致线程重新回到就绪态；如果调用sleep方法，I/O阻塞，等待同步锁，等待通知以及suspend挂起都会导致线程进入阻塞态。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞：</strong>即线程被放入Blocked池。阻塞状态的线程如果结束了sleep方法，I/O方法返回，获取同步锁，收到通知或者resume都会导致其重新进入就绪态，与其它线程竞争cpu时间片。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>死亡：</strong>线程正常执行完run（）或者call（）方法，或者执行stop方法，或者发生异常或者错误都会导致线程死亡。（stop方法会导致锁混乱和死锁，不建议使用）</p>\n<h2><strong>五，线程的基本方法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;wait（线程等待）：</strong>会让线程进入WAITING状态，并且会释放对象的锁。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>sleep（线程睡眠）：</strong>会让线程进入睡眠，进入TIMED_WAITING状态，但是不会释放对象锁，睡眠时间到了之后，再次恢复运行状态</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>yield（线程让步）:</strong>&nbsp; 当前线程会让出其占有的cpu资源，重新回到就绪态和其它线程竞争cpu时间片</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>interrupt（线程终端）:&nbsp;&nbsp;</strong>中断当前线程，但是并不会导致其停止，只是改变其内部的终端标识位，在使用了thread.sleep()之后使用该方法，会导致抛出异常，且我们可以利用中断标识位进行线程的安全退出</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>join（线程加入）：</strong>即将当前线程进入阻塞态，等待下一个线程执行完毕后进入就绪态，重新竞争锁资源。通常用于主线程下面执行子线程，需要主线程阻塞，等待子线程执行完毕后返回其结果给主线程，主线程再执行的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>notify（线程唤醒）/notifyAll：</strong>前者随机唤醒一个等待线程，后者全部唤醒</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>setDaemon（守护线程）:</strong>级别较低的线程，用于后台运行，服务用户用户线程，例如垃圾收集线程就是典型的守护线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>sleep方法和wait方法的区别：</strong>前者属于Thread，后者属于Object，前者不会释放锁资源，后者会释放锁资源</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>start方法和run方法：</strong>start方法只是创建一个线程，并没有运行，run方法时执行线程的真正代码逻辑。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>线程退出的方式：</strong>见四中最后一条</p>\n<h2><strong>六，JAVA中的锁（知识比较杂乱）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述:JAVA中的锁是为了保护数据的一致性。按照不同的标准可分为乐观锁和悲观锁，公平锁和非公平锁，共享锁和独占锁，偏向锁，轻量级锁，重量级锁，自旋锁，可重入锁。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;乐观锁：</strong>即认为每次读取数据都不会被修改，当修改操作的时候再判断当前数据是否被修改，未修改则修改，若已被修改，则返回失败状态。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>悲观锁：</strong>即认为每次读取数据都会被修改，因而每次读取数据都对其进行加锁，这样只有当前用户可以修改，其它用户阻塞等待直到当前用户修改完毕释放锁资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>自旋锁：</strong>即有些线程任务的执行很短，很快就可以释放锁资源，为了避免在这种情况下竞争线程仍然进行内核态和用户态之间的转换，因而让线程自旋（即等一会），如果有可用锁，则获取，减少了线程在用户态和内核态之间切换的时间损耗。提高了性能（优势）。当然线程自旋是占用cpu资源的，因而需要设置一个自旋的最大等待时间，如果超过此时间，则线程退出自旋模式。对于线程竞争锁资源激烈的情况，自旋有可能会导致cpu资源的损耗（劣势）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>公平锁和非公平锁：</strong>即根据线程竞争锁资源的机制判定，一般如果依据先到先得的原则，则位公平锁；如果依据就近原则，则位非公平锁。公平锁相比于非公平锁会更加耗费性能，因为要维护一个线程任务丢列，根据线程任务在队列中的顺序分配锁资源，因而不常用。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>可重入锁：</strong>又被称为递归锁，即该锁可以然后线程对其进行多次的加锁操作。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>偏向锁：</strong>当线程获取到锁的时候，用来消除线程的锁重入的开销（看起来是偏袒这个线程）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>共享锁和独占锁：</strong>共享锁即多线程共享锁资源（典型例子，读锁）；独占锁即当前锁只能有一个线程获取，其它线程阻塞</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>轻量级锁：</strong>没有多线程竞争的前提下，减少重量级锁的使用提高性能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>重量级锁：</strong>基于操作系统的互斥量而实现的锁，会导致进程在用户态和内核态之间切换，耗费性能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>synchronized：独占式悲观锁，可重入锁，非公平锁，重量级锁。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 作用范围：</strong>作用于成员变量和非静态方法，相当于锁住的是对象的实例，即this对象</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;作用于静态方法，相当于锁住的是class实例</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;作用域代码块，相当于锁住的代码块中的对象</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>实现原理：</strong>内部包括ContentionList（锁竞争队列），EntryList（竞争候选列表），WaitSet（等待集合），OnDeck（竞争候选者），Owner，!Owner，其中ContentionList是用来存放竞争锁资源的线程。EntryList是用来存放有资格竞争锁资源的线程。调用wait方法后放入WaitSet中，onDeck指的是同一时刻，只有一个线程竞争锁资源，Owner指的是得到锁资源的线程，!Owner指的是线程执行完毕，释放锁资源的线程。需要注意的是线程首先采用的都是自旋模式获取锁资源，如果自旋获取不到再加入ContentionList，而且Owner状态的线程并不是直接把锁资源交给onDeck状态线程，而是给它竞争锁资源的权利，因而onDeck状态的线程还需要跟自旋线程竞争锁资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>ReentrantLock：独占式，可重入锁，并且可以实现公平锁和非公平锁，重量级锁。</strong></p>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;用法：</strong>lock()加锁，后跟try代码块，finally中进行释放锁unlock()</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;避免死锁的方法：</strong>响应中断（即可以根据情况中断对锁资源的请求），可轮询锁（tryLock（）即尝试获取锁，如果有可用锁则获取返回true，没有则返回。和lock（）的区别在于lock获取锁资源如果没有则一直等待直到获取到锁资源），定时所（tryLock（time,unit）即再一定时间内如果有可用锁，且线程未中断则获取锁，否则禁用当前线程。）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>Semaphore（信号量）:</strong>机制和ReentrantLock类似</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ReadWriteLock（读写锁）：</strong>如果系统要求支持多线程共享读，但不能多线程写，使用读锁；如果要求同一时刻只能有一个线程写，写的过程中不能读取该共享数据，则使用写锁。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; <strong>分段锁：</strong>一种思想，将数据分段加锁，例如ConcurrentHashMap</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;死锁：</strong>即线程之间互相共享资源会导致死锁</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; <strong>锁优化：</strong>第一，减少锁的持有时间；第二：减小锁粒度，例如分段锁；第三：锁分离，例如读写锁；第四：锁粗化，放置锁粒度太小，造成频繁加锁释放锁；第五：锁消除，消除程序代码不规范而造成的乱用了锁</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>\n<h1>水平有限，如果错误，还望指出！</h1>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;</p>","blogGoods":0,"blogId":"1249313090567143424","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6TCO-AEYrKAACh3H-d2Gc645.jpg","blogRead":4,"blogRemark":"面试（三）------之并发编程篇（上）","blogTitle":"面试（三）------之并发编程篇（上）","createdTime":"2020-04-12 12:27:07","typeName":"java面试篇","updateTime":"2020-04-12 12:57:17"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，集合</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，List：</strong>list是java中一种有序的集合，下有三个实现类，分别为ArrayList，Vector，LinkedList</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ArrayList：基于数组实现，增删慢，查询快，线程不安全。因为其基于数组实现，所以查询的时候可以直接根据数组的索引下标进行快速查询，但是进行增删操作的时候，需要将待增删元素后的元素全部移动，因而效率较低。且ArrayList创建时不需要分配初始大小，其空间不够的时候，会自动创建一个更大的list，然后复制数据。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Vector：基于数组实现，和ArrayList一样增删慢，查询快。但是线程安全，因为同一时间只支持一个线程对Vector进行写操作，然而因为要进行频繁的加锁和释放锁的操作，所以效率要低于ArrayList。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; LinkedList：基于双向链表实现，增删快，查询慢。因为基于链表实现，增删元素的时候，只需要改变元素的指针即可，改动较小，效率较高。然而进行查询操作的时候，需要从链表头部进行遍历，因而效率较低。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，Queue：</strong>队列，满足先进先出，种类较多。（不作详细解释）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，set：</strong>具有独一无二的特性，常用来存储无序且不重复的元素，对象相等的本质是hashcode的值相同，而如果想要比较两个对象是否相等，需要重写对象的hashcode方法和equals方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;hashset：基于hashTable实现，无序。存放的是对象的散列值，即通过hashcode计算得到的值</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;treeset：基于二叉树实现，即其中的对象按照一定的排序方式进行排列（升序，降序），每次添加对象的时候，都会进行排序，将其插入指定位置。基本的数据类型例如Integer，String等可以使用treeset默认的排序方法，而自定义数据类型需要实现compareable接口，实现compareTo方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;LinkHashSet：继承自hashset，只不过使用双向链表记录数据的顺序。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，map：</strong>一种键值对形式的集合</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;hashmap：基于数组+链表实现，增删改查操作快，但是每次遍历hashmap元素的顺序无法保证且线程不安全。如果想要其线程安全，可以使用synchronizedMap和ConcurrentHashmap，hashmap的内部是数组，数组中的每一个元素又是一个单向链表，链表中的每个元素嵌套一个Entry实例，其中包括Key，Value，Hash值，指向下一个节点的next。每次查询的时候，可以根据元素的hash值很快定位所在数组，但是定位之后需要遍历链表查找元素，因而时间复杂度为O（n），但是Java8之后对其进行了优化，将其改为了数组+链表或红黑树的结构，即当链表中的元素大于8个的时候，链表会转换为红黑树（红黑树是一种特化的二叉平衡树，因为其左右子树的深度差可以大于1），这样查询的时间复杂度就缩短到了O（logN）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ConcurrentHashmap：采用分段锁的思想进行并发操作，因而使线程安全的。由多个Segment组成，只要保证每个Segment线程安全就可以保证全局线程安全。ConcurrentHashmap的默认Segment即并发度为16，可以在初始化的时候修改，但是初始化之后不能再修改。每个Segment内部的实现和hashmap一样&middot;。Java8之后也和hashmap进行了一样的优化。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;HashTable：线程安全，即同一时刻只能有一个线程对其进行操作，并发度不如ConcurrentHashmap。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;TreeMap：基于二叉树数据结构实现，实现了SortedMap，默认按照键值的升序进行排列。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;LinkedHashMap：Hashmap的子类，只不过使用链表保存元素的插入顺序。使用迭代器遍历的时候按照插入顺序遍历。</p>\n<p><strong>二，异常分类及处理</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;1，异常分类：</strong>Throwable是所有异常类的父类，其下有error和Exception，Error下有AwtError，ThreadDeath；Exception下有RuntimeException和CheckedException。</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</strong>对于Error类异常通常是由内部错误和资源耗尽造成的，无法在程序运行期间对其进行捕获和处理，对于这类错误我们只能记录错误的原因和终止程序。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; Exception中的RuntimeException异常（运行时异常）：这类异常是我们程序中异常处理的核心，可以在程序中进行捕获并处理。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Exception中的CheckedException异常（检查异常）：这类异常时程序中需要强制捕获的异常，通常有IO异常，SQL异常等等。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，异常处理：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>异常处理有两种方式：抛出异常和捕获异常</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;抛出异常有三种方法：throws，throw，系统自动抛出。其中throws是作用在方法上，后面跟的是可能产生的异常类。throw是作用在方法内部，后面跟的是具体的异常对象。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 捕获异常：即使用try{}catch语句进行捕获</p>\n<p><strong>三，反射机制</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，什么叫做反射机制？</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>即在程序运行的过程中，可以获取类的属性和方法，并且可以调用任意一个类的方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，反射机制的使用</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 首先，获取类的class对象，有三种方式，className.getClass()，类对象.class，Class.forName(\"类路径\")，其中最后一种最为安全，性能最好。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 然后利用反射的API可以实现对类中信息的操作，例如getDeclareFields（），getDeclareMethods（），getConstroctors（）等等。反射创建类的对像有两种方法，一，class.newInstance()初始化一个类实例；二，先获取其构造器，然后利用构造器初始化一个实例。利用反射调用类的方法：先获取方法，然后调用method.invoke()执行方法。</p>\n<p><strong>四，注解</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，四种元注解：</strong>@Target（指定注解的使用范围），@Retention（定义注解的保留级别，有三级，SOURCE源程序中保存，CLASS文件中保存，RUNTIME运行时保存），@Documented（可以工具文档化），@Inherited（<span style=\"background-color: #ffff00;\">这个没怎么看懂</span>）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，注解使用示例：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>第一步，定义注解接口</p>\n<pre class=\"language-java\"><code>@Target(ElementType.FIELD)  \n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface FruitProvider {\n\n    //id\n    public int id() default  -1;\n\n    //供应商名称\n    public String name() default \"\";\n\n    //供应商地址\n    public String address() default \"\";\n\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 第二步，使用注解</p>\n<pre class=\"language-java\"><code>public class Apple {\n\n    @FruitProvider(id = 1,name = \"红富士苹果\",address = \"陕西\")\n    private String appleProvider;\n\n    public String getAppleProvider() {\n        return appleProvider;\n    }\n\n    public void setAppleProvider(String appleProvider) {\n        this.appleProvider = appleProvider;\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第三步，定义注解处理器</p>\n<pre class=\"language-java\"><code>public class FruitInfoUtil {\n    public static void getFruitInfo(Class&lt;?&gt; clazz) {\n        String strFruitProvider = \"供应商信息:\";\n        Field[] declaredFields = clazz.getDeclaredFields();\n        for (int i = 0; i &lt; declaredFields.length; i++) {\n            if (declaredFields[i].isAnnotationPresent(FruitProvider.class)) {\n                FruitProvider annotation = declaredFields[i].getAnnotation(FruitProvider.class);\n                strFruitProvider += annotation.id() + \",\" + annotation.name() + \",\" + annotation.address();\n                System.out.println(strFruitProvider);\n            }\n        }\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第四步，主方法入口</p>\n<pre class=\"language-java\"><code>public class FruitRun {\n    public static void main(String[] args) {\n        FruitInfoUtil.getFruitInfo(Apple.class);\n    }\n}</code></pre>\n<p><strong>五，内部类</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 1，静态内部类：</strong>即在类的内部定义的静态类，静态内部类可以访问外部了的静态变量和方法，外部也可以通过outClassName.innerClassName调用内部类</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2，成员内部类：</strong>在类的内部定义的没有用static修饰的内部类，使用方式和静态内部类一样。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>3，成员内部类：</strong>即一个类只在一个方法中使用，则完全可以将这个类定义为这个方法的内部类，即局部内部类，局部内部类可以实现真正的对外隐藏</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>4，匿名内部类：</strong>通常用于继承一个类或者实现一个接口的时候，使用new关键字定义，例如:Person person = new Student(){new Pupil(){}}</p>\n<p><strong>六，泛型</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 1，为什么要使用泛型：</strong>其根本目的是为了实现代码的复用，举个开发中常见的例子，我们需要定义返回类Result，返回类中包含状态码code，信息msg，以及数据data（任意类型），这个时候我们就需要使用泛型，因为我们返回的数据类型有各种vo，pojo类对象，list等。这时候泛型类result就可以被各种对象使用，实现代码的复用，简化开发。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>2，泛型标记和泛型限定：</strong>E表示集合中的元素，K表示键值，V表示value，N表示数值类型，T表示任意类型（包含基础类型，所有的对象类型），？（不确定的java类型）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>泛型限定：</strong>向上限定，&lt;?&nbsp; extends T&gt;，向下限定，&lt;? super&nbsp; T&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; <strong>3，泛型方法：</strong>即参数类型定义为泛型类型，以便于接收不同类型的参数，做出不同的处理。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>4，泛型类：</strong>例如public class Pair&lt;T&gt;{private T data;}</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>5，泛型接口：</strong>与放泛型类类似</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>6，类型擦除：</strong>即在泛型编译的过程中，会将泛型类型替换为限定类型的操作</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>7，明确的一点：</strong>虚拟机在运行程序的过程中，内部是没有泛型的，只有普通的类和方法。</p>\n<p><strong>7，序列化：</strong>序列化是为了确保对象及其状态的持久化</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>序列化的使用：</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </strong>首先，实现序列化接口java.io.Serializble</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 然后，声明序列化ID，通常private static final&nbsp; long&nbsp; serialVersionUid&nbsp; = ***</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 因为序列化是保证对象及其状态的持久化，而静态变量是不属于对象，属于类本身的，所以序列化无法保存静态变量。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果需要序列化父类变量，则父类也要实现Serializable接口</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t'ransient修饰的属性不会序列化</p>\n<p>&nbsp;</p>\n<h2>水平有限，如有错误，还望指出！</h2>","blogGoods":0,"blogId":"1248605157059497984","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6QdaWAWQpnAAD6cIgEnVw521.png","blogRead":17,"blogRemark":"面试（二）------之JAVA基础篇","blogTitle":"面试（二）------之JAVA基础篇","createdTime":"2020-04-10 13:34:02","typeName":"java面试篇","updateTime":"2020-04-12 09:07:59"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，Linux的发展历史</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; </strong>1965年之前，电脑并不像现在这么普遍，除了军事机构和研究即构，一般人基本接触不到电脑，而且那时候的一台大型主机最多也就只能支持30台终端。为了解决数量问题，1965年之后，由贝尔实验室，麻省理工学院以及通用电气一起放弃了Multics项目，准备让大型主机能够支持300台终端，但是在开发过程中，进度缓慢，最终由于资金的短缺，贝尔实验室推出了研究。1969年，从这个项目中退出的Ken Thompson在家无聊，为了让电脑能够运行&ldquo;星际旅行&rdquo;游戏，因而趁着妻子回家探亲的一个月，独自写出了Unix操作系统的原型（！！！！牛批）。1970年，这个人以BCPL语言为基础，又写出了很接近硬件的B语言，并且用B语言写出了第一个Unix操作系统。但是由于B语言的跨平台性比较差，为了解决这个问题。Dennis Ritchie和Ken Thompson决定以B语言为基础开发一种新的语言，1972年，Dennis Ritchie最终设计出了一种新语言，他以BCPL的第二个字母命名，也就是我们后来熟知的C语言。随后两人便迫不及待的用C语言重现Unix操作系统。Unix系统起初开源，但是在Unix7之后，由于政策的变化，代码闭源化，因而大学中不能使用Unix的源代码进行教学。Andrew S. Tanenbaum教授为了能够让学生更好的理解代码细节，在完全不使用任何源代码的情况下开发除了Minix---小型Unix。但是因为其只用于教学，功能并不强大，因而Torvalds以此为基础，开发除了Linux，但是起初Linux并不支持Unix，最终经过全世界网友的帮助，最终让其能够兼容各种硬件。</p>\n<p><strong>二，文件和目录</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; 1，windows和linux的区别：</strong>我们熟知的windows系统，它的文件系统是分盘符的，盘符下的文件构成一个树形结构，但是Linux文件系统没有盘符，所有文件目录都在根目录/之下</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;<strong>2，Linux需要记住的目录：</strong>/bin（存放系统命令的目录），/sbin（只有超级管理员能访问的命令文件目录），/root（存放和root用户相关文件的目录），/etc（存放系统配置文件的目录），/usr（存放系统共享资源的目录），/opt（存放安装的第三方软件的目录，通常在/usr/local下）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;<strong>3，文件权限：</strong>Linux中的文件权限有读（r，可用于数字4表示），写操作（w，可用数字2表示），执行权限（x，可用数字1表示）</p>\n<p><strong>三，常用命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，ls：</strong>列出目录中的所有目录和文件名&nbsp; -a（列出所有，包括隐藏文件和目录），-l（以列表形式列出所有），-h（人性化列出，需要配合-l使用，即文件大小转换为我们熟知的kb，mb等），-d（显示当前目录属性），命令可以联合使用，例如-al，-lh等等。&nbsp;&nbsp;&nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，cd：</strong>用于切换目录，需知（.和..是相对路径，.表示当前目录，..表示上级目录；/表示绝对路径），cd ~（切换到root目录），cd - （切换到前一次切换的目录）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，clear：</strong>清屏</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，pwd：</strong>显示当前所在目录</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，mkdir：</strong>创建目录，-p（如果目录存在则不创建，如果不存在则创建目录再创建自目录），可以一次性创建多级目录，例如：mkdir&nbsp; -p test/test1</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，touch：</strong>创建空文件</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>7，cp：</strong>复制，-r（递归复制目录下的文件目录信息），-i(提示是否覆盖)，-v（显示复制进度）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>8，mv：</strong>移动文件，不过经常用来给文件进行重命名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>9，rm：</strong>删除目录或者文件，-r（递归删除），-f（强制删除），-v（显示删除进度）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>10，cat：</strong>查看文件内部信息</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>11，ln：</strong>文件创建链接，ln 源文件 目标链接文件（创建硬链接，硬链接和源文件大小相同，修改同步，但是删除不同步，使用较少），ln -s（创建软连接，相当于我们平时创建快捷方式，使用较多）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>12，which：</strong>搜索命令所在位置，例如：which&nbsp; &nbsp;ls</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>13，find：</strong>搜索文件所在位置&nbsp; 例如：find&nbsp; &nbsp;test.conf</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>14，grep：</strong>文件内容搜索，例如：grep &ldquo;想要搜索的内容&rdquo;&nbsp; 源文件</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>15，tar：</strong>归档命令，-c（打包成.tar文件），-z（打包的同时压缩），-v（打包的同时显示进度），-f（放在最后，后面跟.tar.gz），-x(解压)，常用：tar -zcvf&nbsp; <em><strong>.tar.gz&nbsp; &nbsp; ;&nbsp; &nbsp; tar -zxvf</strong> tar.gz</em> -C&nbsp; 指定解压目录&nbsp;&nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;还有more，head，tail等命令，不过这些不常用。</p>\n<p><strong>四，用户权限命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，whoami：</strong>查看当前账户的用户名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，who：</strong>查看当前登录用户</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，exit：</strong>退出登录</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，adduser/useradd：</strong>添加用户，-d（指定用户主目录），-g（指定用户用户组），-m（自动建立目录），默认情况下用户主目录和用户组名都和用户名一样</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，passwd：</strong>只有root用户才能使用，用于修改用户密码</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，userdel：</strong>删除用户，默认不删除用户的主目录，-r（删除用户主目录）</p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;7，su：</strong>切换账户</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>8，groupadd/groupdel：</strong>添加用户组和删除用户组</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>9，groups：</strong>查看用户所在用户组，例如：groups&nbsp; 用户名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>10，usermod：</strong>修改用户所在用户组，例如：usermod&nbsp; 用户组名 用户名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>11，chmod：</strong>修改文件权限，例如：chmod&nbsp; 777&nbsp; test</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>12，chown：</strong>修改文件所有者，例如：chown&nbsp; &nbsp;用户&nbsp; 文件名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>13，chgrp：</strong>修改文件所在组，例如：chgrp&nbsp; 组名&nbsp; 文件名</p>\n<p><strong>五，系统命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，cal：</strong>查看日历</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，date：</strong>查看时间，可以设置格式，例如：date '+<span class=\"ql-token hljs-built_in\">%Y</span>-<span class=\"ql-token hljs-built_in\">%m</span>-<span class=\"ql-token hljs-built_in\">%d</span> <span class=\"ql-token hljs-built_in\">%H</span>:<span class=\"ql-token hljs-built_in\">%M</span>:<span class=\"ql-token hljs-built_in\">%S</span>'</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，ps：</strong>查看线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，kill：</strong>杀死线程，-9（强制杀死）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，查看网卡信息：</strong>centos6：ifconfig ；centos7：ip addr</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，ping：</strong>查看网址或者链接的连通性</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>7，防火墙：</strong>centos6：service&nbsp; iptables&nbsp; status（查看防火墙状态），service&nbsp; &nbsp;iptables&nbsp; &nbsp;start(开启),service&nbsp; iptables&nbsp; stop(关闭);centos7:firewall-cmd&nbsp; --state（查看防火墙状态），systemctl&nbsp; start&nbsp; firewalld.service(启动)，systemctl&nbsp; &nbsp;stop&nbsp; firewalld.service（关闭）</p>\n<p><strong>六，网络命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，wget：</strong>下载，例如：wget&nbsp; &nbsp;链接地址</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，yum：</strong>下载安装</p>\n<p><strong>七，vim（这里只说几个常用的命令）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;</strong>vim有三种模式：命令模式，插入模式，编辑模式&nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;vim&nbsp; 文件名：进入文件，且处于命令模式；iao任意一键进入插入模式（i表示在贯标之前插入，a光标之后插入，o在下一行插入），：进入编辑模式</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;命令：set:nu显示行号，set:nonu不显示行号；/strinng，向后搜索字符串，？string向后搜索字符串；：w保存，：wq保存并退出，：q不保存退出</p>","blogGoods":0,"blogId":"1248500061625745408","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6QE92AaLPoAADG_98SpI0054.jpg","blogRead":1,"blogRemark":"Linux基本命令总结","blogTitle":"Linux基本命令","createdTime":"2020-04-10 06:36:25","typeName":"Linux","updateTime":"2020-04-10 06:36:52"},{"blogCollection":0,"blogComment":0,"blogContent":"<p style=\"text-align: left;\"><strong>一，JVM运行机制</strong></p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;jvm即java虚拟机，一共由四个部分组成，分别是类加载器子系统，运行时数据区（程序计数器，本地方法区，jvm栈，方法区，jvm堆），执行引擎（即时编译器，垃圾收集器），本地接口库。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;一个java源程序的运行先是经过编译器将其编译成字节码文件（class文件），然后通过类加载器子系统将其加载进入jvm&mdash;&mdash;&gt;程序运行过程中，运行时数据区存放程序运行过程产生的数据&mdash;&mdash;&gt;执行引擎中的垃圾收集器收集程序运行过程中创建的不再使用的对象，即时编译器将程序的字节码文件编译成机器码&mdash;&mdash;&gt;然后本地接口库利用机器码调用本地方法库中的方法，和操作系统实现交互。</p>\n<pre><strong>二，多线程</strong></pre>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;</strong>在多核操作系统中，jvm支持一个进程中同时并发执行多个线程，且这些线程和本地操作系统的线程相对应。当jvm中的对象初始化，内存空间分配等一系列准备工作完成之后，会调用操作系统中的接口创建一个原生线程，原生线程初始化完毕后，会调用java线程的run（）方法执行该线程，线程结束之后，jvm会释放原生线程和java线程资源。</p>\n<p><strong>三，JVM的内存区域</strong></p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM的内存区域主要分为线程私有区域（程序计数器，本地方法区，JVM栈），线程共享区（方法区，JVM堆）和直接内存。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;程序计数器：线程私有区域，无内存溢出，用来记录程序运行过程中的字节码指令地址，如果是Native方法，则程序计数器为空。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM栈：线程私有区域，用来描述java程序的运行过程，java程序运行每次运行的时候，都会创建一个栈帧，方法的执行和返回对应着栈帧的入栈和出栈操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;本地方法区：线程私有区域，和JVM栈的功能一样，只不过是用来记录Native方法的运行过程。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM堆：线程共享区，主要用来存放程序运行过程中产生的数据，同时也是垃圾收集器进行垃圾回收的主要区域。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;方法区：也被称为永久代，用来存放常量，静态变量，类信息等等。</p>\n<p><strong>四，JVM的运行时内存</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>JVM的运行时内存又被称为JVM堆，因为JVM的GC算法使用的是分代收集算法，所以JVM堆按照GC标准可以分为三个区域分别为：新生代，老年代，永久代。其中新生代占1/3，老年代占2/3，永久代很少，</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;新生代：存放短生命周期，小对象的区域。新生代又分为Eden区，ServivorTo区，ServivorFrom区，区域的GC算法采用复制算法。Eden区是用来存放新创建的对象（大对象除外），ServivorTo区是用来保存MinorGC幸存下来的对象，ServivorFrom区是用来将上一次MinorGC幸存下来的对象作为下一次MinorGC的扫描对象。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;老年代：存放长生命周期的大对象，区域的GC算法采用标记整理算法</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;永久代：主要用来存放class和meta数据信息的。程序运行过程中不会进行永久代的垃圾回收，这也就导致永久代区域的数据会越来越多，最终造成内存溢出。java8之后永久代已经被元数据区取代，元数据区和永久代的功能都是一样的，但是最大的不同在于永久代区域依赖于虚拟机的内存大小，因而可以存储的class，meta信息非常有限。但是元数据区依赖的是本地操作系统，因而不会受到虚拟机内存的限制。</p>\n<p><strong>五，垃圾回收与算法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;(1)垃圾回收：</strong>Jvm的垃圾回收判定依赖于两种方法，引用计数法和可达性分析法。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;引用计数法：即如果想要在程序中使用对象，就必须赋予一个引用，这样在对象赋予引用的时候将其引用计数加1，删除一个引用时，将对象引用计数减1，如果引用计数为0，就说明该对象已经不使用，作为垃圾。但是引用计数法存在一个缺陷，即循环引用的问题，如果两个对象相互引用，则这两个对象的引用计数永远都不会为0，造成对象无法被回收。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;可达性分析法：即先创建一些根节点对象ROOTS，然后通过这些根节点对象向下搜索，如果一个对象到任意一个ROOTS之间都没有可达路径，在经过两次标记（下文解释为什么进行两次标记），还是没有可达路径，则说明该对象可回收。</p>\n<p>&nbsp;&nbsp; &nbsp;<strong>（2）GC算法：</strong>常见的GC算法有四种，分别为标记清除算法，复制算法，标记整理算法，分代收集算法</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;标记清除算法：即在进行垃圾回收前，对所有对象进行一次标记，标记可回收的对象，然后进行清理即可。但是标记清除算法在清除回收对象之后，并不会对堆内存进行整理，这样的话如果内存中的对象大部分为小对象，清理之后就会导致没有大片连续的内存空间，即造成了内存碎片化，这样大对象存储的时候就无法找到相应的完整连续内存。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;复制算法：即将内存分为两块同等大小的区域，区域1和区域2，创建的新对象都存储在区域1中，当区域1中的内存占满之后，会对内存中的所有对象进行一次标记，标记存活的对象，将存活的对象复制到区域2，这时区域1中的对象都是可回收对象，回收区域1中的所有对象即可。但是复制算法也存在着一定的缺陷，即每次都只能使用一半的内存空间，造成了大量的内存浪费。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;标记整理算法：即结合标记清除算法和复制算法的优点，先对所有的对象进行标记，标记存活的对象，将存活的对象复制到内存的另一端，然后清除当前端的对象即可。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;分代收集算法：前面的三种算法，都无法按照对象的类型进行收集，分代收集算法正是解决这个问题，按照对象的不同类型采用不同的GC算法。以JVM的分代收集算法为例，JVM的堆内存分为新生代，老年代，永久代。新生代又分为Eden区，ServivorTo区和ServivorFrom区。新生代因为其存储生</p>\n<p>命周期短的小对象，GC比较频繁，所以采用复制算法。程序运行过程中创建的对象都存储在Eden区（大对象除外，大对象直接复制到老年代区域）。当Eden区的内存不够的时候进行MinorGC，然后将Eden区和ServivorFrom区的存活对象都复制到ServivorTo区，然后将ServivorTo区和ServivorFrom</p>\n<p>区进行交换，再次进行MinorGC。老年代因为存放的都是生命周期长的大对象，因而进行GC的不会太频繁，且清除的对象并不会太多，因而采用标记整理算法。老年代每次进行MajorGC之前都会先进行一次MinorGC，当MinorGC之后新生代的内存仍然不够的时候，将对象复制到老年代进行MajorGC。</p>\n<p>永久代区域主要回收常量，无用class等。</p>\n<p><strong>六，JAVA中的四种引用类型</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;强引用类型<strong>：</strong>即把对象赋给一个引用变量，强引用的对象一定为可达状态，所以不会进行垃圾回收。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;软引用类型：通过SoftReference类实现，当内存不够的时候对其进行GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;弱引用类型：只有弱引用类型的对象，一定会被GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;虚引用类型：虚引用对象主要是用来跟踪对象的GC状态</p>\n<p><strong>七，分代收集算法和分区收集算法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>分代收集算法：新生代因其存放大量短生命周期小对象，且GC频繁，所以采用复制算法。老年代因其存放长生命周期大对象，且GC不平凡，所以采用标记整理算法。永久代，回收常量，类信息等。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;分区收集算法：即将堆内存区域分为大小不同的区，可以按照不同的区进行快速垃圾回收，减少系统的停顿时间。然后再以并行的方式逐步完成整个GC。</p>\n<p><strong>八，垃圾收集器</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>新生代区域：Serial垃圾收集器，单线程复制算法，因为单线程无需进行线程之间的交互和切换，所以效率非常高，是JVM默认的client模式下的默认垃圾回收策略，工作期间需要暂停其它所有的线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ParNew垃圾收集器，多线程复制算法，跟单线程Serial一样，是JVM默认的server模式下的垃圾回收策略，工作期间需要暂停所有其它线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Parallel Scavenge垃圾收集器：多线程复制算法，不同的是优先考虑系统吞吐量，可以利用更高效的利用CPU完成GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;老年代区域：Serial Old垃圾收集器，单线程标记整理算法，同新生代的Serial功能一样，只是采取的算法不同而已。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Parallel Old垃圾收集器：多线程标记整理算法，优先考虑了系统的吞吐量，其次考虑停顿时间。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CMS,多线程标记清除算法，优先考虑系统GC时的停顿时间，且过程分为四步（<span style=\"background-color: #ffff00;\">解释上文的可达性分析中的两次标记</span>，第一步：标记GC ROOTS可达对象，暂停其它工作线程；第二步：和用户线程一起工作，跟踪GC ROOTS；第三步，因为第二步用户进程没有暂停，所以有些对象状态</p>\n<p>可能发生了改变，重新进行标记；第四步，清除不可达对象）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; G1垃圾收集器，多线程标记整理算法，将内存分区，与CMS相比，一方面不会产生内存碎片，一方面，可以精确的控制系统停顿时间。</p>\n<p><strong>九，JAVA的网络编程模型</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;</strong>阻塞I/O模型：即用户线程发出I/O请求之后，内核会检查数据是否准备就绪，这时候用户线程始终处于阻塞状态等待数据准备就绪。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;非阻塞I/O模型：即用户线程不断的给内核发出I/O请求，内核接受到I/O请求之后会返回一个状态，如果数据准备就绪，就将数据复制进入用户线程，如果数据没有准备好，返回一个false，用户线程无需阻塞，可以去处理其它事情，而当数据准备好了且刚好用户线程发起I/O请求进行操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;多路复用I/O模型：多路复用I/O模型通过一个Selector线程轮询Socket的状态，如果Socket有读写事件，则进行I/O操作。此模型的优势在于可以更好的处理连接数众多但消息体不大的情况下。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;信号驱动I/O模型：即用户线程发出一个I/O请求，系统会为该请求创建一个信号函数，用户请求可继续执行其它业务逻辑，当内核数据准备就绪之后会返回给用户线程一个信号，用户线程接收到之后进行I/O操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;异步I/O模型：用户线程给内核发起一个asynchronous read操作，内核接收到之后，返回其请求是否成功，然后等待数据准备成功之后复制到用户线程。整个过程中请求的发起和数据读取都在内核中进行，最终发送一个信号告知用户线程I/O操作已经完成，用户直接使用数据就行。（说实话个人感</p>\n<p>觉和信号驱动很像）</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;java NIO：没怎么读懂（<span style=\"background-color: #993300;\">记得补充！</span>）</p>\n<p><strong>十，JVM的类加载机制</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>JVM类加载分为五个阶段：加载，验证，准备，解析，初始化</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;加载：即将class文件加载到JVM中，且创建class对象，封装其数据结构。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;验证：对class文件进行验证，确保符合JVM的标准，保证JVM的安全。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;准备：即方法区中给类变量分配空间和赋初值。static修改的会在初始化阶段赋值，final修饰的会在准备阶段赋值。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;解析：即将常量池中的引用替换为直接引用</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;初始化：执行类构造器进行初始化。（因为内部流程不是很清楚，所以对于其几种不进行初始化的情况不做说明）</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;类加载器：JVM提供了三种类加载器，启动类加载器（/lib），扩展类加载器(/lib/ext)，应用程序类加载器(classpath)。还可以再应用程序类加载器自定义类加载器。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;双亲委派机制：即当一个类接收到类加载请求的时候，不会自己进行加载，而是将其加载请求委派给其父类加载器，这样一路委派，最终加载请求都会委派到启动类加载器.启动类加载器接收到加载请求之后会去lib目录下寻找相关的class文件，若找不到，则将其加载请求再委培给子类加载器，一路委</p>\n<p>派，直到能够加载。</p>\n<p>&nbsp;</p>\n<h2>水平有限，若发现有误，还望指出！</h2>","blogGoods":0,"blogId":"1248224512563068928","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PEz6AUs0lAAB4ISeFCt8304.jpg","blogRead":7,"blogRemark":"面试（一）------之JVM篇","blogTitle":"面试（一）------之JVM篇","createdTime":"2020-04-09 12:21:30","typeName":"java面试篇","updateTime":"2020-04-12 12:45:18"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，css之弹性布局</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，</strong>何为弹性布局？</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 弹性布局是css的一种新的布局方式，所谓&ldquo;弹性布局&rdquo;，即页面随着不同设备的屏幕大小拉伸会自适应页面的大小。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，</strong>弹性布局的两种主要元素，container（弹性容器），item（弹性子元素），一个弹性容器中可以放入多个弹性子元素，元素之间是可以进行嵌套的，弹性子元素也可以设置为弹性容器，里面再嵌套弹性子元素。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，</strong>弹性布局的基本属性</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （1）display：flex，声明容器为弹性布局</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （2）flex-direction：声明弹性容器内部元素的排列方式，默认为row。row（横向布局），row-reverse（横向布局，但是元素反方向码），column（纵向布局），column-reverse（纵向布局，但是元素反着码）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （3）flex-wrap：声明弹性盒子中的元素是否可以换行，默认为nowrap（不换行），wrap（换行），wrap-reverse（换行，但是反着码）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （4）align-items：设置容器中元素在纵轴方向上的对齐方式，默认为stretch（即如果不设置子元素高度，则默认拉伸至于容器同宽度），flex-start（子元素位于容器的开始位置），flex-end（子元素位于容器的结尾处），center（元素依纵轴方向居中），baseline（元素位于容器基线，不过没怎么用过，所以不是很清楚）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （5）justify-content（设置元素在主轴上的对齐方式），默认为flex-start（元素从容器主轴开始位置码），flex-end（元素从容器主轴结尾处码），center（元素位于主轴居中处），space-between（元素布局在容器的两端），space-around（元素布局在容器两端，但是元素前后都留有空白）因为项目中大多数只使用了对于容器的操作，对于容器中元素的操作很少，所以这里只介绍这点。谢谢阅读！</p>","blogGoods":0,"blogId":"1248135765829918720","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6OwJOAYOmCAACSMXNdKeQ941.jpg","blogRead":2,"blogRemark":"CSS----之flex弹性布局","blogTitle":"CSS----之flex弹性布局","createdTime":"2020-04-09 06:28:51","typeName":"CSS","updateTime":"2020-04-10 13:46:01"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，前后端分离开发优势</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，</strong>项目开发过程中，前后端完全解耦，前端只需要负责页面的实现，只需要通过接口拿数据。后端不需要管页面的跳转，只需要负责接口的编写</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，</strong>前后端人员有更多的精力去负责自己的工作，前端人员可以将更多的精力投放在页面的编写，页面的美化，页面特效的制作和用户体验上；而后端人员可以将更多的精力放在接口代码的优化，sql优化，jvm调优上面</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，</strong>前后端分离的项目部署的时候，前端项目往往都是部署在nginx服务器上，而前后端不分离的项目往往都是部署再一台服务器上。因此前后端分离项目大大降低了服务器的负担</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>4，</strong>前后端不分离的项目使用模板引擎例如freemaker，thymeleaf等，前后端人员交流起来较为困难。且前端项目使用原生的DOM操作，极大的增加了前端工作人员的工作量。而前后端分离项目前端通常都是用各种ui框架，框架采用MVVM模式，极大的减轻了前端工作人员的工作量</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，</strong>前后端分离开发，前端可以通过easy-mock来伪造接口数据进行测试，后端人员可以通过postman进行接口测试，开发效率大大提升。</p>","blogGoods":0,"blogId":"1247867141693128704","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NxmWAR3lsAAB7Q44XPGk369.jpg","blogRead":7,"blogRemark":"前后端分离开发的优势所在","blogTitle":"闲谈前后端分离开发","createdTime":"2020-04-08 12:41:25","typeName":"随笔","updateTime":"2020-04-10 13:45:56"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，数据库设计--表的命名规范等</strong></p>\n<p>（1），统一采用bl_开头对表进行命名</p>\n<p>（2），对于数据比较重要的表统一添加四个字段，分别为：created_time(创建时间),update_time(修改时间),version(版本号),deleted(删除字段)</p>\n<p>（3），数据库表的字段尽量都设置为NOT_NULL</p>\n<p>（4），数据库中表varchar类型字段需要设置长度的尽量设置为2<sup>n</sup>-1</p>\n<p>（5），因为博客系统分为前台展示界面和后台管理，所以对于有些表，例如bl_type（博客类型表），bl_music（音乐表）等设置了enable（启用字段）</p>\n<p><strong>二，上述第二条--四个字段的解释</strong></p>\n<p>（1），为什么要设置created_time和update_time字段：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;其一，从数据库的通用性上来说，设计这两个字段是必要的，但也需要根据业务的需要来合理添加这两个字段，因为无用的字段会浪费空间，性能，影响系统的运行。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 其二，大部分的应用都有需要根据时间进行排序的功能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 其三，当系统发生异常的时候，我们可以通过这两个字段对异常进行排查和定位。</p>\n<p>（2），为什么要设置version字段：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 1，version字段含义：字段的含义与其字面意思一样，代表版本，在这里作为乐观锁进行使用，从而保证不会出现脏数据的情况。下面解释一下什么叫乐观锁，以及乐观锁和悲观锁</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 2，乐观锁：总是假定最好的情况，即每次用户调用接口从数据库中取出数据到修改数据前的过程中，不会有其它用户对当前数据进行修改，这样在当前用户修改数据的时候，利用版本机制即判断取出的version字段和当前数据库该条数据的version字段是否相等来判断该条数据是否已经被修改，如果未修改，则予以修改（且version字段递增），如果已经修改，则提示用户更新失败。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 悲观锁：总是假定最坏的情况，即每次用户调用接口从数据库取出数据的时候，都认为该条数据会被修改，因此每次取出数据都对数据进行加锁处理，只允许当前用户进行修改，其它用户阻塞，直到当前用户修改完毕。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3，为什么使用乐观锁而不使用悲观锁：因为悲观锁比较浪费性能</p>\n<p>（3），为什么设置deleted字段：deleted字段在这里作为一个逻辑删除字段（0否1是），何为逻辑删除，即执行删除操作操作的时候，不会真正的删除数据库中的数据，而是将deleted字段设置为1即可。&nbsp;这样如果用户出现误删的操作，可以通过数据库修改该字段进行数据的恢复。</p>\n<p><strong>三，上述第三条--数据库表字段尽量设置为NOT_NULL</strong></p>\n<p>（1），数据库表字段尽量设置为NOT_NULL：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 1，有些人可能认为设置为NULL相比于NOT_NULL不是更节省空间吗？但是实际上不是这样的，设计为NULL相比于NOT_NULL要多占用一个字节的空间</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 2，设计为NOT_NULL，这样在做查询的时候能够更好的避免空指针异常，且发生该类错误的时候能够更好的进行排查</p>\n<p><strong>四，上述第四条--表varchar类型字段长度尽量设置为2<sup>n</sup>-1</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>因为计算机只识别二进制，且有一定的范围，例如2<sup>8</sup>，在计算机中的范围为-128~127,因此对于varchar字段长度来说，如果设置为255，则正好是一个字节，而如果设置为256，则占用两个字节，这样会浪费计算机的内存空间，因此数据库varchar类型字段的长度最好设置为2<sup>n</sup>-1</p>\n<p><strong>五，上述第五条--对于设置enable字段的解释</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>enable字段，字面意思启用，在这里表明是否启用（0否1是），因为系统分为前台博客页面和后台管理，对于这两个不同的前端项目，后台可以通过启用字段来控制内容在前台博客页面的展示与否，与deleted字段不同的是，如果执行删除操作，那么我们只能通过手动修改数据库中的字段进行数据的恢复，且如果执行删除操作，则该数据在前台博客页面和后台管理页面都无法看见。但是如果将数据弃用（即修改enable字段值为1），则表明该数据被弃用，在前台博客页面无法显示，但是在后台管理页面可以看见，且无需通过手动修改数据库来恢复数据，可以在后台管理页面操作启用数据。</p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1247745014683947008","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NVHmAfuv6AADVlotocVo322.jpg","blogRead":21,"blogRemark":"博客开发总结（一）-----之数据库设计篇","blogTitle":"博客开发总结（一）-----之数据库设计篇","createdTime":"2020-04-08 04:36:07","typeName":"博客开发和维护总结","updateTime":"2020-04-12 12:57:33"}],"pageSize":15,"params":{},"sortColumn":"created_time","sortMethod":"DESC","totalCount":15,"totalPage":1},"msg":"操作成功!"}
2020-04-17 10:47:01.272 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/read/1250802898447667200
2020-04-17 10:47:01.273 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-17 10:47:01.274 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-17 10:47:01.274 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /comment/getComment/1250802898447667200
2020-04-17 10:47:01.274 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.readBlog
2020-04-17 10:47:01.274 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-17 10:47:01.274 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/getGoods/1250802898447667200
2020-04-17 10:47:01.274 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /comment/getCommentGoods/1250802898447667200
2020-04-17 10:47:01.274 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/getCollection/1250802898447667200
2020-04-17 10:47:01.275 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[1250802898447667200]
2020-04-17 10:47:01.275 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-17 10:47:01.275 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-17 10:47:01.275 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-17 10:47:01.275 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-17 10:47:01.275 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-17 10:47:01.275 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.CommentController.getComment
2020-04-17 10:47:01.275 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-17 10:47:01.275 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.CommentController.getCommentGoods
2020-04-17 10:47:01.275 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-17 10:47:01.275 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[1250802898447667200]
2020-04-17 10:47:01.275 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[1250802898447667200]
2020-04-17 10:47:01.275 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getGoods
2020-04-17 10:47:01.276 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[1250802898447667200]
2020-04-17 10:47:01.275 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getCollection
2020-04-17 10:47:01.276 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[1250802898447667200]
2020-04-17 10:47:01.470 ERROR [http-nio-1000-exec-6]o.a.c.c.C.[Tomcat].[localhost].[/].[dispatcherServlet].log:175 -Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.NullPointerException] with root cause
java.lang.NullPointerException: null
	at com.wcj.service.impl.BlogServiceImpl.getCollection(BlogServiceImpl.java:279)
	at com.wcj.service.impl.BlogServiceImpl$$FastClassBySpringCGLIB$$428136bb.invoke(<generated>)
	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)
	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:685)
	at com.wcj.service.impl.BlogServiceImpl$$EnhancerBySpringCGLIB$$4fa08134.getCollection(<generated>)
	at com.wcj.controller.BlogController.getCollection(BlogController.java:206)
	at com.wcj.controller.BlogController$$FastClassBySpringCGLIB$$39c39313.invoke(<generated>)
	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:769)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)
	at org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor.invoke(MethodBeforeAdviceInterceptor.java:56)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)
	at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:88)
	at com.wcj.aspect.LogAspect.doAround(LogAspect.java:63)
	at sun.reflect.GeneratedMethodAccessor128.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:644)
	at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:633)
	at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:70)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)
	at org.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:55)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)
	at org.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:62)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)
	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:95)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)
	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:689)
	at com.wcj.controller.BlogController$$EnhancerBySpringCGLIB$$1ae7ca4c.getCollection(<generated>)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:106)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:879)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:112)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.shiro.web.servlet.ProxiedFilterChain.doFilter(ProxiedFilterChain.java:61)
	at org.apache.shiro.web.servlet.AdviceFilter.executeChain(AdviceFilter.java:108)
	at org.apache.shiro.web.servlet.AdviceFilter.doFilterInternal(AdviceFilter.java:137)
	at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:125)
	at org.apache.shiro.web.servlet.ProxiedFilterChain.doFilter(ProxiedFilterChain.java:66)
	at org.apache.shiro.web.servlet.AbstractShiroFilter.executeChain(AbstractShiroFilter.java:449)
	at org.apache.shiro.web.servlet.AbstractShiroFilter$1.call(AbstractShiroFilter.java:365)
	at org.apache.shiro.subject.support.SubjectCallable.doCall(SubjectCallable.java:90)
	at org.apache.shiro.subject.support.SubjectCallable.call(SubjectCallable.java:83)
	at org.apache.shiro.subject.support.DelegatingSubject.execute(DelegatingSubject.java:383)
	at org.apache.shiro.web.servlet.AbstractShiroFilter.doFilterInternal(AbstractShiroFilter.java:362)
	at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:125)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:367)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1639)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.lang.Thread.run(Thread.java:745)
2020-04-17 10:47:01.472 ERROR [http-nio-1000-exec-6]com.wcj.advice.BlogExceptionHandler.exceptionHandler:28 -统一异常处理,
com.wcj.exception.BlogException: 当前帐号未登录!
	at com.wcj.interceptor.LoginInterceptor.preHandle(LoginInterceptor.java:48)
	at org.springframework.web.servlet.HandlerExecutionChain.applyPreHandle(HandlerExecutionChain.java:141)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1035)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:712)
	at org.apache.catalina.core.ApplicationDispatcher.processRequest(ApplicationDispatcher.java:461)
	at org.apache.catalina.core.ApplicationDispatcher.doForward(ApplicationDispatcher.java:384)
	at org.apache.catalina.core.ApplicationDispatcher.forward(ApplicationDispatcher.java:312)
	at org.apache.catalina.core.StandardHostValve.custom(StandardHostValve.java:394)
	at org.apache.catalina.core.StandardHostValve.status(StandardHostValve.java:253)
	at org.apache.catalina.core.StandardHostValve.throwable(StandardHostValve.java:348)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:173)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:367)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1639)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.lang.Thread.run(Thread.java:745)
2020-04-17 10:47:01.747 ERROR [http-nio-1000-exec-2]o.a.c.c.C.[Tomcat].[localhost].[/].[dispatcherServlet].log:175 -Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.NullPointerException] with root cause
java.lang.NullPointerException: null
	at com.wcj.service.impl.BlogServiceImpl.getGoods(BlogServiceImpl.java:243)
	at com.wcj.service.impl.BlogServiceImpl$$FastClassBySpringCGLIB$$428136bb.invoke(<generated>)
	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)
	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:685)
	at com.wcj.service.impl.BlogServiceImpl$$EnhancerBySpringCGLIB$$4fa08134.getGoods(<generated>)
	at com.wcj.controller.BlogController.getGoods(BlogController.java:178)
	at com.wcj.controller.BlogController$$FastClassBySpringCGLIB$$39c39313.invoke(<generated>)
	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:769)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)
	at org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor.invoke(MethodBeforeAdviceInterceptor.java:56)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)
	at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:88)
	at com.wcj.aspect.LogAspect.doAround(LogAspect.java:63)
	at sun.reflect.GeneratedMethodAccessor128.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:644)
	at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:633)
	at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:70)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)
	at org.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:55)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)
	at org.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:62)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)
	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:95)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)
	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:689)
	at com.wcj.controller.BlogController$$EnhancerBySpringCGLIB$$1ae7ca4c.getGoods(<generated>)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:106)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:879)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:112)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.shiro.web.servlet.ProxiedFilterChain.doFilter(ProxiedFilterChain.java:61)
	at org.apache.shiro.web.servlet.AdviceFilter.executeChain(AdviceFilter.java:108)
	at org.apache.shiro.web.servlet.AdviceFilter.doFilterInternal(AdviceFilter.java:137)
	at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:125)
	at org.apache.shiro.web.servlet.ProxiedFilterChain.doFilter(ProxiedFilterChain.java:66)
	at org.apache.shiro.web.servlet.AbstractShiroFilter.executeChain(AbstractShiroFilter.java:449)
	at org.apache.shiro.web.servlet.AbstractShiroFilter$1.call(AbstractShiroFilter.java:365)
	at org.apache.shiro.subject.support.SubjectCallable.doCall(SubjectCallable.java:90)
	at org.apache.shiro.subject.support.SubjectCallable.call(SubjectCallable.java:83)
	at org.apache.shiro.subject.support.DelegatingSubject.execute(DelegatingSubject.java:383)
	at org.apache.shiro.web.servlet.AbstractShiroFilter.doFilterInternal(AbstractShiroFilter.java:362)
	at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:125)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:367)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1639)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.lang.Thread.run(Thread.java:745)
2020-04-17 10:47:01.749 ERROR [http-nio-1000-exec-2]com.wcj.advice.BlogExceptionHandler.exceptionHandler:28 -统一异常处理,
com.wcj.exception.BlogException: 当前帐号未登录!
	at com.wcj.interceptor.LoginInterceptor.preHandle(LoginInterceptor.java:48)
	at org.springframework.web.servlet.HandlerExecutionChain.applyPreHandle(HandlerExecutionChain.java:141)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1035)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:712)
	at org.apache.catalina.core.ApplicationDispatcher.processRequest(ApplicationDispatcher.java:461)
	at org.apache.catalina.core.ApplicationDispatcher.doForward(ApplicationDispatcher.java:384)
	at org.apache.catalina.core.ApplicationDispatcher.forward(ApplicationDispatcher.java:312)
	at org.apache.catalina.core.StandardHostValve.custom(StandardHostValve.java:394)
	at org.apache.catalina.core.StandardHostValve.status(StandardHostValve.java:253)
	at org.apache.catalina.core.StandardHostValve.throwable(StandardHostValve.java:348)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:173)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:367)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1639)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.lang.Thread.run(Thread.java:745)
2020-04-17 10:47:01.839 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 567
2020-04-17 10:47:01.839 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"blogCollection":0,"blogComment":0,"blogContent":"<h2>问题描述：</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; <strong>之前还没有注意到，直到最近两天写博客的时候，发现博客的创建时间信息和实际时间对不上号，总是早了八个小时，一开始以为是项目中没有配置时区的问题，所以看了一下项目的配置，结果发现数据库连接中加入了\"serverTimezone=GMT%2B8\"；所以想到的是不是哪个地方配置了什么，导致servrTimezone的配</strong><strong>置失效了，然后又试了一下网上提供的两种方法，很幸运的都失败了哈哈，之后就考虑到是不是mysql数据库本身的时区问题，然后修改了mysql本身的时区解决了这个问题。在这里总结一下</strong></p>\n<h2><strong>问题的具体情况（以添加一篇博客为例）</strong></h2>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 我这里添加博客的时候，前台传回来的数据中只有博客的内容，标题等信息，并不包括创建时间的信息，而后台进行数据保存逻辑的时候，也并没有往实体中的createdTime字段添加new Date（）信息，而是让数据库的ceated_time字段根据当前时间自动生成时间信息（<span style=\"background-color: #ffcc00;\">因此不是根据数据库自动生成时间信息的小伙伴</span>，</strong><strong><span style=\"background-color: #ffcc00;\">只需要看看常用解决办法即可</span>）</strong></p>\n<h2><strong>常用解决办法</strong></h2>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;一，在数据库连接url中加入serverTimezone=GMT%2B8,如下：</strong></p>\n<pre class=\"language-markup\"><code>url: jdbc:mysql://localhost:3306/blog?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>二，springboot项目中也可以在yml文件中进行如下配置：</strong></p>\n<pre class=\"language-markup\"><code>spring:\n   jackson:\n      time-zone: GMT+8</code></pre>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 三，相对比较麻烦，也是不建议使用的一种方法（要是实体类很多，怕是添加起来会很难受的哦），即在实体类的时间字段上添加注解如下：</strong></p>\n<pre class=\"language-markup\"><code>@JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\",timezone = \"GMT+8\")\n    private String createdTime;</code></pre>\n<h2><strong>我的解决办法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;因为博主试了上面的所有办法，发现都无效，因此就考虑到是不是mysql数据库本身的时区问题，然后一测试，发现果然是这样的。博主的项目是部署在docker上的，因此详细步骤可能不具备参考性，这里挑重点的说：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;首先，命令行进入mysql：mysql&nbsp; -uroot&nbsp; &nbsp;-p&nbsp; 回车，然后输入mysql的密码进入mysql。<span style=\"background-color: #ffcc00;\">注意进入到mysql之后输入命令都要以；结尾或者\\g结尾哦</span></strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;然后：select now();&nbsp; &nbsp;查看mysql的当前时间，到这里和当前的真实时间对比一下就知道是否是mysql本身的时区问题了（下面是该命令显示界面，然后我发现果然是mysql的问题）</strong></p>\n<pre class=\"language-markup\"><code>mysql&gt; select now();\n+---------------------+\n| now()               |\n+---------------------+\n| 2020-04-16 14:24:38 |\n+---------------------+\n</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>之后，在查看mysql的时区变量：show&nbsp; variables like&nbsp; \"%time_zone%\";&nbsp; （这里就发现了问题，mysql这里默认采用的UTC，及世界通用时间，正好这个时间比北京东八区的时间少了八个小时）</strong></p>\n<pre class=\"language-markup\"><code>mysql&gt; show variables like \"%time_zone\";\n+------------------+--------+\n| Variable_name    | Value  |\n+------------------+--------+\n| system_time_zone | UTC    |\n| time_zone        | SYSTEM |\n+------------------+--------+</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>修改mysql的时区</strong></p>\n<pre class=\"language-markup\"><code>mysql&gt; set global time_zone = '+08:00';\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql&gt; set time_zone = '+08:00';\nQuery OK, 0 affected (0.00 sec)</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; <strong>再刷新一下即可：</strong></p>\n<pre class=\"language-markup\"><code>mysql&gt; flush privileges;\nQuery OK, 0 rows affected (0.02 sec)</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>最后，再查看一下当前的时区设置：show&nbsp; varibales like \"%time_zone%\";&nbsp; 发现已经在UTC时间基础上加了8个小时</strong></p>\n<pre class=\"language-markup\"><code>+------------------+--------+\n| Variable_name    | Value  |\n+------------------+--------+\n| system_time_zone | UTC    |\n| time_zone        | +08:00 |\n+------------------+--------+</code></pre>\n<p>&nbsp;</p>\n<h1>水平有限，如果不对，可以探讨交流啦！</h1>","blogGoods":0,"blogId":"1250802898447667200","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6YdI6ARhHKAAMyt4z7zK450.jpeg","blogRead":5,"blogRemark":"项目中的时区问题","blogTitle":"项目中的时区问题","createdTime":"2020-04-16 23:07:05","typeName":"博客开发和维护总结","updateTime":"2020-04-16 23:14:46"},"msg":"操作成功!"}
2020-04-17 10:47:20.467 INFO  [http-nio-1000-exec-3]org.mongodb.driver.connection.info:71 -Closed connection [connectionId{localValue:3, serverValue:288}] to 121.199.34.159:27017 because there was a socket exception raised by this connection.
2020-04-17 10:47:20.467 INFO  [http-nio-1000-exec-7]org.mongodb.driver.connection.info:71 -Closed connection [connectionId{localValue:2, serverValue:287}] to 121.199.34.159:27017 because there was a socket exception raised by this connection.
2020-04-17 10:47:20.594 INFO  [http-nio-1000-exec-7]org.mongodb.driver.connection.info:71 -Opened connection [connectionId{localValue:5, serverValue:289}] to 121.199.34.159:27017
2020-04-17 10:47:20.606 INFO  [http-nio-1000-exec-3]org.mongodb.driver.connection.info:71 -Opened connection [connectionId{localValue:4, serverValue:290}] to 121.199.34.159:27017
2020-04-17 10:47:20.639 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 19365
2020-04-17 10:47:20.640 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[],"msg":"操作成功!"}
2020-04-17 10:47:20.698 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 19424
2020-04-17 10:47:20.699 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[],"msg":"操作成功!"}
2020-04-17 11:23:05.006 INFO  [cluster-ClusterId{value='5e99114899add37bb08e3d67', description='null'}-121.199.34.159:27017]org.mongodb.driver.cluster.info:76 -Exception in monitor thread while connecting to server 121.199.34.159:27017
com.mongodb.MongoSocketOpenException: Exception opening socket
	at com.mongodb.internal.connection.SocketStream.open(SocketStream.java:70)
	at com.mongodb.internal.connection.InternalStreamConnection.open(InternalStreamConnection.java:128)
	at com.mongodb.internal.connection.DefaultServerMonitor$ServerMonitorRunnable.run(DefaultServerMonitor.java:131)
	at java.lang.Thread.run(Thread.java:745)
Caused by: java.net.NoRouteToHostException: No route to host: connect
	at java.net.DualStackPlainSocketImpl.waitForConnect(Native Method)
	at java.net.DualStackPlainSocketImpl.socketConnect(DualStackPlainSocketImpl.java:85)
	at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)
	at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)
	at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)
	at java.net.PlainSocketImpl.connect(PlainSocketImpl.java:172)
	at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)
	at java.net.Socket.connect(Socket.java:589)
	at com.mongodb.internal.connection.SocketStreamHelper.initialize(SocketStreamHelper.java:64)
	at com.mongodb.internal.connection.SocketStream.initializeSocket(SocketStream.java:79)
	at com.mongodb.internal.connection.SocketStream.open(SocketStream.java:65)
	... 3 common frames omitted
2020-04-17 12:19:08.931 INFO  [cluster-ClusterId{value='5e99114899add37bb08e3d67', description='null'}-121.199.34.159:27017]org.mongodb.driver.connection.info:71 -Opened connection [connectionId{localValue:342, serverValue:291}] to 121.199.34.159:27017
2020-04-17 12:19:08.973 INFO  [cluster-ClusterId{value='5e99114899add37bb08e3d67', description='null'}-121.199.34.159:27017]org.mongodb.driver.cluster.info:71 -Monitor thread successfully connected to server with description ServerDescription{address=121.199.34.159:27017, type=STANDALONE, state=CONNECTED, ok=true, version=ServerVersion{versionList=[4, 2, 5]}, minWireVersion=0, maxWireVersion=8, maxDocumentSize=16777216, logicalSessionTimeoutMinutes=30, roundTripTimeNanos=41669200}
2020-04-17 13:51:58.768 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /rotation-picture/listFront
2020-04-17 13:51:58.774 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-17 13:51:58.775 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-17 13:51:58.775 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.RotationPictureController.getRotationPictureListFront
2020-04-17 13:51:58.775 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-17 13:51:58.776 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/list
2020-04-17 13:51:58.777 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-17 13:51:58.777 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-17 13:51:58.777 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogList
2020-04-17 13:51:58.778 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=15, totalPage=0, totalCount=0, list=[], params={}, sortColumn=created_time, sortMethod=DESC)]
2020-04-17 13:51:59.426 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 658
2020-04-17 13:51:59.429 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"createdTime":"2020-04-09 13:31:10","enable":1,"rotationId":3,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PI5KAYzGaAAGfH751PIw644.jpg"},{"createdTime":"2020-04-09 13:31:20","enable":1,"rotationId":4,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PI6aAZIz1AASCO4hlpJI295.jpg"},{"createdTime":"2020-04-09 13:37:02","enable":1,"rotationId":9,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJPyAbm8fAAG9gfO8lxE28.jpeg"},{"createdTime":"2020-04-09 13:41:30","enable":1,"rotationId":10,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJgeAeG8wAAS2pjJC5QU547.jpg"},{"createdTime":"2020-04-09 13:41:38","enable":1,"rotationId":11,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhGAQFZbAAP2OOBWb6k310.jpg"},{"createdTime":"2020-04-09 13:41:50","enable":1,"rotationId":12,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhyABMZCAAG7doyXiM8109.jpg"},{"createdTime":"2020-04-09 13:41:59","enable":1,"rotationId":13,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJiWAL7BoAARW3_O3ISw651.jpg"}],"msg":"操作成功!"}
2020-04-17 13:52:00.042 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 1266
2020-04-17 13:52:00.045 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogContent":"<h2>问题描述：</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; <strong>之前还没有注意到，直到最近两天写博客的时候，发现博客的创建时间信息和实际时间对不上号，总是早了八个小时，一开始以为是项目中没有配置时区的问题，所以看了一下项目的配置，结果发现数据库连接中加入了\"serverTimezone=GMT%2B8\"；所以想到的是不是哪个地方配置了什么，导致servrTimezone的配</strong><strong>置失效了，然后又试了一下网上提供的两种方法，很幸运的都失败了哈哈，之后就考虑到是不是mysql数据库本身的时区问题，然后修改了mysql本身的时区解决了这个问题。在这里总结一下</strong></p>\n<h2><strong>问题的具体情况（以添加一篇博客为例）</strong></h2>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 我这里添加博客的时候，前台传回来的数据中只有博客的内容，标题等信息，并不包括创建时间的信息，而后台进行数据保存逻辑的时候，也并没有往实体中的createdTime字段添加new Date（）信息，而是让数据库的ceated_time字段根据当前时间自动生成时间信息（<span style=\"background-color: #ffcc00;\">因此不是根据数据库自动生成时间信息的小伙伴</span>，</strong><strong><span style=\"background-color: #ffcc00;\">只需要看看常用解决办法即可</span>）</strong></p>\n<h2><strong>常用解决办法</strong></h2>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;一，在数据库连接url中加入serverTimezone=GMT%2B8,如下：</strong></p>\n<pre class=\"language-markup\"><code>url: jdbc:mysql://localhost:3306/blog?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>二，springboot项目中也可以在yml文件中进行如下配置：</strong></p>\n<pre class=\"language-markup\"><code>spring:\n   jackson:\n      time-zone: GMT+8</code></pre>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 三，相对比较麻烦，也是不建议使用的一种方法（要是实体类很多，怕是添加起来会很难受的哦），即在实体类的时间字段上添加注解如下：</strong></p>\n<pre class=\"language-markup\"><code>@JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\",timezone = \"GMT+8\")\n    private String createdTime;</code></pre>\n<h2><strong>我的解决办法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;因为博主试了上面的所有办法，发现都无效，因此就考虑到是不是mysql数据库本身的时区问题，然后一测试，发现果然是这样的。博主的项目是部署在docker上的，因此详细步骤可能不具备参考性，这里挑重点的说：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;首先，命令行进入mysql：mysql&nbsp; -uroot&nbsp; &nbsp;-p&nbsp; 回车，然后输入mysql的密码进入mysql。<span style=\"background-color: #ffcc00;\">注意进入到mysql之后输入命令都要以；结尾或者\\g结尾哦</span></strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;然后：select now();&nbsp; &nbsp;查看mysql的当前时间，到这里和当前的真实时间对比一下就知道是否是mysql本身的时区问题了（下面是该命令显示界面，然后我发现果然是mysql的问题）</strong></p>\n<pre class=\"language-markup\"><code>mysql&gt; select now();\n+---------------------+\n| now()               |\n+---------------------+\n| 2020-04-16 14:24:38 |\n+---------------------+\n</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>之后，在查看mysql的时区变量：show&nbsp; variables like&nbsp; \"%time_zone%\";&nbsp; （这里就发现了问题，mysql这里默认采用的UTC，及世界通用时间，正好这个时间比北京东八区的时间少了八个小时）</strong></p>\n<pre class=\"language-markup\"><code>mysql&gt; show variables like \"%time_zone\";\n+------------------+--------+\n| Variable_name    | Value  |\n+------------------+--------+\n| system_time_zone | UTC    |\n| time_zone        | SYSTEM |\n+------------------+--------+</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>修改mysql的时区</strong></p>\n<pre class=\"language-markup\"><code>mysql&gt; set global time_zone = '+08:00';\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql&gt; set time_zone = '+08:00';\nQuery OK, 0 affected (0.00 sec)</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; <strong>再刷新一下即可：</strong></p>\n<pre class=\"language-markup\"><code>mysql&gt; flush privileges;\nQuery OK, 0 rows affected (0.02 sec)</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>最后，再查看一下当前的时区设置：show&nbsp; varibales like \"%time_zone%\";&nbsp; 发现已经在UTC时间基础上加了8个小时</strong></p>\n<pre class=\"language-markup\"><code>+------------------+--------+\n| Variable_name    | Value  |\n+------------------+--------+\n| system_time_zone | UTC    |\n| time_zone        | +08:00 |\n+------------------+--------+</code></pre>\n<p>&nbsp;</p>\n<h1>水平有限，如果不对，可以探讨交流啦！</h1>","blogGoods":0,"blogId":"1250802898447667200","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6YdI6ARhHKAAMyt4z7zK450.jpeg","blogRead":5,"blogRemark":"项目中的时区问题","blogTitle":"项目中的时区问题","createdTime":"2020-04-16 23:07:05","typeName":"博客开发和维护总结","updateTime":"2020-04-17 10:47:02"},{"blogCollection":0,"blogComment":1,"blogContent":"<h2><strong>一，分布式缓存</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;进程内缓存：对于用户信息，热点数据等信息，访问比较频繁，我们将其存放进入缓存，用户查询数据的时候直接从内存种读取，而不需要从数据库查询，既降低了数据库的负载，同时又提升了查询效率。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;分布式缓存：对于单点web应用，我们使用进程内缓存就足够了，但是对于分布式系统，数据库是部署在多个服务器上分布式数据库，缓存则是部署在多个服务器上的分布式缓存，并且缓存数据存在备份，当一个缓存服务挂掉之后，可以立即启用备份的缓存进行工作（高可用）。</strong></p>\n<h2><strong>二， redis的基本数据类型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;String，hash，List，Set，Zset</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;基本数据类型的基本命令见redis篇：<a href=\"http://localhost:1002/info/1249588251598041088\">http://localhost:1002/info/1249588251598041088</a></strong></p>\n<h2><strong>三，redis管道</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;客户端发出一个redis命令请求之后，会监控socket，客户端处于阻塞状态，直到服务器端返回结果，客户端才可以继续发出下一个请求。且在分布式系统中，redis是部署在不同的服务器上，这样服务器之间的数据传输还会有一定的延迟，redis的性能瓶颈就是在网络延迟上 。redis管道机制，即客户端发出一个请求之</strong><strong>后，可以不等服务器端返回结果就发送下一个请求，然后批量的接收服务器端返回的结果。这样客户端批量发出请求，服务器端接</strong><strong>收到批量请</strong><strong>求之后，进行处理返回批量数据。这样提高了redis的性能。</strong></p>\n<h2><strong>四，redis事务</strong></h2>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>基本命令（multi开启事务，exec执行事务，discard取消事务，watch监听某个key的变化，unwatch取消监听所有key的变化）</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;事务基本流程：客户端执行multi命令开启事务</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;客户端提交命令到事务</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;redis将客户端请求放入事务队列等待</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;服务器返回QURUD，表明命令已经进入事务</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;客户端通过exec执行事务</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;执行事务的过程中，如果有某个命令错误，则其它命令继续执行，不会回滚。</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;服务器端向客户端返回事务的执行结果</strong></p>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong></p>\n<h2><strong>五， redis的发布，订阅</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;发布者向频道发布消息，订阅者从频道获取消息（<span style=\"background-color: #ffcc00;\">有待补充</span>）</strong></p>\n<h2><strong>六，redis集群数据复制原理</strong></h2>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;从数据库（slave）发出数据同步请求SYNC给主数据库（master）</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;主数据库接收到从数据库的请求，进行快照，并将快照期间的命令缓存起来，生成.rdb文件</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;主数据库将.rdb文件发送给从数据库</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;从数据库接收到.rdb文件，载入文件进入本地</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;从数据库执行快照，将数据写入内存，即初始化</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;从数据库初始化完成后，主数据接收到写请求之后，会将写请求发送给从数据库，实现数据的一致性</strong></p>\n<h2><strong>七，</strong><strong>redis持久化</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;redis持久化有rdb和aof两种，rdb即采用快照的方式，每隔一定的时间，进行依次数据的快照，对于大数据集的数据处理较快，但是对于数据的完整性要求较低。aof方式是采用日志的形式，将写操作的命令都存于aof文件中，启动服务的时候直接将aof中的命令按顺序执行用以构建原始数据集，但是速度较慢，</strong><strong>且aof文件的大小要比rdb文件大。如果两种方式都开启，则启动服务的时候默认采用aof的方式进行数据恢复。</strong></p>\n<h2><strong>八， redis的集群模式及工作原理</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;主从模式：中心化，所有的写请求都发送到主数据库，读操作分发给从数据库，分担主句库的压力。但是缺陷很明显，如果主数据库宕机，则从数据库必须要阻塞等待，或者手动切换从数据库为主数据库？</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;哨兵模式：即主数据库宕机，自动选举从数据库。设置一个哨兵监视集群的运行状态，如果主数据库宕机，哨兵会依据投票机制从数据库中选举出一个主数据替换宕机的主数据库。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;集群模式：redis集群实现了redis的数据分片和数据复制能力。数据分片能够让我们对redis进行横向扩展，提升集群的吞吐量。数据复制能力，在一些节点挂掉之后，集群仍然能够对外提供服务。</strong></p>\n<h2><strong>九，redis整合springboot见redis篇</strong></h2>\n<h2><strong>十，分布式缓存设计的核心问题</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;缓存预热：用户请求数据前先将数据保存到缓存中。通常的方法是系统启动加载，定时加载</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;缓存更新：即当数据发生变化的时候，对缓存中的数据进行更改</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;缓存淘汰策略：FIFO（先进先出，即先淘汰时间长远的缓存），LRU（最近最少使用，即判断缓存最近被使用的时间，淘汰离被使用时间最远时间的缓存），LFU（最不经常使用，即在一段时间内，被使用次数最少的缓存淘汰）</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;缓存雪崩：即缓存中同一时间有大量的数据失效，导致用户请求直接访问数据库，增大数据库的负荷，导致数据库宕机甚至整个系统的崩溃。</strong><strong>&nbsp;设置随机的失效时间，缓存更新，请求加锁</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;缓存穿透：即请求一条缓存中没有的数据，则会直接访问数据库，如果同一时间大量不存在的key访问缓存，就会都去访问数据库，导致数据库宕机。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;布隆过滤器：即用户请求访问缓存之前先经过布隆过滤器，如果发现数据库和缓存中都不存在该数据，则拒绝该请求。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;cache&nbsp; null：即如果访问的数据请求返回为null，则对null值也进行缓存，只不过需要给它设置一个短暂的失效时间这样在接收到相同的请求的时候，从缓存中读取返回null，不会访问数据库</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;缓存降级：当读操作增加的时候，我们先从缓存中读取，等到数据库恢复正常再从数据库读取</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;当写操作增加的时候，我们先从写入缓存，然后再异步的写入数据库。</strong></p>\n<p>&nbsp;</p>\n<h1><strong>水平有限，如有错误，还望指出！</strong></h1>","blogGoods":0,"blogId":"1250774653945802752","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6YWj2AQzPpAABXKIA7NHQ430.jpg","blogRead":5,"blogRemark":"面试（八）------之分布式缓存的原理及应用","blogTitle":"面试（八）------之分布式缓存的原理及应用","createdTime":"2020-04-16 13:14:51","typeName":"java面试篇","updateTime":"2020-04-16 23:08:07"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，存储引擎</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;MyIASM：MySQL默认的存储引擎，不支持事务，行级锁和外键。因此插入和更新操作需要锁定整个表，效率较低。二查询操作是直接查询文件的OFFSET，因而效率较快，高于InnoDB（InnoDB寻址要先映射到块，再映射到行）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;InnoDB：为MySQL提供了事务支持，回滚，崩溃修复能力，多版本并发控制，事务安全。InnoDB的底层数据结构采用的是B+树（即非叶子节点仅存储索引信息，不存储数据，数据都被存放再叶子节点上，所有的叶子节点构成一个顺序链表）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;TokuDB：底层数据结构为Fractal Tree，和InnoDB的B+树很像，但是Fractal Tree除了每个指针都指向孩子节点，孩子节点还带有一个message&nbsp; Buffer（用来缓存更新操作的），每次的插入操作只需要到message Buffer就可以返回了，不需要走到叶子节点。（写入速度很快）<br /></strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;Memory：Memory因为其数据都是存放再内存中，所以读的速度很快，通常使用hash索引来做数据索引。缺点是一旦服务关闭，数据就会丢失。</strong></p>\n<h2><strong>二，创建索引的原则</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;选择唯一性索引：因为唯一性索引使用hash算法实现，能够快速的定位到一条数据</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;为经常需要分组，联合，排序，作为查询条件的列设置索引</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;限制索引的数量：因为索引越多，更新表的数据越慢</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;尽量使用数据量少的索引：因为索引值过长，占用的磁盘空间九会很多，查询速度会受影响</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;尽量使用前缀来索引：如果索引的字段很长，则不但会影响索引的大小，还会降低索引的执行效率</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;删除不经常使用的索引</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;选择区分度高的列作为索引：数据重复少</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;索引列不能参与计算：带函数的查询不建议参与索引</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;尽量扩展现有索引：联合索引的查询效率要远高于多个独立索引</strong></p>\n<h2><strong>三，数据库三范式</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;一范式：即该列的数据是不可再拆分的最小的数据单元。例如：address列：中国北京，美国纽约。这种就违背了第一范式，因为address可以拆分为国家country和城市city</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;二范式：基于一范式，非主键列不能存在对主键列的部分依赖。即每张表都单独描述一个事务。例如：一张表中既有订单表编号，订单数，产品编号，产品数，则就不符合第二范式，应该将其拆分为两个表，订单表和产品表</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;三范式：基于一范式和二范式，非主键列不能存在对其它非主键列的传递依赖。例如：除了订单编号，顾客还依赖于表中的顾客编号，这时候就应该删除顾客编号。</strong></p>\n<h2><strong>四，数据库事务</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：数据库事务即一系列的基本操作，这些基本操作要么全部执行，要不都不执行，是一个完整的逻辑单元。数据库事务具备ACID特性：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;A（原子性）：即数据库事务是一个完整逻辑单元，其中的基本操作要么全部执行，要么全部不执行</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;C（一致性）：即事务执行完毕后（无论是正常执行完毕还是异常退出），数据都要保持一致的状态。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;I（隔离性）：即更新数据的事务都是并发执行的，不存在任意一个事务以任意的方法影响其它事务</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;D（永久性）：即事务执行完毕后，更新的数据要持久化到永久性存储中</strong></p>\n<h2><strong>五，存储过程</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：存储过程指的就是一组用于完成特定功能的SQL语句集</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;优化思路：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;尽量利用SQL语句代替一些小循环，例如聚合函数，平均函数等。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;中间结果存放于临时表中，并加索引</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;少使用游标：因为SQL是集合语言，对集合运算有较高的性能，但是游标是过程运算</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;事务越短越好：SQL&nbsp; Server支持并发操作，如果事务过长或者隔离级别过高，会造成并发操作的阻塞，死锁，导致查询慢 。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;使用try-catch处理异常</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;尽量不要将查询语句放入到循环中，避免过度消耗系统资源</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>触发器：是一种自动执行的程序，一般是当数据发生变化后执行一系列的操作</strong></p>\n<h2><strong>六，数据库并发策略（前面的总结中有总结过，这里不作详细展开，具体参照并发编程篇）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;乐观锁</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;悲观锁</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;时间戳（类似版本号机制）</strong></p>\n<h2><strong>七，数据库锁</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;行级锁：锁住数据库中的一行数据，不允许其它事务进行修改。例如增删改查等操作都使用了行级锁</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;表级锁：给整张表加锁，分为共享读锁和独占写锁。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;页级锁：行级锁冲突少，加锁慢；表级锁冲突多，加锁快，页级锁介于两者之间</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;基于Redis的分布式锁：利用redis的setnx命令，如果不存在一个key则插入，返回1；如果已存在一个key，则不做任何操作，返回0。获取锁：即使用此命令，如果返回0表示锁正在被使用，获取失败，如果返回1则获取到锁</strong></p>\n<h2><strong>八，数据库分表</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;垂直分表：即根据功能模块的不同，表的关联程度将表分于不同的库中</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;水平分表：即当一个表中的数据量较大时，按照表的某种规则，将不同数据分到相同表的不同库中</strong></p>\n<h2>九，CAP</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>概述：即一个分布式系统中的一致性（C），可用性（A），分区容错性（P）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;一致性：即同一时间不同数据备份，数据是否保持一致</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;可用性：即当集群的某些节点故障，集群是否可以正常的提供服务（高可用性）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;分区容错性：即当某些时刻数据无法保持一致性，即分区了，这个时候我们就需要在C和A之间进行权衡</strong></p>\n<h2><strong>十，两阶段提交协议和三阶段提交协议</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;两阶段提交协议（准备阶段prepare，提交阶段commit）：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 准备阶段：即协调者给每一个参与者发送一个prepare消息，参与者接收到之后要么返回false，要么立即执行本地事务进行日志的redo和undo但不进行提交</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 提交阶段：即协调者根据参与者反馈的消息，如果参与者反馈失败或者超时，则给每个参与者发送消息中止提交或者进行回滚操作。否则，进行提交操作</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 缺点：第一，参与者的任务都是阻塞进行的；第二，比较中心化，如果协调者出现故障，则参与者进入阻塞状态；第三，数据不一致，即如果协调者在给每个参与者发送commit过程中突然出现故障，导致部分参与者没有接收到commit，则将会导致数据不一致的情况；第四，如果协调者进行发送commit时出现</strong><strong>故障，而唯一接收commit的参与者也出现故障，则将会出现事务状态未知的情况。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;三阶段提交协议（在二阶段提交协议基础上进行完善）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;增加了超时机制：即如果协调者长时间未接受到参与者的反馈，则认为参与者执行失败</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;在准备和提交阶段之前都加了预准备阶段，保证参与者状态的一致。（canCommit，preCommit，doCommit）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;canCommit：即协调者发送commit消息给所有的参与者，参与者如果可以执行就返回yes，不能返回no</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; preCommit：即协调者根据参与者的反馈，如果所有的参与者都可以进行正常提交，则预执行事务；如果有参与者反馈no或者反馈超时，就执行事务的中断。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;doCommit：提交事务</strong></p>\n<h2><strong>十一，分布式事务</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;传统事务：即遵循ACID特性</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;柔性事务：阿里巴巴提出的，基于CAD和BASE。BASE理论是CAD理论的延伸，包括基本可用，柔韧状态，最终一致性</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;两阶段提交型：指的就是分布式事务的两阶段提交</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;补偿性：例如事务A开启事务，事务B参与事务，如果事务A和事务B都能够正常执行事务，则事务执行完毕。如果事务出现故障，则事务B回滚，但是这时候事务A已经提交，所以需要有一种补偿机制，让事务A反操作回到执行事务A之前的状态。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;异步确保型（没怎么读懂，因为还没学到分布式的太多东西，后面补充）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;最大努力通知型（没怎么读懂，后面补充）</strong></p>\n<p>&nbsp;</p>\n<h1><strong>水平有限，如果错误还望指出！</strong></h1>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1250704122190073856","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6YGImARpJnAADh1C7LBxU514.jpg","blogRead":0,"blogRemark":"面试（七）-----数据库及分布式事务","blogTitle":"面试（七）-----数据库及分布式事务","createdTime":"2020-04-16 08:34:35","typeName":"java面试篇","updateTime":"2020-04-16 08:35:14"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，OSI七层网络模型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;物理层：主要用于定义物理设备的标准，发送比特流</strong><strong style=\"font-size: 14px;\">数据链路层：主要用于对数据包中的MAC地址进行解析和封装。这一层的数据单位叫做帧</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;网络层：主要用于对数据包中的ip地址进行解析和封装，这一层的数据单位叫做数据包。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;传输层：定义传输的协议和端口，进行的数据的分段，重组和传输。TCP传输控制协议，适用于对可靠性要求高，数据量大的传输。UDP适用于对可靠性要求不高，数据量不大的传输。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;会话层：用于再传输层的基础上建立连接和管理会话。比如登录，断点续传，数据粘包和分包。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;表示层：用于对接收到的数据进行解析，将计算机识别的信息转换成人也能够识别的信息。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;应用层：构建具体应用</strong></p>\n<h2><strong>二，TCP/IP四层网络模型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：TCP/IP并不是指tcp和ip协议，而是指因特网中的TCP/IP协议簇，分为四层网络模型：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;网络接口层：用来定义主机间的连通协议</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;网络层：用于数据的传输，路由及地址的解析，确保数据能够发送到任何网络的目标上。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;传输层：使源端和目的端的相同实体能够进行通信</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;应用层：负责具体应用协议的定义</strong></p>\n<h2><strong>三，TCP三次握手/四次挥手</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：客户端和服务器之间建立连接之前需要进行三次沟通，称为&ldquo;三次握手&rdquo;；客户端和服务器之间断开连接之前，会进行四次沟通，称为&ldquo;四次挥手&rdquo;。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;三次握手：客户端发送连接请求的标识位SYN给服务器端，进入SYN-SEND状态，请求建立连接；服务器端接收到请求之后，返回一个SYN+ACK报文，进入SYN-RECV状态；客户端接收到请求之后，回应一个ACK报文，至此，三次握手完毕，客户端与服务器端之间的TCP连接已建立，可以进行数据传输。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;四次挥手：客户端和服务器端断开连接要进行四次挥手是因为TCP的关闭是半关闭造成的，即TCP连接是全双工的（即数据可以在两个方向上同时进行交换），因此想要关闭连接，就必须每个方向进行单独关闭。（客户端主动断开连接和服务器端主动断开连接），这里以客户端主动断开连接为例：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;客户端数据传输完毕之后，发送一个释放连接的标识位FIN=1给服务器端，请求断开客户端到服务器端之间的连接操作，进入FIN-WAIT-1状态；</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;服务器端接收到请求之后，返回一个ACK报文给客户端，表</strong><strong>示已经接收到其断开连接的请求，然后释放客户端到服务器端的连接，服务器端进入CLOSE-WAIT状态，客户端接收到请求后进入FIN-WAIT-2状态；</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;服务器端在将待传输到客户端的数据传输完毕之前，发出一个中断连接的标识位FIN=1给客户端，请求客户端中端服务器端到客户端的连接操作，进入进入LAST-ACK状态，等待客户端的最终确认；</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;客户端接收到服务器端的断开连接请求之后，回应一个ACK，表示接收到断开连接请求，随后等待计时器设置的时间后，断开连接。</strong></p>\n<h2><strong>四，HTTP协议</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;概述：http协议是一种无状态的协议，即客户端和服务器端不需要建立持久的连接，客户端发出请求后，服务器端接收到请求，处理数据返回应答之后，连接关闭。http协议遵循请求（Request）和应答（Response）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;传输流程：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 地址解析：通过域名系统DNS获取请求地址的协议，主机名，端口号，对象路径</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 封装HTTP数据包：根据解析出来的请求协议，主机名，端口号，对象路径和本机信息封装出HTTP数据包</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 封装TCP数据包：将HTTP数据包进一步封装成TCP数据包</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;建立TCP连接：利用三次握手协议建立客户端和服务器端的TCP连接</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 客户端发送请求：客户端发送一个请求给服务器端</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 服务器端响应：服务器端接收到客户端发送的请求之后，进行数据处理，返回响应</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;服务器关闭TCP连接：服务器返回应答之后，关闭TCP连接。如果在服务器返回的应答中加上connection：keep-alive，则返回应答后不会关闭TCP连接，下一次浏览器发送请求的时候仍然可以使用该连接（减少了响应时间和带宽资源的消耗）。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;HTTP中常见的状态码：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;20x表示成功，30x表示重定向，40x表示客户端错误，50x表示服务器错误</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;100（继续），101（切换协议），200（成功），201（created创建），202（accepted创建），203（未授权），204（无内容），205（重置内容），206（部分内容）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;300（多种选择），301（永久移动），302（临时移动），303（查看其它位置），304（未修改），305（使用代理），306（未使用），307（临时重定向），308（永久重定向）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;400（客户端请求错误），401（未授权），402（待付款），403（禁止访问），404（未发现），405（不允许使用该方法），406（无法接受），407（需要使用代理身份），408（请求超时），409（冲突），410（已失效），413（请求实体过长），414（请求地址过长），415（媒体类型不支持）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;500（内部服务器错误），501（未实现），502（网关错误），503（服务不可用），504（网关超时），505(Http版本不支持)</strong></p>\n<h2>五，HTTPS</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>概述：HTTPS是在http的基础上增加了SSL协议以保证传输数据的安全性，因为HTTP传输数据使用的明文传输，不安全。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;HTTPS加密流程：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 客户端和服务器端建立TCP连接之后，发送一个请求证书的请求</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 服务器端接收到请求之后，返回应答并且返回证书信息</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 客户端接收到证书之后，进行确认，如果确认正确，则生成密钥</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 客户端将密钥发送给服务器端，服务器端接收到之后利用私钥进行解密</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 经过上面的步骤，客户端和服务器端之间的数传传输就可以进行加密传输了</strong></p>\n<h2><strong>六，CDN原理（待补充）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：CDN即基于分布在不同的地方的机房服务器，通过中心平台的负载均衡，内容分发和任务调度让用户就近获取所需要的内容，降低网络延时，提升用户体验。</strong></p>\n<h2><strong>七，七层负载均衡和四层负载均衡</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;四层负载均衡：即利用ip和端口号，根据负载均衡的配置和分发策略将请求分发给真实服务器</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;七层负载均衡：利用请求的URL或者主机名接受所有用户的请求，然后将其分发给真实服务器</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;区别：四层负载均衡只能根据ip和端口号进行请求的分发，但是七层负载均衡根据URL可以根据具体的请求信息进行分发，例如一个ip下面有多个具体的请求，/user,/business等。四层负载均衡将该ip或者端口号下的所有请求都分配给一台服务器进行处理，但是七层负载均衡可以根据不同的路径信息，将/user分配给一台真实</strong><strong>服务器，将/business分配给一台真实服务器。（Nginx既支持四层负载均衡，又支持七层负载均衡）</strong></p>\n<h2><strong>八，负载均衡算法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;轮询均衡：将请求均等的分发到1-n台服务器上，用于各台服务器之间的软硬件设备没有差距的情况下。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;权重轮询均衡：即根据权重的不同，将不同数量的请求轮询分发到不同的服务器上</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;随即均衡：即将请求随机分发到服务器上</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;权重随即均衡：即根据权重的不同，将请求随机分发到服务器上</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;响应速度均衡：即根据服务器的响应速度，将请求分发到请求速度最快的服务器上</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;最少连接数均衡：即在服务器内部维护一个记录服务器处理连接数量的计数器，将请求分发到连接数最少的服务器上。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;处理能力均衡：将请求分发给内部负荷最轻的服务器</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;DNS响应均衡：不同中心机房的均衡设备接收到域名解析请求时，都进行域名解析，然后返回给客户端，客户端连接第一个返回应答的服务器，忽略其它的均衡设备。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;散列算法均衡：即通过一次性散列算法将相同参数的请求分发到一台服务器上，长期稳定的为客户端进行服务</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;IP地址散列均衡：将来自同一客户端的请求分发到同一台服务器</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;URL散列：将相同URL的请求分发到同一台服务器</strong></p>\n<h2><strong>九，Nginx的反向代理和负载均衡</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;正向代理：即客户端找代理服务器取寻找真实服务器，真实服务器并不知道客户端的ip和端口，因此可以隐藏客户端真实ip和端口</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;反向代理：即服务器找代理服务器去跟客户端打交道，在客户端眼中，代理服务器就是服务器，它并不知道真实服务器是谁</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;负载均衡：即通过Nginx，根据负载均衡的配置和分发策略将不同的请求交给不同的服务器进行处理。</strong></p>\n<p>&nbsp;</p>\n<h1><strong>水平有限，如有错误，还望指出！</strong></h1>","blogGoods":0,"blogId":"1250622112591376384","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6XzDGALH67AABkNXEA3-0043.jpg","blogRead":2,"blogRemark":"面试（六）------之网络与负载均衡","blogTitle":"面试（六）------之网络与负载均衡","createdTime":"2020-04-16 03:08:42","typeName":"java面试篇","updateTime":"2020-04-16 03:09:55"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，二分查找算法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：二分查找算法又称为折半查找算法，待查找的序列必须已经是有序的，每次取序列的中间值与查找值进行比较，若相等则返回；若中间值小于查找值，则在中间值右侧序列中进行查找；若中间值大于查找值，则在中间值左侧序列中进行查找。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现如下：</strong></p>\n<pre class=\"language-java\"><code>public static int binarySearch(int[] arr,int low,int high,int key){\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(arr[mid]==key){\n                return mid;\n            }else if(arr[mid]&lt;key){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        return -1;\n    }</code></pre>\n<h2><strong>二，冒泡排序（这里以升序为例）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：冒泡排序即对于一个无序序列，从第一个元素开始，依次比较相邻的元素，如果前一个元素大于后一个元素，则交换位置，这样一趟比较下来，就确定出最大值。直到整个序列有序为止</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现如下：</strong></p>\n<pre class=\"language-java\"><code>public static void bubbleSort(int[] arr){\n        for (int i = arr.length-1; i &gt;=0 ; i--) {\n            for (int j = 0; j &lt; i; j++) {\n                if(arr[j]&gt;arr[j+1]){\n                    swap(arr,j,j+1);\n                }\n            }\n        }\n    }\n    /**\n     * 交换元素\n     * @param arr\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] arr,int i,int j){\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }</code></pre>\n<h2>三，插入排序（升序为例）</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>概述：即默认无序序列中的第一个元素有序，随后每次排列有序序列后的一个元素，将其排列进入前面的有序序列，同时保证有序序列的有序性即可。（类似于我们打扑克牌时，每拿一张从后往前比较大小，放入正确的位置）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现如下：</strong></p>\n<pre class=\"language-java\"><code>public static void insertSort(int[] arr){\n        for (int i = 1; i &lt; arr.length; i++) {\n            for (int j = i; j &gt;=0; j--) {\n                if(arr[j]&lt;arr[j-1]){\n                    swap(arr,i,j);\n                }\n            }\n        }\n    }\n\n    /**\n     * 交换元素\n     * @param arr\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] arr,int i,int j){\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }</code></pre>\n<h2>四，快速排序（升序为例）</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>概述：在一个无序序列中，取一个基准值，通常取第一个元素为基准值。然后从最右边依次查找，找到第一个比基准值小的元素，与其交换位置；再从最左边查找，查找到第一个比基准值大的元素，与其交换位置。直到从左往右查找的索引等于从右往左查找的索引，结束一次循环，重复以上过程分别比较左右两标的序列，直到整个</strong></p>\n<p><strong>有序为止。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;JAVA代码实现如下：</strong></p>\n<pre class=\"language-java\"><code>public static void quickSort(int[] arr,int low,int high){\n        int base = arr[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //先从右往左查找第一个比基准值小的元素\n            while(R&gt;L&amp;&amp;arr[R]&gt;=base){\n                R--;\n            }\n            if(arr[R]&lt;base){\n             swap(arr,L,R);\n            }\n            //再从左往右查找第一个比基准值大的元素\n            while(R&gt;L&amp;&amp;arr[L]&lt;=base){\n                L++;\n            }\n            if(arr[L]&gt;base){\n                swap(arr,L,R);\n            }\n        }\n        //递归左右序列\n        if(L&gt;low) {\n            quickSort(arr,low,L-1);\n        }\n        if(R&lt;high) {\n            quickSort(arr,R+1,high);\n        }\n    }\n\n    /**\n     * 交换元素\n     * @param arr\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] arr,int i,int j){\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }</code></pre>\n<h2>五，希尔排序（升序为例，以初始dk为length/3+1）</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>概述：希尔排序又称增量排序，是优化的插入排序，即有一个增量dk，根据增量dk将无序序列分为若干个子序列，分别对子序列进行插入排序，每进行完一趟排序，更改增量，直到增量dk为1时，则对整个序列再进行依次插入排序。希尔排序，当增量dk大的时候，因为序列数据较少，排序较快；而当增量dk小的时候，又因为序列</strong></p>\n<p><strong>中的数据已经基本有序了，因而排序也较快。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;JAVA代码实现：为例</strong></p>\n<pre class=\"language-java\"><code>public static void sort(int[] arr){\n\n        int dk = arr.length/3+1;\n        while(dk!=1){\n            shellSort(arr,dk);\n            dk = dk/3+1;\n        }\n        if(dk==1){\n            shellSort(arr,dk);\n        }\n    }\n\n    public static void shellSort(int[] arr,int dk){\n        for (int i = dk; i &lt;arr.length ; i++) {\n            if(arr[i]&lt;arr[i-dk]){\n                swap(arr,i,i-dk);\n            }\n        }\n    }\n\n    /**\n     * 交换元素\n     * @param arr\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] arr,int i,int j){\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }</code></pre>\n<h2><strong>六，归并排序</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：归并排序采用的是典型的分治思想，即先分解，然后再归并。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n     * 先分\n     * @param arr\n     */\n    public static void sortProcess(int[] arr,int L,int R){\n        if(L==R){\n            return;\n        }\n        int mid = (L+R)/2;\n        sortProcess(arr,L,mid);\n        sortProcess(arr,mid+1,R);\n        merge(arr,L,mid,R);\n    }\n\n    /**\n     * 分治中的治\n     * @param arr\n     * @param L\n     * @param mid\n     * @param R\n     */\n    public static void merge(int[] arr,int L,int mid,int R){\n        int[] help = new int[R-L+1];\n        int p1 = L;\n        int p2 = mid+1;\n        int i =0;\n        while(p1&lt;=mid&amp;&amp;p2&lt;=R){\n            help[i++] = arr[p1]&gt;arr[p2]?arr[p2++]:arr[p1++];\n        }\n        while(p1&lt;=mid){\n            help[i++] = arr[p1++];\n        }\n        while(p2&lt;=R){\n            help[i++] = arr[p2++];\n        }\n        //将数组help复制回原数组（注意一定要有这一步，不然无法保证元素比较后的大小顺序性）\n        for (int j = 0; j &lt; help.length; j++) {\n            arr[L+j] = help[j];\n        }\n        System.out.println(Arrays.toString(arr));\n    }</code></pre>\n<h2>七，桶排序算法</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>概述：先找出无序序列中的最大值和最小值，然后根据最大值和最小值计算桶的个数并且初始化桶，然后将每个元素加入到对应的桶中，对每个桶进行排序，再整合桶中的数据即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>JAVA代码如下：</strong></p>\n<pre class=\"language-java\"><code>public static void bucketSort(int[] arr){\n\n        int k = 0;\n        //找出无序序列中的最大值和最小值\n        int max = Integer.MIN_VALUE;\n        int min = Integer.MAX_VALUE;\n        for (int i : arr) {\n            max = Math.max(max,i);\n            min = Math.min(min,i);\n        }\n\n        //根据最大值和最小值确定桶\n        int bucketNum = (max-min)/arr.length+1;\n        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = new ArrayList&lt;&gt;(bucketNum);\n        for (int i = 0; i &lt; bucketNum; i++) {\n            bucketArr.add(new ArrayList&lt;&gt;());\n        }\n\n        //遍历序列中的数据，将其分配进入不同的桶\n        for (int i=0;i&lt;arr.length;i++) {\n            int num = (arr[i]-min)/arr.length;\n            bucketArr.get(num).add(arr[i]);\n        }\n\n        //对每个桶都进行排序\n        for (ArrayList&lt;Integer&gt; bucket : bucketArr) {\n            Collections.sort(bucket);\n        }\n\n        //将桶中的数据按照顺序复制回原数组\n        for (ArrayList&lt;Integer&gt; bucket : bucketArr) {\n            for (Integer integer : bucket) {\n                arr[k++] = integer;\n            }\n        }\n    }</code></pre>\n<h2>八，基数排序（这里以高位优先为例）</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>概述：基数排序是一种优化的桶排序，但是基数排序只能排序整型数据。先要统一数据的位数，位数不够的前面添0，然后按照从低位到高位的位数顺序依据位数上数字的大小进行排序，最终得到一个有序序列。 &nbsp;</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码如下：</strong></p>\n<pre class=\"language-java\"><code>public static void radixSort(int[] arr){\n        //指数\n        int exp = 1;\n\n        //查找数组中的最大值\n        int max= Integer.MIN_VALUE;\n        for (int i : arr) {\n            max = Math.max(max,i);\n        }\n\n        //按照低位到高位的顺序依次排序\n        for (exp=1;(max/exp)&gt;0;exp*=10){\n            int[] temp = new int[arr.length];\n            //初始化桶\n            int[] buckets = new int[10];\n            //统计每个桶中数据的次数\n            for (int i = 0; i &lt; arr.length; i++) {\n                buckets[(arr[i]/exp)%10]++;\n            }\n\n            //更改buckets[i]\n            for (int i = 1; i &lt; buckets.length; i++) {\n                buckets[i]+=buckets[i-1];\n            }\n\n            //将数据存储到临时数组temp中\n            for (int i = 0; i &lt; arr.length; i++) {\n                temp[buckets[(arr[i]/exp)%10]-1] = arr[i];\n                buckets[(arr[i]/exp)%10]--;\n            }\n\n            //将临时数组的数据复制到原数组\n            System.arraycopy(temp,0,arr,0,arr.length);\n        }\n    }</code></pre>\n<h2><strong>九，其它算法（对于最短路径算法和回溯算法后面会单列出来）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;剪枝算法，最短路径算法，回溯算法</strong></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1250364779516665856","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6W3IWAZhjCAACsl_OYPcQ410.jpg","blogRead":2,"blogRemark":"面试（五）------之算法","blogTitle":"面试（五）------之算法","createdTime":"2020-04-15 10:06:09","typeName":"java面试篇","updateTime":"2020-04-16 08:26:53"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，栈及其JAVA实现</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：栈是一种先进后出的数据结构，对栈顶元素的添加，删除等操作较快，但是对于栈内的元素操作很慢</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA实现：实现需要定义栈的数据结构，写栈的入栈，出栈，获取栈顶元素的方法，如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n * 基于数组实现栈\n * @author wcj\n * @Date 2020/4/14 20:59\n * @Version 1.0\n */\npublic class StackExample&lt;E&gt; {\n\n    /**\n     * 站的深度\n     */\n    private int maxSize;\n    /**\n     * 存储数据的数组\n     */\n    private Object[] data;\n    /**\n     * 栈顶指针\n     */\n    private int top = -1;\n\n    /**\n     * 默认栈的深度为10\n     */\n    public StackExample(){\n        this(10);\n    }\n\n    /**\n     * 用户自定义栈的深度\n     * @param initialSize\n     */\n    public StackExample(int initialSize){\n        if(initialSize&gt;=0){\n            this.maxSize = initialSize;\n            this.data = new  Object[initialSize];\n            this.top = -1;\n        }else{\n            throw new RuntimeException(\"初始化栈的深度不能小于0!\");\n        }\n    }\n\n    /**\n     * 入栈操作\n     * @param e\n     * @return\n     */\n    public Boolean push(E e){\n        if(top == maxSize-1){\n            throw new RuntimeException(\"栈已满,不能入栈\");\n        }else{\n            data[++top] = e;\n        }\n        return true;\n    }\n\n    /**\n     * 出栈操作\n     * @return\n     */\n    public E pop(){\n        if(top==-1){\n            throw new RuntimeException(\"栈空，不能出栈！\");\n        }else{\n            return (E) data[top--];\n        }\n    }\n\n    /**\n     * 获取栈顶元素\n     * @return\n     */\n    public E peak(){\n        if(top==-1){\n            throw new RuntimeException(\"栈空异常！\");\n        }else{\n            return (E) data[top];\n        }\n    }  </code></pre>\n<h2><strong>二，队列极其JAVA实现</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：队列是一种先进先出的数据结构，对队头和队尾的操作简单，但是队内元素的操作复杂。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA实现：定义队列的数据结构，队列的出队，入队，获取队头元素。代码如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n * 基于数组实现队列\n * @author wcj\n * @Date 2020/4/14 21:14\n * @Version 1.0\n */\npublic class QueueExample&lt;E&gt; {\n\n    /**\n     * 队列长度\n     */\n    private int maxSize;\n    /**\n     * 存储数据数组\n     */\n    private Object[] data;\n    /**\n     * 队头指针\n     */\n    private int front;\n    /**\n     * 队尾指针\n     */\n    private int rear;\n\n    /**\n     * 默认构造器\n     */\n    public QueueExample(){\n        this(10);\n    }\n    /**\n     * 用户自定义队列长度构造器\n     * @param initialSize\n     */\n    public QueueExample(int initialSize){\n        if(initialSize&gt;=0){\n            this.maxSize = initialSize;\n            data = new Object[initialSize];\n            front = rear = 0;\n        }else{\n            throw new RuntimeException(\"初始化队列长度不能小于0！\");\n        }\n    }\n\n    /**\n     * 入队操作\n     * @param e\n     * @return\n     */\n    public Boolean add(E e){\n        if(rear == maxSize){\n            throw new RuntimeException(\"队列已满，无法入队!\");\n        }else{\n            data[rear++] = e;\n        }\n        return true;\n    }\n\n    /**\n     * 出队操作\n     * @return\n     */\n    public E poll(){\n        if(front==rear){\n            throw new RuntimeException(\"队空，无元素可出队！\");\n        }else{\n            E e = (E) data[front];\n            data[front] = null;\n            return e;\n        }\n    }\n\n    /**\n     * 获取队头元素\n     * @return\n     */\n    public E peek(){\n        if(front==rear){\n            throw new RuntimeException(\"队空，无元素可出队!\");\n        }else{\n            return (E) data[front];\n        }\n    }\n}\n</code></pre>\n<h2><strong>三，链表及其JAVA实现</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：链表是由一系列数据节点组成的数据结构，节点可以动态生成。对于元素的增加，删除操作快，查询操作慢</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;这里主要讲述几种有代表性的链表：单向链表，双向链表，双向循环链表</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;单链表的JAVA实现：数据结构定义，添加节点，删除节点，查找节点，代码如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n * 单向链表\n * @author wcj\n * @Date 2020/4/14 21:32\n * @Version 1.0\n */\npublic class SingleLinkedList {\n\n    /**\n     * 链表长度\n     */\n    private int length;\n    /**\n     * 链表头节点\n     */\n    private Node head;\n\n    public SingleLinkedList(){\n        this.length = 0;\n        this.head = null;\n    }\n    /**\n     * 内部类声明每个链表节点\n     * 每个节点包括数据域和指向下一个节点的指针\n     */\n    private class Node{\n        private Object data;\n        private Node next;\n        public Node(Object data){\n            this.data = data;\n        }\n    }\n\n    /**\n     * 插入节点（这里使用头插法）\n     * @param obj\n     * @return\n     */\n    public Boolean add(Object obj){\n        Node node = new Node(obj);\n        if(length==0){\n            head = node;\n        }else{\n            node.next= head;\n            head = node;\n        }\n        length++;\n        return true;\n    }\n\n    /**\n     * 删除某个节点\n     * 先对链表进行判空处理\n     * 然后找到要删除的节点\n     * 最后进行删除\n     * @param obj\n     * @return\n     */\n    public Boolean delete(Object obj){\n        if(length==0){\n            throw new RuntimeException(\"链表为空，无节点可删除!\");\n        }else{\n            Node prev = head;\n            Node current = head;\n            //查找待删除元素\n            while(!current.data.equals(obj)){\n                if(current.next==null){\n                    return false;\n                }else{\n                    prev = current;\n                    current = current.next;\n                }\n            }\n            prev.next = current.next;\n            length--;\n        }\n        return true;\n    }\n\n    /**\n     * 获取某个元素\n     * @param obj\n     * @return\n     */\n    public Object find(Object obj){\n        if(length==0){\n            throw new RuntimeException(\"链表为空\");\n        }else{\n            Node current = head;\n            while(current.data.equals(obj)){\n                if(current.next==null){\n                    return null;\n                }else{\n                    current = current.next;\n                }\n            }\n            return current.data;\n        }\n    }\n}\n</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>双向链表的JAVA实现：定义数据结构，头插法，尾插法，删除头部节点，删除尾部节点（这里只写尾插节点和删除尾部节点），代码如下：</strong></p>\n<pre class=\"language-java\"><code>import com.sun.org.apache.xpath.internal.operations.Bool;\n\n/**\n * 单向循环链表\n * @author wcj\n * @Date 2020/4/14 22:05\n * @Version 1.0\n */\npublic class CircleLinkedList {\n\n    /**\n     * 链表长度\n     */\n    private int length;\n    /**\n     * 头节点\n     */\n    private Node head;\n    /**\n     * 尾节点\n     */\n    private Node tail;\n\n    /**\n     * 初始化构造方法\n     */\n    public CircleLinkedList(){\n        this.length = 0;\n        this.head=this.tail = null;\n    }\n\n    /**\n     * 内部类实现的链表节点\n     */\n    private class Node{\n        private Object data;\n        private Node prev;\n        private Node next;\n        public Node(Object data){\n            this.data = data;\n        }\n    }\n\n    /**\n     * 尾插节点\n     * @param obj\n     * @return\n     */\n    public Boolean addTail(Object obj){\n        Node node = new Node(obj);\n        if(length==0){\n            head = tail= node;\n            length++;\n        }else{\n            tail.next = node;\n            node.prev = tail;\n            tail = node;\n            length++;\n        }\n        return true;\n    }\n\n    /**\n     * 删除尾部节点\n     * @return\n     */\n    public Boolean delTail(){\n        Node temp = tail;\n        if(length==0){\n            throw new RuntimeException(\"链表为空!\");\n        }else{\n            tail = tail.prev;\n            tail.next = null;\n            length--;\n        }\n        return true;\n    }\n}\n</code></pre>\n<h2><strong>四，散列表</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：有一张表M，一个映射函数f(key)，如果对于任意一个key，都有一个函数指与表中的内存地址相对应，则M就为散列表，f(key)就为散列函数。散列函数存储key-value键值对形式的数据，直接生成key与表中地址值的映射，因此查询非常迅速。同时散列表也经常被用于信息安全，用于加密操作。</strong></p>\n<h2><strong>五，二叉排序树</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：二叉查找树又成为二叉搜索树，二叉查找树</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;特征：根节点左边的数据小于根节点，根节点右边的数据大于根节点，且其左右子树还是二叉排序树</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现：定义数据结构，插入操作，删除操作，查找操作，代码如下：</strong></p>\n<pre class=\"language-java\"><code>package interviewFour.example4;\n\n/**\n * 二叉排序树\n * @author wcj\n * @Date 2020/4/14 17:17\n * @Version 1.0\n */\npublic class Node {\n\n    private Node root = null;\n    private int value;\n    private Node left;\n    private Node right;\n\n    public Node(){}\n\n    public Node(int value, Node left, Node right){\n        this.value = value;\n        this.left = left;\n        this.right = right;\n    }\n\n    public Node(int value){\n        this.left = null;\n        this.right = null;\n        this.value = value;\n    }\n\n    public int getValue() {\n        return value;\n    }\n\n    public void setValue(int value) {\n        this.value = value;\n    }\n\n    public Node getLeft() {\n        return left;\n    }\n\n    public void setLeft(Node left) {\n        this.left = left;\n    }\n\n    public Node getRight() {\n        return right;\n    }\n\n    public void setRight(Node right) {\n        this.right = right;\n    }\n\n    /**\n     * 插入节点\n     * @param value\n     * @return\n     */\n    public Boolean insert(int value){\n        //root代表根节点\n        Node p = root;\n        Node prev = null;\n        //创建一个节点\n        Node node = new Node(value);\n        //寻找节点的插入位置\n        while(p!=null){\n            prev = p;\n            if(value==p.getValue()){\n                return false;\n            }else if(value&lt;p.getValue()){\n                p = p.getLeft();\n            }else{\n                p = p.getRight();\n            }\n        }\n        if(root==null){\n            root = node;\n        }else if(value&lt;prev.getValue()){\n            prev.setLeft(node);\n        }else{\n            prev.setRight(node);\n        }\n        return true;\n    }\n\n    /**\n     * 删除某个节点\n     * 分为三种情况，待删除节点为叶子节点，则直接删除\n     * 待删除节点只有左子树或者右子树，则用左子树或者右子树替代当前节点位置\n     * 待删除节点即有左子树又有右子树，则寻找左子树最大节点或者右子树最小节点顶替当前节点(这里使用左子树的最大节点)\n     * @param value\n     * @return\n     */\n    public void deleteBST(int value){\n        deleteBST(root,value);\n    }\n\n    /**\n     * 递归删除左子树，或者右子树，或者根节点\n     * @param root\n     * @param value\n     * @return\n     */\n    public Boolean deleteBST(Node root,int value){\n        if(root==null){\n            return false;\n        }else{\n            if(root.getValue()==value){\n                delete(root);\n            }else if(value&lt;root.getValue()){\n                deleteBST(root.getLeft(),value);\n            }else{\n                deleteBST(root.getRight(),value);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * 分情况执行具体的删除逻辑\n     * @param node\n     * @return\n     */\n    public Boolean delete(Node node){\n        if(node.getLeft()==null){\n            node = node.getRight();\n        }else if(node.getRight()==null){\n            node = node.getLeft();\n        }else{\n            Node temp = node;\n            Node s = node;\n            //转向左子树，向右走到底\n            s = s.getLeft();\n            //寻找替换待删除节点的节点\n            while(s!=null){\n                temp = s;\n                s = s.getRight();\n            }\n            node.setValue(temp.getValue());\n            if(temp!=node){\n                node.setLeft(temp.getLeft());\n            }else{\n                node.setRight(temp.getRight());\n            }\n        }\n        return true;\n    }\n\n    /**\n     * 在二叉查找树中找到对应节点\n     * @param value\n     * @return\n     */\n    public Boolean searchBTS(int value){\n        Node node = root;\n        if(node==null){\n            throw new RuntimeException(\"无此节点！\");\n        }else{\n            if(value==node.getValue()){\n                return true;\n            }else if(value&lt;node.getValue()){\n                node = node.getLeft();\n            }else{\n                node = node.getRight();\n            }\n        }\n        return false;\n    }\n}\n</code></pre>\n<h2>&nbsp;</h2>\n<h2><strong>六，红黑树</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 概述：红黑树是一种特化的自平衡二叉排序树，即其左右子树的深度差可以超过1。（详细的插入等操作过段时间会补充）</strong></p>\n<h2><strong>七，图，位图</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;图的知识：定义，有向图/无向图，邻接矩阵/邻接表，BFS/DFS，位图的话没怎么搞清楚。</strong></p>\n<h2>&nbsp;</h2>","blogGoods":0,"blogId":"1250068950784536576","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6VyQCAX-J_AACqF70d5gI039.jpg","blogRead":1,"blogRemark":"面试（四）------之数据结构篇","blogTitle":"面试（四）------之数据结构篇","createdTime":"2020-04-14 14:30:37","typeName":"java面试篇","updateTime":"2020-04-14 14:30:58"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，线程上下文切换</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>cpu利用时间片轮询的方式来为每个任务都分配一定的时间片，任务的执行过程中保存任务的状态。任务状态的保存和在加载就叫做上下文切换。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>进程：</strong>指的是一个运行中的程序实例，一个进程中可以有多个线程，并且与进程共享同样的内存和系统资源</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong> 上下文：</strong>指的是寄存器和程序计数器保存的线程的信息</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>寄存器：</strong>指的是内存中很小但是运行速度很快的一块区域（相对于RAM外部内存）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>程序计数器：</strong>一种寄存器，用来保存当前执行指令的位置或者下一个待执行指令的位置</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>上下文切换：</strong>上下文切换指的是操作系统的内核在cpu上对进程或者线程的切换。上下文信息保存在进程控制块中（PCB）。流程如下：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;挂起当前进程，将进程的上下文信息保存在进程控制块中；</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;在进程控制块中寻找下一个任务的上下文信息。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;恢复进程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>上下文切换的原因：</strong>第一，任务正常执行完毕，调度下一个任务；第二，线程出现I/O阻塞，被挂起，cpu调度下一个任务；第三，线程等待同步锁，获取socket通知等，被挂起，cpu调度下一个任务；第四，用户调用sleep方法，让出cpu；第五，硬件中断</p>\n<h2><strong>二，JAVA阻塞队列</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>阻塞队列的是调度当前队列的线程处于阻塞状态</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 消费者阻塞：如果队列为空，则消费者线程被挂起，处于阻塞状态，当有新数据进入队列，则消费者线程被唤醒，消费数据</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 生产者阻塞：如果队列数据已满，则生产者线程挂起，处于阻塞状态，当队列有空闲位置，生产者线程被唤醒，生产数据。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞队列的主要操作：</strong>插入操作和移除（获取）操作</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>插入操作：</strong>add(e)，有空间则插入，无空间报异常；offer(e),有空间则插入，无空间返回false；offer(e,time,unit),有空间插入，无空间等待time时间，若超时返回false；put(e),有空间插入，无空间则线程挂起处于阻塞直到有空间</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>移除操作：</strong>poll(e),有值返回值，无值返回null;poll(e,time,unit),有值返回值，无值等待time时间，超时返回null;take(e),有值返回值，无值等待新数据进入再立即返回；drainTo(collection&lt;Object&gt;)批量移除，提高获取效率</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞队列的实现：</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong> ArrayBlockingQueue：</strong>基于数组的有界阻塞队列，按照先进先出顺序对元素进行排序</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>LinkedBlockingQueue：</strong>基于链表的有界阻塞队列，队头队尾采用不两个不同的锁控制数据同步，并发性高</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>PriorityBlockingQueue：</strong>基于优先级的无界队列，默认升序排列，可以自定义排序规则，根据优先级访问数据。但是有数据优先级一样的情况</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>DelayQueue：</strong>支持延时的队列，即从队列中取数据时等待一定的时间才能获取元素。可以用于缓存系统的设计，设计过期时间，也可以用来设置定时调度任务，即如果能够从队列中获取，说明到了任务的调度时间。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>SynchronousQueue</strong>：没怎么读懂（<span style=\"background-color: #ffff00;\">记得补充</span>！）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>LinkedTransferQueue：</strong>基于链表的无界阻塞队列，多了transfer方法(如果消费者等待，直接将任务从生产者传递给消费者，无消费者等待，则将任务加到队尾直到被消费才返回)和tryTransfer（与transfer一致，只不过不管有没有消费者等待获取都会立即返回tryTransfer（e,time,unit）（与tryTransfer一致，只不过设置了超时时间）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>LinkedBlockingDeque：</strong>基于链表的双向阻塞队列，可以在两端同时进行读写操作，提高了队列的操作效率。</p>\n<h2><strong>三，并发关键字</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;CountDownLatch：</strong>适用于一个主线程等待子线程完成任务之后执行（原理：设置一个程序计数器，计数器的值为子线程的个数，子线程并发执行，每个子线程执行完毕后，调用CountDown方法，将其计数器的值减去1，值为0时，唤醒主线程执行）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>CyclicBarrier：</strong>即当所有线程到达一个状态共同执行。await（）方法：确保所有线程到达Barrier状态才执行；await（time,unit）：设置一个超时时间，超过这个时间，执行达到Barrier状态的线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>Semaphore：</strong>因为其限制了多线程访问资源的线程个数，所以适用于多线程并发访问有限资源的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>volatile：</strong>直接用来修饰变量，是一种比Synchronized更加轻量级的机制，用于多线程共享同一变量，可以同时对其进行读写操作。当多个线程共享变量的时候，读取变量将其从内存复制到cpu缓存中，然后线程对其操作进行修改，这样再多cpu的情况下，有可能出现线程修改原数据造成数据不一致的情况，使用volatile关键字直接将线程修改的变量存入内存，解决这个问题。</p>\n<h2><strong>四，多线程共享数据</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>多线程共享数据主要通过共享内存实现，而共享内存的可见性，有序性，原子性已经由JVM和锁解决。理想情况下我们需要解决同步和互斥的问题（<span style=\"background-color: #ffff00;\">怎么解决的有待考证！</span>）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>解决方法一：</strong>将数据抽象成一个类，将对数据的操作封装成类中的方法</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解决方法二：</strong>将Runnable对象作为一个内部类，将共享数据作为这个类的成员变量</p>\n<h2><strong>五，ConcurrentHashmap并发</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ConcurrentHashmap使用了减小锁粒度，这里具体为分段锁的思想优化了锁，因为如果直接对hashmap进行加锁，锁太大，而且同一时刻只能有一个线程操作hashmap，并发性能较差</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;实现原理：</strong>即内部采用分段锁思想，将hashmap分为多个segment，每次读取数据的时候，对数据所在的segment进行加锁，这样只要保证每个segment线程安全，就可以保证整个hashmap线程安全</p>\n<h2><strong>六，JAVA中的线程调度</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;抢占式调度：</strong>即线程对cpu资源进行抢占，这种策略下每个线程抢占到cpu资源的概率是相等的，这样就不会一个线程阻塞造成整个系统阻塞的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>协同式调度：</strong>即一个线程使用完cpu资源之后通知cpu调度下一个任务，适用于多线程交替执行任务。因为如果一个线程阻塞可能会造成整个系统阻塞甚至崩溃</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>JAVA采用的是抢占式调度，但同时又尽可能的保证公平性（即为每个线程分配优先级不同的cpu时间片）</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>&nbsp;线程让出cpu的情况</strong>：第一，线程调用yield方法；第二，I/O阻塞，socket等待等；第三，等待同步锁；第四，正常执行完毕</p>\n<h2>七，进程调度算法</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>优先调度算法：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;先来先服务调度算法：</strong>即遵循先来先被分配cpu资源运行的原则</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>短作业调度算法：</strong>即预估作业的时间长短，优先调度时间短的任务，可能会导致长时间大任务很长时间无法被调度 &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>高优先权调度算法：即每个任务会预先被分配优先级</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;非抢占式优先调度算法：</strong>按照优先级的高低一次分配cpu资源运行</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>抢占式优先调度算法：</strong>按照优先级的高低分配cpu资源运行，但是如果任务再运行过程中有优先级更高的任务加入，则将其cpu资源临时回收分配给紧急任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>高响应比调度算法：</strong>动态调度，即作业时间短，则优先级高；等待时间长，则优先级高。前者遵循短作业调度算法，后者遵循先来先服务原则。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>时间片轮转调度算法：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;时间片轮转法：</strong>按照任务再队列中的顺序进行调度</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>多级反馈队列调度算法：</strong>即再时间片轮转法的基础上维护了就绪队列，默认第一队列优先级高，先调度第一队列的任务，如果再分配的cpu时间片内未完成则将其加入第二队列队尾，以此类推直到其执行完毕。只有第1 -（n-1）队列为空，才会调度第n队列的任务，而且当前任务执行时，如</p>\n<p>果有优先级高的任务进来，会抢占其cpu资源。</p>\n<h2><strong>八，CAS</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>即比较和交换，CAS（V,E,N）三个参数，只有当V=E的时候才会将V设置为N。如果V!=E，则说明数据已经被其它线程修改，不做任何操作</p>\n<h2><strong>九，ABA问题</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>概述：</strong>即当1线程从V中取出A时，2线程也从中取出1，修改为B，再修改为A。而1线程仍然修改成功，实际上修改过程中V的实际值已经发生改变，只不过1没有发觉。解决这种问题，常采用乐观锁的版本号机制。</p>\n<h2><strong>另外有AQS问题没怎么读懂，下次完善！</strong></h2>\n<p>&nbsp;</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</p>","blogGoods":0,"blogId":"1249742755949817856","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6UmSuAdB35AABzd_wnH78043.jpg","blogRead":2,"blogRemark":"面试（三）------之并发编程篇（下）","blogTitle":"面试（三）------之并发编程篇（下）","createdTime":"2020-04-13 16:54:26","typeName":"java面试篇","updateTime":"2020-04-17 10:16:11"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，redis简介</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>redis是NoSQL型系统之一，与之相似的还有Memcache，用来存储key-value这种键值型数据。相比于Memcache而言，redis不仅可以做临时缓存，还可以做数据持久化，将数据定时的存入硬盘或者将命令追加到日志文件当中。而Memcache只能做临时缓存，因而现在基本上已经被redis完全取代。redis的读写速度非常快，官方给出的数据是读110000次/s，写81000次/s；而且redis支持多种数据类型，例如String，list，hash，set，zset；redis支持主从复制（集群），进行数据持久化；还支持过期时间，事务等。</p>\n<h2><strong>二，redis的安装与启动（docker环境下）</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;docker安装完毕后，安装redis：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第一步：拉取redis镜像，docker&nbsp; pull&nbsp; redis</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第二步：启动redis，docker&nbsp; &nbsp;run&nbsp; &nbsp;redis&nbsp; &nbsp;</p>\n<p><strong>三，基本知识串讲</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>单进程单线程：redis只有一个进程，且内部为单线程，这样做的优势是不存在线程安全问题，且不需要进行线程间的切换，提高了性能，而且多线程可能会涉及到锁。劣势是无法发挥多核cpu的优势，不过可以通过开启搭建多个redis实例实现</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>redis中默认有16个数据库（0-15），可以通过select n来进行数据库之间的切换</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;常用的基本命令：flushDB（清空当前数据库），flushAll（清空所有数据库），dbSize（查看有多少数据库）</p>\n<h2><strong>四，redis基本数据类型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;string：</strong>字符串类型，数据库中存储Map&lt;String,String&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>list：</strong>列表数组类型，数据库中存储Map&lt;String,List&lt;Object&gt;&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>hash：</strong>哈希类型，数据库中存储Map&lt;String,Map&lt;Object,Object&gt;&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>set：</strong>集合类型，其中元素无序，数据库中存储Map&lt;String,Set&lt;Object,Object&gt;&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>Zset：</strong>有序集合类型，每个元素都有一个可用于排序的权重</p>\n<h2><strong>五，redis相关命令（这里详解一些常用的命令，不常用的一笔带过）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;string：</strong>(1)set&nbsp; key&nbsp; value,插入一条数据&nbsp; （2）mset&nbsp; key value...批量插入 （3）setnx&nbsp; key value&nbsp; 若无则插入（4）get&nbsp; key&nbsp; 获取某条数据&nbsp; （5）mget keys 批量获取&nbsp; （6）getrange key&nbsp; 0 -1获取数据库全部数据&nbsp; （7）incr age 递增&nbsp; (8) incrby&nbsp; age&nbsp; 10&nbsp; 递增 age 步长为10（9）decr&nbsp; age&nbsp; 递减&nbsp; （10）decrby&nbsp; age&nbsp; 10 步长递减&nbsp; &nbsp;（11）del&nbsp; key&nbsp; 删除某条数据&nbsp; <span style=\"background-color: #ffff00;\">（12）exists&nbsp; key&nbsp; 判断是否存在某个key&nbsp; &nbsp;(13)expire&nbsp; key&nbsp; 10&nbsp; 设置过期时间（单位为秒）&nbsp; （14）pexpire&nbsp; key&nbsp; 1000 设置过期时间，单位为毫秒&nbsp; （15）persist key删除过期时间 （</span><span style=\"background-color: #ffff00;\">16）ttl&nbsp; key&nbsp; 查看过期时间</span></p>\n<p><span style=\"background-color: #ffff00;\">&nbsp;<span style=\"background-color: #ffffff;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>list：&nbsp;&nbsp;</strong>（1）lpush&nbsp; key&nbsp; value 左插入一条数据&nbsp; &nbsp;（2）lpush mylist&nbsp; key&nbsp; value....批量左插入&nbsp; （3）rpush&nbsp; key value 右插入一条数据&nbsp; (4)rpush&nbsp; mylist&nbsp; key value...右批量插入&nbsp; （5）lrange&nbsp; mylist&nbsp; 0&nbsp; -1&nbsp; 取出数据集合&nbsp; （6）lpop mylist 左弹出集合中第一条数据&nbsp; （7）rpop&nbsp; </span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">mylist&nbsp; 右弹出集合中第一条数据&nbsp; （8）llen&nbsp; mylist&nbsp; 获取数据集合长度lrem&nbsp; mylist&nbsp; count&nbsp; value&nbsp; （count&gt;0,从表头开始搜索，移除count个与值与value相等的元素；count&lt;0,表尾开始；count=0，移除所有值与value相等的元素） （9）linsert mylist&nbsp; before/after&nbsp; a&nbsp; 在a元素前或后插入。</span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">(10) lpoplpush&nbsp; list&nbsp; list1 转移列表的元素到另一个列表</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>hash：</strong>（1）hset&nbsp; key&nbsp; &nbsp;val-key&nbsp; val-val&nbsp; 插入一条数据&nbsp; （2）hset&nbsp; myhash&nbsp; name&nbsp; xxx&nbsp; 用于给哈希表中的字段赋值，不存在则创建哈希表赋值，存在则覆盖旧值&nbsp; (3) hget&nbsp; &nbsp;myhash&nbsp; name&nbsp; 取哈希表中某个值&nbsp; （4）hmset&nbsp; myhash name&nbsp; xxx age xxx&nbsp; 批量插入字段&nbsp; （5）hmget</span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">批量获取 （6）hgetall&nbsp; myhash&nbsp; 获取哈希表中所有值&nbsp; (7)&nbsp; hexisets myhash&nbsp; name&nbsp; 判断哈希表中是否存在name字段&nbsp; （8）hsetnx&nbsp; myhash score 100 若存在则不插入，若不存在则插入数据&nbsp; （9）hincrby&nbsp; myhash id 1/hdecrby&nbsp; myhash id&nbsp; 10 递增递减 （10）hdel&nbsp; myhash name&nbsp; </span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">删除&nbsp; （11）hkeys&nbsp; myhash&nbsp; 只取key值&nbsp; （12）hvals&nbsp; myhash&nbsp; 只取value值&nbsp; （13）hlen&nbsp; myhash 获取哈希表长度</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>set：</strong>（1）sadd myset&nbsp; redis&nbsp; 添加一条数据&nbsp; （2）smembers myset&nbsp; 获取数据集合&nbsp; （3）srem&nbsp; myset&nbsp; set1&nbsp; 删除set1&nbsp; （4）sismember myset&nbsp; set1 判断set中是否存在set1&nbsp; (5)srandmember&nbsp; key count&nbsp; 随机获取count个元素（6）spop&nbsp; 从集合中弹出一个元素</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>zset：</strong>之后补充</span></span></p>\n<h2><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">六，redis配置文件（常见配置）</span></span></strong></h2>\n<p><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;daemonize no：</span></span></strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">redis默认不是以守护进程的方式运行的，可以更改为yes启用守护进程（即后台运行）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>pidfile&nbsp; /var/run/redis.pid&nbsp; :</strong>启用守护进程后，默认将pid写入/var/run/redis.pid文件，可以更改</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>port&nbsp; 6379 ：</strong>redis默认端口</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp; &nbsp; &nbsp; &nbsp; <strong>bind&nbsp; 127.0.0.1：</strong>绑定的主机地址</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\"> &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>timeout&nbsp; 300</strong><strong>：</strong>redis客户端闲置多长时间后关闭连接，改为0的话，表示关闭该功能</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>loglevel&nbsp; verbose：</strong>默认日志级别（还有debug，notice，warning）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>database 16：</strong>redis默认有16个数据库可以修改</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>save&nbsp; 900&nbsp; 1/save&nbsp; 300&nbsp; 10/save&nbsp; 60&nbsp; 10000：&nbsp;</strong>表示一定时间内有多少条数据发生修改，就将其同步到数据文件一次，例如第一个表示15分钟内有一条数据发生改变就同步</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>rdbcompression yes&nbsp; ：</strong>表示数据存储到本地数据库时是否进行压缩</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>dbfilename&nbsp; dump.rdb：</strong>指定本地数据库文件名</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>dir&nbsp; /...../redis安装目录/bin ：</strong>本地数据库存放目录，默认在redis安装目录的bin目录下</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>slaveof&nbsp; &nbsp;masterip&nbsp; masterport ：</strong>设置当本机为从机时，它的主机的ip和端口</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>masterauth&nbsp; &lt;master-password&gt;：</strong>当master服务设置了密码时，slav服务连接master的密码</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>requirepass&nbsp; foobared：</strong>默认关闭redis连接需要密码，当给redis设置了密码，就需要打开</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>maxclients&nbsp; &nbsp;128：</strong>redis同一时间最大连接客户端的数量</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>appendonly&nbsp; &nbsp;no：</strong>是否开启aof持久化，默认不开启，采用rdb</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>appendfilename&nbsp; appendonlu.aof：</strong>指定aof持久化的文件名</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>appendfsync&nbsp; everysec :</strong>指定更新日志条件，默认每秒更新一次（还有no，指等操作系统进行数据缓存到磁盘，快；always指每次更新操作后都手动写入磁盘，慢但安全）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;虚拟机方面的配置暂不说明</span></span></p>\n<h2><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">七，redis持久化</span></span></strong></h2>\n<p><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;概述：</span></span></strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">redis持久化主要有两种方式，即rdb和aof</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>rdb：</strong>适用于大数据集的恢复，数据的备份，但是因为设置周期时间进行数据的快照，所以如果redis宕机，可能会丢失最后一个写操作的数据，因为数据完整性较差。数据保存在dump.db文件中，只需要移动到redis安装目录，重启即可恢复数据</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>aof：</strong>适用于对数据的完整性要求较高的情况，因为可以设置不同的持久化策略，例如每秒保存一次，这样即时redis宕机，也只会丢失最后一秒的数据。但是因为其日志文件存储的是写入命令，因而其文件大小要大于rdb的数据文件，且每次重启，都要从头执行数据文件中的命令，因而恢复速度也</span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">要慢于rdb。</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>注意：</strong>当rdb和aof同时开启的时候，redis重启，默认会采用aof的形式进行数据的重新构建</span></span></p>\n<h2><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">八，redis事务</span></span></strong></h2>\n<p><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;概述：</span></span></strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">什么是事务？事务即是一系列的命令要买全部执行，要么全部回滚</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <strong>常用命令：</strong>multi(启动事务)，discard（取消事务）,exec（执行事务块内命令）,watch key(监控某个key的变化)，unwatch（取消对所有key的监控）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>注意：</strong>redis的事务中在命令本身出错的情况下会造成命令的全部回滚，但是在命令无错，执行某个命令的时候发生异常的时候，则谁的错，谁停止（这一点和mysql是不同的）</span></span></p>\n<h2><strong>九，redis的主从复制</strong></h2>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>redis的主从复制，即主机数据更新后根据我们设置的策略将数据同步到从机上，主机以写为主，从机以读为主<strong>。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 使用：</strong>配主不配从，在从机中使用slaveof&nbsp; 主机ip&nbsp; &nbsp;主机端口配置从机，但是这种配置方式当redis重启之后就会失效，如果想要redis重启仍然可用，则需要配置redis.conf配置文件中的slaveof&nbsp; masterip&nbsp; masterport。这种配置方式的问题所在，中心化只有一台极其支持写操作，如果主机宕机，则从机等待，且从机宕机重启后不会跟上大部队（即重启后变为主机）。当然我们可以采用命令slave&nbsp; no&nbsp; one 使从机反客为主，成为主机。但是这种手动操作太过麻烦。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>哨兵模式：</strong>即配置之后，如果主机宕机，则哨兵会自动根据投票规则在从机中进行选举，从而产生新的主机顶替。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>主从复制的缺点：</strong>因为所有的写操作都是子主机上进行，从而在同步到从机上，所以存在着一定的延迟，当系统繁忙或者从机数量较多的时候，这种问题就更加明显。</p>\n<h2><strong>十，redis集群</strong></h2>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;概述：</strong>集群是一种去中心化的模式，与中心化模式不同的是，中心化模式中如果主服务挂掉了，那么服务就挂掉了。但是集群模式下，没有主路由，每个节点自身都可以成为路由</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;redis集群：即配置多台主机，多台从机，不同的主机中有不同的槽点，当执行数据写入时，会根据crc16算法计算出数据的槽点，从而将数据存入到对应的主机中，并同步到与其对应的从机中</p>\n<p>&nbsp;</p>\n<h1>水平有限，如有错误，还望指出！</h1>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1249588251598041088","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6UCU-ALIMAAACFuGw0Y70739.jpg","blogRead":3,"blogRemark":"redis基础（一）","blogTitle":"redis基础（一）","createdTime":"2020-04-13 06:40:30","typeName":"redis","updateTime":"2020-04-16 13:15:50"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，JAVA线程的创建方式</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>JAVA线程的创建有四种方式，分别为，继承Thread类，实现Runable接口，实现Callable&lt;Class&gt;接口，基于线程池。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>1，继承Thread方式：创建一个类继承Thread类，创建类的实例对象，调用start方法，继而执行线程的run（）方法，代码如下：</strong></p>\n<pre class=\"language-java\"><code>public class NewThread extends Thread{\n    public static void main(String[] args) {\n        NewThread thread = new NewThread();\n        thread.start();\n    }\n    @Override\n    public void run(){\n        System.out.println(\"create  a  new thread by Thread!\");\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>2，当子类已经继承了一个类，这时候就没法再继承Thread类了，这时候就可以实现Runable接口，实例化类的线程实例，创建Thread实例传入类的实例，执行start方法，继而执行run（）方法代码如下：</strong></p>\n<p>&nbsp;</p>\n<pre class=\"language-java\"><code>public class ThreadExample2 implements Runnable {\n    public static void main(String[] args) {\n        ThreadExample2 threadExample2 = new ThreadExample2();\n        Thread thread = new Thread(threadExample2);\n        thread.start();\n    }\n    @Override\n    public void run() {\n        System.out.println(\"create a new thread by Runnable!\");\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，有些情况下，我们需要再一个主线程中并发多个子线程执行同一个任务，然后回收子线程的返回值整理汇总，这时候就需要实现Callable&lt;Class&gt;接口，重写其call（）方法，用于计算结果。然床创建一个线程池用于提交线程，继而执行call方法，并且创建一个Future的list用于接收子线程逻辑代码即call方法的返回，最终遍历list，得到想要的返回值，如下：</strong></p>\n<pre class=\"language-java\"><code>public class ThreadExample3 implements Callable&lt;String&gt; {\n\n    private String name;\n\n    public ThreadExample3(String name){\n        this.name = name;\n    }\n\n    @Override\n    public String call() throws Exception {\n        return name;\n    }\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        ExecutorService pool = Executors.newFixedThreadPool(3);\n        List&lt;Future&gt; list = new ArrayList&lt;&gt;();\n        for(int i=0;i&lt;3;i++){\n            ThreadExample3 threadExample3 = new ThreadExample3(i+\"\");\n            Future future =pool.submit(threadExample3);\n            System.out.println(future.get().toString()+\" is running\");\n            list.add(future);\n        }\n        pool.shutdown();\n        for (Future future : list) {\n            System.out.println(\"currentThread's result is \"+future.get().toString());\n        }\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，基于线程池创建线程</strong></p>\n<pre class=\"language-java\"><code>public class ThreadExample4 {\n    public static void main(String[] args){\n        ExecutorService pool = Executors.newFixedThreadPool(3);\n        for(int i=0;i&lt;3;i++){\n            pool.execute(new Runnable() {\n                @Override\n                public void run() {\n                    System.out.println(\"thread  is running by FixedThreadPool\");\n                }\n            });\n        }\n        pool.shutdown();\n    }\n}</code></pre>\n<h2>二，线程池的工作原理</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong> &nbsp;1，概述：</strong>JVM根据用户提供的参数创建一定数量的线程任务，将其放入队列中，线程创建之后启动这些任务，如果线程的数量大于核心线程数量（用户设置的线程数量），则超出数量的线程排在队列中等待，当有线程任务执行完毕后，线程池调度器就会发现有可用可用线程，继而从队列中取出任务继续执行<strong>。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; </strong><strong>2，线程复用：</strong>（参见JDK源码解读，这里只做简单描述），由前可知，JVM会根据用户提供的参数创建一定数量的线程任务，且将其添加到任务队列中。JVM通过start（）方法创建一个线程之后， 会相应的为其创建一个任务队列，线程会不停的查看任务队列，如果任务队列中有任务，则调用run方法，执行，这样就达到了一次start（）创建线程，多次使用，完成线程复用的任务。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>3，线程池的核心组件和核心类（见JDK源码分类中关于线程的总结）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; </strong><strong>4，JAVA线程的工作流程：</strong>线程池刚被创建的时候，只是向系统申请一个执行线程队列和管理线程池的线程资源，当调用execute方法之后，执行下列流程：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果正在运行的线程数量小于corePoolSize（核心线程数量，即用户定义的的线程数量），则立即创建线程执行线程任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果正在运行的线程数量大于或等于corePoolSize，则将超过数量的线程加入到阻塞队列中</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在阻塞队列已满且线程数量小于MaximumPoolSize（即线程池能够容纳的最大线程数），线程池会创建非核心线程立即执行任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在阻塞队列已满且线程数量大于或等于MaximumPoolSize的时候，线程池会拒绝该线程任务且抛出异常</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在线程任务执行完毕之后，会将其从任务队列中移除，从队列中取出下一个线程任务执行</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在线程处于空闲状态且空闲时间超过KeepAliveTime，且线程数量大于corePoolSize的时候，会停止该线程，这样在没有任务的时候，线程池中的线程数始终维持在corePoolSize。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，线程池的拒绝策略：</strong>分为四种，分别为AbortPolicy，CallerRunsPolicy，DiscardOldestPolicy，DiscardPolicy</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; AbortPolicy：直接抛出异常，阻止线程运行，源码如下：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</p>\n<pre class=\"language-java\"><code>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n            throw new RejectedExecutionException(\"Task \" + r.toString() +\n                                                 \" rejected from \" +\n                                                 e.toString());\n        }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CallerRunsPolicy：如果线程任务没有关闭，则尝试执行该线程任务，源码如下：</p>\n<pre class=\"language-java\"><code>* @param r the runnable task requested to be executed\n* @param e the executor attempting to execute this task\n*/\npublic void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n     if (!e.isShutdown()) {\n         r.run()\n     }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DiscardOldestPolicy：移除任务队列中最早进入的线程任务，执行当前任务线程，源码如下：</p>\n<pre class=\"language-java\"><code>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n       if (!e.isShutdown()) {\n           e.getQueue().poll();\n           e.execute(r);\n       }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DiscardPolicy：直接丢弃线程任务，不做任何处理</p>\n<h2><strong>三，五种常用的线程池</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;newCachedThreadPool（可缓存线程池）：</strong>当线程池创建线程的时候如果发现有可复用的线程（执行完任务，且未关闭的线程），则直接复用，如果没有则创建新线程。可缓存线程池可以高效的利用执行任务时间短的线程，提高系统的性能，且线程池中的线程如果空闲时间超过60s，则会被终止且从缓存中移除，这样可缓存线程池不会占用系统资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>newFixedThreadPool（固定大小的线程池）：</strong>即线程池中的线程是初始化固定的，当任务线程大于线程池中线程数量时，任务线程就会进入阻塞队列等待。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newScheduledThreadPool（可做任务调度的线程池）：</strong>即可以设置线程执行的停顿时间和执行周期，进行定期定时的执行某个任务。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newSingleThreadPool（单个线程的线程池）:&nbsp;</strong>即线程池中永远只有一个线程进行工作，如果下称停止或者异常，则线程池创建新的线程替代当前线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newWorkStealingPool（足够大小的线程池）：</strong>即创建足够数量的线程的线程池，保证更快的进行运算，提高效率。</p>\n<h2><strong>四，线程的生命周期</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;线程的生命周期大致分为五个阶段：新建（new），就绪（Runnable），运行（Running），阻塞（Blocked），死亡（Dead）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;新建：</strong>即使用new创建一个线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>就绪：</strong>调用start方法，</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>运行：</strong>即线程获取cpu资源，执行run（）方法，进入运行状态，运行状态的线程如果调用yield（线程让步方法）或者失去cpu资源，都会导致线程重新回到就绪态；如果调用sleep方法，I/O阻塞，等待同步锁，等待通知以及suspend挂起都会导致线程进入阻塞态。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞：</strong>即线程被放入Blocked池。阻塞状态的线程如果结束了sleep方法，I/O方法返回，获取同步锁，收到通知或者resume都会导致其重新进入就绪态，与其它线程竞争cpu时间片。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>死亡：</strong>线程正常执行完run（）或者call（）方法，或者执行stop方法，或者发生异常或者错误都会导致线程死亡。（stop方法会导致锁混乱和死锁，不建议使用）</p>\n<h2><strong>五，线程的基本方法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;wait（线程等待）：</strong>会让线程进入WAITING状态，并且会释放对象的锁。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>sleep（线程睡眠）：</strong>会让线程进入睡眠，进入TIMED_WAITING状态，但是不会释放对象锁，睡眠时间到了之后，再次恢复运行状态</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>yield（线程让步）:</strong>&nbsp; 当前线程会让出其占有的cpu资源，重新回到就绪态和其它线程竞争cpu时间片</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>interrupt（线程终端）:&nbsp;&nbsp;</strong>中断当前线程，但是并不会导致其停止，只是改变其内部的终端标识位，在使用了thread.sleep()之后使用该方法，会导致抛出异常，且我们可以利用中断标识位进行线程的安全退出</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>join（线程加入）：</strong>即将当前线程进入阻塞态，等待下一个线程执行完毕后进入就绪态，重新竞争锁资源。通常用于主线程下面执行子线程，需要主线程阻塞，等待子线程执行完毕后返回其结果给主线程，主线程再执行的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>notify（线程唤醒）/notifyAll：</strong>前者随机唤醒一个等待线程，后者全部唤醒</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>setDaemon（守护线程）:</strong>级别较低的线程，用于后台运行，服务用户用户线程，例如垃圾收集线程就是典型的守护线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>sleep方法和wait方法的区别：</strong>前者属于Thread，后者属于Object，前者不会释放锁资源，后者会释放锁资源</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>start方法和run方法：</strong>start方法只是创建一个线程，并没有运行，run方法时执行线程的真正代码逻辑。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>线程退出的方式：</strong>见四中最后一条</p>\n<h2><strong>六，JAVA中的锁（知识比较杂乱）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述:JAVA中的锁是为了保护数据的一致性。按照不同的标准可分为乐观锁和悲观锁，公平锁和非公平锁，共享锁和独占锁，偏向锁，轻量级锁，重量级锁，自旋锁，可重入锁。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;乐观锁：</strong>即认为每次读取数据都不会被修改，当修改操作的时候再判断当前数据是否被修改，未修改则修改，若已被修改，则返回失败状态。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>悲观锁：</strong>即认为每次读取数据都会被修改，因而每次读取数据都对其进行加锁，这样只有当前用户可以修改，其它用户阻塞等待直到当前用户修改完毕释放锁资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>自旋锁：</strong>即有些线程任务的执行很短，很快就可以释放锁资源，为了避免在这种情况下竞争线程仍然进行内核态和用户态之间的转换，因而让线程自旋（即等一会），如果有可用锁，则获取，减少了线程在用户态和内核态之间切换的时间损耗。提高了性能（优势）。当然线程自旋是占用cpu资源的，因而需要设置一个自旋的最大等待时间，如果超过此时间，则线程退出自旋模式。对于线程竞争锁资源激烈的情况，自旋有可能会导致cpu资源的损耗（劣势）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>公平锁和非公平锁：</strong>即根据线程竞争锁资源的机制判定，一般如果依据先到先得的原则，则位公平锁；如果依据就近原则，则位非公平锁。公平锁相比于非公平锁会更加耗费性能，因为要维护一个线程任务丢列，根据线程任务在队列中的顺序分配锁资源，因而不常用。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>可重入锁：</strong>又被称为递归锁，即该锁可以然后线程对其进行多次的加锁操作。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>偏向锁：</strong>当线程获取到锁的时候，用来消除线程的锁重入的开销（看起来是偏袒这个线程）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>共享锁和独占锁：</strong>共享锁即多线程共享锁资源（典型例子，读锁）；独占锁即当前锁只能有一个线程获取，其它线程阻塞</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>轻量级锁：</strong>没有多线程竞争的前提下，减少重量级锁的使用提高性能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>重量级锁：</strong>基于操作系统的互斥量而实现的锁，会导致进程在用户态和内核态之间切换，耗费性能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>synchronized：独占式悲观锁，可重入锁，非公平锁，重量级锁。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 作用范围：</strong>作用于成员变量和非静态方法，相当于锁住的是对象的实例，即this对象</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;作用于静态方法，相当于锁住的是class实例</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;作用域代码块，相当于锁住的代码块中的对象</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>实现原理：</strong>内部包括ContentionList（锁竞争队列），EntryList（竞争候选列表），WaitSet（等待集合），OnDeck（竞争候选者），Owner，!Owner，其中ContentionList是用来存放竞争锁资源的线程。EntryList是用来存放有资格竞争锁资源的线程。调用wait方法后放入WaitSet中，onDeck指的是同一时刻，只有一个线程竞争锁资源，Owner指的是得到锁资源的线程，!Owner指的是线程执行完毕，释放锁资源的线程。需要注意的是线程首先采用的都是自旋模式获取锁资源，如果自旋获取不到再加入ContentionList，而且Owner状态的线程并不是直接把锁资源交给onDeck状态线程，而是给它竞争锁资源的权利，因而onDeck状态的线程还需要跟自旋线程竞争锁资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>ReentrantLock：独占式，可重入锁，并且可以实现公平锁和非公平锁，重量级锁。</strong></p>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;用法：</strong>lock()加锁，后跟try代码块，finally中进行释放锁unlock()</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;避免死锁的方法：</strong>响应中断（即可以根据情况中断对锁资源的请求），可轮询锁（tryLock（）即尝试获取锁，如果有可用锁则获取返回true，没有则返回。和lock（）的区别在于lock获取锁资源如果没有则一直等待直到获取到锁资源），定时所（tryLock（time,unit）即再一定时间内如果有可用锁，且线程未中断则获取锁，否则禁用当前线程。）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>Semaphore（信号量）:</strong>机制和ReentrantLock类似</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ReadWriteLock（读写锁）：</strong>如果系统要求支持多线程共享读，但不能多线程写，使用读锁；如果要求同一时刻只能有一个线程写，写的过程中不能读取该共享数据，则使用写锁。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; <strong>分段锁：</strong>一种思想，将数据分段加锁，例如ConcurrentHashMap</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;死锁：</strong>即线程之间互相共享资源会导致死锁</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; <strong>锁优化：</strong>第一，减少锁的持有时间；第二：减小锁粒度，例如分段锁；第三：锁分离，例如读写锁；第四：锁粗化，放置锁粒度太小，造成频繁加锁释放锁；第五：锁消除，消除程序代码不规范而造成的乱用了锁</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>\n<h1>水平有限，如果错误，还望指出！</h1>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;</p>","blogGoods":0,"blogId":"1249313090567143424","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6TCO-AEYrKAACh3H-d2Gc645.jpg","blogRead":4,"blogRemark":"面试（三）------之并发编程篇（上）","blogTitle":"面试（三）------之并发编程篇（上）","createdTime":"2020-04-12 12:27:07","typeName":"java面试篇","updateTime":"2020-04-12 12:57:17"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，集合</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，List：</strong>list是java中一种有序的集合，下有三个实现类，分别为ArrayList，Vector，LinkedList</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ArrayList：基于数组实现，增删慢，查询快，线程不安全。因为其基于数组实现，所以查询的时候可以直接根据数组的索引下标进行快速查询，但是进行增删操作的时候，需要将待增删元素后的元素全部移动，因而效率较低。且ArrayList创建时不需要分配初始大小，其空间不够的时候，会自动创建一个更大的list，然后复制数据。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Vector：基于数组实现，和ArrayList一样增删慢，查询快。但是线程安全，因为同一时间只支持一个线程对Vector进行写操作，然而因为要进行频繁的加锁和释放锁的操作，所以效率要低于ArrayList。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; LinkedList：基于双向链表实现，增删快，查询慢。因为基于链表实现，增删元素的时候，只需要改变元素的指针即可，改动较小，效率较高。然而进行查询操作的时候，需要从链表头部进行遍历，因而效率较低。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，Queue：</strong>队列，满足先进先出，种类较多。（不作详细解释）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，set：</strong>具有独一无二的特性，常用来存储无序且不重复的元素，对象相等的本质是hashcode的值相同，而如果想要比较两个对象是否相等，需要重写对象的hashcode方法和equals方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;hashset：基于hashTable实现，无序。存放的是对象的散列值，即通过hashcode计算得到的值</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;treeset：基于二叉树实现，即其中的对象按照一定的排序方式进行排列（升序，降序），每次添加对象的时候，都会进行排序，将其插入指定位置。基本的数据类型例如Integer，String等可以使用treeset默认的排序方法，而自定义数据类型需要实现compareable接口，实现compareTo方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;LinkHashSet：继承自hashset，只不过使用双向链表记录数据的顺序。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，map：</strong>一种键值对形式的集合</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;hashmap：基于数组+链表实现，增删改查操作快，但是每次遍历hashmap元素的顺序无法保证且线程不安全。如果想要其线程安全，可以使用synchronizedMap和ConcurrentHashmap，hashmap的内部是数组，数组中的每一个元素又是一个单向链表，链表中的每个元素嵌套一个Entry实例，其中包括Key，Value，Hash值，指向下一个节点的next。每次查询的时候，可以根据元素的hash值很快定位所在数组，但是定位之后需要遍历链表查找元素，因而时间复杂度为O（n），但是Java8之后对其进行了优化，将其改为了数组+链表或红黑树的结构，即当链表中的元素大于8个的时候，链表会转换为红黑树（红黑树是一种特化的二叉平衡树，因为其左右子树的深度差可以大于1），这样查询的时间复杂度就缩短到了O（logN）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ConcurrentHashmap：采用分段锁的思想进行并发操作，因而使线程安全的。由多个Segment组成，只要保证每个Segment线程安全就可以保证全局线程安全。ConcurrentHashmap的默认Segment即并发度为16，可以在初始化的时候修改，但是初始化之后不能再修改。每个Segment内部的实现和hashmap一样&middot;。Java8之后也和hashmap进行了一样的优化。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;HashTable：线程安全，即同一时刻只能有一个线程对其进行操作，并发度不如ConcurrentHashmap。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;TreeMap：基于二叉树数据结构实现，实现了SortedMap，默认按照键值的升序进行排列。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;LinkedHashMap：Hashmap的子类，只不过使用链表保存元素的插入顺序。使用迭代器遍历的时候按照插入顺序遍历。</p>\n<p><strong>二，异常分类及处理</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;1，异常分类：</strong>Throwable是所有异常类的父类，其下有error和Exception，Error下有AwtError，ThreadDeath；Exception下有RuntimeException和CheckedException。</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</strong>对于Error类异常通常是由内部错误和资源耗尽造成的，无法在程序运行期间对其进行捕获和处理，对于这类错误我们只能记录错误的原因和终止程序。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; Exception中的RuntimeException异常（运行时异常）：这类异常是我们程序中异常处理的核心，可以在程序中进行捕获并处理。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Exception中的CheckedException异常（检查异常）：这类异常时程序中需要强制捕获的异常，通常有IO异常，SQL异常等等。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，异常处理：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>异常处理有两种方式：抛出异常和捕获异常</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;抛出异常有三种方法：throws，throw，系统自动抛出。其中throws是作用在方法上，后面跟的是可能产生的异常类。throw是作用在方法内部，后面跟的是具体的异常对象。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 捕获异常：即使用try{}catch语句进行捕获</p>\n<p><strong>三，反射机制</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，什么叫做反射机制？</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>即在程序运行的过程中，可以获取类的属性和方法，并且可以调用任意一个类的方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，反射机制的使用</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 首先，获取类的class对象，有三种方式，className.getClass()，类对象.class，Class.forName(\"类路径\")，其中最后一种最为安全，性能最好。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 然后利用反射的API可以实现对类中信息的操作，例如getDeclareFields（），getDeclareMethods（），getConstroctors（）等等。反射创建类的对像有两种方法，一，class.newInstance()初始化一个类实例；二，先获取其构造器，然后利用构造器初始化一个实例。利用反射调用类的方法：先获取方法，然后调用method.invoke()执行方法。</p>\n<p><strong>四，注解</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，四种元注解：</strong>@Target（指定注解的使用范围），@Retention（定义注解的保留级别，有三级，SOURCE源程序中保存，CLASS文件中保存，RUNTIME运行时保存），@Documented（可以工具文档化），@Inherited（<span style=\"background-color: #ffff00;\">这个没怎么看懂</span>）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，注解使用示例：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>第一步，定义注解接口</p>\n<pre class=\"language-java\"><code>@Target(ElementType.FIELD)  \n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface FruitProvider {\n\n    //id\n    public int id() default  -1;\n\n    //供应商名称\n    public String name() default \"\";\n\n    //供应商地址\n    public String address() default \"\";\n\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 第二步，使用注解</p>\n<pre class=\"language-java\"><code>public class Apple {\n\n    @FruitProvider(id = 1,name = \"红富士苹果\",address = \"陕西\")\n    private String appleProvider;\n\n    public String getAppleProvider() {\n        return appleProvider;\n    }\n\n    public void setAppleProvider(String appleProvider) {\n        this.appleProvider = appleProvider;\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第三步，定义注解处理器</p>\n<pre class=\"language-java\"><code>public class FruitInfoUtil {\n    public static void getFruitInfo(Class&lt;?&gt; clazz) {\n        String strFruitProvider = \"供应商信息:\";\n        Field[] declaredFields = clazz.getDeclaredFields();\n        for (int i = 0; i &lt; declaredFields.length; i++) {\n            if (declaredFields[i].isAnnotationPresent(FruitProvider.class)) {\n                FruitProvider annotation = declaredFields[i].getAnnotation(FruitProvider.class);\n                strFruitProvider += annotation.id() + \",\" + annotation.name() + \",\" + annotation.address();\n                System.out.println(strFruitProvider);\n            }\n        }\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第四步，主方法入口</p>\n<pre class=\"language-java\"><code>public class FruitRun {\n    public static void main(String[] args) {\n        FruitInfoUtil.getFruitInfo(Apple.class);\n    }\n}</code></pre>\n<p><strong>五，内部类</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 1，静态内部类：</strong>即在类的内部定义的静态类，静态内部类可以访问外部了的静态变量和方法，外部也可以通过outClassName.innerClassName调用内部类</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2，成员内部类：</strong>在类的内部定义的没有用static修饰的内部类，使用方式和静态内部类一样。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>3，成员内部类：</strong>即一个类只在一个方法中使用，则完全可以将这个类定义为这个方法的内部类，即局部内部类，局部内部类可以实现真正的对外隐藏</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>4，匿名内部类：</strong>通常用于继承一个类或者实现一个接口的时候，使用new关键字定义，例如:Person person = new Student(){new Pupil(){}}</p>\n<p><strong>六，泛型</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 1，为什么要使用泛型：</strong>其根本目的是为了实现代码的复用，举个开发中常见的例子，我们需要定义返回类Result，返回类中包含状态码code，信息msg，以及数据data（任意类型），这个时候我们就需要使用泛型，因为我们返回的数据类型有各种vo，pojo类对象，list等。这时候泛型类result就可以被各种对象使用，实现代码的复用，简化开发。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>2，泛型标记和泛型限定：</strong>E表示集合中的元素，K表示键值，V表示value，N表示数值类型，T表示任意类型（包含基础类型，所有的对象类型），？（不确定的java类型）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>泛型限定：</strong>向上限定，&lt;?&nbsp; extends T&gt;，向下限定，&lt;? super&nbsp; T&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; <strong>3，泛型方法：</strong>即参数类型定义为泛型类型，以便于接收不同类型的参数，做出不同的处理。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>4，泛型类：</strong>例如public class Pair&lt;T&gt;{private T data;}</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>5，泛型接口：</strong>与放泛型类类似</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>6，类型擦除：</strong>即在泛型编译的过程中，会将泛型类型替换为限定类型的操作</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>7，明确的一点：</strong>虚拟机在运行程序的过程中，内部是没有泛型的，只有普通的类和方法。</p>\n<p><strong>7，序列化：</strong>序列化是为了确保对象及其状态的持久化</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>序列化的使用：</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </strong>首先，实现序列化接口java.io.Serializble</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 然后，声明序列化ID，通常private static final&nbsp; long&nbsp; serialVersionUid&nbsp; = ***</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 因为序列化是保证对象及其状态的持久化，而静态变量是不属于对象，属于类本身的，所以序列化无法保存静态变量。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果需要序列化父类变量，则父类也要实现Serializable接口</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t'ransient修饰的属性不会序列化</p>\n<p>&nbsp;</p>\n<h2>水平有限，如有错误，还望指出！</h2>","blogGoods":0,"blogId":"1248605157059497984","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6QdaWAWQpnAAD6cIgEnVw521.png","blogRead":17,"blogRemark":"面试（二）------之JAVA基础篇","blogTitle":"面试（二）------之JAVA基础篇","createdTime":"2020-04-10 13:34:02","typeName":"java面试篇","updateTime":"2020-04-12 09:07:59"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，Linux的发展历史</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; </strong>1965年之前，电脑并不像现在这么普遍，除了军事机构和研究即构，一般人基本接触不到电脑，而且那时候的一台大型主机最多也就只能支持30台终端。为了解决数量问题，1965年之后，由贝尔实验室，麻省理工学院以及通用电气一起放弃了Multics项目，准备让大型主机能够支持300台终端，但是在开发过程中，进度缓慢，最终由于资金的短缺，贝尔实验室推出了研究。1969年，从这个项目中退出的Ken Thompson在家无聊，为了让电脑能够运行&ldquo;星际旅行&rdquo;游戏，因而趁着妻子回家探亲的一个月，独自写出了Unix操作系统的原型（！！！！牛批）。1970年，这个人以BCPL语言为基础，又写出了很接近硬件的B语言，并且用B语言写出了第一个Unix操作系统。但是由于B语言的跨平台性比较差，为了解决这个问题。Dennis Ritchie和Ken Thompson决定以B语言为基础开发一种新的语言，1972年，Dennis Ritchie最终设计出了一种新语言，他以BCPL的第二个字母命名，也就是我们后来熟知的C语言。随后两人便迫不及待的用C语言重现Unix操作系统。Unix系统起初开源，但是在Unix7之后，由于政策的变化，代码闭源化，因而大学中不能使用Unix的源代码进行教学。Andrew S. Tanenbaum教授为了能够让学生更好的理解代码细节，在完全不使用任何源代码的情况下开发除了Minix---小型Unix。但是因为其只用于教学，功能并不强大，因而Torvalds以此为基础，开发除了Linux，但是起初Linux并不支持Unix，最终经过全世界网友的帮助，最终让其能够兼容各种硬件。</p>\n<p><strong>二，文件和目录</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; 1，windows和linux的区别：</strong>我们熟知的windows系统，它的文件系统是分盘符的，盘符下的文件构成一个树形结构，但是Linux文件系统没有盘符，所有文件目录都在根目录/之下</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;<strong>2，Linux需要记住的目录：</strong>/bin（存放系统命令的目录），/sbin（只有超级管理员能访问的命令文件目录），/root（存放和root用户相关文件的目录），/etc（存放系统配置文件的目录），/usr（存放系统共享资源的目录），/opt（存放安装的第三方软件的目录，通常在/usr/local下）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;<strong>3，文件权限：</strong>Linux中的文件权限有读（r，可用于数字4表示），写操作（w，可用数字2表示），执行权限（x，可用数字1表示）</p>\n<p><strong>三，常用命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，ls：</strong>列出目录中的所有目录和文件名&nbsp; -a（列出所有，包括隐藏文件和目录），-l（以列表形式列出所有），-h（人性化列出，需要配合-l使用，即文件大小转换为我们熟知的kb，mb等），-d（显示当前目录属性），命令可以联合使用，例如-al，-lh等等。&nbsp;&nbsp;&nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，cd：</strong>用于切换目录，需知（.和..是相对路径，.表示当前目录，..表示上级目录；/表示绝对路径），cd ~（切换到root目录），cd - （切换到前一次切换的目录）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，clear：</strong>清屏</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，pwd：</strong>显示当前所在目录</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，mkdir：</strong>创建目录，-p（如果目录存在则不创建，如果不存在则创建目录再创建自目录），可以一次性创建多级目录，例如：mkdir&nbsp; -p test/test1</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，touch：</strong>创建空文件</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>7，cp：</strong>复制，-r（递归复制目录下的文件目录信息），-i(提示是否覆盖)，-v（显示复制进度）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>8，mv：</strong>移动文件，不过经常用来给文件进行重命名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>9，rm：</strong>删除目录或者文件，-r（递归删除），-f（强制删除），-v（显示删除进度）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>10，cat：</strong>查看文件内部信息</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>11，ln：</strong>文件创建链接，ln 源文件 目标链接文件（创建硬链接，硬链接和源文件大小相同，修改同步，但是删除不同步，使用较少），ln -s（创建软连接，相当于我们平时创建快捷方式，使用较多）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>12，which：</strong>搜索命令所在位置，例如：which&nbsp; &nbsp;ls</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>13，find：</strong>搜索文件所在位置&nbsp; 例如：find&nbsp; &nbsp;test.conf</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>14，grep：</strong>文件内容搜索，例如：grep &ldquo;想要搜索的内容&rdquo;&nbsp; 源文件</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>15，tar：</strong>归档命令，-c（打包成.tar文件），-z（打包的同时压缩），-v（打包的同时显示进度），-f（放在最后，后面跟.tar.gz），-x(解压)，常用：tar -zcvf&nbsp; <em><strong>.tar.gz&nbsp; &nbsp; ;&nbsp; &nbsp; tar -zxvf</strong> tar.gz</em> -C&nbsp; 指定解压目录&nbsp;&nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;还有more，head，tail等命令，不过这些不常用。</p>\n<p><strong>四，用户权限命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，whoami：</strong>查看当前账户的用户名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，who：</strong>查看当前登录用户</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，exit：</strong>退出登录</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，adduser/useradd：</strong>添加用户，-d（指定用户主目录），-g（指定用户用户组），-m（自动建立目录），默认情况下用户主目录和用户组名都和用户名一样</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，passwd：</strong>只有root用户才能使用，用于修改用户密码</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，userdel：</strong>删除用户，默认不删除用户的主目录，-r（删除用户主目录）</p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;7，su：</strong>切换账户</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>8，groupadd/groupdel：</strong>添加用户组和删除用户组</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>9，groups：</strong>查看用户所在用户组，例如：groups&nbsp; 用户名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>10，usermod：</strong>修改用户所在用户组，例如：usermod&nbsp; 用户组名 用户名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>11，chmod：</strong>修改文件权限，例如：chmod&nbsp; 777&nbsp; test</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>12，chown：</strong>修改文件所有者，例如：chown&nbsp; &nbsp;用户&nbsp; 文件名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>13，chgrp：</strong>修改文件所在组，例如：chgrp&nbsp; 组名&nbsp; 文件名</p>\n<p><strong>五，系统命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，cal：</strong>查看日历</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，date：</strong>查看时间，可以设置格式，例如：date '+<span class=\"ql-token hljs-built_in\">%Y</span>-<span class=\"ql-token hljs-built_in\">%m</span>-<span class=\"ql-token hljs-built_in\">%d</span> <span class=\"ql-token hljs-built_in\">%H</span>:<span class=\"ql-token hljs-built_in\">%M</span>:<span class=\"ql-token hljs-built_in\">%S</span>'</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，ps：</strong>查看线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，kill：</strong>杀死线程，-9（强制杀死）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，查看网卡信息：</strong>centos6：ifconfig ；centos7：ip addr</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，ping：</strong>查看网址或者链接的连通性</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>7，防火墙：</strong>centos6：service&nbsp; iptables&nbsp; status（查看防火墙状态），service&nbsp; &nbsp;iptables&nbsp; &nbsp;start(开启),service&nbsp; iptables&nbsp; stop(关闭);centos7:firewall-cmd&nbsp; --state（查看防火墙状态），systemctl&nbsp; start&nbsp; firewalld.service(启动)，systemctl&nbsp; &nbsp;stop&nbsp; firewalld.service（关闭）</p>\n<p><strong>六，网络命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，wget：</strong>下载，例如：wget&nbsp; &nbsp;链接地址</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，yum：</strong>下载安装</p>\n<p><strong>七，vim（这里只说几个常用的命令）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;</strong>vim有三种模式：命令模式，插入模式，编辑模式&nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;vim&nbsp; 文件名：进入文件，且处于命令模式；iao任意一键进入插入模式（i表示在贯标之前插入，a光标之后插入，o在下一行插入），：进入编辑模式</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;命令：set:nu显示行号，set:nonu不显示行号；/strinng，向后搜索字符串，？string向后搜索字符串；：w保存，：wq保存并退出，：q不保存退出</p>","blogGoods":0,"blogId":"1248500061625745408","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6QE92AaLPoAADG_98SpI0054.jpg","blogRead":1,"blogRemark":"Linux基本命令总结","blogTitle":"Linux基本命令","createdTime":"2020-04-10 06:36:25","typeName":"Linux","updateTime":"2020-04-10 06:36:52"},{"blogCollection":0,"blogComment":0,"blogContent":"<p style=\"text-align: left;\"><strong>一，JVM运行机制</strong></p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;jvm即java虚拟机，一共由四个部分组成，分别是类加载器子系统，运行时数据区（程序计数器，本地方法区，jvm栈，方法区，jvm堆），执行引擎（即时编译器，垃圾收集器），本地接口库。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;一个java源程序的运行先是经过编译器将其编译成字节码文件（class文件），然后通过类加载器子系统将其加载进入jvm&mdash;&mdash;&gt;程序运行过程中，运行时数据区存放程序运行过程产生的数据&mdash;&mdash;&gt;执行引擎中的垃圾收集器收集程序运行过程中创建的不再使用的对象，即时编译器将程序的字节码文件编译成机器码&mdash;&mdash;&gt;然后本地接口库利用机器码调用本地方法库中的方法，和操作系统实现交互。</p>\n<pre><strong>二，多线程</strong></pre>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;</strong>在多核操作系统中，jvm支持一个进程中同时并发执行多个线程，且这些线程和本地操作系统的线程相对应。当jvm中的对象初始化，内存空间分配等一系列准备工作完成之后，会调用操作系统中的接口创建一个原生线程，原生线程初始化完毕后，会调用java线程的run（）方法执行该线程，线程结束之后，jvm会释放原生线程和java线程资源。</p>\n<p><strong>三，JVM的内存区域</strong></p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM的内存区域主要分为线程私有区域（程序计数器，本地方法区，JVM栈），线程共享区（方法区，JVM堆）和直接内存。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;程序计数器：线程私有区域，无内存溢出，用来记录程序运行过程中的字节码指令地址，如果是Native方法，则程序计数器为空。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM栈：线程私有区域，用来描述java程序的运行过程，java程序运行每次运行的时候，都会创建一个栈帧，方法的执行和返回对应着栈帧的入栈和出栈操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;本地方法区：线程私有区域，和JVM栈的功能一样，只不过是用来记录Native方法的运行过程。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM堆：线程共享区，主要用来存放程序运行过程中产生的数据，同时也是垃圾收集器进行垃圾回收的主要区域。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;方法区：也被称为永久代，用来存放常量，静态变量，类信息等等。</p>\n<p><strong>四，JVM的运行时内存</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>JVM的运行时内存又被称为JVM堆，因为JVM的GC算法使用的是分代收集算法，所以JVM堆按照GC标准可以分为三个区域分别为：新生代，老年代，永久代。其中新生代占1/3，老年代占2/3，永久代很少，</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;新生代：存放短生命周期，小对象的区域。新生代又分为Eden区，ServivorTo区，ServivorFrom区，区域的GC算法采用复制算法。Eden区是用来存放新创建的对象（大对象除外），ServivorTo区是用来保存MinorGC幸存下来的对象，ServivorFrom区是用来将上一次MinorGC幸存下来的对象作为下一次MinorGC的扫描对象。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;老年代：存放长生命周期的大对象，区域的GC算法采用标记整理算法</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;永久代：主要用来存放class和meta数据信息的。程序运行过程中不会进行永久代的垃圾回收，这也就导致永久代区域的数据会越来越多，最终造成内存溢出。java8之后永久代已经被元数据区取代，元数据区和永久代的功能都是一样的，但是最大的不同在于永久代区域依赖于虚拟机的内存大小，因而可以存储的class，meta信息非常有限。但是元数据区依赖的是本地操作系统，因而不会受到虚拟机内存的限制。</p>\n<p><strong>五，垃圾回收与算法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;(1)垃圾回收：</strong>Jvm的垃圾回收判定依赖于两种方法，引用计数法和可达性分析法。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;引用计数法：即如果想要在程序中使用对象，就必须赋予一个引用，这样在对象赋予引用的时候将其引用计数加1，删除一个引用时，将对象引用计数减1，如果引用计数为0，就说明该对象已经不使用，作为垃圾。但是引用计数法存在一个缺陷，即循环引用的问题，如果两个对象相互引用，则这两个对象的引用计数永远都不会为0，造成对象无法被回收。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;可达性分析法：即先创建一些根节点对象ROOTS，然后通过这些根节点对象向下搜索，如果一个对象到任意一个ROOTS之间都没有可达路径，在经过两次标记（下文解释为什么进行两次标记），还是没有可达路径，则说明该对象可回收。</p>\n<p>&nbsp;&nbsp; &nbsp;<strong>（2）GC算法：</strong>常见的GC算法有四种，分别为标记清除算法，复制算法，标记整理算法，分代收集算法</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;标记清除算法：即在进行垃圾回收前，对所有对象进行一次标记，标记可回收的对象，然后进行清理即可。但是标记清除算法在清除回收对象之后，并不会对堆内存进行整理，这样的话如果内存中的对象大部分为小对象，清理之后就会导致没有大片连续的内存空间，即造成了内存碎片化，这样大对象存储的时候就无法找到相应的完整连续内存。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;复制算法：即将内存分为两块同等大小的区域，区域1和区域2，创建的新对象都存储在区域1中，当区域1中的内存占满之后，会对内存中的所有对象进行一次标记，标记存活的对象，将存活的对象复制到区域2，这时区域1中的对象都是可回收对象，回收区域1中的所有对象即可。但是复制算法也存在着一定的缺陷，即每次都只能使用一半的内存空间，造成了大量的内存浪费。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;标记整理算法：即结合标记清除算法和复制算法的优点，先对所有的对象进行标记，标记存活的对象，将存活的对象复制到内存的另一端，然后清除当前端的对象即可。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;分代收集算法：前面的三种算法，都无法按照对象的类型进行收集，分代收集算法正是解决这个问题，按照对象的不同类型采用不同的GC算法。以JVM的分代收集算法为例，JVM的堆内存分为新生代，老年代，永久代。新生代又分为Eden区，ServivorTo区和ServivorFrom区。新生代因为其存储生</p>\n<p>命周期短的小对象，GC比较频繁，所以采用复制算法。程序运行过程中创建的对象都存储在Eden区（大对象除外，大对象直接复制到老年代区域）。当Eden区的内存不够的时候进行MinorGC，然后将Eden区和ServivorFrom区的存活对象都复制到ServivorTo区，然后将ServivorTo区和ServivorFrom</p>\n<p>区进行交换，再次进行MinorGC。老年代因为存放的都是生命周期长的大对象，因而进行GC的不会太频繁，且清除的对象并不会太多，因而采用标记整理算法。老年代每次进行MajorGC之前都会先进行一次MinorGC，当MinorGC之后新生代的内存仍然不够的时候，将对象复制到老年代进行MajorGC。</p>\n<p>永久代区域主要回收常量，无用class等。</p>\n<p><strong>六，JAVA中的四种引用类型</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;强引用类型<strong>：</strong>即把对象赋给一个引用变量，强引用的对象一定为可达状态，所以不会进行垃圾回收。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;软引用类型：通过SoftReference类实现，当内存不够的时候对其进行GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;弱引用类型：只有弱引用类型的对象，一定会被GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;虚引用类型：虚引用对象主要是用来跟踪对象的GC状态</p>\n<p><strong>七，分代收集算法和分区收集算法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>分代收集算法：新生代因其存放大量短生命周期小对象，且GC频繁，所以采用复制算法。老年代因其存放长生命周期大对象，且GC不平凡，所以采用标记整理算法。永久代，回收常量，类信息等。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;分区收集算法：即将堆内存区域分为大小不同的区，可以按照不同的区进行快速垃圾回收，减少系统的停顿时间。然后再以并行的方式逐步完成整个GC。</p>\n<p><strong>八，垃圾收集器</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>新生代区域：Serial垃圾收集器，单线程复制算法，因为单线程无需进行线程之间的交互和切换，所以效率非常高，是JVM默认的client模式下的默认垃圾回收策略，工作期间需要暂停其它所有的线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ParNew垃圾收集器，多线程复制算法，跟单线程Serial一样，是JVM默认的server模式下的垃圾回收策略，工作期间需要暂停所有其它线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Parallel Scavenge垃圾收集器：多线程复制算法，不同的是优先考虑系统吞吐量，可以利用更高效的利用CPU完成GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;老年代区域：Serial Old垃圾收集器，单线程标记整理算法，同新生代的Serial功能一样，只是采取的算法不同而已。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Parallel Old垃圾收集器：多线程标记整理算法，优先考虑了系统的吞吐量，其次考虑停顿时间。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CMS,多线程标记清除算法，优先考虑系统GC时的停顿时间，且过程分为四步（<span style=\"background-color: #ffff00;\">解释上文的可达性分析中的两次标记</span>，第一步：标记GC ROOTS可达对象，暂停其它工作线程；第二步：和用户线程一起工作，跟踪GC ROOTS；第三步，因为第二步用户进程没有暂停，所以有些对象状态</p>\n<p>可能发生了改变，重新进行标记；第四步，清除不可达对象）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; G1垃圾收集器，多线程标记整理算法，将内存分区，与CMS相比，一方面不会产生内存碎片，一方面，可以精确的控制系统停顿时间。</p>\n<p><strong>九，JAVA的网络编程模型</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;</strong>阻塞I/O模型：即用户线程发出I/O请求之后，内核会检查数据是否准备就绪，这时候用户线程始终处于阻塞状态等待数据准备就绪。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;非阻塞I/O模型：即用户线程不断的给内核发出I/O请求，内核接受到I/O请求之后会返回一个状态，如果数据准备就绪，就将数据复制进入用户线程，如果数据没有准备好，返回一个false，用户线程无需阻塞，可以去处理其它事情，而当数据准备好了且刚好用户线程发起I/O请求进行操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;多路复用I/O模型：多路复用I/O模型通过一个Selector线程轮询Socket的状态，如果Socket有读写事件，则进行I/O操作。此模型的优势在于可以更好的处理连接数众多但消息体不大的情况下。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;信号驱动I/O模型：即用户线程发出一个I/O请求，系统会为该请求创建一个信号函数，用户请求可继续执行其它业务逻辑，当内核数据准备就绪之后会返回给用户线程一个信号，用户线程接收到之后进行I/O操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;异步I/O模型：用户线程给内核发起一个asynchronous read操作，内核接收到之后，返回其请求是否成功，然后等待数据准备成功之后复制到用户线程。整个过程中请求的发起和数据读取都在内核中进行，最终发送一个信号告知用户线程I/O操作已经完成，用户直接使用数据就行。（说实话个人感</p>\n<p>觉和信号驱动很像）</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;java NIO：没怎么读懂（<span style=\"background-color: #993300;\">记得补充！</span>）</p>\n<p><strong>十，JVM的类加载机制</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>JVM类加载分为五个阶段：加载，验证，准备，解析，初始化</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;加载：即将class文件加载到JVM中，且创建class对象，封装其数据结构。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;验证：对class文件进行验证，确保符合JVM的标准，保证JVM的安全。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;准备：即方法区中给类变量分配空间和赋初值。static修改的会在初始化阶段赋值，final修饰的会在准备阶段赋值。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;解析：即将常量池中的引用替换为直接引用</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;初始化：执行类构造器进行初始化。（因为内部流程不是很清楚，所以对于其几种不进行初始化的情况不做说明）</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;类加载器：JVM提供了三种类加载器，启动类加载器（/lib），扩展类加载器(/lib/ext)，应用程序类加载器(classpath)。还可以再应用程序类加载器自定义类加载器。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;双亲委派机制：即当一个类接收到类加载请求的时候，不会自己进行加载，而是将其加载请求委派给其父类加载器，这样一路委派，最终加载请求都会委派到启动类加载器.启动类加载器接收到加载请求之后会去lib目录下寻找相关的class文件，若找不到，则将其加载请求再委培给子类加载器，一路委</p>\n<p>派，直到能够加载。</p>\n<p>&nbsp;</p>\n<h2>水平有限，若发现有误，还望指出！</h2>","blogGoods":0,"blogId":"1248224512563068928","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PEz6AUs0lAAB4ISeFCt8304.jpg","blogRead":7,"blogRemark":"面试（一）------之JVM篇","blogTitle":"面试（一）------之JVM篇","createdTime":"2020-04-09 12:21:30","typeName":"java面试篇","updateTime":"2020-04-12 12:45:18"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，css之弹性布局</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，</strong>何为弹性布局？</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 弹性布局是css的一种新的布局方式，所谓&ldquo;弹性布局&rdquo;，即页面随着不同设备的屏幕大小拉伸会自适应页面的大小。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，</strong>弹性布局的两种主要元素，container（弹性容器），item（弹性子元素），一个弹性容器中可以放入多个弹性子元素，元素之间是可以进行嵌套的，弹性子元素也可以设置为弹性容器，里面再嵌套弹性子元素。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，</strong>弹性布局的基本属性</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （1）display：flex，声明容器为弹性布局</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （2）flex-direction：声明弹性容器内部元素的排列方式，默认为row。row（横向布局），row-reverse（横向布局，但是元素反方向码），column（纵向布局），column-reverse（纵向布局，但是元素反着码）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （3）flex-wrap：声明弹性盒子中的元素是否可以换行，默认为nowrap（不换行），wrap（换行），wrap-reverse（换行，但是反着码）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （4）align-items：设置容器中元素在纵轴方向上的对齐方式，默认为stretch（即如果不设置子元素高度，则默认拉伸至于容器同宽度），flex-start（子元素位于容器的开始位置），flex-end（子元素位于容器的结尾处），center（元素依纵轴方向居中），baseline（元素位于容器基线，不过没怎么用过，所以不是很清楚）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （5）justify-content（设置元素在主轴上的对齐方式），默认为flex-start（元素从容器主轴开始位置码），flex-end（元素从容器主轴结尾处码），center（元素位于主轴居中处），space-between（元素布局在容器的两端），space-around（元素布局在容器两端，但是元素前后都留有空白）因为项目中大多数只使用了对于容器的操作，对于容器中元素的操作很少，所以这里只介绍这点。谢谢阅读！</p>","blogGoods":0,"blogId":"1248135765829918720","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6OwJOAYOmCAACSMXNdKeQ941.jpg","blogRead":2,"blogRemark":"CSS----之flex弹性布局","blogTitle":"CSS----之flex弹性布局","createdTime":"2020-04-09 06:28:51","typeName":"CSS","updateTime":"2020-04-10 13:46:01"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，前后端分离开发优势</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，</strong>项目开发过程中，前后端完全解耦，前端只需要负责页面的实现，只需要通过接口拿数据。后端不需要管页面的跳转，只需要负责接口的编写</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，</strong>前后端人员有更多的精力去负责自己的工作，前端人员可以将更多的精力投放在页面的编写，页面的美化，页面特效的制作和用户体验上；而后端人员可以将更多的精力放在接口代码的优化，sql优化，jvm调优上面</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，</strong>前后端分离的项目部署的时候，前端项目往往都是部署在nginx服务器上，而前后端不分离的项目往往都是部署再一台服务器上。因此前后端分离项目大大降低了服务器的负担</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>4，</strong>前后端不分离的项目使用模板引擎例如freemaker，thymeleaf等，前后端人员交流起来较为困难。且前端项目使用原生的DOM操作，极大的增加了前端工作人员的工作量。而前后端分离项目前端通常都是用各种ui框架，框架采用MVVM模式，极大的减轻了前端工作人员的工作量</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，</strong>前后端分离开发，前端可以通过easy-mock来伪造接口数据进行测试，后端人员可以通过postman进行接口测试，开发效率大大提升。</p>","blogGoods":0,"blogId":"1247867141693128704","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NxmWAR3lsAAB7Q44XPGk369.jpg","blogRead":7,"blogRemark":"前后端分离开发的优势所在","blogTitle":"闲谈前后端分离开发","createdTime":"2020-04-08 12:41:25","typeName":"随笔","updateTime":"2020-04-10 13:45:56"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，数据库设计--表的命名规范等</strong></p>\n<p>（1），统一采用bl_开头对表进行命名</p>\n<p>（2），对于数据比较重要的表统一添加四个字段，分别为：created_time(创建时间),update_time(修改时间),version(版本号),deleted(删除字段)</p>\n<p>（3），数据库表的字段尽量都设置为NOT_NULL</p>\n<p>（4），数据库中表varchar类型字段需要设置长度的尽量设置为2<sup>n</sup>-1</p>\n<p>（5），因为博客系统分为前台展示界面和后台管理，所以对于有些表，例如bl_type（博客类型表），bl_music（音乐表）等设置了enable（启用字段）</p>\n<p><strong>二，上述第二条--四个字段的解释</strong></p>\n<p>（1），为什么要设置created_time和update_time字段：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;其一，从数据库的通用性上来说，设计这两个字段是必要的，但也需要根据业务的需要来合理添加这两个字段，因为无用的字段会浪费空间，性能，影响系统的运行。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 其二，大部分的应用都有需要根据时间进行排序的功能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 其三，当系统发生异常的时候，我们可以通过这两个字段对异常进行排查和定位。</p>\n<p>（2），为什么要设置version字段：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 1，version字段含义：字段的含义与其字面意思一样，代表版本，在这里作为乐观锁进行使用，从而保证不会出现脏数据的情况。下面解释一下什么叫乐观锁，以及乐观锁和悲观锁</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 2，乐观锁：总是假定最好的情况，即每次用户调用接口从数据库中取出数据到修改数据前的过程中，不会有其它用户对当前数据进行修改，这样在当前用户修改数据的时候，利用版本机制即判断取出的version字段和当前数据库该条数据的version字段是否相等来判断该条数据是否已经被修改，如果未修改，则予以修改（且version字段递增），如果已经修改，则提示用户更新失败。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 悲观锁：总是假定最坏的情况，即每次用户调用接口从数据库取出数据的时候，都认为该条数据会被修改，因此每次取出数据都对数据进行加锁处理，只允许当前用户进行修改，其它用户阻塞，直到当前用户修改完毕。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3，为什么使用乐观锁而不使用悲观锁：因为悲观锁比较浪费性能</p>\n<p>（3），为什么设置deleted字段：deleted字段在这里作为一个逻辑删除字段（0否1是），何为逻辑删除，即执行删除操作操作的时候，不会真正的删除数据库中的数据，而是将deleted字段设置为1即可。&nbsp;这样如果用户出现误删的操作，可以通过数据库修改该字段进行数据的恢复。</p>\n<p><strong>三，上述第三条--数据库表字段尽量设置为NOT_NULL</strong></p>\n<p>（1），数据库表字段尽量设置为NOT_NULL：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 1，有些人可能认为设置为NULL相比于NOT_NULL不是更节省空间吗？但是实际上不是这样的，设计为NULL相比于NOT_NULL要多占用一个字节的空间</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 2，设计为NOT_NULL，这样在做查询的时候能够更好的避免空指针异常，且发生该类错误的时候能够更好的进行排查</p>\n<p><strong>四，上述第四条--表varchar类型字段长度尽量设置为2<sup>n</sup>-1</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>因为计算机只识别二进制，且有一定的范围，例如2<sup>8</sup>，在计算机中的范围为-128~127,因此对于varchar字段长度来说，如果设置为255，则正好是一个字节，而如果设置为256，则占用两个字节，这样会浪费计算机的内存空间，因此数据库varchar类型字段的长度最好设置为2<sup>n</sup>-1</p>\n<p><strong>五，上述第五条--对于设置enable字段的解释</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>enable字段，字面意思启用，在这里表明是否启用（0否1是），因为系统分为前台博客页面和后台管理，对于这两个不同的前端项目，后台可以通过启用字段来控制内容在前台博客页面的展示与否，与deleted字段不同的是，如果执行删除操作，那么我们只能通过手动修改数据库中的字段进行数据的恢复，且如果执行删除操作，则该数据在前台博客页面和后台管理页面都无法看见。但是如果将数据弃用（即修改enable字段值为1），则表明该数据被弃用，在前台博客页面无法显示，但是在后台管理页面可以看见，且无需通过手动修改数据库来恢复数据，可以在后台管理页面操作启用数据。</p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1247745014683947008","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NVHmAfuv6AADVlotocVo322.jpg","blogRead":21,"blogRemark":"博客开发总结（一）-----之数据库设计篇","blogTitle":"博客开发总结（一）-----之数据库设计篇","createdTime":"2020-04-08 04:36:07","typeName":"博客开发和维护总结","updateTime":"2020-04-12 12:57:33"}],"pageSize":15,"params":{},"sortColumn":"created_time","sortMethod":"DESC","totalCount":15,"totalPage":1},"msg":"操作成功!"}
