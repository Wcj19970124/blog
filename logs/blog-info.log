2020-04-26 22:22:42.280 INFO  [restartedMain]com.wcj.BlogApplication.logStarting:55 -Starting BlogApplication on LAPTOP-SF80F1HO with PID 26612 (D:\MyBlog\blog\target\classes started by 邬成军 in D:\MyBlog\blog)
2020-04-26 22:22:42.294 INFO  [restartedMain]com.wcj.BlogApplication.logStartupProfileInfo:655 -The following profiles are active: pro
2020-04-26 22:22:42.408 INFO  [restartedMain]o.s.b.devtools.env.DevToolsPropertyDefaultsPostProcessor.logTo:225 -Devtools property defaults active! Set 'spring.devtools.add-properties' to 'false' to disable
2020-04-26 22:22:42.409 INFO  [restartedMain]o.s.b.devtools.env.DevToolsPropertyDefaultsPostProcessor.logTo:225 -For additional web related logging consider setting the 'logging.level.web' property to 'DEBUG'
2020-04-26 22:22:44.043 INFO  [restartedMain]o.s.d.repository.config.RepositoryConfigurationDelegate.registerRepositoriesIn:127 -Bootstrapping Spring Data MongoDB repositories in DEFAULT mode.
2020-04-26 22:22:44.328 INFO  [restartedMain]o.s.d.repository.config.RepositoryConfigurationDelegate.registerRepositoriesIn:187 -Finished Spring Data repository scanning in 271ms. Found 4 MongoDB repository interfaces.
2020-04-26 22:22:45.518 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'shiroConfig' of type [com.wcj.config.ShiroConfig$$EnhancerBySpringCGLIB$$5a76d866] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:45.573 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'hashedCredentialsMatcher' of type [org.apache.shiro.authc.credential.HashedCredentialsMatcher] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:45.632 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mybatis-org.mybatis.spring.boot.autoconfigure.MybatisProperties' of type [org.mybatis.spring.boot.autoconfigure.MybatisProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:45.648 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration' of type [org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration$$EnhancerBySpringCGLIB$$b728da0d] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:45.660 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceAutoConfigure' of type [com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceAutoConfigure$$EnhancerBySpringCGLIB$$9e007e4f] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:45.667 INFO  [restartedMain]c.a.d.s.boot.autoconfigure.DruidDataSourceAutoConfigure.dataSource:56 -Init DruidDataSource
2020-04-26 22:22:45.818 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'spring.datasource-org.springframework.boot.autoconfigure.jdbc.DataSourceProperties' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:45.839 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'com.alibaba.druid.spring.boot.autoconfigure.stat.DruidFilterConfiguration' of type [com.alibaba.druid.spring.boot.autoconfigure.stat.DruidFilterConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:45.912 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'statFilter' of type [com.alibaba.druid.filter.stat.StatFilter] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:50.454 INFO  [restartedMain]com.alibaba.druid.pool.DruidDataSource.init:930 -{dataSource-1} inited
2020-04-26 22:22:50.455 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'dataSource' of type [com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceWrapper] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:50.629 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:51.261 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'sqlSessionFactory' of type [org.apache.ibatis.session.defaults.DefaultSqlSessionFactory] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:51.282 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'sqlSessionTemplate' of type [org.mybatis.spring.SqlSessionTemplate] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:51.309 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'adminMapper' of type [org.mybatis.spring.mapper.MapperFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:51.320 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'adminMapper' of type [com.sun.proxy.$Proxy92] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:51.326 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'adminServiceImpl' of type [com.wcj.service.impl.AdminServiceImpl] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:51.336 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'userMapper' of type [org.mybatis.spring.mapper.MapperFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:51.338 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'userMapper' of type [com.sun.proxy.$Proxy95] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:51.384 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#7541ba7e' of type [org.springframework.beans.factory.config.PropertiesFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:51.390 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#7541ba7e' of type [java.util.Properties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:51.461 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#1f503b74' of type [org.springframework.data.repository.core.support.PropertiesBasedNamedQueries] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:51.469 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#56464c33' of type [org.springframework.data.repository.core.support.RepositoryFragmentsFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:51.479 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#56464c33' of type [org.springframework.data.repository.core.support.RepositoryComposition$RepositoryFragments] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:51.538 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'spring.data.mongodb-org.springframework.boot.autoconfigure.mongo.MongoProperties' of type [org.springframework.boot.autoconfigure.mongo.MongoProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:51.543 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.data.mongo.MongoDbFactoryDependentConfiguration' of type [org.springframework.boot.autoconfigure.data.mongo.MongoDbFactoryDependentConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:51.548 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.data.mongo.MongoDbFactoryConfiguration' of type [org.springframework.boot.autoconfigure.data.mongo.MongoDbFactoryConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:51.554 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration' of type [org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:51.769 INFO  [restartedMain]org.mongodb.driver.cluster.info:71 -Cluster created with settings {hosts=[121.199.34.159:27017], mode=MULTIPLE, requiredClusterType=UNKNOWN, serverSelectionTimeout='30000 ms', maxWaitQueueSize=500}
2020-04-26 22:22:51.771 INFO  [restartedMain]org.mongodb.driver.cluster.info:71 -Adding discovered server 121.199.34.159:27017 to client view of cluster
2020-04-26 22:22:51.886 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongo' of type [com.mongodb.MongoClient] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:51.911 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongoDbFactory' of type [org.springframework.data.mongodb.core.SimpleMongoDbFactory] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:51.931 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.data.mongo.MongoDataConfiguration' of type [org.springframework.boot.autoconfigure.data.mongo.MongoDataConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:52.030 INFO  [cluster-ClusterId{value='5ea5993b2f68362ca88cd116', description='null'}-121.199.34.159:27017]org.mongodb.driver.connection.info:71 -Opened connection [connectionId{localValue:1, serverValue:612}] to 121.199.34.159:27017
2020-04-26 22:22:52.078 INFO  [cluster-ClusterId{value='5ea5993b2f68362ca88cd116', description='null'}-121.199.34.159:27017]org.mongodb.driver.cluster.info:71 -Monitor thread successfully connected to server with description ServerDescription{address=121.199.34.159:27017, type=STANDALONE, state=CONNECTED, ok=true, version=ServerVersion{versionList=[4, 2, 5]}, minWireVersion=0, maxWireVersion=8, maxDocumentSize=16777216, logicalSessionTimeoutMinutes=30, roundTripTimeNanos=44922200}
2020-04-26 22:22:52.082 INFO  [cluster-ClusterId{value='5ea5993b2f68362ca88cd116', description='null'}-121.199.34.159:27017]org.mongodb.driver.cluster.info:71 -Discovered cluster type of STANDALONE
2020-04-26 22:22:52.177 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongoCustomConversions' of type [org.springframework.data.mongodb.core.convert.MongoCustomConversions] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:52.237 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongoMappingContext' of type [org.springframework.data.mongodb.core.mapping.MongoMappingContext] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:52.331 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mappingMongoConverter' of type [org.springframework.data.mongodb.core.convert.MappingMongoConverter] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:52.470 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongoTemplate' of type [org.springframework.data.mongodb.core.MongoTemplate] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:52.883 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'blogCollectionDao' of type [org.springframework.data.mongodb.repository.support.MongoRepositoryFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:52.899 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'blogCollectionDao' of type [com.sun.proxy.$Proxy110] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:52.940 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'typeMapper' of type [org.mybatis.spring.mapper.MapperFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:52.941 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'typeMapper' of type [com.sun.proxy.$Proxy112] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:52.947 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#758fae03' of type [org.springframework.beans.factory.config.PropertiesFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:52.948 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#758fae03' of type [java.util.Properties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:52.950 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#761cb7ec' of type [org.springframework.data.repository.core.support.PropertiesBasedNamedQueries] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:52.952 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#a325d97' of type [org.springframework.data.repository.core.support.RepositoryFragmentsFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:52.953 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#a325d97' of type [org.springframework.data.repository.core.support.RepositoryComposition$RepositoryFragments] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:52.976 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'commentDao' of type [org.springframework.data.mongodb.repository.support.MongoRepositoryFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:52.977 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'commentDao' of type [com.sun.proxy.$Proxy116] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:53.006 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'userServiceImpl' of type [com.wcj.service.impl.UserServiceImpl] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:53.028 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'adminRealm' of type [com.wcj.realm.AdminRealm] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:53.088 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'securityManager' of type [org.apache.shiro.web.mgt.DefaultWebSecurityManager] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 22:22:53.629 INFO  [restartedMain]o.s.boot.web.embedded.tomcat.TomcatWebServer.initialize:92 -Tomcat initialized with port(s): 1000 (http)
2020-04-26 22:22:53.645 INFO  [restartedMain]org.apache.coyote.http11.Http11NioProtocol.log:173 -Initializing ProtocolHandler ["http-nio-1000"]
2020-04-26 22:22:53.646 INFO  [restartedMain]org.apache.catalina.core.StandardService.log:173 -Starting service [Tomcat]
2020-04-26 22:22:53.647 INFO  [restartedMain]org.apache.catalina.core.StandardEngine.log:173 -Starting Servlet engine: [Apache Tomcat/9.0.31]
2020-04-26 22:22:53.651 INFO  [restartedMain]org.apache.catalina.core.AprLifecycleListener.log:173 -Loaded APR based Apache Tomcat Native library [1.2.23] using APR version [1.7.0].
2020-04-26 22:22:53.652 INFO  [restartedMain]org.apache.catalina.core.AprLifecycleListener.log:173 -APR capabilities: IPv6 [true], sendfile [true], accept filters [false], random [true].
2020-04-26 22:22:53.652 INFO  [restartedMain]org.apache.catalina.core.AprLifecycleListener.log:173 -APR/OpenSSL configuration: useAprConnector [false], useOpenSSL [true]
2020-04-26 22:22:53.674 INFO  [restartedMain]org.apache.catalina.core.AprLifecycleListener.log:173 -OpenSSL successfully initialized [OpenSSL 1.1.1c  28 May 2019]
2020-04-26 22:22:53.857 INFO  [restartedMain]o.a.catalina.core.ContainerBase.[Tomcat].[localhost].[/].log:173 -Initializing Spring embedded WebApplicationContext
2020-04-26 22:22:53.858 INFO  [restartedMain]org.springframework.web.context.ContextLoader.prepareWebApplicationContext:284 -Root WebApplicationContext: initialization completed in 11448 ms
2020-04-26 22:22:54.105 INFO  [restartedMain]o.s.boot.devtools.autoconfigure.OptionalLiveReloadServer.startServer:58 -LiveReload server is running on port 35729
2020-04-26 22:22:56.482 INFO  [restartedMain]org.apache.coyote.http11.Http11NioProtocol.log:173 -Starting ProtocolHandler ["http-nio-1000"]
2020-04-26 22:22:56.529 INFO  [restartedMain]o.s.boot.web.embedded.tomcat.TomcatWebServer.start:204 -Tomcat started on port(s): 1000 (http) with context path ''
2020-04-26 22:22:56.533 INFO  [restartedMain]com.wcj.BlogApplication.logStarted:61 -Started BlogApplication in 15.314 seconds (JVM running for 17.716)
2020-04-26 22:23:13.809 INFO  [http-nio-1000-exec-1]o.a.catalina.core.ContainerBase.[Tomcat].[localhost].[/].log:173 -Initializing Spring DispatcherServlet 'dispatcherServlet'
2020-04-26 22:23:13.809 INFO  [http-nio-1000-exec-1]org.springframework.web.servlet.DispatcherServlet.initServletBean:525 -Initializing Servlet 'dispatcherServlet'
2020-04-26 22:23:13.823 INFO  [http-nio-1000-exec-1]org.springframework.web.servlet.DispatcherServlet.initServletBean:547 -Completed initialization in 13 ms
2020-04-26 22:23:13.942 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /admin/login
2020-04-26 22:23:13.943 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 22:23:13.945 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 22:23:13.947 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.AdminController.login
2020-04-26 22:23:13.948 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Admin(id=null, name=null, header=null, signature=null, comment=null, username=admin, password=admin)]
2020-04-26 22:23:14.195 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 254
2020-04-26 22:23:14.274 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"token":"CBE73F58A4E9280E56CF8E1E3FDE26BD"},"msg":"操作成功!"}
2020-04-26 22:23:14.791 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /admin/info
2020-04-26 22:23:14.791 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 22:23:14.792 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 22:23:14.792 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.AdminController.getAdminInfo
2020-04-26 22:23:14.793 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 22:23:14.793 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 2
2020-04-26 22:23:14.798 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"header":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMSKACehsAACHOzTvceE295.jpg","name":"小屋","password":"","signature":"时光好不经用，转眼已是半生","username":"admin"},"msg":"操作成功!"}
2020-04-26 22:23:15.098 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listFront
2020-04-26 22:23:15.099 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 22:23:15.100 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 22:23:15.100 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeLists
2020-04-26 22:23:15.101 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 22:23:15.210 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 112
2020-04-26 22:23:15.214 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":1,"typeName":"Linux"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":2,"typeName":"Docker"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"SpringBoot"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":4,"typeName":"Mybatis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":5,"typeName":"爬虫"},{"deleted":0,"enable":1,"typeBlogCount":4,"typeId":6,"typeName":"博客开发和维护总结"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":7,"typeName":"CSS"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"JavaScript"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Vue"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":10,"typeName":"随笔"},{"deleted":0,"enable":1,"typeBlogCount":16,"typeId":11,"typeName":"java面试篇"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":13,"typeName":"JDK源码阅读"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":14,"typeName":"redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":15,"typeName":"MongoDB"},{"deleted":0,"enable":1,"typeBlogCount":28,"typeId":16,"typeName":"LeetCode"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":17,"typeName":"随心日记"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":18,"typeName":"计算机网络"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":19,"typeName":"操作系统"}],"msg":"操作成功!"}
2020-04-26 22:23:15.400 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/blog-statistic
2020-04-26 22:23:15.401 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 22:23:15.402 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 22:23:15.402 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogStatistic
2020-04-26 22:23:15.403 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 22:23:15.404 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/popular-statistic
2020-04-26 22:23:15.405 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 22:23:15.406 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 22:23:15.407 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogPopularStatistic
2020-04-26 22:23:15.407 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 22:23:15.505 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 101
2020-04-26 22:23:15.508 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"blogTitle":"面试（二）-----","count":27},{"blogTitle":"博客开发总结（一）-","count":21},{"blogTitle":"面试（三）-----","count":17},{"blogTitle":"面试（一）-----","count":17},{"blogTitle":"面试（三）-----","count":8}],"msg":"操作成功!"}
2020-04-26 22:23:15.508 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 109
2020-04-26 22:23:15.511 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"blogNumber":53,"month":"04"}],"msg":"操作成功!"}
2020-04-26 22:23:23.104 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/list
2020-04-26 22:23:23.104 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 22:23:23.105 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 22:23:23.105 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogList
2020-04-26 22:23:23.105 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=ASC)]
2020-04-26 22:23:23.529 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 425
2020-04-26 22:23:23.538 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，数据库设计--表的命名规范等</strong></p>\n<p>（1），统一采用bl_开头对表进行命名</p>\n<p>（2），对于数据比较重要的表统一添加四个字段，分别为：created_time(创建时间),update_time(修改时间),version(版本号),deleted(删除字段)</p>\n<p>（3），数据库表的字段尽量都设置为NOT_NULL</p>\n<p>（4），数据库中表varchar类型字段需要设置长度的尽量设置为2<sup>n</sup>-1</p>\n<p>（5），因为博客系统分为前台展示界面和后台管理，所以对于有些表，例如bl_type（博客类型表），bl_music（音乐表）等设置了enable（启用字段）</p>\n<p><strong>二，上述第二条--四个字段的解释</strong></p>\n<p>（1），为什么要设置created_time和update_time字段：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;其一，从数据库的通用性上来说，设计这两个字段是必要的，但也需要根据业务的需要来合理添加这两个字段，因为无用的字段会浪费空间，性能，影响系统的运行。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 其二，大部分的应用都有需要根据时间进行排序的功能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 其三，当系统发生异常的时候，我们可以通过这两个字段对异常进行排查和定位。</p>\n<p>（2），为什么要设置version字段：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 1，version字段含义：字段的含义与其字面意思一样，代表版本，在这里作为乐观锁进行使用，从而保证不会出现脏数据的情况。下面解释一下什么叫乐观锁，以及乐观锁和悲观锁</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 2，乐观锁：总是假定最好的情况，即每次用户调用接口从数据库中取出数据到修改数据前的过程中，不会有其它用户对当前数据进行修改，这样在当前用户修改数据的时候，利用版本机制即判断取出的version字段和当前数据库该条数据的version字段是否相等来判断该条数据是否已经被修改，如果未修改，则予以修改（且version字段递增），如果已经修改，则提示用户更新失败。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 悲观锁：总是假定最坏的情况，即每次用户调用接口从数据库取出数据的时候，都认为该条数据会被修改，因此每次取出数据都对数据进行加锁处理，只允许当前用户进行修改，其它用户阻塞，直到当前用户修改完毕。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3，为什么使用乐观锁而不使用悲观锁：因为悲观锁比较浪费性能</p>\n<p>（3），为什么设置deleted字段：deleted字段在这里作为一个逻辑删除字段（0否1是），何为逻辑删除，即执行删除操作操作的时候，不会真正的删除数据库中的数据，而是将deleted字段设置为1即可。&nbsp;这样如果用户出现误删的操作，可以通过数据库修改该字段进行数据的恢复。</p>\n<p><strong>三，上述第三条--数据库表字段尽量设置为NOT_NULL</strong></p>\n<p>（1），数据库表字段尽量设置为NOT_NULL：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 1，有些人可能认为设置为NULL相比于NOT_NULL不是更节省空间吗？但是实际上不是这样的，设计为NULL相比于NOT_NULL要多占用一个字节的空间</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 2，设计为NOT_NULL，这样在做查询的时候能够更好的避免空指针异常，且发生该类错误的时候能够更好的进行排查</p>\n<p><strong>四，上述第四条--表varchar类型字段长度尽量设置为2<sup>n</sup>-1</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>因为计算机只识别二进制，且有一定的范围，例如2<sup>8</sup>，在计算机中的范围为-128~127,因此对于varchar字段长度来说，如果设置为255，则正好是一个字节，而如果设置为256，则占用两个字节，这样会浪费计算机的内存空间，因此数据库varchar类型字段的长度最好设置为2<sup>n</sup>-1</p>\n<p><strong>五，上述第五条--对于设置enable字段的解释</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>enable字段，字面意思启用，在这里表明是否启用（0否1是），因为系统分为前台博客页面和后台管理，对于这两个不同的前端项目，后台可以通过启用字段来控制内容在前台博客页面的展示与否，与deleted字段不同的是，如果执行删除操作，那么我们只能通过手动修改数据库中的字段进行数据的恢复，且如果执行删除操作，则该数据在前台博客页面和后台管理页面都无法看见。但是如果将数据弃用（即修改enable字段值为1），则表明该数据被弃用，在前台博客页面无法显示，但是在后台管理页面可以看见，且无需通过手动修改数据库来恢复数据，可以在后台管理页面操作启用数据。</p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1247745014683947008","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dDViAcnjvAACb6PL1tzA485.jpg","blogRead":21,"blogRemark":"博客开发总结（一）-----之数据库设计篇","blogTitle":"博客开发总结（一）-----之数据库设计篇","createdTime":"2020-04-08 04:36:07","typeName":"博客开发和维护总结","updateTime":"2020-04-20 10:47:54"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，前后端分离开发优势</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，</strong>项目开发过程中，前后端完全解耦，前端只需要负责页面的实现，只需要通过接口拿数据。后端不需要管页面的跳转，只需要负责接口的编写</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，</strong>前后端人员有更多的精力去负责自己的工作，前端人员可以将更多的精力投放在页面的编写，页面的美化，页面特效的制作和用户体验上；而后端人员可以将更多的精力放在接口代码的优化，sql优化，jvm调优上面</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，</strong>前后端分离的项目部署的时候，前端项目往往都是部署在nginx服务器上，而前后端不分离的项目往往都是部署再一台服务器上。因此前后端分离项目大大降低了服务器的负担</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>4，</strong>前后端不分离的项目使用模板引擎例如freemaker，thymeleaf等，前后端人员交流起来较为困难。且前端项目使用原生的DOM操作，极大的增加了前端工作人员的工作量。而前后端分离项目前端通常都是用各种ui框架，框架采用MVVM模式，极大的减轻了前端工作人员的工作量</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，</strong>前后端分离开发，前端可以通过easy-mock来伪造接口数据进行测试，后端人员可以通过postman进行接口测试，开发效率大大提升。</p>","blogGoods":0,"blogId":"1247867141693128704","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dG6CAI6ipAACiM2P5LtI65.jpeg","blogRead":7,"blogRemark":"前后端分离开发的优势所在","blogTitle":"闲谈前后端分离开发","createdTime":"2020-04-08 12:41:25","typeName":"随笔","updateTime":"2020-04-20 11:48:53"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，css之弹性布局</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，</strong>何为弹性布局？</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 弹性布局是css的一种新的布局方式，所谓&ldquo;弹性布局&rdquo;，即页面随着不同设备的屏幕大小拉伸会自适应页面的大小。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，</strong>弹性布局的两种主要元素，container（弹性容器），item（弹性子元素），一个弹性容器中可以放入多个弹性子元素，元素之间是可以进行嵌套的，弹性子元素也可以设置为弹性容器，里面再嵌套弹性子元素。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，</strong>弹性布局的基本属性</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （1）display：flex，声明容器为弹性布局</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （2）flex-direction：声明弹性容器内部元素的排列方式，默认为row。row（横向布局），row-reverse（横向布局，但是元素反方向码），column（纵向布局），column-reverse（纵向布局，但是元素反着码）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （3）flex-wrap：声明弹性盒子中的元素是否可以换行，默认为nowrap（不换行），wrap（换行），wrap-reverse（换行，但是反着码）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （4）align-items：设置容器中元素在纵轴方向上的对齐方式，默认为stretch（即如果不设置子元素高度，则默认拉伸至于容器同宽度），flex-start（子元素位于容器的开始位置），flex-end（子元素位于容器的结尾处），center（元素依纵轴方向居中），baseline（元素位于容器基线，不过没怎么用过，所以不是很清楚）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （5）justify-content（设置元素在主轴上的对齐方式），默认为flex-start（元素从容器主轴开始位置码），flex-end（元素从容器主轴结尾处码），center（元素位于主轴居中处），space-between（元素布局在容器的两端），space-around（元素布局在容器两端，但是元素前后都留有空白）因为项目中大多数只使用了对于容器的操作，对于容器中元素的操作很少，所以这里只介绍这点。谢谢阅读！</p>","blogGoods":0,"blogId":"1248135765829918720","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dGnuAWkLLAAAaRXQXNms575.jpg","blogRead":3,"blogRemark":"CSS----之flex弹性布局","blogTitle":"CSS----之flex弹性布局","createdTime":"2020-04-09 06:28:51","typeName":"CSS","updateTime":"2020-04-20 11:43:57"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2 style=\"text-align: left;\"><strong>一，JVM运行机制</strong></h2>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;jvm即java虚拟机，一共由四个部分组成，分别是类加载器子系统，运行时数据区（程序计数器，本地方法区，jvm栈，方法区，jvm堆），执行引擎（即时编译器，垃圾收集器），本地接口库。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;一个java源程序的运行先是经过编译器将其编译成字节码文件（class文件），然后通过类加载器子系统将其加载进入jvm&mdash;&mdash;&gt;程序运行过程中，运行时数据区存放程序运行过程产生的数据&mdash;&mdash;&gt;执行引擎中的垃圾收集器收集程序运行过程中创建的不再使用的对象，即时编译器将程序的字节码文件编译成机器码&mdash;&mdash;&gt;然后本地接口库利用机器码调用本地方法库中的方法，和操作系统实现交互。</p>\n<h2><strong>二，多线程</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;</strong>在多核操作系统中，jvm支持一个进程中同时并发执行多个线程，且这些线程和本地操作系统的线程相对应。当jvm中的对象初始化，内存空间分配等一系列准备工作完成之后，会调用操作系统中的接口创建一个原生线程，原生线程初始化完毕后，会调用java线程的run（）方法执行该线程，线程结束之后，jvm会释放原生线程和java线程资源。</p>\n<h2><strong>三，JVM的内存区域</strong></h2>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM的内存区域主要分为线程私有区域（程序计数器，本地方法区，JVM栈），线程共享区（方法区，JVM堆）和直接内存。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;程序计数器：线程私有区域，无内存溢出，用来记录程序运行过程中的字节码指令地址，如果是Native方法，则程序计数器为空。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM栈：线程私有区域，用来描述java程序的运行过程，java程序运行每次运行的时候，都会创建一个栈帧，方法的执行和返回对应着栈帧的入栈和出栈操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;本地方法区：线程私有区域，和JVM栈的功能一样，只不过是用来记录Native方法的运行过程。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM堆：线程共享区，主要用来存放程序运行过程中产生的数据，同时也是垃圾收集器进行垃圾回收的主要区域。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;方法区：也被称为永久代，用来存放常量，静态变量，类信息等等。</p>\n<h2><strong>四，JVM的运行时内存</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>JVM的运行时内存又被称为JVM堆，因为JVM的GC算法使用的是分代收集算法，所以JVM堆按照GC标准可以分为三个区域分别为：新生代，老年代，永久代。其中新生代占1/3，老年代占2/3，永久代很少，</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;新生代：存放短生命周期，小对象的区域。新生代又分为Eden区，ServivorTo区，ServivorFrom区，区域的GC算法采用复制算法。Eden区是用来存放新创建的对象（大对象除外），ServivorTo区是用来保存MinorGC幸存下来的对象，ServivorFrom区是用来将上一次MinorGC幸存下来的对象作为下一次MinorGC的扫描对象。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;老年代：存放长生命周期的大对象，区域的GC算法采用标记整理算法</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;永久代：主要用来存放class和meta数据信息的。程序运行过程中不会进行永久代的垃圾回收，这也就导致永久代区域的数据会越来越多，最终造成内存溢出。java8之后永久代已经被元数据区取代，元数据区和永久代的功能都是一样的，但是最大的不同在于永久代区域依赖于虚拟机的内存大小，因而可以存储的class，meta信息非常有限。但是元数据区依赖的是本地操作系统，因而不会受到虚拟机内存的限制。</p>\n<h2><strong>五，垃圾回收与算法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;(1)垃圾回收：</strong>Jvm的垃圾回收判定依赖于两种方法，引用计数法和可达性分析法。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;引用计数法：即如果想要在程序中使用对象，就必须赋予一个引用，这样在对象赋予引用的时候将其引用计数加1，删除一个引用时，将对象引用计数减1，如果引用计数为0，就说明该对象已经不使用，作为垃圾。但是引用计数法存在一个缺陷，即循环引用的问题，如果两个对象相互引用，则这两个对象的引用计数永远都不会为0，造成对象无法被回收。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;可达性分析法：即先创建一些根节点对象ROOTS，然后通过这些根节点对象向下搜索，如果一个对象到任意一个ROOTS之间都没有可达路径，在经过两次标记（下文解释为什么进行两次标记），还是没有可达路径，则说明该对象可回收。</p>\n<p>&nbsp;&nbsp; &nbsp;<strong>（2）GC算法：</strong>常见的GC算法有四种，分别为标记清除算法，复制算法，标记整理算法，分代收集算法</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;标记清除算法：即在进行垃圾回收前，对所有对象进行一次标记，标记可回收的对象，然后进行清理即可。但是标记清除算法在清除回收对象之后，并不会对堆内存进行整理，这样的话如果内存中的对象大部分为小对象，清理之后就会导致没有大片连续的内存空间，即造成了内存碎片化，这样大对象存储的时候就无法找到相应的完整连续内存。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;复制算法：即将内存分为两块同等大小的区域，区域1和区域2，创建的新对象都存储在区域1中，当区域1中的内存占满之后，会对内存中的所有对象进行一次标记，标记存活的对象，将存活的对象复制到区域2，这时区域1中的对象都是可回收对象，回收区域1中的所有对象即可。但是复制算法也存在着一定的缺陷，即每次都只能使用一半的内存空间，造成了大量的内存浪费。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;标记整理算法：即结合标记清除算法和复制算法的优点，先对所有的对象进行标记，标记存活的对象，将存活的对象复制到内存的另一端，然后清除当前端的对象即可。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;分代收集算法：前面的三种算法，都无法按照对象的类型进行收集，分代收集算法正是解决这个问题，按照对象的不同类型采用不同的GC算法。以JVM的分代收集算法为例，JVM的堆内存分为新生代，老年代，永久代。新生代又分为Eden区，ServivorTo区和ServivorFrom区。新生代因为其存储生命周期短的小对象，GC比较频繁，所以采用复制算法。程序运行过程中创建的对象都存储在Eden区（大对象除外，大对象直接复制到老年代区域）。当Eden区的内存不够的时候进行MinorGC，然后将Eden区和ServivorFrom区的存活对象都复制到ServivorTo区，然后将ServivorTo区和ServivorFrom区进行交换，再次进行MinorGC。老年代因为存放的都是生命周期长的大对象，因而进行GC的不会太频繁，且清除的对象并不会太多，因而采用标记整理算法。老年代每次进行MajorGC之前都会先进行一次MinorGC，当MinorGC之后新生代的内存仍然不够的时候，将对象复制到老年代进行MajorGC。永久代区域主要回收常量，无用class等。</p>\n<h2><strong>六，JAVA中的四种引用类型</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;强引用类型<strong>：</strong>即把对象赋给一个引用变量，强引用的对象一定为可达状态，所以不会进行垃圾回收。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;软引用类型：通过SoftReference类实现，当内存不够的时候对其进行GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;弱引用类型：只有弱引用类型的对象，一定会被GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;虚引用类型：虚引用对象主要是用来跟踪对象的GC状态</p>\n<h2><strong>七，分代收集算法和分区收集算法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>分代收集算法：新生代因其存放大量短生命周期小对象，且GC频繁，所以采用复制算法。老年代因其存放长生命周期大对象，且GC不平凡，所以采用标记整理算法。永久代，回收常量，类信息等。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;分区收集算法：即将堆内存区域分为大小不同的区，可以按照不同的区进行快速垃圾回收，减少系统的停顿时间。然后再以并行的方式逐步完成整个GC。</p>\n<h2><strong>八，垃圾收集器</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>新生代区域：Serial垃圾收集器，单线程复制算法，因为单线程无需进行线程之间的交互和切换，所以效率非常高，是JVM默认的client模式下的默认垃圾回收策略，工作期间需要暂停其它所有的线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ParNew垃圾收集器，多线程复制算法，跟单线程Serial一样，是JVM默认的server模式下的垃圾回收策略，工作期间需要暂停所有其它线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Parallel Scavenge垃圾收集器：多线程复制算法，不同的是优先考虑系统吞吐量，可以利用更高效的利用CPU完成GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;老年代区域：Serial Old垃圾收集器，单线程标记整理算法，同新生代的Serial功能一样，只是采取的算法不同而已。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Parallel Old垃圾收集器：多线程标记整理算法，优先考虑了系统的吞吐量，其次考虑停顿时间。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CMS,多线程标记清除算法，优先考虑系统GC时的停顿时间，且过程分为四步（<span style=\"background-color: #ffff00;\">解释上文的可达性分析中的两次标记</span>，第一步：标记GC ROOTS可达对象，暂停其它工作线程；第二步：和用户线程一起工作，跟踪GC ROOTS；第三步，因为第二步用户进程没有暂停，所以有些对象状态</p>\n<p>可能发生了改变，重新进行标记；第四步，清除不可达对象）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; G1垃圾收集器，多线程标记整理算法，将内存分区，与CMS相比，一方面不会产生内存碎片，一方面，可以精确的控制系统停顿时间。</p>\n<h2><strong>九，JAVA的网络编程模型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;</strong>阻塞I/O模型：即用户线程发出I/O请求之后，内核会检查数据是否准备就绪，这时候用户线程始终处于阻塞状态等待数据准备就绪。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;非阻塞I/O模型：即用户线程不断的给内核发出I/O请求，内核接受到I/O请求之后会返回一个状态，如果数据准备就绪，就将数据复制进入用户线程，如果数据没有准备好，返回一个false，用户线程无需阻塞，可以去处理其它事情，而当数据准备好了且刚好用户线程发起I/O请求进行操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;多路复用I/O模型：多路复用I/O模型通过一个Selector线程轮询Socket的状态，如果Socket有读写事件，则进行I/O操作。此模型的优势在于可以更好的处理连接数众多但消息体不大的情况下。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;信号驱动I/O模型：即用户线程发出一个I/O请求，系统会为该请求创建一个信号函数，用户请求可继续执行其它业务逻辑，当内核数据准备就绪之后会返回给用户线程一个信号，用户线程接收到之后进行I/O操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;异步I/O模型：用户线程给内核发起一个asynchronous read操作，内核接收到之后，返回其请求是否成功，然后等待数据准备成功之后复制到用户线程。整个过程中请求的发起和数据读取都在内核中进行，最终发送一个信号告知用户线程I/O操作已经完成，用户直接使用数据就行。（说实话个人感</p>\n<p>觉和信号驱动很像）</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;java NIO：没怎么读懂（<span style=\"background-color: #993300;\">记得补充！</span>）</p>\n<h2><strong>十，JVM的类加载机制</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>JVM类加载分为五个阶段：加载，验证，准备，解析，初始化</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;加载：即将class文件加载到JVM中，且创建class对象，封装其数据结构。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;验证：对class文件进行验证，确保符合JVM的标准，保证JVM的安全。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;准备：即方法区中给类变量分配空间和赋初值。static修改的会在初始化阶段赋值，final修饰的会在准备阶段赋值。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;解析：即将常量池中的引用替换为直接引用</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;初始化：执行类构造器进行初始化。（因为内部流程不是很清楚，所以对于其几种不进行初始化的情况不做说明）</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;类加载器：JVM提供了三种类加载器，启动类加载器（/lib），扩展类加载器(/lib/ext)，应用程序类加载器(classpath)。还可以再应用程序类加载器自定义类加载器。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;双亲委派机制：即当一个类接收到类加载请求的时候，不会自己进行加载，而是将其加载请求委派给其父类加载器，这样一路委派，最终加载请求都会委派到启动类加载器.启动类加载器接收到加载请求之后会去lib目录下寻找相关的class文件，若找不到，则将其加载请求再委培给子类加载器，一路委派，直到能够加载。</p>\n<h3><strong>最后，送给大家一张博主画的JVM的思维导图，以后读《深入JVM虚拟机》的时候可能会出一个JVM专题：<a href=\"https://uploader.shimo.im/f/X0MX3hLaHrevltxW.png!thumbnail\" target=\"_blank\" rel=\"noopener\">JVM思维导图</a></strong></h3>\n<p>&nbsp;</p>\n<h2>水平有限，若发现有误，还望指出！</h2>","blogGoods":0,"blogId":"1248224512563068928","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHLeALxSjAABJTVJPTfk677.jpg","blogRead":17,"blogRemark":"面试（一）------之JVM篇","blogTitle":"面试（一）------之JVM篇","createdTime":"2020-04-09 12:21:30","typeName":"java面试篇","updateTime":"2020-04-20 11:53:29"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，Linux的发展历史</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; </strong>1965年之前，电脑并不像现在这么普遍，除了军事机构和研究即构，一般人基本接触不到电脑，而且那时候的一台大型主机最多也就只能支持30台终端。为了解决数量问题，1965年之后，由贝尔实验室，麻省理工学院以及通用电气一起放弃了Multics项目，准备让大型主机能够支持300台终端，但是在开发过程中，进度缓慢，最终由于资金的短缺，贝尔实验室推出了研究。1969年，从这个项目中退出的Ken Thompson在家无聊，为了让电脑能够运行&ldquo;星际旅行&rdquo;游戏，因而趁着妻子回家探亲的一个月，独自写出了Unix操作系统的原型（！！！！牛批）。1970年，这个人以BCPL语言为基础，又写出了很接近硬件的B语言，并且用B语言写出了第一个Unix操作系统。但是由于B语言的跨平台性比较差，为了解决这个问题。Dennis Ritchie和Ken Thompson决定以B语言为基础开发一种新的语言，1972年，Dennis Ritchie最终设计出了一种新语言，他以BCPL的第二个字母命名，也就是我们后来熟知的C语言。随后两人便迫不及待的用C语言重现Unix操作系统。Unix系统起初开源，但是在Unix7之后，由于政策的变化，代码闭源化，因而大学中不能使用Unix的源代码进行教学。Andrew S. Tanenbaum教授为了能够让学生更好的理解代码细节，在完全不使用任何源代码的情况下开发除了Minix---小型Unix。但是因为其只用于教学，功能并不强大，因而Torvalds以此为基础，开发除了Linux，但是起初Linux并不支持Unix，最终经过全世界网友的帮助，最终让其能够兼容各种硬件。</p>\n<p><strong>二，文件和目录</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; 1，windows和linux的区别：</strong>我们熟知的windows系统，它的文件系统是分盘符的，盘符下的文件构成一个树形结构，但是Linux文件系统没有盘符，所有文件目录都在根目录/之下</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;<strong>2，Linux需要记住的目录：</strong>/bin（存放系统命令的目录），/sbin（只有超级管理员能访问的命令文件目录），/root（存放和root用户相关文件的目录），/etc（存放系统配置文件的目录），/usr（存放系统共享资源的目录），/opt（存放安装的第三方软件的目录，通常在/usr/local下）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;<strong>3，文件权限：</strong>Linux中的文件权限有读（r，可用于数字4表示），写操作（w，可用数字2表示），执行权限（x，可用数字1表示）</p>\n<p><strong>三，常用命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，ls：</strong>列出目录中的所有目录和文件名&nbsp; -a（列出所有，包括隐藏文件和目录），-l（以列表形式列出所有），-h（人性化列出，需要配合-l使用，即文件大小转换为我们熟知的kb，mb等），-d（显示当前目录属性），命令可以联合使用，例如-al，-lh等等。&nbsp;&nbsp;&nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，cd：</strong>用于切换目录，需知（.和..是相对路径，.表示当前目录，..表示上级目录；/表示绝对路径），cd ~（切换到root目录），cd - （切换到前一次切换的目录）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，clear：</strong>清屏</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，pwd：</strong>显示当前所在目录</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，mkdir：</strong>创建目录，-p（如果目录存在则不创建，如果不存在则创建目录再创建自目录），可以一次性创建多级目录，例如：mkdir&nbsp; -p test/test1</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，touch：</strong>创建空文件</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>7，cp：</strong>复制，-r（递归复制目录下的文件目录信息），-i(提示是否覆盖)，-v（显示复制进度）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>8，mv：</strong>移动文件，不过经常用来给文件进行重命名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>9，rm：</strong>删除目录或者文件，-r（递归删除），-f（强制删除），-v（显示删除进度）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>10，cat：</strong>查看文件内部信息</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>11，ln：</strong>文件创建链接，ln 源文件 目标链接文件（创建硬链接，硬链接和源文件大小相同，修改同步，但是删除不同步，使用较少），ln -s（创建软连接，相当于我们平时创建快捷方式，使用较多）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>12，which：</strong>搜索命令所在位置，例如：which&nbsp; &nbsp;ls</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>13，find：</strong>搜索文件所在位置&nbsp; 例如：find&nbsp; &nbsp;test.conf</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>14，grep：</strong>文件内容搜索，例如：grep &ldquo;想要搜索的内容&rdquo;&nbsp; 源文件</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>15，tar：</strong>归档命令，-c（打包成.tar文件），-z（打包的同时压缩），-v（打包的同时显示进度），-f（放在最后，后面跟.tar.gz），-x(解压)，常用：tar -zcvf&nbsp; <em><strong>.tar.gz&nbsp; &nbsp; ;&nbsp; &nbsp; tar -zxvf</strong> tar.gz</em> -C&nbsp; 指定解压目录&nbsp;&nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;还有more，head，tail等命令，不过这些不常用。</p>\n<p><strong>四，用户权限命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，whoami：</strong>查看当前账户的用户名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，who：</strong>查看当前登录用户</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，exit：</strong>退出登录</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，adduser/useradd：</strong>添加用户，-d（指定用户主目录），-g（指定用户用户组），-m（自动建立目录），默认情况下用户主目录和用户组名都和用户名一样</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，passwd：</strong>只有root用户才能使用，用于修改用户密码</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，userdel：</strong>删除用户，默认不删除用户的主目录，-r（删除用户主目录）</p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;7，su：</strong>切换账户</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>8，groupadd/groupdel：</strong>添加用户组和删除用户组</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>9，groups：</strong>查看用户所在用户组，例如：groups&nbsp; 用户名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>10，usermod：</strong>修改用户所在用户组，例如：usermod&nbsp; 用户组名 用户名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>11，chmod：</strong>修改文件权限，例如：chmod&nbsp; 777&nbsp; test</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>12，chown：</strong>修改文件所有者，例如：chown&nbsp; &nbsp;用户&nbsp; 文件名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>13，chgrp：</strong>修改文件所在组，例如：chgrp&nbsp; 组名&nbsp; 文件名</p>\n<p><strong>五，系统命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，cal：</strong>查看日历</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，date：</strong>查看时间，可以设置格式，例如：date '+<span class=\"ql-token hljs-built_in\">%Y</span>-<span class=\"ql-token hljs-built_in\">%m</span>-<span class=\"ql-token hljs-built_in\">%d</span> <span class=\"ql-token hljs-built_in\">%H</span>:<span class=\"ql-token hljs-built_in\">%M</span>:<span class=\"ql-token hljs-built_in\">%S</span>'</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，ps：</strong>查看线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，kill：</strong>杀死线程，-9（强制杀死）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，查看网卡信息：</strong>centos6：ifconfig ；centos7：ip addr</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，ping：</strong>查看网址或者链接的连通性</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>7，防火墙：</strong>centos6：service&nbsp; iptables&nbsp; status（查看防火墙状态），service&nbsp; &nbsp;iptables&nbsp; &nbsp;start(开启),service&nbsp; iptables&nbsp; stop(关闭);centos7:firewall-cmd&nbsp; --state（查看防火墙状态），systemctl&nbsp; start&nbsp; firewalld.service(启动)，systemctl&nbsp; &nbsp;stop&nbsp; firewalld.service（关闭）</p>\n<p><strong>六，网络命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，wget：</strong>下载，例如：wget&nbsp; &nbsp;链接地址</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，yum：</strong>下载安装</p>\n<p><strong>七，vim（这里只说几个常用的命令）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;</strong>vim有三种模式：命令模式，插入模式，编辑模式&nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;vim&nbsp; 文件名：进入文件，且处于命令模式；iao任意一键进入插入模式（i表示在贯标之前插入，a光标之后插入，o在下一行插入），：进入编辑模式</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;命令：set:nu显示行号，set:nonu不显示行号；/strinng，向后搜索字符串，？string向后搜索字符串；：w保存，：wq保存并退出，：q不保存退出</p>","blogGoods":0,"blogId":"1248500061625745408","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dDA6AfCOJAAAyfL52jxY706.jpg","blogRead":2,"blogRemark":"Linux基本命令总结","blogTitle":"Linux基本命令","createdTime":"2020-04-10 06:36:25","typeName":"Linux","updateTime":"2020-04-20 10:42:25"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，集合</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，List：</strong>list是java中一种有序的集合，下有三个实现类，分别为ArrayList，Vector，LinkedList</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ArrayList：基于数组实现，增删慢，查询快，线程不安全。因为其基于数组实现，所以查询的时候可以直接根据数组的索引下标进行快速查询，但是进行增删操作的时候，需要将待增删元素后的元素全部移动，因而效率较低。且ArrayList创建时不需要分配初始大小，其空间不够的时候，会自动创建一个更大的list，然后复制数据。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Vector：基于数组实现，和ArrayList一样增删慢，查询快。但是线程安全，因为同一时间只支持一个线程对Vector进行写操作，然而因为要进行频繁的加锁和释放锁的操作，所以效率要低于ArrayList。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; LinkedList：基于双向链表实现，增删快，查询慢。因为基于链表实现，增删元素的时候，只需要改变元素的指针即可，改动较小，效率较高。然而进行查询操作的时候，需要从链表头部进行遍历，因而效率较低。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，Queue：</strong>队列，满足先进先出，种类较多。（不作详细解释）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，set：</strong>具有独一无二的特性，常用来存储无序且不重复的元素，对象相等的本质是hashcode的值相同，而如果想要比较两个对象是否相等，需要重写对象的hashcode方法和equals方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;hashset：基于hashTable实现，无序。存放的是对象的散列值，即通过hashcode计算得到的值</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;treeset：基于二叉树实现，即其中的对象按照一定的排序方式进行排列（升序，降序），每次添加对象的时候，都会进行排序，将其插入指定位置。基本的数据类型例如Integer，String等可以使用treeset默认的排序方法，而自定义数据类型需要实现compareable接口，实现compareTo方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;LinkHashSet：继承自hashset，只不过使用双向链表记录数据的顺序。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，map：</strong>一种键值对形式的集合</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;hashmap：基于数组+链表实现，增删改查操作快，但是每次遍历hashmap元素的顺序无法保证且线程不安全。如果想要其线程安全，可以使用synchronizedMap和ConcurrentHashmap，hashmap的内部是数组，数组中的每一个元素又是一个单向链表，链表中的每个元素嵌套一个Entry实例，其中包括Key，Value，Hash值，指向下一个节点的next。每次查询的时候，可以根据元素的hash值很快定位所在数组，但是定位之后需要遍历链表查找元素，因而时间复杂度为O（n），但是Java8之后对其进行了优化，将其改为了数组+链表或红黑树的结构，即当链表中的元素大于8个的时候，链表会转换为红黑树（红黑树是一种特化的二叉平衡树，因为其左右子树的深度差可以大于1），这样查询的时间复杂度就缩短到了O（logN）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ConcurrentHashmap：采用分段锁的思想进行并发操作，因而使线程安全的。由多个Segment组成，只要保证每个Segment线程安全就可以保证全局线程安全。ConcurrentHashmap的默认Segment即并发度为16，可以在初始化的时候修改，但是初始化之后不能再修改。每个Segment内部的实现和hashmap一样&middot;。Java8之后也和hashmap进行了一样的优化。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;HashTable：线程安全，即同一时刻只能有一个线程对其进行操作，并发度不如ConcurrentHashmap。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;TreeMap：基于二叉树数据结构实现，实现了SortedMap，默认按照键值的升序进行排列。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;LinkedHashMap：Hashmap的子类，只不过使用链表保存元素的插入顺序。使用迭代器遍历的时候按照插入顺序遍历。</p>\n<h2><strong>二，异常分类及处理</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;1，异常分类：</strong>Throwable是所有异常类的父类，其下有error和Exception，Error下有AwtError，ThreadDeath；Exception下有RuntimeException和CheckedException。</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</strong>对于Error类异常通常是由内部错误和资源耗尽造成的，无法在程序运行期间对其进行捕获和处理，对于这类错误我们只能记录错误的原因和终止程序。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; Exception中的RuntimeException异常（运行时异常）：这类异常是我们程序中异常处理的核心，可以在程序中进行捕获并处理。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Exception中的CheckedException异常（检查异常）：这类异常时程序中需要强制捕获的异常，通常有IO异常，SQL异常等等。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，异常处理：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>异常处理有两种方式：抛出异常和捕获异常</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;抛出异常有三种方法：throws，throw，系统自动抛出。其中throws是作用在方法上，后面跟的是可能产生的异常类。throw是作用在方法内部，后面跟的是具体的异常对象。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 捕获异常：即使用try{}catch语句进行捕获</p>\n<h2><strong>三，反射机制</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，什么叫做反射机制？</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>即在程序运行的过程中，可以获取类的属性和方法，并且可以调用任意一个类的方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，反射机制的使用</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 首先，获取类的class对象，有三种方式，className.getClass()，类对象.class，Class.forName(\"类路径\")，其中最后一种最为安全，性能最好。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 然后利用反射的API可以实现对类中信息的操作，例如getDeclareFields（），getDeclareMethods（），getConstroctors（）等等。反射创建类的对像有两种方法，一，class.newInstance()初始化一个类实例；二，先获取其构造器，然后利用构造器初始化一个实例。利用反射调用类的方法：先获取方法，然后调用method.invoke()执行方法。</p>\n<h2><strong>四，注解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，四种元注解：</strong>@Target（指定注解的使用范围），@Retention（定义注解的保留级别，有三级，SOURCE源程序中保存，CLASS文件中保存，RUNTIME运行时保存），@Documented（可以工具文档化），@Inherited（<span style=\"background-color: #ffff00;\">这个没怎么看懂</span>）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，注解使用示例：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>第一步，定义注解接口</p>\n<pre class=\"language-java\"><code>@Target(ElementType.FIELD)  \n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface FruitProvider {\n\n    //id\n    public int id() default  -1;\n\n    //供应商名称\n    public String name() default \"\";\n\n    //供应商地址\n    public String address() default \"\";\n\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 第二步，使用注解</p>\n<pre class=\"language-java\"><code>public class Apple {\n\n    @FruitProvider(id = 1,name = \"红富士苹果\",address = \"陕西\")\n    private String appleProvider;\n\n    public String getAppleProvider() {\n        return appleProvider;\n    }\n\n    public void setAppleProvider(String appleProvider) {\n        this.appleProvider = appleProvider;\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第三步，定义注解处理器</p>\n<pre class=\"language-java\"><code>public class FruitInfoUtil {\n    public static void getFruitInfo(Class&lt;?&gt; clazz) {\n        String strFruitProvider = \"供应商信息:\";\n        Field[] declaredFields = clazz.getDeclaredFields();\n        for (int i = 0; i &lt; declaredFields.length; i++) {\n            if (declaredFields[i].isAnnotationPresent(FruitProvider.class)) {\n                FruitProvider annotation = declaredFields[i].getAnnotation(FruitProvider.class);\n                strFruitProvider += annotation.id() + \",\" + annotation.name() + \",\" + annotation.address();\n                System.out.println(strFruitProvider);\n            }\n        }\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第四步，主方法入口</p>\n<pre class=\"language-java\"><code>public class FruitRun {\n    public static void main(String[] args) {\n        FruitInfoUtil.getFruitInfo(Apple.class);\n    }\n}</code></pre>\n<h2><strong>五，内部类</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 1，静态内部类：</strong>即在类的内部定义的静态类，静态内部类可以访问外部了的静态变量和方法，外部也可以通过outClassName.innerClassName调用内部类</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2，成员内部类：</strong>在类的内部定义的没有用static修饰的内部类，使用方式和静态内部类一样。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>3，局部内部类：</strong>即一个类只在一个方法中使用，则完全可以将这个类定义为这个方法的内部类，即局部内部类，局部内部类可以实现真正的对外隐藏</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>4，匿名内部类：</strong>通常用于继承一个类或者实现一个接口的时候，使用new关键字定义，例如:Person person = new Student(){new Pupil(){}}</p>\n<h2><strong>六，泛型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 1，为什么要使用泛型：</strong>其根本目的是为了实现代码的复用，举个开发中常见的例子，我们需要定义返回类Result，返回类中包含状态码code，信息msg，以及数据data（任意类型），这个时候我们就需要使用泛型，因为我们返回的数据类型有各种vo，pojo类对象，list等。这时候泛型类result就可以被各种对象使用，实现代码的复用，简化开发。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>2，泛型标记和泛型限定：</strong>E表示集合中的元素，K表示键值，V表示value，N表示数值类型，T表示任意类型（包含基础类型，所有的对象类型），？（不确定的java类型）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>泛型限定：</strong>向上限定，&lt;?&nbsp; extends T&gt;，向下限定，&lt;? super&nbsp; T&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; <strong>3，泛型方法：</strong>即参数类型定义为泛型类型，以便于接收不同类型的参数，做出不同的处理。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>4，泛型类：</strong>例如public class Pair&lt;T&gt;{private T data;}</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>5，泛型接口：</strong>与放泛型类类似</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>6，类型擦除：</strong>即在泛型编译的过程中，会将泛型类型替换为限定类型的操作</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>7，明确的一点：</strong>虚拟机在运行程序的过程中，内部是没有泛型的，只有普通的类和方法。</p>\n<h2><strong>7，序列化</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 序列化是为了确保对象及其状态的持久化</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>序列化的使用：</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </strong>首先，实现序列化接口java.io.Serializble</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 然后，声明序列化ID，通常private static final&nbsp; long&nbsp; serialVersionUid&nbsp; = ***</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 因为序列化是保证对象及其状态的持久化，而静态变量是不属于对象，属于类本身的，所以序列化无法保存静态变量。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果需要序列化父类变量，则父类也要实现Serializable接口</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t'ransient修饰的属性不会序列化</p>\n<h3><strong>最后，提供一张思维导图供大家学习：<a href=\"https://images-cdn.shimo.im/es83SQH0CggucT7f__thumbnail\" target=\"_blank\" rel=\"noopener\">JAVA基础</a></strong></h3>\n<p>&nbsp;</p>\n<h2>水平有限，如有错误，还望指出！</h2>","blogGoods":0,"blogId":"1248605157059497984","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHMKAcvZ8AABJTVJPTfk020.jpg","blogRead":27,"blogRemark":"面试（二）------之JAVA基础篇","blogTitle":"面试（二）------之JAVA基础篇","createdTime":"2020-04-10 13:34:02","typeName":"java面试篇","updateTime":"2020-04-20 11:53:39"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，JAVA线程的创建方式</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>JAVA线程的创建有四种方式，分别为，继承Thread类，实现Runable接口，实现Callable&lt;Class&gt;接口，基于线程池。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>1，继承Thread方式：创建一个类继承Thread类，创建类的实例对象，调用start方法，继而执行线程的run（）方法，代码如下：</strong></p>\n<pre class=\"language-java\"><code>public class NewThread extends Thread{\n    public static void main(String[] args) {\n        NewThread thread = new NewThread();\n        thread.start();\n    }\n    @Override\n    public void run(){\n        System.out.println(\"create  a  new thread by Thread!\");\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>2，当子类已经继承了一个类，这时候就没法再继承Thread类了，这时候就可以实现Runable接口，实例化类的线程实例，创建Thread实例传入类的实例，执行start方法，继而执行run（）方法代码如下：</strong></p>\n<p>&nbsp;</p>\n<pre class=\"language-java\"><code>public class ThreadExample2 implements Runnable {\n    public static void main(String[] args) {\n        ThreadExample2 threadExample2 = new ThreadExample2();\n        Thread thread = new Thread(threadExample2);\n        thread.start();\n    }\n    @Override\n    public void run() {\n        System.out.println(\"create a new thread by Runnable!\");\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，有些情况下，我们需要再一个主线程中并发多个子线程执行同一个任务，然后回收子线程的返回值整理汇总，这时候就需要实现Callable&lt;Class&gt;接口，重写其call（）方法，用于计算结果。然床创建一个线程池用于提交线程，继而执行call方法，并且创建一个Future的list用于接收子线程逻辑代码即call方法的返回，最终遍历list，得到想要的返回值，如下：</strong></p>\n<pre class=\"language-java\"><code>public class ThreadExample3 implements Callable&lt;String&gt; {\n\n    private String name;\n\n    public ThreadExample3(String name){\n        this.name = name;\n    }\n\n    @Override\n    public String call() throws Exception {\n        return name;\n    }\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        ExecutorService pool = Executors.newFixedThreadPool(3);\n        List&lt;Future&gt; list = new ArrayList&lt;&gt;();\n        for(int i=0;i&lt;3;i++){\n            ThreadExample3 threadExample3 = new ThreadExample3(i+\"\");\n            Future future =pool.submit(threadExample3);\n            System.out.println(future.get().toString()+\" is running\");\n            list.add(future);\n        }\n        pool.shutdown();\n        for (Future future : list) {\n            System.out.println(\"currentThread's result is \"+future.get().toString());\n        }\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，基于线程池创建线程</strong></p>\n<pre class=\"language-java\"><code>public class ThreadExample4 {\n    public static void main(String[] args){\n        ExecutorService pool = Executors.newFixedThreadPool(3);\n        for(int i=0;i&lt;3;i++){\n            pool.execute(new Runnable() {\n                @Override\n                public void run() {\n                    System.out.println(\"thread  is running by FixedThreadPool\");\n                }\n            });\n        }\n        pool.shutdown();\n    }\n}</code></pre>\n<h2>二，线程池的工作原理</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong> &nbsp;1，概述：</strong>JVM根据用户提供的参数创建一定数量的线程任务，将其放入队列中，线程创建之后启动这些任务，如果线程的数量大于核心线程数量（用户设置的线程数量），则超出数量的线程排在队列中等待，当有线程任务执行完毕后，线程池调度器就会发现有可用可用线程，继而从队列中取出任务继续执行<strong>。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; </strong><strong>2，线程复用：</strong>（参见JDK源码解读，这里只做简单描述），由前可知，JVM会根据用户提供的参数创建一定数量的线程任务，且将其添加到任务队列中。JVM通过start（）方法创建一个线程之后， 会相应的为其创建一个任务队列，线程会不停的查看任务队列，如果任务队列中有任务，则调用run方法，执行，这样就达到了一次start（）创建线程，多次使用，完成线程复用的任务。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>3，线程池的核心组件和核心类（见JDK源码分类中关于线程的总结）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; </strong><strong>4，JAVA线程的工作流程：</strong>线程池刚被创建的时候，只是向系统申请一个执行线程队列和管理线程池的线程资源，当调用execute方法之后，执行下列流程：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果正在运行的线程数量小于corePoolSize（核心线程数量，即用户定义的的线程数量），则立即创建线程执行线程任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果正在运行的线程数量大于或等于corePoolSize，则将超过数量的线程加入到阻塞队列中</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在阻塞队列已满且线程数量小于MaximumPoolSize（即线程池能够容纳的最大线程数），线程池会创建非核心线程立即执行任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在阻塞队列已满且线程数量大于或等于MaximumPoolSize的时候，线程池会拒绝该线程任务且抛出异常</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在线程任务执行完毕之后，会将其从任务队列中移除，从队列中取出下一个线程任务执行</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在线程处于空闲状态且空闲时间超过KeepAliveTime，且线程数量大于corePoolSize的时候，会停止该线程，这样在没有任务的时候，线程池中的线程数始终维持在corePoolSize。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，线程池的拒绝策略：</strong>分为四种，分别为AbortPolicy，CallerRunsPolicy，DiscardOldestPolicy，DiscardPolicy</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; AbortPolicy：直接抛出异常，阻止线程运行，源码如下：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</p>\n<pre class=\"language-java\"><code>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n            throw new RejectedExecutionException(\"Task \" + r.toString() +\n                                                 \" rejected from \" +\n                                                 e.toString());\n        }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CallerRunsPolicy：如果线程任务没有关闭，则尝试执行该线程任务，源码如下：</p>\n<pre class=\"language-java\"><code>* @param r the runnable task requested to be executed\n* @param e the executor attempting to execute this task\n*/\npublic void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n     if (!e.isShutdown()) {\n         r.run()\n     }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DiscardOldestPolicy：移除任务队列中最早进入的线程任务，执行当前任务线程，源码如下：</p>\n<pre class=\"language-java\"><code>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n       if (!e.isShutdown()) {\n           e.getQueue().poll();\n           e.execute(r);\n       }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DiscardPolicy：直接丢弃线程任务，不做任何处理</p>\n<h2><strong>三，五种常用的线程池</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;newCachedThreadPool（可缓存线程池）：</strong>当线程池创建线程的时候如果发现有可复用的线程（执行完任务，且未关闭的线程），则直接复用，如果没有则创建新线程。可缓存线程池可以高效的利用执行任务时间短的线程，提高系统的性能，且线程池中的线程如果空闲时间超过60s，则会被终止且从缓存中移除，这样可缓存线程池不会占用系统资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>newFixedThreadPool（固定大小的线程池）：</strong>即线程池中的线程是初始化固定的，当任务线程大于线程池中线程数量时，任务线程就会进入阻塞队列等待。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newScheduledThreadPool（可做任务调度的线程池）：</strong>即可以设置线程执行的停顿时间和执行周期，进行定期定时的执行某个任务。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newSingleThreadPool（单个线程的线程池）:&nbsp;</strong>即线程池中永远只有一个线程进行工作，如果下称停止或者异常，则线程池创建新的线程替代当前线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newWorkStealingPool（足够大小的线程池）：</strong>即创建足够数量的线程的线程池，保证更快的进行运算，提高效率。</p>\n<h2><strong>四，线程的生命周期</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;线程的生命周期大致分为五个阶段：新建（new），就绪（Runnable），运行（Running），阻塞（Blocked），死亡（Dead）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;新建：</strong>即使用new创建一个线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>就绪：</strong>调用start方法，</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>运行：</strong>即线程获取cpu资源，执行run（）方法，进入运行状态，运行状态的线程如果调用yield（线程让步方法）或者失去cpu资源，都会导致线程重新回到就绪态；如果调用sleep方法，I/O阻塞，等待同步锁，等待通知以及suspend挂起都会导致线程进入阻塞态。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞：</strong>即线程被放入Blocked池。阻塞状态的线程如果结束了sleep方法，I/O方法返回，获取同步锁，收到通知或者resume都会导致其重新进入就绪态，与其它线程竞争cpu时间片。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>死亡：</strong>线程正常执行完run（）或者call（）方法，或者执行stop方法，或者发生异常或者错误都会导致线程死亡。（stop方法会导致锁混乱和死锁，不建议使用）</p>\n<h2><strong>五，线程的基本方法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;wait（线程等待）：</strong>会让线程进入WAITING状态，并且会释放对象的锁。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>sleep（线程睡眠）：</strong>会让线程进入睡眠，进入TIMED_WAITING状态，但是不会释放对象锁，睡眠时间到了之后，再次恢复运行状态</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>yield（线程让步）:</strong>&nbsp; 当前线程会让出其占有的cpu资源，重新回到就绪态和其它线程竞争cpu时间片</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>interrupt（线程中断）:&nbsp; </strong>中断当前线程，但是并不会导致其停止，只是改变其内部的终端标识位，在使用了thread.sleep()之后使用该方法，会导致抛出异常，且我们可以利用中断标识位进行线程的安全退出</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>join（线程加入）：</strong>即将当前线程进入阻塞态，等待下一个线程执行完毕后进入就绪态，重新竞争锁资源。通常用于主线程下面执行子线程，需要主线程阻塞，等待子线程执行完毕后返回其结果给主线程，主线程再执行的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>notify（线程唤醒）/notifyAll：</strong>前者随机唤醒一个等待线程，后者全部唤醒</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>setDaemon（守护线程）:</strong>级别较低的线程，用于后台运行，服务用户用户线程，例如垃圾收集线程就是典型的守护线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>sleep方法和wait方法的区别：</strong>前者属于Thread，后者属于Object，前者不会释放锁资源，后者会释放锁资源</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>start方法和run方法：</strong>start方法只是创建一个线程，并没有运行，run方法时执行线程的真正代码逻辑。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>线程退出的方式：</strong>见四中最后一条</p>\n<h2><strong>六，JAVA中的锁（知识比较杂乱）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述:JAVA中的锁是为了保护数据的一致性。按照不同的标准可分为乐观锁和悲观锁，公平锁和非公平锁，共享锁和独占锁，偏向锁，轻量级锁，重量级锁，自旋锁，可重入锁。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;乐观锁：</strong>即认为每次读取数据都不会被修改，当修改操作的时候再判断当前数据是否被修改，未修改则修改，若已被修改，则返回失败状态。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>悲观锁：</strong>即认为每次读取数据都会被修改，因而每次读取数据都对其进行加锁，这样只有当前用户可以修改，其它用户阻塞等待直到当前用户修改完毕释放锁资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>自旋锁：</strong>即有些线程任务的执行很短，很快就可以释放锁资源，为了避免在这种情况下竞争线程仍然进行内核态和用户态之间的转换，因而让线程自旋（即等一会），如果有可用锁，则获取，减少了线程在用户态和内核态之间切换的时间损耗。提高了性能（优势）。当然线程自旋是占用cpu资源的，因而需要设置一个自旋的最大等待时间，如果超过此时间，则线程退出自旋模式。对于线程竞争锁资源激烈的情况，自旋有可能会导致cpu资源的损耗（劣势）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>公平锁和非公平锁：</strong>即根据线程竞争锁资源的机制判定，一般如果依据先到先得的原则，则位公平锁；如果依据就近原则，则位非公平锁。公平锁相比于非公平锁会更加耗费性能，因为要维护一个线程任务丢列，根据线程任务在队列中的顺序分配锁资源，因而不常用。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>可重入锁：</strong>又被称为递归锁，即该锁可以然后线程对其进行多次的加锁操作。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>偏向锁：</strong>当线程获取到锁的时候，用来消除线程的锁重入的开销（看起来是偏袒这个线程）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>共享锁和独占锁：</strong>共享锁即多线程共享锁资源（典型例子，读锁）；独占锁即当前锁只能有一个线程获取，其它线程阻塞</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>轻量级锁：</strong>没有多线程竞争的前提下，减少重量级锁的使用提高性能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>重量级锁：</strong>基于操作系统的互斥量而实现的锁，会导致进程在用户态和内核态之间切换，耗费性能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>synchronized：独占式悲观锁，可重入锁，非公平锁，重量级锁。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 作用范围：</strong>作用于成员变量和非静态方法，相当于锁住的是对象的实例，即this对象</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;作用于静态方法，相当于锁住的是class实例</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;作用域代码块，相当于锁住的代码块中的对象</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>实现原理：</strong>内部包括ContentionList（锁竞争队列），EntryList（竞争候选列表），WaitSet（等待集合），OnDeck（竞争候选者），Owner，!Owner，其中ContentionList是用来存放竞争锁资源的线程。EntryList是用来存放有资格竞争锁资源的线程。调用wait方法后放入WaitSet中，onDeck指的是同一时刻，只有一个线程竞争锁资源，Owner指的是得到锁资源的线程，!Owner指的是线程执行完毕，释放锁资源的线程。需要注意的是线程首先采用的都是自旋模式获取锁资源，如果自旋获取不到再加入ContentionList，而且Owner状态的线程并不是直接把锁资源交给onDeck状态线程，而是给它竞争锁资源的权利，因而onDeck状态的线程还需要跟自旋线程竞争锁资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>ReentrantLock：独占式，可重入锁，并且可以实现公平锁和非公平锁，重量级锁。</strong></p>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;用法：</strong>lock()加锁，后跟try代码块，finally中进行释放锁unlock()</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;避免死锁的方法：</strong>响应中断（即可以根据情况中断对锁资源的请求），可轮询锁（tryLock（）即尝试获取锁，如果有可用锁则获取返回true，没有则返回。和lock（）的区别在于lock获取锁资源如果没有则一直等待直到获取到锁资源），定时所（tryLock（time,unit）即再一定时间内如果有可用锁，且线程未中断则获取锁，否则禁用当前线程。）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>Semaphore（信号量）:</strong>机制和ReentrantLock类似</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ReadWriteLock（读写锁）：</strong>如果系统要求支持多线程共享读，但不能多线程写，使用读锁；如果要求同一时刻只能有一个线程写，写的过程中不能读取该共享数据，则使用写锁。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; <strong>分段锁：</strong>一种思想，将数据分段加锁，例如ConcurrentHashMap</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;死锁：</strong>即线程之间互相共享资源会导致死锁</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; <strong>锁优化：</strong>第一，减少锁的持有时间；第二：减小锁粒度，例如分段锁；第三：锁分离，例如读写锁；第四：锁粗化，放置锁粒度太小，造成频繁加锁释放锁；第五：锁消除，消除程序代码不规范而造成的乱用了锁</p>\n<p>&nbsp;</p>\n<h3><strong>并发编程（上）的思维导图送上：<a href=\"https://images-cdn.shimo.im/1UcHkyrlJyGRPYnn.png__thumbnail\" target=\"_blank\" rel=\"noopener\">并发编程（上）</a></strong></h3>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>\n<h1>水平有限，如果错误，还望指出！</h1>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;</p>","blogGoods":0,"blogId":"1249313090567143424","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHM2AQOeZAABJTVJPTfk967.jpg","blogRead":8,"blogRemark":"面试（三）------之并发编程篇（上）","blogTitle":"面试（三）------之并发编程篇（上）","createdTime":"2020-04-12 12:27:07","typeName":"java面试篇","updateTime":"2020-04-20 11:53:51"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，redis简介</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>redis是NoSQL型系统之一，与之相似的还有Memcache，用来存储key-value这种键值型数据。相比于Memcache而言，redis不仅可以做临时缓存，还可以做数据持久化，将数据定时的存入硬盘或者将命令追加到日志文件当中。而Memcache只能做临时缓存，因而现在基本上已经被redis完全取代。redis的读写速度非常快，官方给出的数据是读110000次/s，写81000次/s；而且redis支持多种数据类型，例如String，list，hash，set，zset；redis支持主从复制（集群），进行数据持久化；还支持过期时间，事务等。</p>\n<h2><strong>二，redis的安装与启动（docker环境下）</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;docker安装完毕后，安装redis：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第一步：拉取redis镜像，docker&nbsp; pull&nbsp; redis</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第二步：启动redis，docker&nbsp; &nbsp;run&nbsp; &nbsp;redis&nbsp; &nbsp;</p>\n<p><strong>三，基本知识串讲</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>单进程单线程：redis只有一个进程，且内部为单线程，这样做的优势是不存在线程安全问题，且不需要进行线程间的切换，提高了性能，而且多线程可能会涉及到锁。劣势是无法发挥多核cpu的优势，不过可以通过开启搭建多个redis实例实现</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>redis中默认有16个数据库（0-15），可以通过select n来进行数据库之间的切换</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;常用的基本命令：flushDB（清空当前数据库），flushAll（清空所有数据库），dbSize（查看有多少数据库）</p>\n<h2><strong>四，redis基本数据类型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;string：</strong>字符串类型，数据库中存储Map&lt;String,String&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>list：</strong>列表数组类型，数据库中存储Map&lt;String,List&lt;Object&gt;&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>hash：</strong>哈希类型，数据库中存储Map&lt;String,Map&lt;Object,Object&gt;&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>set：</strong>集合类型，其中元素无序，数据库中存储Map&lt;String,Set&lt;Object,Object&gt;&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>Zset：</strong>有序集合类型，每个元素都有一个可用于排序的权重</p>\n<h2><strong>五，redis相关命令（这里详解一些常用的命令，不常用的一笔带过）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;string：</strong>(1)set&nbsp; key&nbsp; value,插入一条数据&nbsp; （2）mset&nbsp; key value...批量插入 （3）setnx&nbsp; key value&nbsp; 若无则插入（4）get&nbsp; key&nbsp; 获取某条数据&nbsp; （5）mget keys 批量获取&nbsp; （6）getrange key&nbsp; 0 -1获取数据库全部数据&nbsp; （7）incr age 递增&nbsp; (8) incrby&nbsp; age&nbsp; 10&nbsp; 递增 age 步长为10（9）decr&nbsp; age&nbsp; 递减&nbsp; （10）decrby&nbsp; age&nbsp; 10 步长递减&nbsp; &nbsp;（11）del&nbsp; key&nbsp; 删除某条数据&nbsp; <span style=\"background-color: #ffff00;\">（12）exists&nbsp; key&nbsp; 判断是否存在某个key&nbsp; &nbsp;(13)expire&nbsp; key&nbsp; 10&nbsp; 设置过期时间（单位为秒）&nbsp; （14）pexpire&nbsp; key&nbsp; 1000 设置过期时间，单位为毫秒&nbsp; （15）persist key删除过期时间 （</span><span style=\"background-color: #ffff00;\">16）ttl&nbsp; key&nbsp; 查看过期时间</span></p>\n<p><span style=\"background-color: #ffff00;\">&nbsp;<span style=\"background-color: #ffffff;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>list：&nbsp;&nbsp;</strong>（1）lpush&nbsp; key&nbsp; value 左插入一条数据&nbsp; &nbsp;（2）lpush mylist&nbsp; key&nbsp; value....批量左插入&nbsp; （3）rpush&nbsp; key value 右插入一条数据&nbsp; (4)rpush&nbsp; mylist&nbsp; key value...右批量插入&nbsp; （5）lrange&nbsp; mylist&nbsp; 0&nbsp; -1&nbsp; 取出数据集合&nbsp; （6）lpop mylist 左弹出集合中第一条数据&nbsp; （7）rpop&nbsp; </span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">mylist&nbsp; 右弹出集合中第一条数据&nbsp; （8）llen&nbsp; mylist&nbsp; 获取数据集合长度lrem&nbsp; mylist&nbsp; count&nbsp; value&nbsp; （count&gt;0,从表头开始搜索，移除count个与值与value相等的元素；count&lt;0,表尾开始；count=0，移除所有值与value相等的元素） （9）linsert mylist&nbsp; before/after&nbsp; a&nbsp; 在a元素前或后插入。</span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">(10) lpoplpush&nbsp; list&nbsp; list1 转移列表的元素到另一个列表</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>hash：</strong>（1）hset&nbsp; key&nbsp; &nbsp;val-key&nbsp; val-val&nbsp; 插入一条数据&nbsp; （2）hset&nbsp; myhash&nbsp; name&nbsp; xxx&nbsp; 用于给哈希表中的字段赋值，不存在则创建哈希表赋值，存在则覆盖旧值&nbsp; (3) hget&nbsp; &nbsp;myhash&nbsp; name&nbsp; 取哈希表中某个值&nbsp; （4）hmset&nbsp; myhash name&nbsp; xxx age xxx&nbsp; 批量插入字段&nbsp; （5）hmget</span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">批量获取 （6）hgetall&nbsp; myhash&nbsp; 获取哈希表中所有值&nbsp; (7)&nbsp; hexisets myhash&nbsp; name&nbsp; 判断哈希表中是否存在name字段&nbsp; （8）hsetnx&nbsp; myhash score 100 若存在则不插入，若不存在则插入数据&nbsp; （9）hincrby&nbsp; myhash id 1/hdecrby&nbsp; myhash id&nbsp; 10 递增递减 （10）hdel&nbsp; myhash name&nbsp; </span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">删除&nbsp; （11）hkeys&nbsp; myhash&nbsp; 只取key值&nbsp; （12）hvals&nbsp; myhash&nbsp; 只取value值&nbsp; （13）hlen&nbsp; myhash 获取哈希表长度</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>set：</strong>（1）sadd myset&nbsp; redis&nbsp; 添加一条数据&nbsp; （2）smembers myset&nbsp; 获取数据集合&nbsp; （3）srem&nbsp; myset&nbsp; set1&nbsp; 删除set1&nbsp; （4）sismember myset&nbsp; set1 判断set中是否存在set1&nbsp; (5)srandmember&nbsp; key count&nbsp; 随机获取count个元素（6）spop&nbsp; 从集合中弹出一个元素</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>zset：</strong>之后补充</span></span></p>\n<h2><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">六，redis配置文件（常见配置）</span></span></strong></h2>\n<p><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;daemonize no：</span></span></strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">redis默认不是以守护进程的方式运行的，可以更改为yes启用守护进程（即后台运行）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>pidfile&nbsp; /var/run/redis.pid&nbsp; :</strong>启用守护进程后，默认将pid写入/var/run/redis.pid文件，可以更改</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>port&nbsp; 6379 ：</strong>redis默认端口</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp; &nbsp; &nbsp; &nbsp; <strong>bind&nbsp; 127.0.0.1：</strong>绑定的主机地址</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\"> &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>timeout&nbsp; 300</strong><strong>：</strong>redis客户端闲置多长时间后关闭连接，改为0的话，表示关闭该功能</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>loglevel&nbsp; verbose：</strong>默认日志级别（还有debug，notice，warning）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>database 16：</strong>redis默认有16个数据库可以修改</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>save&nbsp; 900&nbsp; 1/save&nbsp; 300&nbsp; 10/save&nbsp; 60&nbsp; 10000：&nbsp;</strong>表示一定时间内有多少条数据发生修改，就将其同步到数据文件一次，例如第一个表示15分钟内有一条数据发生改变就同步</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>rdbcompression yes&nbsp; ：</strong>表示数据存储到本地数据库时是否进行压缩</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>dbfilename&nbsp; dump.rdb：</strong>指定本地数据库文件名</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>dir&nbsp; /...../redis安装目录/bin ：</strong>本地数据库存放目录，默认在redis安装目录的bin目录下</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>slaveof&nbsp; &nbsp;masterip&nbsp; masterport ：</strong>设置当本机为从机时，它的主机的ip和端口</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>masterauth&nbsp; &lt;master-password&gt;：</strong>当master服务设置了密码时，slav服务连接master的密码</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>requirepass&nbsp; foobared：</strong>默认关闭redis连接需要密码，当给redis设置了密码，就需要打开</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>maxclients&nbsp; &nbsp;128：</strong>redis同一时间最大连接客户端的数量</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>appendonly&nbsp; &nbsp;no：</strong>是否开启aof持久化，默认不开启，采用rdb</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>appendfilename&nbsp; appendonlu.aof：</strong>指定aof持久化的文件名</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>appendfsync&nbsp; everysec :</strong>指定更新日志条件，默认每秒更新一次（还有no，指等操作系统进行数据缓存到磁盘，快；always指每次更新操作后都手动写入磁盘，慢但安全）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;虚拟机方面的配置暂不说明</span></span></p>\n<h2><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">七，redis持久化</span></span></strong></h2>\n<p><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;概述：</span></span></strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">redis持久化主要有两种方式，即rdb和aof</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>rdb：</strong>适用于大数据集的恢复，数据的备份，但是因为设置周期时间进行数据的快照，所以如果redis宕机，可能会丢失最后一个写操作的数据，因为数据完整性较差。数据保存在dump.db文件中，只需要移动到redis安装目录，重启即可恢复数据</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>aof：</strong>适用于对数据的完整性要求较高的情况，因为可以设置不同的持久化策略，例如每秒保存一次，这样即时redis宕机，也只会丢失最后一秒的数据。但是因为其日志文件存储的是写入命令，因而其文件大小要大于rdb的数据文件，且每次重启，都要从头执行数据文件中的命令，因而恢复速度也</span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">要慢于rdb。</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>注意：</strong>当rdb和aof同时开启的时候，redis重启，默认会采用aof的形式进行数据的重新构建</span></span></p>\n<h2><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">八，redis事务</span></span></strong></h2>\n<p><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;概述：</span></span></strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">什么是事务？事务即是一系列的命令要买全部执行，要么全部回滚</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <strong>常用命令：</strong>multi(启动事务)，discard（取消事务）,exec（执行事务块内命令）,watch key(监控某个key的变化)，unwatch（取消对所有key的监控）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>注意：</strong>redis的事务中在命令本身出错的情况下会造成命令的全部回滚，但是在命令无错，执行某个命令的时候发生异常的时候，则谁的错，谁停止（这一点和mysql是不同的）</span></span></p>\n<h2><strong>九，redis的主从复制</strong></h2>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>redis的主从复制，即主机数据更新后根据我们设置的策略将数据同步到从机上，主机以写为主，从机以读为主<strong>。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 使用：</strong>配主不配从，在从机中使用slaveof&nbsp; 主机ip&nbsp; &nbsp;主机端口配置从机，但是这种配置方式当redis重启之后就会失效，如果想要redis重启仍然可用，则需要配置redis.conf配置文件中的slaveof&nbsp; masterip&nbsp; masterport。这种配置方式的问题所在，中心化只有一台极其支持写操作，如果主机宕机，则从机等待，且从机宕机重启后不会跟上大部队（即重启后变为主机）。当然我们可以采用命令slave&nbsp; no&nbsp; one 使从机反客为主，成为主机。但是这种手动操作太过麻烦。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>哨兵模式：</strong>即配置之后，如果主机宕机，则哨兵会自动根据投票规则在从机中进行选举，从而产生新的主机顶替。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>主从复制的缺点：</strong>因为所有的写操作都是子主机上进行，从而在同步到从机上，所以存在着一定的延迟，当系统繁忙或者从机数量较多的时候，这种问题就更加明显。</p>\n<h2><strong>十，redis集群</strong></h2>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;概述：</strong>集群是一种去中心化的模式，与中心化模式不同的是，中心化模式中如果主服务挂掉了，那么服务就挂掉了。但是集群模式下，没有主路由，每个节点自身都可以成为路由</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;redis集群：即配置多台主机，多台从机，不同的主机中有不同的槽点，当执行数据写入时，会根据crc16算法计算出数据的槽点，从而将数据存入到对应的主机中，并同步到与其对应的从机中</p>\n<p>&nbsp;</p>\n<h1>水平有限，如有错误，还望指出！</h1>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1249588251598041088","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6caUuADBI7AAAb07iHSRw500.jpg","blogRead":4,"blogRemark":"redis基础（一）","blogTitle":"redis基础（一）","createdTime":"2020-04-13 06:40:30","typeName":"redis","updateTime":"2020-04-20 16:47:37"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，线程上下文切换</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>cpu利用时间片轮询的方式来为每个任务都分配一定的时间片，任务的执行过程中保存任务的状态。任务状态的保存和在加载就叫做上下文切换。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>进程：</strong>指的是一个运行中的程序实例，一个进程中可以有多个线程，并且与进程共享同样的内存和系统资源</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong> 上下文：</strong>指的是寄存器和程序计数器保存的线程的信息</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>寄存器：</strong>指的是内存中很小但是运行速度很快的一块区域（相对于RAM外部内存）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>程序计数器：</strong>一种寄存器，用来保存当前执行指令的位置或者下一个待执行指令的位置</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>上下文切换：</strong>上下文切换指的是操作系统的内核在cpu上对进程或者线程的切换。上下文信息保存在进程控制块中（PCB）。流程如下：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;挂起当前进程，将进程的上下文信息保存在进程控制块中；</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;在进程控制块中寻找下一个任务的上下文信息。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;恢复进程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>上下文切换的原因：</strong>第一，任务正常执行完毕，调度下一个任务；第二，线程出现I/O阻塞，被挂起，cpu调度下一个任务；第三，线程等待同步锁，获取socket通知等，被挂起，cpu调度下一个任务；第四，用户调用sleep方法，让出cpu；第五，硬件中断</p>\n<h2><strong>二，JAVA阻塞队列</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>阻塞队列的是调度当前队列的线程处于阻塞状态</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 消费者阻塞：如果队列为空，则消费者线程被挂起，处于阻塞状态，当有新数据进入队列，则消费者线程被唤醒，消费数据</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 生产者阻塞：如果队列数据已满，则生产者线程挂起，处于阻塞状态，当队列有空闲位置，生产者线程被唤醒，生产数据。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞队列的主要操作：</strong>插入操作和移除（获取）操作</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>插入操作：</strong>add(e)，有空间则插入，无空间报异常；offer(e),有空间则插入，无空间返回false；offer(e,time,unit),有空间插入，无空间等待time时间，若超时返回false；put(e),有空间插入，无空间则线程挂起处于阻塞直到有空间</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>移除操作：</strong>poll(e),有值返回值，无值返回null;poll(e,time,unit),有值返回值，无值等待time时间，超时返回null;take(e),有值返回值，无值等待新数据进入再立即返回；drainTo(collection&lt;Object&gt;)批量移除，提高获取效率</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞队列的实现：</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong> ArrayBlockingQueue：</strong>基于数组的有界阻塞队列，按照先进先出顺序对元素进行排序</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>LinkedBlockingQueue：</strong>基于链表的有界阻塞队列，队头队尾采用不两个不同的锁控制数据同步，并发性高</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>PriorityBlockingQueue：</strong>基于优先级的无界队列，默认升序排列，可以自定义排序规则，根据优先级访问数据。但是有数据优先级一样的情况</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>DelayQueue：</strong>支持延时的队列，即从队列中取数据时等待一定的时间才能获取元素。可以用于缓存系统的设计，设计过期时间，也可以用来设置定时调度任务，即如果能够从队列中获取，说明到了任务的调度时间。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>SynchronousQueue</strong>：该队列是一个不存储元素的阻塞队列，每一个put操作都必须等待一个take操作的完成。吞吐量高于ArrayBlockingQueue和LinkedBlockingQueue。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>LinkedTransferQueue：</strong>基于链表的无界阻塞队列，多了transfer方法(如果消费者等待，直接将任务从生产者传递给消费者，无消费者等待，则将任务加到队尾直到被消费才返回)和tryTransfer（与transfer一致，只不过不管有没有消费者等待获取都会立即返回tryTransfer（e,time,unit）（与tryTransfer一致，只不过设置了超时时间）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>LinkedBlockingDeque：</strong>基于链表的双向阻塞队列，可以在两端同时进行读写操作，提高了队列的操作效率。</p>\n<h2><strong>三，并发关键字</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;CountDownLatch：</strong>适用于一个主线程等待子线程完成任务之后执行（原理：设置一个程序计数器，计数器的值为子线程的个数，子线程并发执行，每个子线程执行完毕后，调用CountDown方法，将其计数器的值减去1，值为0时，唤醒主线程执行）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>CyclicBarrier：</strong>即当所有线程到达一个状态共同执行。await（）方法：确保所有线程到达Barrier状态才执行；await（time,unit）：设置一个超时时间，超过这个时间，执行达到Barrier状态的线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>Semaphore：</strong>因为其限制了多线程访问资源的线程个数，所以适用于多线程并发访问有限资源的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>volatile：</strong>直接用来修饰变量，是一种比Synchronized更加轻量级的机制，用于多线程共享同一变量，可以同时对其进行读写操作。当多个线程共享变量的时候，读取变量将其从内存复制到cpu缓存中，然后线程对其操作进行修改，这样再多cpu的情况下，有可能出现线程修改原数据造成数据不一致的情况，使用volatile关键字直接将线程修改的变量存入内存，解决这个问题。</p>\n<h2><strong>四，多线程共享数据</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>多线程共享数据主要通过共享内存实现，而共享内存的可见性，有序性，原子性已经由JVM和锁解决。理想情况下我们需要解决同步和互斥的问题（<span style=\"background-color: #ffff00;\">怎么解决的有待考证！</span>）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>解决方法一：</strong>将数据抽象成一个类，将对数据的操作封装成类中的方法</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解决方法二：</strong>将Runnable对象作为一个内部类，将共享数据作为这个类的成员变量</p>\n<h2><strong>五，ConcurrentHashmap并发</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ConcurrentHashmap使用了减小锁粒度，这里具体为分段锁的思想优化了锁，因为如果直接对hashmap进行加锁，锁太大，而且同一时刻只能有一个线程操作hashmap，并发性能较差</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;实现原理：</strong>即内部采用分段锁思想，将hashmap分为多个segment，每次读取数据的时候，对数据所在的segment进行加锁，这样只要保证每个segment线程安全，就可以保证整个hashmap线程安全</p>\n<h2><strong>六，JAVA中的线程调度</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;抢占式调度：</strong>即线程对cpu资源进行抢占，这种策略下每个线程抢占到cpu资源的概率是相等的，这样就不会一个线程阻塞造成整个系统阻塞的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>协同式调度：</strong>即一个线程使用完cpu资源之后通知cpu调度下一个任务，适用于多线程交替执行任务。因为如果一个线程阻塞可能会造成整个系统阻塞甚至崩溃</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>JAVA采用的是抢占式调度，但同时又尽可能的保证公平性（即为每个线程分配优先级不同的cpu时间片）</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>&nbsp;线程让出cpu的情况</strong>：第一，线程调用yield方法；第二，I/O阻塞，socket等待等；第三，等待同步锁；第四，正常执行完毕</p>\n<h2>七，进程调度算法</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>优先调度算法：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;先来先服务调度算法：</strong>即遵循先来先被分配cpu资源运行的原则</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>短作业调度算法：</strong>即预估作业的时间长短，优先调度时间短的任务，可能会导致长时间大任务很长时间无法被调度 &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>高优先权调度算法：即每个任务会预先被分配优先级</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;非抢占式优先调度算法：</strong>按照优先级的高低一次分配cpu资源运行</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>抢占式优先调度算法：</strong>按照优先级的高低分配cpu资源运行，但是如果任务再运行过程中有优先级更高的任务加入，则将其cpu资源临时回收分配给紧急任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>高响应比调度算法：</strong>动态调度，即作业时间短，则优先级高；等待时间长，则优先级高。前者遵循短作业调度算法，后者遵循先来先服务原则。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>时间片轮转调度算法：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;时间片轮转法：</strong>按照任务再队列中的顺序进行调度</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>多级反馈队列调度算法：</strong>即再时间片轮转法的基础上维护了就绪队列，默认第一队列优先级高，先调度第一队列的任务，如果再分配的cpu时间片内未完成则将其加入第二队列队尾，以此类推直到其执行完毕。只有第1 -（n-1）队列为空，才会调度第n队列的任务，而且当前任务执行时，如果有优先级高的任务进来，会抢占其cpu资源。</p>\n<h2><strong>八，CAS</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>即比较和交换，CAS（V,E,N）三个参数，只有当V=E的时候才会将V设置为N。如果V!=E，则说明数据已经被其它线程修改，不做任何操作</p>\n<h2><strong>九，ABA问题</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>概述：</strong>即当1线程从V中取出A时，2线程也从中取出1，修改为B，再修改为A。而1线程仍然修改成功，实际上修改过程中V的实际值已经发生改变，只不过1没有发觉。解决这种问题，常采用乐观锁的版本号机制。</p>\n<h2><strong>另外有AQS问题没怎么读懂，下次完善！</strong></h2>\n<p>&nbsp;</p>\n<h3><strong>思维导图：<a href=\"https://images-cdn.shimo.im/myFodjsaVAA3PVV7__thumbnail\" target=\"_blank\" rel=\"noopener\">并发编程（下）</a></strong></h3>\n<p>&nbsp;</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</p>","blogGoods":0,"blogId":"1249742755949817856","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHNmAPuxmAABJTVJPTfk117.jpg","blogRead":17,"blogRemark":"面试（三）------之并发编程篇（下）","blogTitle":"面试（三）------之并发编程篇（下）","createdTime":"2020-04-13 16:54:26","typeName":"java面试篇","updateTime":"2020-04-20 11:54:02"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，栈及其JAVA实现</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：栈是一种先进后出的数据结构，对栈顶元素的添加，删除等操作较快，但是对于栈内的元素操作很慢</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA实现：实现需要定义栈的数据结构，写栈的入栈，出栈，获取栈顶元素的方法，如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n * 基于数组实现栈\n * @author wcj\n * @Date 2020/4/14 20:59\n * @Version 1.0\n */\npublic class StackExample&lt;E&gt; {\n\n    /**\n     * 站的深度\n     */\n    private int maxSize;\n    /**\n     * 存储数据的数组\n     */\n    private Object[] data;\n    /**\n     * 栈顶指针\n     */\n    private int top = -1;\n\n    /**\n     * 默认栈的深度为10\n     */\n    public StackExample(){\n        this(10);\n    }\n\n    /**\n     * 用户自定义栈的深度\n     * @param initialSize\n     */\n    public StackExample(int initialSize){\n        if(initialSize&gt;=0){\n            this.maxSize = initialSize;\n            this.data = new  Object[initialSize];\n            this.top = -1;\n        }else{\n            throw new RuntimeException(\"初始化栈的深度不能小于0!\");\n        }\n    }\n\n    /**\n     * 入栈操作\n     * @param e\n     * @return\n     */\n    public Boolean push(E e){\n        if(top == maxSize-1){\n            throw new RuntimeException(\"栈已满,不能入栈\");\n        }else{\n            data[++top] = e;\n        }\n        return true;\n    }\n\n    /**\n     * 出栈操作\n     * @return\n     */\n    public E pop(){\n        if(top==-1){\n            throw new RuntimeException(\"栈空，不能出栈！\");\n        }else{\n            return (E) data[top--];\n        }\n    }\n\n    /**\n     * 获取栈顶元素\n     * @return\n     */\n    public E peak(){\n        if(top==-1){\n            throw new RuntimeException(\"栈空异常！\");\n        }else{\n            return (E) data[top];\n        }\n    }  </code></pre>\n<h2><strong>二，队列极其JAVA实现</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：队列是一种先进先出的数据结构，对队头和队尾的操作简单，但是队内元素的操作复杂。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA实现：定义队列的数据结构，队列的出队，入队，获取队头元素。代码如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n * 基于数组实现队列\n * @author wcj\n * @Date 2020/4/14 21:14\n * @Version 1.0\n */\npublic class QueueExample&lt;E&gt; {\n\n    /**\n     * 队列长度\n     */\n    private int maxSize;\n    /**\n     * 存储数据数组\n     */\n    private Object[] data;\n    /**\n     * 队头指针\n     */\n    private int front;\n    /**\n     * 队尾指针\n     */\n    private int rear;\n\n    /**\n     * 默认构造器\n     */\n    public QueueExample(){\n        this(10);\n    }\n    /**\n     * 用户自定义队列长度构造器\n     * @param initialSize\n     */\n    public QueueExample(int initialSize){\n        if(initialSize&gt;=0){\n            this.maxSize = initialSize;\n            data = new Object[initialSize];\n            front = rear = 0;\n        }else{\n            throw new RuntimeException(\"初始化队列长度不能小于0！\");\n        }\n    }\n\n    /**\n     * 入队操作\n     * @param e\n     * @return\n     */\n    public Boolean add(E e){\n        if(rear == maxSize){\n            throw new RuntimeException(\"队列已满，无法入队!\");\n        }else{\n            data[rear++] = e;\n        }\n        return true;\n    }\n\n    /**\n     * 出队操作\n     * @return\n     */\n    public E poll(){\n        if(front==rear){\n            throw new RuntimeException(\"队空，无元素可出队！\");\n        }else{\n            E e = (E) data[front];\n            data[front] = null;\n            return e;\n        }\n    }\n\n    /**\n     * 获取队头元素\n     * @return\n     */\n    public E peek(){\n        if(front==rear){\n            throw new RuntimeException(\"队空，无元素可出队!\");\n        }else{\n            return (E) data[front];\n        }\n    }\n}\n</code></pre>\n<h2><strong>三，链表及其JAVA实现</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：链表是由一系列数据节点组成的数据结构，节点可以动态生成。对于元素的增加，删除操作快，查询操作慢</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;这里主要讲述几种有代表性的链表：单向链表，双向链表，双向循环链表</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;单链表的JAVA实现：数据结构定义，添加节点，删除节点，查找节点，代码如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n * 单向链表\n * @author wcj\n * @Date 2020/4/14 21:32\n * @Version 1.0\n */\npublic class SingleLinkedList {\n\n    /**\n     * 链表长度\n     */\n    private int length;\n    /**\n     * 链表头节点\n     */\n    private Node head;\n\n    public SingleLinkedList(){\n        this.length = 0;\n        this.head = null;\n    }\n    /**\n     * 内部类声明每个链表节点\n     * 每个节点包括数据域和指向下一个节点的指针\n     */\n    private class Node{\n        private Object data;\n        private Node next;\n        public Node(Object data){\n            this.data = data;\n        }\n    }\n\n    /**\n     * 插入节点（这里使用头插法）\n     * @param obj\n     * @return\n     */\n    public Boolean add(Object obj){\n        Node node = new Node(obj);\n        if(length==0){\n            head = node;\n        }else{\n            node.next= head;\n            head = node;\n        }\n        length++;\n        return true;\n    }\n\n    /**\n     * 删除某个节点\n     * 先对链表进行判空处理\n     * 然后找到要删除的节点\n     * 最后进行删除\n     * @param obj\n     * @return\n     */\n    public Boolean delete(Object obj){\n        if(length==0){\n            throw new RuntimeException(\"链表为空，无节点可删除!\");\n        }else{\n            Node prev = head;\n            Node current = head;\n            //查找待删除元素\n            while(!current.data.equals(obj)){\n                if(current.next==null){\n                    return false;\n                }else{\n                    prev = current;\n                    current = current.next;\n                }\n            }\n            prev.next = current.next;\n            length--;\n        }\n        return true;\n    }\n\n    /**\n     * 获取某个元素\n     * @param obj\n     * @return\n     */\n    public Object find(Object obj){\n        if(length==0){\n            throw new RuntimeException(\"链表为空\");\n        }else{\n            Node current = head;\n            while(current.data.equals(obj)){\n                if(current.next==null){\n                    return null;\n                }else{\n                    current = current.next;\n                }\n            }\n            return current.data;\n        }\n    }\n}\n</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>双向链表的JAVA实现：定义数据结构，头插法，尾插法，删除头部节点，删除尾部节点（这里只写尾插节点和删除尾部节点），代码如下：</strong></p>\n<pre class=\"language-java\"><code>import com.sun.org.apache.xpath.internal.operations.Bool;\n\n/**\n * 单向循环链表\n * @author wcj\n * @Date 2020/4/14 22:05\n * @Version 1.0\n */\npublic class CircleLinkedList {\n\n    /**\n     * 链表长度\n     */\n    private int length;\n    /**\n     * 头节点\n     */\n    private Node head;\n    /**\n     * 尾节点\n     */\n    private Node tail;\n\n    /**\n     * 初始化构造方法\n     */\n    public CircleLinkedList(){\n        this.length = 0;\n        this.head=this.tail = null;\n    }\n\n    /**\n     * 内部类实现的链表节点\n     */\n    private class Node{\n        private Object data;\n        private Node prev;\n        private Node next;\n        public Node(Object data){\n            this.data = data;\n        }\n    }\n\n    /**\n     * 尾插节点\n     * @param obj\n     * @return\n     */\n    public Boolean addTail(Object obj){\n        Node node = new Node(obj);\n        if(length==0){\n            head = tail= node;\n            length++;\n        }else{\n            tail.next = node;\n            node.prev = tail;\n            tail = node;\n            length++;\n        }\n        return true;\n    }\n\n    /**\n     * 删除尾部节点\n     * @return\n     */\n    public Boolean delTail(){\n        Node temp = tail;\n        if(length==0){\n            throw new RuntimeException(\"链表为空!\");\n        }else{\n            tail = tail.prev;\n            tail.next = null;\n            length--;\n        }\n        return true;\n    }\n}\n</code></pre>\n<h2><strong>四，散列表</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：有一张表M，一个映射函数f(key)，如果对于任意一个key，都有一个函数指与表中的内存地址相对应，则M就为散列表，f(key)就为散列函数。散列函数存储key-value键值对形式的数据，直接生成key与表中地址值的映射，因此查询非常迅速。同时散列表也经常被用于信息安全，用于加密操作。</strong></p>\n<h2><strong>五，二叉排序树</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：二叉查找树又成为二叉搜索树，二叉查找树</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;特征：根节点左边的数据小于根节点，根节点右边的数据大于根节点，且其左右子树还是二叉排序树</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现：定义数据结构，插入操作，删除操作，查找操作，代码如下：</strong></p>\n<pre class=\"language-java\"><code>package interviewFour.example4;\n\n/**\n * 二叉排序树\n * @author wcj\n * @Date 2020/4/14 17:17\n * @Version 1.0\n */\npublic class Node {\n\n    private Node root = null;\n    private int value;\n    private Node left;\n    private Node right;\n\n    public Node(){}\n\n    public Node(int value, Node left, Node right){\n        this.value = value;\n        this.left = left;\n        this.right = right;\n    }\n\n    public Node(int value){\n        this.left = null;\n        this.right = null;\n        this.value = value;\n    }\n\n    public int getValue() {\n        return value;\n    }\n\n    public void setValue(int value) {\n        this.value = value;\n    }\n\n    public Node getLeft() {\n        return left;\n    }\n\n    public void setLeft(Node left) {\n        this.left = left;\n    }\n\n    public Node getRight() {\n        return right;\n    }\n\n    public void setRight(Node right) {\n        this.right = right;\n    }\n\n    /**\n     * 插入节点\n     * @param value\n     * @return\n     */\n    public Boolean insert(int value){\n        //root代表根节点\n        Node p = root;\n        Node prev = null;\n        //创建一个节点\n        Node node = new Node(value);\n        //寻找节点的插入位置\n        while(p!=null){\n            prev = p;\n            if(value==p.getValue()){\n                return false;\n            }else if(value&lt;p.getValue()){\n                p = p.getLeft();\n            }else{\n                p = p.getRight();\n            }\n        }\n        if(root==null){\n            root = node;\n        }else if(value&lt;prev.getValue()){\n            prev.setLeft(node);\n        }else{\n            prev.setRight(node);\n        }\n        return true;\n    }\n\n    /**\n     * 删除某个节点\n     * 分为三种情况，待删除节点为叶子节点，则直接删除\n     * 待删除节点只有左子树或者右子树，则用左子树或者右子树替代当前节点位置\n     * 待删除节点即有左子树又有右子树，则寻找左子树最大节点或者右子树最小节点顶替当前节点(这里使用左子树的最大节点)\n     * @param value\n     * @return\n     */\n    public void deleteBST(int value){\n        deleteBST(root,value);\n    }\n\n    /**\n     * 递归删除左子树，或者右子树，或者根节点\n     * @param root\n     * @param value\n     * @return\n     */\n    public Boolean deleteBST(Node root,int value){\n        if(root==null){\n            return false;\n        }else{\n            if(root.getValue()==value){\n                delete(root);\n            }else if(value&lt;root.getValue()){\n                deleteBST(root.getLeft(),value);\n            }else{\n                deleteBST(root.getRight(),value);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * 分情况执行具体的删除逻辑\n     * @param node\n     * @return\n     */\n    public Boolean delete(Node node){\n        if(node.getLeft()==null){\n            node = node.getRight();\n        }else if(node.getRight()==null){\n            node = node.getLeft();\n        }else{\n            Node temp = node;\n            Node s = node;\n            //转向左子树，向右走到底\n            s = s.getLeft();\n            //寻找替换待删除节点的节点\n            while(s!=null){\n                temp = s;\n                s = s.getRight();\n            }\n            node.setValue(temp.getValue());\n            if(temp!=node){\n                node.setLeft(temp.getLeft());\n            }else{\n                node.setRight(temp.getRight());\n            }\n        }\n        return true;\n    }\n\n    /**\n     * 在二叉查找树中找到对应节点\n     * @param value\n     * @return\n     */\n    public Boolean searchBTS(int value){\n        Node node = root;\n        if(node==null){\n            throw new RuntimeException(\"无此节点！\");\n        }else{\n            if(value==node.getValue()){\n                return true;\n            }else if(value&lt;node.getValue()){\n                node = node.getLeft();\n            }else{\n                node = node.getRight();\n            }\n        }\n        return false;\n    }\n}\n</code></pre>\n<h2><strong>六，红黑树</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 概述：红黑树是一种特化的自平衡二叉排序树，即其左右子树的深度差可以超过1。（详细的插入等操作过段时间会补充）</strong></p>\n<h2><strong>七，图，位图</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;图的知识：定义，有向图/无向图，邻接矩阵/邻接表，BFS/DFS，位图的话没怎么搞清楚。</strong></p>\n<h3><strong>思维导图：<a href=\"https://images-cdn.shimo.im/YClQaLxx9e8uEb9U__thumbnail\" target=\"_blank\" rel=\"noopener\">数据结构</a></strong></h3>\n<h2>&nbsp;</h2>","blogGoods":0,"blogId":"1250068950784536576","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHQGAYlUxAABJTVJPTfk990.jpg","blogRead":7,"blogRemark":"面试（四）------之数据结构篇","blogTitle":"面试（四）------之数据结构篇","createdTime":"2020-04-14 14:30:37","typeName":"java面试篇","updateTime":"2020-04-23 22:14:43"}],"pageSize":10,"params":{},"sortMethod":"ASC","totalCount":53,"totalPage":6},"msg":"操作成功!"}
2020-04-26 22:24:15.674 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /rotation-picture/listFront
2020-04-26 22:24:15.674 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 22:24:15.676 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 22:24:15.676 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.RotationPictureController.getRotationPictureListFront
2020-04-26 22:24:15.676 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 22:24:15.718 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/list
2020-04-26 22:24:15.718 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /admin/getInfo
2020-04-26 22:24:15.718 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listFront
2020-04-26 22:24:15.718 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 22:24:15.718 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 22:24:15.718 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 22:24:15.718 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 22:24:15.718 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.AdminController.getInfo
2020-04-26 22:24:15.718 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 22:24:15.718 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 22:24:15.719 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 22:24:15.719 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogList
2020-04-26 22:24:15.719 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeLists
2020-04-26 22:24:15.719 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=15, totalPage=0, totalCount=0, list=[], params={}, sortColumn=created_time, sortMethod=DESC)]
2020-04-26 22:24:15.719 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 22:24:15.768 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 94
2020-04-26 22:24:15.772 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"createdTime":"2020-04-09 13:31:20","enable":1,"rotationId":4,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PI6aAZIz1AASCO4hlpJI295.jpg"},{"createdTime":"2020-04-09 13:37:02","enable":1,"rotationId":9,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJPyAbm8fAAG9gfO8lxE28.jpeg"},{"createdTime":"2020-04-09 13:41:30","enable":1,"rotationId":10,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJgeAeG8wAAS2pjJC5QU547.jpg"},{"createdTime":"2020-04-09 13:41:38","enable":1,"rotationId":11,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhGAQFZbAAP2OOBWb6k310.jpg"},{"createdTime":"2020-04-09 13:41:50","enable":1,"rotationId":12,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhyABMZCAAG7doyXiM8109.jpg"},{"createdTime":"2020-04-09 13:41:59","enable":1,"rotationId":13,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJiWAL7BoAARW3_O3ISw651.jpg"}],"msg":"操作成功!"}
2020-04-26 22:24:15.801 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 82
2020-04-26 22:24:15.802 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"header":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMSKACehsAACHOzTvceE295.jpg","id":1,"name":"小屋","signature":"时光好不经用，转眼已是半生","username":"admin"},"msg":"操作成功!"}
2020-04-26 22:24:15.823 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 105
2020-04-26 22:24:15.824 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":1,"typeName":"Linux"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":2,"typeName":"Docker"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"SpringBoot"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":4,"typeName":"Mybatis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":5,"typeName":"爬虫"},{"deleted":0,"enable":1,"typeBlogCount":4,"typeId":6,"typeName":"博客开发和维护总结"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":7,"typeName":"CSS"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"JavaScript"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Vue"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":10,"typeName":"随笔"},{"deleted":0,"enable":1,"typeBlogCount":16,"typeId":11,"typeName":"java面试篇"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":13,"typeName":"JDK源码阅读"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":14,"typeName":"redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":15,"typeName":"MongoDB"},{"deleted":0,"enable":1,"typeBlogCount":28,"typeId":16,"typeName":"LeetCode"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":17,"typeName":"随心日记"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":18,"typeName":"计算机网络"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":19,"typeName":"操作系统"}],"msg":"操作成功!"}
2020-04-26 22:24:15.953 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/recommendRead
2020-04-26 22:24:15.953 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 22:24:15.954 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 22:24:15.955 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.recommendRead
2020-04-26 22:24:15.955 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 22:24:16.025 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/getTotal
2020-04-26 22:24:16.026 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 22:24:16.027 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 22:24:16.027 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getTotal
2020-04-26 22:24:16.028 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 22:24:16.046 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 93
2020-04-26 22:24:16.047 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1248605157059497984","blogRead":27,"blogTitle":"面试（二）------之JAVA基础篇","createdTime":"2020-04-10 13:34:02","typeName":"java面试篇"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1247745014683947008","blogRead":21,"blogTitle":"博客开发总结（一）-----之数据库设计篇","createdTime":"2020-04-08 04:36:07","typeName":"博客开发和维护总结"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1248224512563068928","blogRead":17,"blogTitle":"面试（一）------之JVM篇","createdTime":"2020-04-09 12:21:30","typeName":"java面试篇"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1249742755949817856","blogRead":17,"blogTitle":"面试（三）------之并发编程篇（下）","createdTime":"2020-04-13 16:54:26","typeName":"java面试篇"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1250622112591376384","blogRead":8,"blogTitle":"面试（六）------之网络与负载均衡","createdTime":"2020-04-16 03:08:42","typeName":"java面试篇"}],"msg":"操作成功!"}
2020-04-26 22:24:16.088 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 370
2020-04-26 22:24:16.091 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，0~n-1中缺失的数字</strong></h2>\n<p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>\n<p>示例 1:</p>\n<p>输入: [0,1,3]<br />输出: 2<br />示例&nbsp;2:</p>\n<p>输入: [0,1,2,3,4,5,6,7,9]<br />输出: 8</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主能想到的并且写出来的方法有：使用map存储数组中的所有元素，然后遍历0-n-1找出不在map中的元素。此种方法时间复杂度O（N），空间复杂度O（N）-----垃圾</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 统计0-n-1所有数字的数字和，再统计数组中所有数字的数字和，两和只差即为所求数字，时间复杂度O（N），空间复杂度O（1）-----垃圾</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;最优解法（二分查找法）：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;通常来说，我们使用二分查找法是查找一个存在于数组中的元素，但是本题需要求不在数组中的一个元素，因此到这很多人就会迷惑，不知道该怎么求了。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;但是我们首先要搞明白二分查找法的本质是什么：1，并不局限于仅仅查找存在于数组中的元素；2，二分查找的本质是对数组根据mid中间值在某一条件上进行二分（例如：通常的num[mid]&gt;target或者nums[mid]&lt;target进行左右切分）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;因此明白这一点，就好解决问题了。拿到这道题，使用二分，我们首先想到的应该是寻找根据mid中间值进行二分的条件</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;审题：题目中提及数组为递增数组，而且0-n-1内的n个数字有一个不在数组中，则不在的这个数字之前的数字满足nums[i]=i即元素本身等于数组下标，而之后的数字nums[i]!=i,所以这就是进行二分的条件了</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 二分查找法\n     * 算法思想：二分查找法的本质是能够有一个条件将数组根据mid中间值进行左右切分\n     * 所以我们想到二分查找法之后，首先需要做的是找出切分数组的条件\n     * 题目中给出了数组是一个递增数组，且0-n-1内的n个数字有一个不在这个长度为n-1的数组内\n     * 因此，不在的这个元素其左边元素必有数组下标值等于元素本身即nums[i]=i\n     * 而不在的这个元素的右边必有nums[i]!=i\n     * 所以根据此条件进行划分数组即可\n     * @param nums\n     * @return\n     */\n    public static int missingNumber(int[] nums) {\n        int low = 0;\n        int high = nums.length-1;\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]==mid){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        return low;\n    }</code></pre>","blogGoods":0,"blogId":"1254063045920022528","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kUM-AON88AAAaZr2Bc1U903.jpg","blogRead":0,"blogRemark":"剑指offer----0~n-1中缺失的数字","blogTitle":"剑指offer----0~n-1中缺失的数字","createdTime":"2020-04-25 23:01:44","typeName":"LeetCode","updateTime":"2020-04-25 23:01:44"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，在排序数组中查找数字I</strong></h2>\n<p>统计一个数字在排序数组中出现的次数。</p>\n<p>示例 1:</p>\n<p>输入: nums = [5,7,7,8,8,10], target = 8<br />输出: 2<br />示例&nbsp;2:</p>\n<p>输入: nums = [5,7,7,8,8,10], target = 6<br />输出: 0</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解法一：直接遍历统计，时间复杂度为O（N）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 遍历数组\n     * 找到第一个与目标元素相等的元素，res+1\n     * 然后往后找到第一个与目标元素不相等的元素,返回res即可\n     * 时间复杂度为O(N)\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static int search(int[] nums, int target) {\n        int res = 0;\n        for (int num : nums) {\n            if(num==target){\n                res++;\n            }\n        }\n        return res;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解法二：二分法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：利用二分法查找数字在排序数组中的左边界Left和右边界Right.如下，如果要寻找数组中的8，则其左边界为left=2,有边界right=5.所以出现次数为right-left-1.时间复杂度为O（logN）</strong></p>\n<table style=\"width: 20%; border-collapse: collapse; margin-left: auto; margin-right: auto;\" border=\"1\" cellpadding=\"5\">\n<tbody>\n<tr>\n<td style=\"width: 16.6667%;\">5</td>\n<td style=\"width: 16.6667%;\">7</td>\n<td style=\"width: 16.6667%;\">7</td>\n<td style=\"width: 16.6667%;\">8</td>\n<td style=\"width: 16.6667%;\">8</td>\n<td style=\"width: 16.6667%;\">10</td>\n</tr>\n</tbody>\n</table>\n<pre class=\"language-java\"><code>    /**\n     * 二分查找法\n     * 时间复杂度为O（logN）\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static int search2(int[] nums, int target){\n        int low = 0;\n        int high = nums.length-1;\n        int left,right;\n        left = right = 0;\n        //一次二分\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]&lt;=target){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        right = low;\n\n        low = 0;\n        high = nums.length -1;\n        //二次二分\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]&lt;target){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        left = high;\n        return right -left -1;\n    }</code></pre>","blogGoods":0,"blogId":"1254055163115724800","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kSXiAYRyFAAAaZr2Bc1U379.jpg","blogRead":0,"blogRemark":"剑指offer----在排序数组中查找数字I----LeetCode34","blogTitle":"剑指offer----在排序数组中查找数字I----LeetCode34","createdTime":"2020-04-25 22:30:24","typeName":"LeetCode","updateTime":"2020-04-25 22:30:24"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，两个链表的第一个公共节点</strong></h2>\n<p><strong><img src=\"https://images-cdn.shimo.im/Wd1NC8pveQYp9iIL.png__thumbnail\" alt=\"示例图\" width=\"742\" height=\"241\" /></strong></p>\n<p><strong>这是我从官方截下的一张图，也是有些人疑惑的地方，因为官方这张图给出的公共节点为8，而大多数人看到这张图，认为公共节点应该是1.</strong></p>\n<p><strong>但是实际上这里的公共节点不仅要节点的value相等，同时还需要节点的地址相等。从图中可以看出两个1节点虽然值相等，但是地址却不同，因而不是公共节点</strong></p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解法一：双指针</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：初始化两个指针p1=headA,p2=headB</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;分别遍历两个链表，求出两个链表的长度l1,l2</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;然后重置p1,p2指针指向头节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;让长链表的指针先走多的步数（l1-l2或者l2-l1）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;然后让两个指针同时走，直到两者相遇，即找到公共节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解疑：弄清楚第一个value相等的节点和指针相遇的节点，这两种节点是不同的，指针相遇的节点，不仅包含value相等，同时地址也相等。（如图中的8）；而第一个value相等的节点则可能并不在同一个地址，因此不一定是公共节点</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法\n     * @param headA\n     * @param headB\n     * @return\n     */\n    public static ListNode getIntersectionNode2(ListNode headA, ListNode headB){\n        ListNode p1 =headA;\n        ListNode p2 = headB;\n        int l1 = 0;\n        int l2 = 0;\n        //计算链表1的长度\n        while(p1!=null){\n            l1++;\n            p1 = p1.next;\n        }\n        //计算链表2的长度\n        while(p2!=null){\n            l2++;\n            p2 = p2.next;\n        }\n        p1 = headA;\n        p2 = headB;\n        //让长链表指针先走长的步数\n        if(l1&gt;l2){\n            for (int i = 0; i &lt; l1-l2; i++) {\n                p1 = p1.next;\n            }\n        }else{\n            for (int i = 0; i &lt; l2-l1; i++) {\n                p2 = p2.next;\n            }\n        }\n        //然后让两个指针同时走，直到相遇\n        while(p1!=p2){\n            p1 = p1.next;\n            p2 = p2.next;\n        }\n        return p1;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;解法二（大神解法）：丘比特相遇法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;利用两个指针p1=headA,p2=headB,让两个指针同时走，</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果p1先走到底，就将p1置为headB，</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果p2,先走到底，就将p2置为headA,</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;当两个指针相遇的时候，他们就相爱了（当然是找到公共节点了）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法p1=headA,p2=headB\n     * 思想是：两个节点同时从各自的链表出发\n     * p1走到末尾时，回到headB的头部\n     * p2走到末尾时，回到headA的头部\n     * 两个指针相遇的时候，即使要找的公共节点\n     * @param headA\n     * @param headB\n     * @return\n     */\n    public static ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode p1 = headA;\n        ListNode p2 = headB;\n        while(p1!=p2){\n            p1 = (p1==null)?headB:p1.next;\n            p2 = (p2==null)?headA:p2.next;\n        }\n        return p1;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1253992797703364608","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kD2OADD3mAAAaZr2Bc1U709.jpg","blogRead":0,"blogRemark":"剑指offer----之两个链表的第一个公共节点----LeetCode160","blogTitle":"剑指offer----之两个链表的第一个公共节点----LeetCode160","createdTime":"2020-04-25 18:22:35","typeName":"LeetCode","updateTime":"2020-04-25 18:22:35"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，第一个只出现一次的字符</strong></h2>\n<p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。</p>\n<p>示例:</p>\n<p>s = \"abaccdeff\"<br />返回 \"b\"</p>\n<p>s = \"\" <br />返回 \" \"</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主现在发现，做一道算法题的时候，最重要的一步就是读题，审题，在草稿纸上写下自己的思路（当然那种望眼欲穿的大佬除外）。然后才开始动笔，对于IT人来说，真的，多将时间花费在思考上面，而不是无意义的重复搬砖。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;题目分析：看到这道题，抓住两个关键字：第一个，只出现一次。什么意思呢，例如\"abaccdeff\"，其中只出现一次的字符有'b','d','e'三个，然后在三个字符中第一个出现在字符串中的是'b'，因此本题的答案是'b'.</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法分析：根据题目分析，我们最直观的解法应该是，先找出字符串中只出现一次的字符，然后再找出只出现一次字符中，第一个在字符串中出现的。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;所以我们需要做两件事，一是统计字符串中各个字符的出现次数，并且记录；二，统计完毕后，找出第一个出现次数为1的字符，返回即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;因此我们既要存字符，还要存字符对应的出现次数，所以理所当然我们选择map集合。当然对于本题而言，因为求第一个出现一次的字符，所以我们更好的是可以使用LinkedHashMap。这样免去最后的一次遍历字符串</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;下面提供两种解法：三种解法都是使用map集合，但是略有不同</strong></p>\n<p><strong>LinkedHashMap：（这是博主写的，代码冗余，这里用来和大神的写法做比较，警醒自己）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 用LinkedHashMap\n     * 思想：遍历字符串，如果map为空或者map中不含当前字符，则将其存入map\n     * 如果map中已经含有当前字符，则从map中移除\n     * 最终map中只剩出现一次的字符\n     * 返货map中的第一个即可\n     * @param s\n     * @return\n     */\n    public static char firstUniqChar(String s) {\n        Map&lt;Character,Integer&gt;map = new LinkedHashMap&lt;&gt;();\n        for (int i = 0; i &lt; s.length(); i++) {\n            char ch = s.charAt(i);\n            if(map.isEmpty()||!map.containsKey(ch)){\n                map.put(ch,1);\n            }else{\n                Integer val = map.get(ch);\n                map.put(ch,++val);\n            }\n        }\n        //返回map中第一个元素即可\n        Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entries = map.entrySet();\n        for (Map.Entry&lt;Character, Integer&gt; entry : entries) {\n            if(entry.getValue()==1){\n                return entry.getKey();\n            }\n        }\n        return ' ';\n    }</code></pre>\n<p><strong>HashMap（大神解法）：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 哈希表法\n     * @param s\n     * @return\n     */\n    public char firstUniqChar2(String s) {\n        Map&lt;Character,Boolean&gt; map = new HashMap&lt;&gt;();\n        char[] chars = s.toCharArray();\n        for (char ch : chars) {\n            map.put(ch,!map.containsKey(ch));\n        }\n        for (char ch : chars) {\n            if(map.get(ch)){\n                return ch;\n            }\n        }\n        return ' ';\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;分析：首先，这里提供了两种解法，一种为LinkedHashMap，一种为HashMap，这两种解法的不同之处就在于最后获取值的时候，LinkedHashMap获取最终值是遍历LinkedHashMap的entrySet，但是HashMap获取最终值是遍历原字符串。因而当数据庞大的时候，显然使用LinkedHashMap性能更高。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;然后，再分析一下这两种解法不另外一个不同之处，没错！就是大神的解法中使用map存放key对应的value值是Boolean型！（<span style=\"background-color: #ffcc00;\">这个真的是神一般的存在</span>），既省去了计算次数的麻烦，同时最后取的时候也不需要判断次数。wc！同一种解法，为什么天差地别！</strong></p>","blogGoods":0,"blogId":"1253956468789600256","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6j7Y6ACrySAAAaZr2Bc1U825.jpg","blogRead":0,"blogRemark":"剑指offer----第一次只出现一次的字符","blogTitle":"剑指offer----第一次只出现一次的字符","createdTime":"2020-04-25 15:58:14","typeName":"LeetCode","updateTime":"2020-04-25 15:58:14"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，连续子数组的最大和</strong></h2>\n<p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>\n<p>要求时间复杂度为O(n)。</p>\n<p>示例1:</p>\n<p>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br />输出: 6<br />解释:&nbsp;连续子数组&nbsp;[4,-1,2,1] 的和最大，为&nbsp;6。</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;看到这道题，最简单的想法肯定是求出所有连续子数组的值，然后进行比较，找出最大的即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;但是随后会想到既然要找出所有的子数组，那么我们可以使用分治的思想，因为分治的分过程即可以得到所有子序列</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;随后，再深一步，既然可以分治的思想，分的过程即是递归的过程，而且子数组的最大值依赖与前一子数组，所以可以想到使用动态规划</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：设dp[i]为以nums[i]为结尾的最大子数组和，初始值dp[0] = nums[0]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;遍历数组，如果dp[i-1]&gt;=0。则说明前面的最大子数组对当前子数组有增益效果，所以dp[i] = dp[i-1]+nums[i]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果dp[i-1]&lt;0。说明前面的最大子数组对当前子数组有夫负效果，还不如nums[i]本身，所以dp[i]=nums[i]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主的这样的写法：时间复杂度为O（N），空间复杂度也为O（N），但是实际上不需要使用dp数组，使用nums原数组就行，所以可以减小空间复杂度为O（1）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 动态规划\n     * 算法思想：因为求的是连续子数组的最大和\n     * 所以我们可以设dp[i]为以nums[i]结尾的最大连续子数组\n     * 如果dp[i]&lt;=nums[i],dp[i]=nums[i]\n     * 如果dp[i]&gt;nums[i],则dp[i]=dp[i]+nums[i]\n     * @param nums\n     * @return\n     */\n    public static int maxSubArray(int[] nums) {\n        int[] dp  = new int[nums.length];\n        dp[0] = nums[0];\n        int res = nums[0];\n        for (int i = 1; i &lt; nums.length; i++) {\n            if(dp[i-1]&lt;0){\n                dp[i] = nums[i];\n            }else{\n                dp[i] = dp[i-1]+nums[i];\n            }\n            res = Math.max(res,dp[i]);\n        }\n        return res;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1253938714590175232","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6j3QSACLxRAAAaZr2Bc1U017.jpg","blogRead":0,"blogRemark":"剑指offer---连续子数组的最大和---LeetCode53","blogTitle":"剑指offer---连续子数组的最大和---LeetCode53","createdTime":"2020-04-25 14:47:41","typeName":"LeetCode","updateTime":"2020-04-25 14:47:41"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，最小的k个数</strong></h2>\n<p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>\n<p>示例 1：</p>\n<p>输入：arr = [3,2,1], k = 2<br />输出：[1,2] 或者 [2,1]<br />示例 2：</p>\n<p>输入：arr = [0,1,2,1], k = 1<br />输出：[0]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;1,可以采用快排的思想，将原数组按照升序排序，然后取出前k个数即可，时间复杂度为O（NlogN）。但是其实跟API中的sort方法好像差别不大</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 对原数组升序排序，然后取前k个元素\n     * @param arr\n     * @param k\n     * @return\n     */\n    public static int[] getLeastNumbers(int[] arr, int k) {\n        quickSort(arr,0,arr.length-1);\n        int[] result = new int[k];\n        for (int i = 0; i &lt; k; i++) {\n            result[i] = arr[i];\n        }\n        return result;\n    }\n\n    /**\n     * 快排\n     * @param nums\n     * @param low\n     * @param high\n     */\n    public static void quickSort(int[] nums,int low,int high){\n        int base = nums[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //先从右向左找到第一个小于基准元素的元素\n            while(L&lt;R&amp;&amp;nums[R]&gt;=base){\n                R--;\n            }\n            if(nums[R]&lt;base){\n                swap(nums,L,R);\n            }\n            //再从左向右找到第一个大于基准元素的元素\n            while(L&lt;R&amp;&amp;nums[L]&lt;=base){\n                L++;\n            }\n            if(nums[L]&gt;base){\n                swap(nums,L,R);\n            }\n        }\n        //左递归\n        if(L&gt;low){\n            quickSort(nums,low,L-1);\n        }\n        //右递归\n        if(high&gt;R){\n            quickSort(nums,R+1,high);\n        }\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>2，堆排序：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;先讲解一下堆排序：堆排序是一种完全二叉树的结构，常见的存在两种堆结构，小根堆（即满足arr[2i+1]&gt;=arr[i]&amp;&amp;arr[2i+2]&gt;=arr[i]），大根堆（即满足arr[2i+1]&lt;=arr[i]&amp;&amp;arr[2i+2]&lt;=arr[i]）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;基本算法思想：第一步，初始化堆，即堆初始化为大根堆或者小根堆（这里我们简称调整堆）；第二步，将堆顶元素与堆的末尾元素进行交换，然后重新调整堆。在java中堆通常用来实现优先级队列PriorityQueue(默认的采用小根堆，若想使用大根堆，需要在创建时实现comparator)</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;使用情况：这里以java中的优先级队列为例，堆的使用情况不能按照堆名断章取义，例如小根堆实际上是将元素升序存放，因为在算法第二步中将堆顶元素与末尾元素进行交换，然后重新调整，交换的堆顶元素为最小元素，也是最先从堆中进入队列的。所以小根堆适用于TOPk大的算法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;相反的，大根堆适用于TOPk小的算法，下面分别给出小根堆和大根堆的算法：</strong></p>\n<p><strong>小根堆：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 堆排序---小根堆\n     * @param nums\n     */\n    public static void HeapSort(int[] nums){\n        //先初始化堆\n        for (int i = nums.length/2-1; i &gt;=0 ; i--) {\n            adjustHeap(nums,i,nums.length);\n        }\n        //交换堆顶与末尾节点+重新调整为小根堆\n        for (int i = nums.length-1; i &gt;0; i--) {\n            //先交换\n            swap(nums,0,i);\n            //再调整\n            adjustHeap(nums,0,i);\n        }\n    }\n\n    /**\n     * 调整为小根堆\n     * @param nums\n     * @param i\n     * @param length\n     */\n    public static void adjustHeap(int[] nums,int i,int length){\n        int temp = nums[i];\n        for (int j = 2*i+1; j &lt; length; j=2*j+1) {\n            //找出左右节点中的最小值\n            if(j+1&lt;length&amp;&amp;nums[j]&gt;nums[j+1]){\n                j++;\n            }\n            if(nums[j]&lt;temp){\n                nums[i] = nums[j];\n                i = j;\n            }\n        }\n        nums[i] = temp;\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p><strong>大根堆：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 堆排序---大根堆\n     * @param nums\n     */\n    public static void heapSort(int[] nums){\n\n        //初始化堆的过程\n        for (int i = nums.length/2-1; i &gt;=0; i--) {\n            adjustHeap(nums,i,nums.length);\n        }\n        //调整+交换堆顶和末尾的元素\n        for (int i = nums.length-1; i &gt;0; i--) {\n            //先交换，再重新调整\n            swap(nums,0,i);\n            adjustHeap(nums,0,i);\n        }\n    }\n\n    /**\n     * 调整大顶堆的过程\n     * @param nums\n     * @param i\n     * @param length\n     */\n    public static void adjustHeap(int[] nums,int i,int length){\n        int temp = nums[i];\n        for (int j = 2*i+1; j &lt; length; j=2*j+1) {\n            //找出左右节点中的最大值\n            if(j+1&lt;length&amp;&amp;nums[j]&lt;nums[j+1]){\n                j++;\n            }\n            if(nums[j]&gt;temp){\n                nums[i] = nums[j];\n                i = j;\n            }\n        }\n        nums[i] = temp;\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>本题利用大根堆解法，且使用java中自带的优先级队列PriorityQueue：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用堆数据结构，java中的优先级队列对应着最小堆\n     * 实现其comparator即可\n     * @param arr\n     * @param k\n     * @return\n     */\n    public static int[] getLeastNumbers2(int[] arr, int k){\n        Queue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(k,(v1,v2)-&gt;v2-v1);\n        for (int i : arr) {\n            if(heap.isEmpty()||heap.size()&lt;k||i&lt;heap.peek()){\n                heap.offer(i);\n            }\n            if(heap.size()&gt;k){\n                heap.poll();\n            }\n        }\n        int[] result = new int[k];\n        int j = 0;\n        for (Integer val : heap) {\n            result[j++] = val;\n        }\n        return result;\n    }</code></pre>","blogGoods":0,"blogId":"1253874832811089920","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6joYWAF3oqAAAaZr2Bc1U671.jpg","blogRead":2,"blogRemark":"剑指offer----之最小的k个数","blogTitle":"剑指offer----之最小的k个数","createdTime":"2020-04-25 10:33:50","typeName":"LeetCode","updateTime":"2020-04-25 11:53:15"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，数组中出现次数超过一半的元素---即众数</strong></h2>\n<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>\n<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>\n<p>示例&nbsp;1:</p>\n<p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br />输出: 2</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>方法有三：哈希表统计法，数组排序法，摩尔投票法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;哈希统计法：时间复杂度O（N），空间复杂度O（N）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 博主刚开始看到这道题的时候，首先想到的是哈希表统计法，因为博主想的是要找到众数，那么肯定得统计每个数字的出现次数，然后按照次数比较。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 单单是想到这些，用了map集合之后发现还是不行，因为即便用map集合统计出了每个数字和其对应的出现次数之后，你会发现没有办法按照出现的次数进行比较并且得到次数最多的数字（众数</strong><strong>）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 然后，就又审了一遍题目，结果发现了一个本题很关键的点，（<span style=\"background-color: #ffcc00;\">数组中有一个数字出现的次数超过数组长度的一半</span>），也就是说数组中有且仅有一个数字的出现次数会超过数组长度的一半（别笑博主笨，我是真的刚开始没反应过来）</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 那么我为什么要把数组中的所有元素和其次数全部存放进入map集合，然后再取次数进行比较呢？我为什么不在将元素和其次数存入集合的过程中判断次数是否已经超过数组长度的一半了呢？如果超过一半了，那它肯定是众数了呀！</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 思路：根据题意需要找出两个东西，一是多素元素，二是多素元素的出现次数\n     * 所以我们首先想到的是采用map集合\n     * 然后遍历数组，如果元素不存在与集合中，我们就将其加入map，value置为1\n     * 如果元素存在于map中，则我们取出其value将其加1与数组长度的一半做比较\n     * 如果大于数组长度一半，直接返回该元素即可\n     * 小于数组长度一半，则将其value加1存入map覆盖原有的值即可\n     *\n     * @param nums\n     * @return\n     */\n    public static int majorityElement(int[] nums) {\n        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(nums.length);\n        for (int num : nums) {\n            if(!map.containsKey(num)){\n                map.put(num,1);\n            }else{\n                Integer val = map.get(num);\n                if(++val&gt;nums.length/2){\n                    return num;\n                }else{\n                    map.put(num,val);\n                }\n            }\n        }\n        throw new RuntimeException(\"\");\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>数组排序法：由题可知，数组众必然存在一个多数元素，且出现次数超过数组长度的一半。所以我们可以对原数组进行排序，然后取数组中间的元素即可。（我擦，我当时看到这个，就在想，好简单，这个思路，但是我为什么没想到，对，因为我没有仔细的分析题目，超过一半看见没）。既然进行排序，那么我们可以选择快排，这样时间复杂度就是O（NlogN），空间复杂度O（1）.</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 数组排序法，因为多数元素的出现次数超过数组长度一半，\n     * 所以我们可以先对其进行排序，采用快排，时间复杂度O（NlogN）\n     * 然后取数组中点元素即可\n     * @param nums\n     * @return\n     */\n    public static int majorityElement2(int[] nums){\n        quickSort(nums,0,nums.length-1);\n        return nums[nums.length/2];\n    }\n\n    /**\n     * 快排\n     * @param nums\n     * @param low\n     * @param high\n     */\n    public static void quickSort(int[] nums,int low,int high){\n        int base = nums[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //从右向左找到第一个比基准元素小的元素\n            while(L&lt;R&amp;&amp;nums[R]&gt;=base){\n                R--;\n            }\n            if(nums[R]&lt;base){\n                swap(nums,L,R);\n            }\n            //从左向右找到第一个比基准元素大的元素\n            while(L&lt;R&amp;&amp;nums[L]&lt;=base){\n                L++;\n            }\n            if(nums[L]&gt;base){\n                swap(nums,L,R);\n            }\n        }\n        //左递归\n        if(L&gt;low){\n            quickSort(nums,low,L-1);\n        }\n        //右递归\n        if(high&gt;R){\n            quickSort(nums,R+1,high);\n        }\n    }\n\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>摩尔投票法（我将其称为大佬解法）：大概的意思就是采用正负抵消的方法，设置一个投票变量votes，初始设置为0；设置一个本题中的众数变量x，初始设置为数组首元素。然后遍历数组，判断跟设置的众数变量是否相等，如果相等将votes加一，如果不相等，则重置votes为0，且将x设置为数组下一个元素。本题众因为已经声明了肯定存在众数，所以不需要进行验证，但是如果没有声明的话，需要验证，下列代码众添加了验证：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 摩尔投票法\n     * @param nums\n     */\n    public static int majorityElement3(int[] nums){\n        int votes = 0;\n        int x = nums[0];\n        int count = 0;\n        for (int num : nums) {\n            if(votes==0){\n                x = num;\n            }\n            votes+=(num==x)?1:-1;\n        }\n        //验证数组众是否存在众数\n        for (int num : nums) {\n            if(num==x){\n                count++;\n            }\n        }\n        return count&gt;nums.length/2?x:0;\n    }</code></pre>","blogGoods":0,"blogId":"1253674617332162560","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6i5v-AUh39AAAaZr2Bc1U885.jpg","blogRead":0,"blogRemark":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","blogTitle":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","createdTime":"2020-04-24 21:18:14","typeName":"LeetCode","updateTime":"2020-04-24 21:18:14"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，从上到下打印二叉树-2</strong></h2>\n<p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>\n<p>例如:<br />给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>\n<p>3<br />/ \\<br />9 20<br />/ \\<br />15 7<br />返回其层次遍历结果：</p>\n<p>[<br />[3],<br />[9,20],<br />[15,7]<br />]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;BFS（广度优先搜索）：层次遍历</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * BFS\n     * @param root\n     * @return\n     */\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {\n        if (root == null) {\n            return new ArrayList&lt;&gt;(0);\n        }\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();\n        TreeNode current;\n        while (!queue.isEmpty()) {\n            List&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();\n            for (int i = queue.size(); i &gt; 0; i--) {\n                current = queue.poll();\n                arrayList.add(current.val);\n                if (current.left != null) {\n                    queue.add(current.left);\n                }\n                if (current.right != null) {\n                    queue.add(current.right);\n                }\n            }\n            list.add(arrayList);\n        }\n        return list;\n    }</code></pre>","blogGoods":0,"blogId":"1253350612905598976","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6huUyATZJ_AAAaZr2Bc1U363.jpg","blogRead":1,"blogRemark":"剑指offer----之从上到下打印二叉树----LeetCode102","blogTitle":"剑指offer----之从上到下打印二叉树----LeetCode102","createdTime":"2020-04-23 23:50:45","typeName":"LeetCode","updateTime":"2020-04-23 23:50:57"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，从上打印二叉树-1</strong></h2>\n<p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>\n<p>例如:<br />给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>\n<p>3<br />/ \\<br />9 20<br />/ \\<br />15 7<br />返回：</p>\n<p>[3,9,20,15,7]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;BFS（广度优先搜索）：也即是二叉树的层次遍历，代码和注意事项看代码注释</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 二叉树的层次遍历\n     * 这里是将层次遍历的结果存储在数组中\n     * 但是因为二叉树的节点个数并不知道\n     * 所以不能使用数组直接进行存储，因为无法初始化数组的大小\n     * 所以可以想到使用容量能自动扩充的list集合\n     * 然后再根据list集合的size来初始化数组的大小\n     * 并且将list元素赋值到数组中\n     * @param root\n     * @return\n     */\n    public static int[] levelOrder(TreeNode root) {\n        if(root==null){\n            return new int[0];\n        }\n        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n        TreeNode current;\n        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n        while(!queue.isEmpty()){\n            current = queue.poll();\n            list.add(current.val);\n            if(current.left!=null){\n                queue.add(current.left);\n            }\n            if(current.right!=null){\n                queue.add(current.right);\n            }\n        }\n        int[] result = new int[list.size()];\n        for (int i = 0; i &lt; list.size(); i++) {\n            result[i] = list.get(i);\n        }\n        return result;\n    }</code></pre>","blogGoods":0,"blogId":"1253346228108894208","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6htTeAUHGlAAAaZr2Bc1U102.jpg","blogRead":0,"blogRemark":"剑指offer----之从上到下打印二叉树","blogTitle":"剑指offer----之从上到下打印二叉树","createdTime":"2020-04-23 23:33:20","typeName":"LeetCode","updateTime":"2020-04-23 23:33:20"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，包含min函数的栈</strong></h2>\n<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>\n<p>&nbsp;</p>\n<p>示例:</p>\n<p>MinStack minStack = new MinStack();<br />minStack.push(-2);<br />minStack.push(0);<br />minStack.push(-3);<br />minStack.min(); --&gt; 返回 -3.<br />minStack.pop();<br />minStack.top(); --&gt; 返回 0.<br />minStack.min(); --&gt; 返回 -2.</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>&nbsp;辅助栈法：即初始化两个栈A,B</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;A栈用于实现基本的push(),pop(),top()的正常逻辑</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;B栈用来存放A栈中的非严格降序元素（这个我也理解不了，看代码就知道是存放什么的啦），代码中的方法注释很清楚</strong></p>\n<pre class=\"language-java\"><code>public class MinStack {\n    /** initialize your data structure here. */\n    Stack&lt;Integer&gt; A,B;\n\n    public MinStack() {\n        A = new Stack&lt;&gt;();\n        B = new Stack&lt;&gt;();\n    }\n\n    /**\n     * 入栈操作，元素先入A栈\n     * 如果B栈为空或者B栈的栈顶元素大于待入栈元素，则B栈也执行入栈操作\n     * @param x\n     */\n    public void push(int x) {\n        A.add(x);\n        if(B.isEmpty()||B.peek()&gt;=x){\n            B.add(x);\n        }\n    }\n\n    /**\n     * 这段代码优点巧妙\n     * 注意这里使用的A.pop()而不是A.peek()\n     * 所以这里实际上是分为两种情况的\n     * 第一种：当A的栈顶元素不为当前栈中的最小元素，即不等于栈B的栈顶元素\n     *         则只进行栈A的出栈操作，即A.pop()\n     * 第二种：当A的栈顶元素为当前栈中的最小元素，即等于栈B的栈顶元素\n     *        则不仅要A.pop(),而且为了保证A,B栈中最小元素的同步性\n     *        B栈也要执行出栈操作\n     */\n    public void pop() {\n        if(A.pop().equals(B.peek())){\n            B.pop();\n        }\n    }\n\n    /**\n     * 正常获取A的栈顶元素\n     * @return\n     */\n    public int top() {\n        return A.peek();\n    }\n\n    /**\n     * 获取A栈的最小元素，即B栈的栈顶元素\n     * @return\n     */\n    public int min() {\n        return B.peek();\n    }\n}</code></pre>","blogGoods":0,"blogId":"1253331349566234624","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hp12AMy2MAAAaZr2Bc1U568.jpg","blogRead":4,"blogRemark":"剑指offer----之包含min函数的栈---LeetCode155","blogTitle":"剑指offer----之包含min函数的栈---LeetCode155","createdTime":"2020-04-23 22:34:13","typeName":"LeetCode","updateTime":"2020-04-23 23:50:51"},{"blogCollection":0,"blogComment":0,"blogContent":"<h3><strong>晚上九点多，坐在床上，面前摆放着电脑，屏幕显示的是LeetCode中的《剑指offer》的题解</strong></h3>\n<h3><strong>此时的我毫无睡意，当然，这并不是因为解出一道题的喜悦冲淡了我的睡意</strong></h3>\n<h3><strong>相反的，这是一种难以言明的心情，包含着对自己无知的羞愧，也包含着别人面对如此无知的自己也能给出耐心回应的感动</strong></h3>\n<h3><strong>人有时或许就是这样，刻意的举动会让人心生防备，但是无意的善举却能温润人心</strong></h3>\n<h3><strong>别人无意的一个回答，一个小举动，一句肯定的话</strong></h3>\n<h3><strong>殊不知却能为对方赋予无穷无尽的能量</strong></h3>\n<h3><strong>将这一天的疲惫和劳累都消除</strong></h3>\n<h3><strong>赠人玫瑰，手有余香</strong></h3>\n<h3><strong>我一直抱着这样的一种心态，或许我无法做到赠人玫瑰，但是我会尽量将自己的善意展现给别人</strong></h3>\n<h3><strong>也许他刚刚好正处于某个难关，而你又刚刚好是他难关之初的引导者</strong></h3>\n<h3><strong>一句话，或许对于你来说只是人生中微不足道的几秒钟</strong></h3>\n<h3><strong>而对他来说，或许可能是多年之后回忆起来也能嘴角上扬的美好岁月</strong></h3>\n<h3><strong>想起前段时间一部剧里面的话，在这里也送给屏幕前的你：愿你永怀善意，清澈明朗</strong></h3>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1253326423486144512","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hosWANYd2AAHQzo49lBU641.jpg","blogRead":3,"blogRemark":"2020-4-23有感","blogTitle":"2020-4-23有感","createdTime":"2020-04-23 22:14:38","typeName":"随心日记","updateTime":"2020-04-25 21:22:30"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，顺时针打印矩阵</strong></h2>\n<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>\n<p>示例 1：</p>\n<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br />输出：[1,2,3,6,9,8,7,4,5]<br />示例 2：</p>\n<p>输入：matrix =&nbsp;[[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br />输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p>\n<p>限制：</p>\n<p>0 &lt;= matrix.length &lt;= 100<br />0 &lt;= matrix[i].length&nbsp;&lt;= 100</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;模拟顺时针打印的这种循环结构：设置四个边界条件，l,r,t,b。按照从左往右，从上往下，从右往左，从下网往上的顺序依次读取矩阵的元素，并且每一次都判断边界是否相遇，直到将整个矩阵元素都加入到数组中即可。</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 设置四个边界值，分别为left=0,right=matrix[0].length-1,top=0,bottom=matrix.length-1\n     * 顺时针顺序即先从左到右，再从上到下，再从右向左，再从下向上，每一次执行都要判断边界值\n     * @param matrix\n     * @return\n     */\n    public static int[] spiralOrder(int[][] matrix) {\n        if(matrix.length==0){\n            return new int[0];\n        }\n        int l = 0;\n        int r=matrix[0].length-1;\n        int t=0;\n        int b=matrix.length-1;\n        int x=0;\n        int[] res = new int[(r+1)*(b+1)];\n        while(true){\n            //从左向右\n            for(int i=l;i&lt;=r;i++){\n                res[x++]=matrix[t][i];\n            }\n            if(++t&gt;b) {\n                break;\n            }\n            //从上向下\n            for(int i=t;i&lt;=b;i++){\n                res[x++] = matrix[i][r];\n            }\n            if(--r&lt;l){\n                break;\n            }\n            //从右向左\n            for(int i=r;i&gt;=l;i--){\n                res[x++] = matrix[b][i];\n            }\n            if(--b&lt;t){\n                break;\n            }\n            //从下往上\n            for(int i=b;i&gt;=t;i--){\n                res[x++] = matrix[i][l];\n            }\n            if(++l&gt;r){\n                break;\n            }\n        }\n        return res;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1253250557729087488","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hXB2ASIQwAAAaZr2Bc1U016.jpg","blogRead":0,"blogRemark":"剑指offer-----之顺时针打印矩阵----LeetCode54","blogTitle":"剑指offer-----之顺时针打印矩阵----LeetCode54","createdTime":"2020-04-23 17:13:11","typeName":"LeetCode","updateTime":"2020-04-23 17:13:11"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，对称的二叉树</strong></h2>\n<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>\n<p>例如，二叉树&nbsp;[1,2,2,3,4,4,3] 是对称的。</p>\n<p>&nbsp; &nbsp; 1<br />&nbsp; &nbsp;/ \\<br />&nbsp; 2 &nbsp; 2<br />&nbsp;/ \\ / \\<br />3 &nbsp;4 4 &nbsp;3<br />但是下面这个&nbsp;[1,2,2,null,3,null,3] 则不是镜像对称的:</p>\n<p>&nbsp; &nbsp; 1<br />&nbsp; &nbsp;/ \\<br />&nbsp; 2 &nbsp; 2<br />&nbsp; &nbsp;\\ &nbsp; \\<br />&nbsp; &nbsp;3 &nbsp; &nbsp;3</p>\n<p>示例 1：</p>\n<p>输入：root = [1,2,2,3,4,4,3]<br />输出：true<br />示例 2：</p>\n<p>输入：root = [1,2,2,null,3,null,3]<br />输出：false</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>递归法：从对称的二叉树中我们可以找到如下规律</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果一个二叉树是对称的，则每一个节点的左右子树也是对称的,因此是递归的</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 设L = root.left，R=root.right，则满足L.left.val = R.right.val;L.right.val=R.left.val;</strong></p>\n<pre class=\"language-java\"><code>public boolean isSymmetric(TreeNode root) {\n        return  root==null?true:recur(root.left,root.right);\n    }\n    public boolean recur(TreeNode L,TreeNode R){\n        if(L==null&amp;&amp;R==null){\n            return true;\n        }\n        if(L==null||R==null||L.val!=R.val){\n            return false;\n        }\n        return recur(L.left,R.right)&amp;&amp;recur(L.right,R.left);\n    }</code></pre>","blogGoods":0,"blogId":"1252992659794968576","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6ga--AKQdvAAAaZr2Bc1U862.jpg","blogRead":1,"blogRemark":"剑指offer----之对称的二叉树----LeetCode101","blogTitle":"剑指offer----之对称的二叉树----LeetCode101","createdTime":"2020-04-23 00:08:23","typeName":"LeetCode","updateTime":"2020-04-23 00:12:33"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，二叉树镜像</strong></h2>\n<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>\n<p>例如输入：</p>\n<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; 2 &nbsp; &nbsp; 7<br />&nbsp;/ \\ &nbsp; / \\<br />1 &nbsp; 3 6 &nbsp; 9<br />镜像输出：</p>\n<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; 7 &nbsp; &nbsp; 2<br />&nbsp;/ \\ &nbsp; / \\<br />9 &nbsp; 6 3&nbsp; &nbsp;1</p>\n<p>示例 1：</p>\n<p>输入：root = [4,2,7,1,3,6,9]<br />输出：[4,7,2,9,6,3,1]</p>\n<p>限制：</p>\n<p>0 &lt;= 节点个数 &lt;= 1000</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;递归法：即递归的去交换根节点的左右子树，直到根节点为叶子节点</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用递归的方法，交换根节点的左子树和右子树\n     * 递归出口为，根节点为叶子节点\n     * @param root\n     * @return\n     */\n    public TreeNode mirrorTree(TreeNode root) {\n        TreeNode center = root;\n        if(center!=null){\n            TreeNode temp = center.left;\n            center.left = center.right;\n            center.right = temp;\n            mirrorTree(center.left);\n            mirrorTree(center.right);\n        }\n        return root;\n    }</code></pre>","blogGoods":0,"blogId":"1252985443281027072","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6gZTWABF55AAAaZr2Bc1U678.jpg","blogRead":0,"blogRemark":"剑指offer----之二叉树的镜像----LeetCode226","blogTitle":"剑指offer----之二叉树的镜像----LeetCode226","createdTime":"2020-04-22 23:39:43","typeName":"LeetCode","updateTime":"2020-04-22 23:39:43"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，合并两个有序链表</strong></h2>\n<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>\n<p>示例1：</p>\n<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br />输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br />限制：</p>\n<p>0 &lt;= 链表长度 &lt;= 1000</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>伪头节点法：即创建一个伪头节点head和一个用于辅助的节点cur</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法：如果l1.val&lt;=l2.val,就让cur指向l1，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l1指向其next</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果l1.val&gt;l2.val,就让cur指向l2，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l2指向其next</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;直到l1和l2有一个为空为止，让cur指向剩余的一个非空链表即可，若两个链表的长度为M,N则时间复杂度为O(M+N)</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用四节点，一个伪头节点，一个当前节点cur，已经链表的两个节点l1,l2\n     * 每次比较l1,l2节点的val大小，将小的节点连接到当前节点cur上即可\n     * 直到l1,l2有一个空，则将剩余的一个非空链表连接到cur尾部即可\n     * @param l1\n     * @param l2\n     * @return\n     */\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode head;\n        ListNode cur;\n        head = cur = new ListNode(0);\n        while(l1!=null&amp;&amp;l2!=null){\n            if(l1.val&lt;=l2.val){\n                cur.next = l1;\n                cur = cur.next;\n                l1 = l1.next;\n            }else{\n                cur.next = l2;\n                cur = cur.next;\n                l2 = l2.next;\n            }\n        }\n        if(l1!=null){\n            cur.next = l1;\n        }\n        if(l2!=null){\n            cur.next = l2;\n        }\n        return head.next;\n    }</code></pre>","blogGoods":0,"blogId":"1252980258446000128","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6gYGWAe-MZAAAaZr2Bc1U550.jpg","blogRead":0,"blogRemark":"剑指offer----之合并有序链表---LeetCode21","blogTitle":"剑指offer----之合并有序链表---LeetCode21","createdTime":"2020-04-22 23:19:06","typeName":"LeetCode","updateTime":"2020-04-22 23:19:06"}],"pageSize":15,"params":{},"sortColumn":"created_time","sortMethod":"DESC","totalCount":53,"totalPage":4},"msg":"操作成功!"}
2020-04-26 22:24:16.125 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 100
2020-04-26 22:24:16.126 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":53,"msg":"操作成功!"}
2020-04-26 22:24:16.224 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /music/listFront
2020-04-26 22:24:16.225 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 22:24:16.229 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 22:24:16.230 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.MusicController.getMusicList
2020-04-26 22:24:16.231 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 22:24:16.245 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /link/list
2020-04-26 22:24:16.246 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 22:24:16.247 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 22:24:16.247 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.LinkController.getLinkList
2020-04-26 22:24:16.248 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 22:24:16.733 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 488
2020-04-26 22:24:16.733 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 509
2020-04-26 22:24:16.739 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"createdTime":"2020-04-08 02:11:26","linkId":1,"linkName":"百度","linkUrl":"www.baidu.com","updateTime":"2020-04-08 02:11:26","version":1},{"createdTime":"2020-04-18 21:39:52","linkId":2,"linkName":"CSDN","linkUrl":"https://www.csdn.net/","updateTime":"2020-04-18 21:39:52","version":1}],"msg":"操作成功!"}
2020-04-26 22:24:16.739 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"artist":"周深","cover":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMh2AFeEFAAAZaWcYmAM180.jpg","id":1,"lrc":"[00:00.37]周深 - 直破穹苍 (《斗破苍穹》动画第三季主题曲)\n[00:02.79]作词：冥凰\n[00:03.86]作曲：李建衡\n[00:05.19]编曲：崔博源、李建衡\n[00:07.13]人声录制：徐威@上海V-Studio\n[00:09.23]监唱：徐威@上海V-Studio\n[00:11.38]混音：周天澈@Studio21A\n[00:24.13]有没有想过 穿越这片沙漠\n[00:32.21]前方是什么\n[00:35.16]是就此陨落\n[00:37.97]还是抓牢命运脉搏\n[00:45.38]他曾经 爱过 恨过 痛过\n[00:51.07]直到望见远处那抹焰火\n[00:56.73]也许这 是祸 是过 是错\n[01:02.41]仍不害怕 去烧灼\n[01:08.50]管那六合八荒 斗一场\n[01:14.06]焰分噬浪谁能抗\n[01:19.28]漫却这漫漫险关 莫登攀\n[01:24.88]他欲乘风 直破穹苍\n[01:43.04]太多的纠葛 太多悲欢离合\n[01:51.39]要人太执着\n[01:54.21]该如何选择\n[01:57.02]才能看清是非漩涡\n[02:04.58]他曾经 哭过 泪过 笑过\n[02:10.16]直到紧握手心那抹焰火\n[02:15.77]走遍这 荒山 大漠 湖泊\n[02:21.49]仍不退缩 去冲破\n[02:27.44]管那龙潭虎穴 斗一场\n[02:32.72]生死福祸也跌宕\n[02:38.28]漫却他太多如果 都过往\n[02:43.86]还来惊诧 满堂\n[02:50.00]管那六合八荒 斗一场\n[02:55.22]焰分噬浪谁能抗\n[03:00.85]漫却这漫漫险关 莫登攀\n[03:06.51]他欲乘风 直破穹苍","name":"直破苍穹","url":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMlWAC1FrAr8ypaThmW479.flac"},{"artist":"冷鸢","cover":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMnWAa32EAABwmk6a5Cs834.jpg","id":2,"lrc":"你是信的开头诗的内容\n童话的结尾\n你是理所当然的奇迹\n你是月色真美\n你是圣诞老人送给我\n好孩子的礼物\n你是三千美丽世界里\n我的一瓢水\n所以让我再靠近一点点\n因为你太温暖\n我会再变得坚强一点点\n因为你太柔软\n交换无名指金色的契约\n给彼此岁月\n说好从今以后都牵着手\n因为要走很远\n你是我万水千山的冒险\n要找的标记点\n你是分割我人生的线\n又将它们相连\n你是前世千次的回眸\n虔诚牵的手\n你是其余所有的一切\n是我的世界\n所以请你再闪亮一点点\n尽管我太平凡\n我会再变得柔软一点点\n因为你太敏感\n交换无名指金色的契约\n给彼此岁月\n说好从今以后都牵着手\n不管要走多远\n让我再靠近一点点\n因为你太温暖\n我会再变得坚强一点点\n因为你太柔软\n交换无名指金色的契约\n给彼此岁月\n说好从今以后都牵着手\n因为要走很远","name":"勾指起誓","url":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMomAGXdvAHZQ_9pwL9c866.mp3"}],"msg":"操作成功!"}
2020-04-26 22:24:24.782 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/list
2020-04-26 22:24:24.782 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 22:24:24.782 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 22:24:24.782 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogList
2020-04-26 22:24:24.783 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=6, pageSize=15, totalPage=4, totalCount=53, list=[BlogVo(blogId=1254063045920022528, blogTitle=剑指offer----0~n-1中缺失的数字, blogImage=http://121.199.34.159/group1/M00/00/01/rBD3pF6kUM-AON88AAAaZr2Bc1U903.jpg, blogContent=<h2><strong>一，0~n-1中缺失的数字</strong></h2>
<p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<p>示例 1:</p>
<p>输入: [0,1,3]<br />输出: 2<br />示例&nbsp;2:</p>
<p>输入: [0,1,2,3,4,5,6,7,9]<br />输出: 8</p>
<h2><strong>二，题解</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主能想到的并且写出来的方法有：使用map存储数组中的所有元素，然后遍历0-n-1找出不在map中的元素。此种方法时间复杂度O（N），空间复杂度O（N）-----垃圾</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 统计0-n-1所有数字的数字和，再统计数组中所有数字的数字和，两和只差即为所求数字，时间复杂度O（N），空间复杂度O（1）-----垃圾</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;最优解法（二分查找法）：</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;通常来说，我们使用二分查找法是查找一个存在于数组中的元素，但是本题需要求不在数组中的一个元素，因此到这很多人就会迷惑，不知道该怎么求了。</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;但是我们首先要搞明白二分查找法的本质是什么：1，并不局限于仅仅查找存在于数组中的元素；2，二分查找的本质是对数组根据mid中间值在某一条件上进行二分（例如：通常的num[mid]&gt;target或者nums[mid]&lt;target进行左右切分）</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;因此明白这一点，就好解决问题了。拿到这道题，使用二分，我们首先想到的应该是寻找根据mid中间值进行二分的条件</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;审题：题目中提及数组为递增数组，而且0-n-1内的n个数字有一个不在数组中，则不在的这个数字之前的数字满足nums[i]=i即元素本身等于数组下标，而之后的数字nums[i]!=i,所以这就是进行二分的条件了</strong></p>
<pre class="language-java"><code>    /**
     * 二分查找法
     * 算法思想：二分查找法的本质是能够有一个条件将数组根据mid中间值进行左右切分
     * 所以我们想到二分查找法之后，首先需要做的是找出切分数组的条件
     * 题目中给出了数组是一个递增数组，且0-n-1内的n个数字有一个不在这个长度为n-1的数组内
     * 因此，不在的这个元素其左边元素必有数组下标值等于元素本身即nums[i]=i
     * 而不在的这个元素的右边必有nums[i]!=i
     * 所以根据此条件进行划分数组即可
     * @param nums
     * @return
     */
    public static int missingNumber(int[] nums) {
        int low = 0;
        int high = nums.length-1;
        while(low&lt;=high){
            int mid = (low+high)/2;
            if(nums[mid]==mid){
                low = mid+1;
            }else{
                high = mid-1;
            }
        }
        return low;
    }</code></pre>, blogGoods=0, blogRead=0, blogCollection=0, typeName=LeetCode, blogRemark=剑指offer----0~n-1中缺失的数字, blogComment=0, blogSource=null, createdTime=2020-04-25 23:01:44, blogMonth=null, updateTime=2020-04-25 23:01:44), BlogVo(blogId=1254055163115724800, blogTitle=剑指offer----在排序数组中查找数字I----LeetCode34, blogImage=http://121.199.34.159/group1/M00/00/01/rBD3pF6kSXiAYRyFAAAaZr2Bc1U379.jpg, blogContent=<h2><strong>一，在排序数组中查找数字I</strong></h2>
<p>统计一个数字在排序数组中出现的次数。</p>
<p>示例 1:</p>
<p>输入: nums = [5,7,7,8,8,10], target = 8<br />输出: 2<br />示例&nbsp;2:</p>
<p>输入: nums = [5,7,7,8,8,10], target = 6<br />输出: 0</p>
<h2><strong>二，题解</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解法一：直接遍历统计，时间复杂度为O（N）</strong></p>
<pre class="language-java"><code>    /**
     * 遍历数组
     * 找到第一个与目标元素相等的元素，res+1
     * 然后往后找到第一个与目标元素不相等的元素,返回res即可
     * 时间复杂度为O(N)
     * @param nums
     * @param target
     * @return
     */
    public static int search(int[] nums, int target) {
        int res = 0;
        for (int num : nums) {
            if(num==target){
                res++;
            }
        }
        return res;
    }</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解法二：二分法</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：利用二分法查找数字在排序数组中的左边界Left和右边界Right.如下，如果要寻找数组中的8，则其左边界为left=2,有边界right=5.所以出现次数为right-left-1.时间复杂度为O（logN）</strong></p>
<table style="width: 20%; border-collapse: collapse; margin-left: auto; margin-right: auto;" border="1" cellpadding="5">
<tbody>
<tr>
<td style="width: 16.6667%;">5</td>
<td style="width: 16.6667%;">7</td>
<td style="width: 16.6667%;">7</td>
<td style="width: 16.6667%;">8</td>
<td style="width: 16.6667%;">8</td>
<td style="width: 16.6667%;">10</td>
</tr>
</tbody>
</table>
<pre class="language-java"><code>    /**
     * 二分查找法
     * 时间复杂度为O（logN）
     * @param nums
     * @param target
     * @return
     */
    public static int search2(int[] nums, int target){
        int low = 0;
        int high = nums.length-1;
        int left,right;
        left = right = 0;
        //一次二分
        while(low&lt;=high){
            int mid = (low+high)/2;
            if(nums[mid]&lt;=target){
                low = mid+1;
            }else{
                high = mid-1;
            }
        }
        right = low;

        low = 0;
        high = nums.length -1;
        //二次二分
        while(low&lt;=high){
            int mid = (low+high)/2;
            if(nums[mid]&lt;target){
                low = mid+1;
            }else{
                high = mid-1;
            }
        }
        left = high;
        return right -left -1;
    }</code></pre>, blogGoods=0, blogRead=0, blogCollection=0, typeName=LeetCode, blogRemark=剑指offer----在排序数组中查找数字I----LeetCode34, blogComment=0, blogSource=null, createdTime=2020-04-25 22:30:24, blogMonth=null, updateTime=2020-04-25 22:30:24), BlogVo(blogId=1253992797703364608, blogTitle=剑指offer----之两个链表的第一个公共节点----LeetCode160, blogImage=http://121.199.34.159/group1/M00/00/01/rBD3pF6kD2OADD3mAAAaZr2Bc1U709.jpg, blogContent=<h2><strong>一，两个链表的第一个公共节点</strong></h2>
<p><strong><img src="https://images-cdn.shimo.im/Wd1NC8pveQYp9iIL.png__thumbnail" alt="示例图" width="742" height="241" /></strong></p>
<p><strong>这是我从官方截下的一张图，也是有些人疑惑的地方，因为官方这张图给出的公共节点为8，而大多数人看到这张图，认为公共节点应该是1.</strong></p>
<p><strong>但是实际上这里的公共节点不仅要节点的value相等，同时还需要节点的地址相等。从图中可以看出两个1节点虽然值相等，但是地址却不同，因而不是公共节点</strong></p>
<h2><strong>二，题解</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解法一：双指针</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：初始化两个指针p1=headA,p2=headB</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;分别遍历两个链表，求出两个链表的长度l1,l2</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;然后重置p1,p2指针指向头节点</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;让长链表的指针先走多的步数（l1-l2或者l2-l1）</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;然后让两个指针同时走，直到两者相遇，即找到公共节点</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解疑：弄清楚第一个value相等的节点和指针相遇的节点，这两种节点是不同的，指针相遇的节点，不仅包含value相等，同时地址也相等。（如图中的8）；而第一个value相等的节点则可能并不在同一个地址，因此不一定是公共节点</strong></p>
<pre class="language-java"><code>    /**
     * 双指针法
     * @param headA
     * @param headB
     * @return
     */
    public static ListNode getIntersectionNode2(ListNode headA, ListNode headB){
        ListNode p1 =headA;
        ListNode p2 = headB;
        int l1 = 0;
        int l2 = 0;
        //计算链表1的长度
        while(p1!=null){
            l1++;
            p1 = p1.next;
        }
        //计算链表2的长度
        while(p2!=null){
            l2++;
            p2 = p2.next;
        }
        p1 = headA;
        p2 = headB;
        //让长链表指针先走长的步数
        if(l1&gt;l2){
            for (int i = 0; i &lt; l1-l2; i++) {
                p1 = p1.next;
            }
        }else{
            for (int i = 0; i &lt; l2-l1; i++) {
                p2 = p2.next;
            }
        }
        //然后让两个指针同时走，直到相遇
        while(p1!=p2){
            p1 = p1.next;
            p2 = p2.next;
        }
        return p1;
    }</code></pre>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;解法二（大神解法）：丘比特相遇法</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;利用两个指针p1=headA,p2=headB,让两个指针同时走，</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果p1先走到底，就将p1置为headB，</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果p2,先走到底，就将p2置为headA,</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;当两个指针相遇的时候，他们就相爱了（当然是找到公共节点了）</strong></p>
<pre class="language-java"><code>    /**
     * 双指针法p1=headA,p2=headB
     * 思想是：两个节点同时从各自的链表出发
     * p1走到末尾时，回到headB的头部
     * p2走到末尾时，回到headA的头部
     * 两个指针相遇的时候，即使要找的公共节点
     * @param headA
     * @param headB
     * @return
     */
    public static ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode p1 = headA;
        ListNode p2 = headB;
        while(p1!=p2){
            p1 = (p1==null)?headB:p1.next;
            p2 = (p2==null)?headA:p2.next;
        }
        return p1;
    }</code></pre>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>, blogGoods=0, blogRead=0, blogCollection=0, typeName=LeetCode, blogRemark=剑指offer----之两个链表的第一个公共节点----LeetCode160, blogComment=0, blogSource=null, createdTime=2020-04-25 18:22:35, blogMonth=null, updateTime=2020-04-25 18:22:35), BlogVo(blogId=1253956468789600256, blogTitle=剑指offer----第一次只出现一次的字符, blogImage=http://121.199.34.159/group1/M00/00/01/rBD3pF6j7Y6ACrySAAAaZr2Bc1U825.jpg, blogContent=<h2><strong>一，第一个只出现一次的字符</strong></h2>
<p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。</p>
<p>示例:</p>
<p>s = "abaccdeff"<br />返回 "b"</p>
<p>s = "" <br />返回 " "</p>
<h2><strong>二，题解</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主现在发现，做一道算法题的时候，最重要的一步就是读题，审题，在草稿纸上写下自己的思路（当然那种望眼欲穿的大佬除外）。然后才开始动笔，对于IT人来说，真的，多将时间花费在思考上面，而不是无意义的重复搬砖。</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;题目分析：看到这道题，抓住两个关键字：第一个，只出现一次。什么意思呢，例如"abaccdeff"，其中只出现一次的字符有'b','d','e'三个，然后在三个字符中第一个出现在字符串中的是'b'，因此本题的答案是'b'.</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法分析：根据题目分析，我们最直观的解法应该是，先找出字符串中只出现一次的字符，然后再找出只出现一次字符中，第一个在字符串中出现的。</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;所以我们需要做两件事，一是统计字符串中各个字符的出现次数，并且记录；二，统计完毕后，找出第一个出现次数为1的字符，返回即可。</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;因此我们既要存字符，还要存字符对应的出现次数，所以理所当然我们选择map集合。当然对于本题而言，因为求第一个出现一次的字符，所以我们更好的是可以使用LinkedHashMap。这样免去最后的一次遍历字符串</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;下面提供两种解法：三种解法都是使用map集合，但是略有不同</strong></p>
<p><strong>LinkedHashMap：（这是博主写的，代码冗余，这里用来和大神的写法做比较，警醒自己）</strong></p>
<pre class="language-java"><code>    /**
     * 用LinkedHashMap
     * 思想：遍历字符串，如果map为空或者map中不含当前字符，则将其存入map
     * 如果map中已经含有当前字符，则从map中移除
     * 最终map中只剩出现一次的字符
     * 返货map中的第一个即可
     * @param s
     * @return
     */
    public static char firstUniqChar(String s) {
        Map&lt;Character,Integer&gt;map = new LinkedHashMap&lt;&gt;();
        for (int i = 0; i &lt; s.length(); i++) {
            char ch = s.charAt(i);
            if(map.isEmpty()||!map.containsKey(ch)){
                map.put(ch,1);
            }else{
                Integer val = map.get(ch);
                map.put(ch,++val);
            }
        }
        //返回map中第一个元素即可
        Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entries = map.entrySet();
        for (Map.Entry&lt;Character, Integer&gt; entry : entries) {
            if(entry.getValue()==1){
                return entry.getKey();
            }
        }
        return ' ';
    }</code></pre>
<p><strong>HashMap（大神解法）：</strong></p>
<pre class="language-java"><code>    /**
     * 哈希表法
     * @param s
     * @return
     */
    public char firstUniqChar2(String s) {
        Map&lt;Character,Boolean&gt; map = new HashMap&lt;&gt;();
        char[] chars = s.toCharArray();
        for (char ch : chars) {
            map.put(ch,!map.containsKey(ch));
        }
        for (char ch : chars) {
            if(map.get(ch)){
                return ch;
            }
        }
        return ' ';
    }</code></pre>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;分析：首先，这里提供了两种解法，一种为LinkedHashMap，一种为HashMap，这两种解法的不同之处就在于最后获取值的时候，LinkedHashMap获取最终值是遍历LinkedHashMap的entrySet，但是HashMap获取最终值是遍历原字符串。因而当数据庞大的时候，显然使用LinkedHashMap性能更高。</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;然后，再分析一下这两种解法不另外一个不同之处，没错！就是大神的解法中使用map存放key对应的value值是Boolean型！（<span style="background-color: #ffcc00;">这个真的是神一般的存在</span>），既省去了计算次数的麻烦，同时最后取的时候也不需要判断次数。wc！同一种解法，为什么天差地别！</strong></p>, blogGoods=0, blogRead=0, blogCollection=0, typeName=LeetCode, blogRemark=剑指offer----第一次只出现一次的字符, blogComment=0, blogSource=null, createdTime=2020-04-25 15:58:14, blogMonth=null, updateTime=2020-04-25 15:58:14), BlogVo(blogId=1253938714590175232, blogTitle=剑指offer---连续子数组的最大和---LeetCode53, blogImage=http://121.199.34.159/group1/M00/00/01/rBD3pF6j3QSACLxRAAAaZr2Bc1U017.jpg, blogContent=<h2><strong>一，连续子数组的最大和</strong></h2>
<p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>
<p>要求时间复杂度为O(n)。</p>
<p>示例1:</p>
<p>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br />输出: 6<br />解释:&nbsp;连续子数组&nbsp;[4,-1,2,1] 的和最大，为&nbsp;6。</p>
<h2><strong>二，题解</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;看到这道题，最简单的想法肯定是求出所有连续子数组的值，然后进行比较，找出最大的即可。</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;但是随后会想到既然要找出所有的子数组，那么我们可以使用分治的思想，因为分治的分过程即可以得到所有子序列</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;随后，再深一步，既然可以分治的思想，分的过程即是递归的过程，而且子数组的最大值依赖与前一子数组，所以可以想到使用动态规划</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：设dp[i]为以nums[i]为结尾的最大子数组和，初始值dp[0] = nums[0]</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;遍历数组，如果dp[i-1]&gt;=0。则说明前面的最大子数组对当前子数组有增益效果，所以dp[i] = dp[i-1]+nums[i]</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果dp[i-1]&lt;0。说明前面的最大子数组对当前子数组有夫负效果，还不如nums[i]本身，所以dp[i]=nums[i]</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主的这样的写法：时间复杂度为O（N），空间复杂度也为O（N），但是实际上不需要使用dp数组，使用nums原数组就行，所以可以减小空间复杂度为O（1）</strong></p>
<pre class="language-java"><code>    /**
     * 动态规划
     * 算法思想：因为求的是连续子数组的最大和
     * 所以我们可以设dp[i]为以nums[i]结尾的最大连续子数组
     * 如果dp[i]&lt;=nums[i],dp[i]=nums[i]
     * 如果dp[i]&gt;nums[i],则dp[i]=dp[i]+nums[i]
     * @param nums
     * @return
     */
    public static int maxSubArray(int[] nums) {
        int[] dp  = new int[nums.length];
        dp[0] = nums[0];
        int res = nums[0];
        for (int i = 1; i &lt; nums.length; i++) {
            if(dp[i-1]&lt;0){
                dp[i] = nums[i];
            }else{
                dp[i] = dp[i-1]+nums[i];
            }
            res = Math.max(res,dp[i]);
        }
        return res;
    }</code></pre>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>, blogGoods=0, blogRead=0, blogCollection=0, typeName=LeetCode, blogRemark=剑指offer---连续子数组的最大和---LeetCode53, blogComment=0, blogSource=null, createdTime=2020-04-25 14:47:41, blogMonth=null, updateTime=2020-04-25 14:47:41), BlogVo(blogId=1253874832811089920, blogTitle=剑指offer----之最小的k个数, blogImage=http://121.199.34.159/group1/M00/00/01/rBD3pF6joYWAF3oqAAAaZr2Bc1U671.jpg, blogContent=<h2><strong>一，最小的k个数</strong></h2>
<p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
<p>示例 1：</p>
<p>输入：arr = [3,2,1], k = 2<br />输出：[1,2] 或者 [2,1]<br />示例 2：</p>
<p>输入：arr = [0,1,2,1], k = 1<br />输出：[0]</p>
<h2><strong>二，题解</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;1,可以采用快排的思想，将原数组按照升序排序，然后取出前k个数即可，时间复杂度为O（NlogN）。但是其实跟API中的sort方法好像差别不大</strong></p>
<pre class="language-java"><code>    /**
     * 对原数组升序排序，然后取前k个元素
     * @param arr
     * @param k
     * @return
     */
    public static int[] getLeastNumbers(int[] arr, int k) {
        quickSort(arr,0,arr.length-1);
        int[] result = new int[k];
        for (int i = 0; i &lt; k; i++) {
            result[i] = arr[i];
        }
        return result;
    }

    /**
     * 快排
     * @param nums
     * @param low
     * @param high
     */
    public static void quickSort(int[] nums,int low,int high){
        int base = nums[low];
        int L = low;
        int R = high;
        while(L&lt;R){
            //先从右向左找到第一个小于基准元素的元素
            while(L&lt;R&amp;&amp;nums[R]&gt;=base){
                R--;
            }
            if(nums[R]&lt;base){
                swap(nums,L,R);
            }
            //再从左向右找到第一个大于基准元素的元素
            while(L&lt;R&amp;&amp;nums[L]&lt;=base){
                L++;
            }
            if(nums[L]&gt;base){
                swap(nums,L,R);
            }
        }
        //左递归
        if(L&gt;low){
            quickSort(nums,low,L-1);
        }
        //右递归
        if(high&gt;R){
            quickSort(nums,R+1,high);
        }
    }

    /**
     * 交换元素
     * @param nums
     * @param i
     * @param j
     */
    public static void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>2，堆排序：</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;先讲解一下堆排序：堆排序是一种完全二叉树的结构，常见的存在两种堆结构，小根堆（即满足arr[2i+1]&gt;=arr[i]&amp;&amp;arr[2i+2]&gt;=arr[i]），大根堆（即满足arr[2i+1]&lt;=arr[i]&amp;&amp;arr[2i+2]&lt;=arr[i]）</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;基本算法思想：第一步，初始化堆，即堆初始化为大根堆或者小根堆（这里我们简称调整堆）；第二步，将堆顶元素与堆的末尾元素进行交换，然后重新调整堆。在java中堆通常用来实现优先级队列PriorityQueue(默认的采用小根堆，若想使用大根堆，需要在创建时实现comparator)</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;使用情况：这里以java中的优先级队列为例，堆的使用情况不能按照堆名断章取义，例如小根堆实际上是将元素升序存放，因为在算法第二步中将堆顶元素与末尾元素进行交换，然后重新调整，交换的堆顶元素为最小元素，也是最先从堆中进入队列的。所以小根堆适用于TOPk大的算法</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;相反的，大根堆适用于TOPk小的算法，下面分别给出小根堆和大根堆的算法：</strong></p>
<p><strong>小根堆：</strong></p>
<pre class="language-java"><code>    /**
     * 堆排序---小根堆
     * @param nums
     */
    public static void HeapSort(int[] nums){
        //先初始化堆
        for (int i = nums.length/2-1; i &gt;=0 ; i--) {
            adjustHeap(nums,i,nums.length);
        }
        //交换堆顶与末尾节点+重新调整为小根堆
        for (int i = nums.length-1; i &gt;0; i--) {
            //先交换
            swap(nums,0,i);
            //再调整
            adjustHeap(nums,0,i);
        }
    }

    /**
     * 调整为小根堆
     * @param nums
     * @param i
     * @param length
     */
    public static void adjustHeap(int[] nums,int i,int length){
        int temp = nums[i];
        for (int j = 2*i+1; j &lt; length; j=2*j+1) {
            //找出左右节点中的最小值
            if(j+1&lt;length&amp;&amp;nums[j]&gt;nums[j+1]){
                j++;
            }
            if(nums[j]&lt;temp){
                nums[i] = nums[j];
                i = j;
            }
        }
        nums[i] = temp;
    }

    /**
     * 交换元素
     * @param nums
     * @param i
     * @param j
     */
    public static void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }</code></pre>
<p><strong>大根堆：</strong></p>
<pre class="language-java"><code>    /**
     * 堆排序---大根堆
     * @param nums
     */
    public static void heapSort(int[] nums){

        //初始化堆的过程
        for (int i = nums.length/2-1; i &gt;=0; i--) {
            adjustHeap(nums,i,nums.length);
        }
        //调整+交换堆顶和末尾的元素
        for (int i = nums.length-1; i &gt;0; i--) {
            //先交换，再重新调整
            swap(nums,0,i);
            adjustHeap(nums,0,i);
        }
    }

    /**
     * 调整大顶堆的过程
     * @param nums
     * @param i
     * @param length
     */
    public static void adjustHeap(int[] nums,int i,int length){
        int temp = nums[i];
        for (int j = 2*i+1; j &lt; length; j=2*j+1) {
            //找出左右节点中的最大值
            if(j+1&lt;length&amp;&amp;nums[j]&lt;nums[j+1]){
                j++;
            }
            if(nums[j]&gt;temp){
                nums[i] = nums[j];
                i = j;
            }
        }
        nums[i] = temp;
    }

    /**
     * 交换元素
     * @param nums
     * @param i
     * @param j
     */
    public static void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>本题利用大根堆解法，且使用java中自带的优先级队列PriorityQueue：</strong></p>
<pre class="language-java"><code>    /**
     * 使用堆数据结构，java中的优先级队列对应着最小堆
     * 实现其comparator即可
     * @param arr
     * @param k
     * @return
     */
    public static int[] getLeastNumbers2(int[] arr, int k){
        Queue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(k,(v1,v2)-&gt;v2-v1);
        for (int i : arr) {
            if(heap.isEmpty()||heap.size()&lt;k||i&lt;heap.peek()){
                heap.offer(i);
            }
            if(heap.size()&gt;k){
                heap.poll();
            }
        }
        int[] result = new int[k];
        int j = 0;
        for (Integer val : heap) {
            result[j++] = val;
        }
        return result;
    }</code></pre>, blogGoods=0, blogRead=2, blogCollection=0, typeName=LeetCode, blogRemark=剑指offer----之最小的k个数, blogComment=0, blogSource=null, createdTime=2020-04-25 10:33:50, blogMonth=null, updateTime=2020-04-25 11:53:15), BlogVo(blogId=1253674617332162560, blogTitle=剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169, blogImage=http://121.199.34.159/group1/M00/00/01/rBD3pF6i5v-AUh39AAAaZr2Bc1U885.jpg, blogContent=<h2><strong>一，数组中出现次数超过一半的元素---即众数</strong></h2>
<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p>示例&nbsp;1:</p>
<p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br />输出: 2</p>
<h2>二，题解</h2>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>方法有三：哈希表统计法，数组排序法，摩尔投票法</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;哈希统计法：时间复杂度O（N），空间复杂度O（N）</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 博主刚开始看到这道题的时候，首先想到的是哈希表统计法，因为博主想的是要找到众数，那么肯定得统计每个数字的出现次数，然后按照次数比较。</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 单单是想到这些，用了map集合之后发现还是不行，因为即便用map集合统计出了每个数字和其对应的出现次数之后，你会发现没有办法按照出现的次数进行比较并且得到次数最多的数字（众数</strong><strong>）</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 然后，就又审了一遍题目，结果发现了一个本题很关键的点，（<span style="background-color: #ffcc00;">数组中有一个数字出现的次数超过数组长度的一半</span>），也就是说数组中有且仅有一个数字的出现次数会超过数组长度的一半（别笑博主笨，我是真的刚开始没反应过来）</strong></p>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 那么我为什么要把数组中的所有元素和其次数全部存放进入map集合，然后再取次数进行比较呢？我为什么不在将元素和其次数存入集合的过程中判断次数是否已经超过数组长度的一半了呢？如果超过一半了，那它肯定是众数了呀！</strong></p>
<pre class="language-java"><code>    /**
     * 思路：根据题意需要找出两个东西，一是多素元素，二是多素元素的出现次数
     * 所以我们首先想到的是采用map集合
     * 然后遍历数组，如果元素不存在与集合中，我们就将其加入map，value置为1
     * 如果元素存在于map中，则我们取出其value将其加1与数组长度的一半做比较
     * 如果大于数组长度一半，直接返回该元素即可
     * 小于数组长度一半，则将其value加1存入map覆盖原有的值即可
     *
     * @param nums
     * @return
     */
    public static int majorityElement(int[] nums) {
        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(nums.length);
        for (int num : nums) {
            if(!map.containsKey(num)){
                map.put(num,1);
            }else{
                Integer val = map.get(num);
                if(++val&gt;nums.length/2){
                    return num;
                }else{
                    map.put(num,val);
                }
            }
        }
        throw new RuntimeException("");
    }</code></pre>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>数组排序法：由题可知，数组众必然存在一个多数元素，且出现次数超过数组长度的一半。所以我们可以对原数组进行排序，然后取数组中间的元素即可。（我擦，我当时看到这个，就在想，好简单，这个思路，但是我为什么没想到，对，因为我没有仔细的分析题目，超过一半看见没）。既然进行排序，那么我们可以选择快排，这样时间复杂度就是O（NlogN），空间复杂度O（1）.</strong></p>
<pre class="language-java"><code>    /**
     * 数组排序法，因为多数元素的出现次数超过数组长度一半，
     * 所以我们可以先对其进行排序，采用快排，时间复杂度O（NlogN）
     * 然后取数组中点元素即可
     * @param nums
     * @return
     */
    public static int majorityElement2(int[] nums){
        quickSort(nums,0,nums.length-1);
        return nums[nums.length/2];
    }

    /**
     * 快排
     * @param nums
     * @param low
     * @param high
     */
    public static void quickSort(int[] nums,int low,int high){
        int base = nums[low];
        int L = low;
        int R = high;
        while(L&lt;R){
            //从右向左找到第一个比基准元素小的元素
            while(L&lt;R&amp;&amp;nums[R]&gt;=base){
                R--;
            }
            if(nums[R]&lt;base){
                swap(nums,L,R);
            }
            //从左向右找到第一个比基准元素大的元素
            while(L&lt;R&amp;&amp;nums[L]&lt;=base){
                L++;
            }
            if(nums[L]&gt;base){
                swap(nums,L,R);
            }
        }
        //左递归
        if(L&gt;low){
            quickSort(nums,low,L-1);
        }
        //右递归
        if(high&gt;R){
            quickSort(nums,R+1,high);
        }
    }

    public static void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>摩尔投票法（我将其称为大佬解法）：大概的意思就是采用正负抵消的方法，设置一个投票变量votes，初始设置为0；设置一个本题中的众数变量x，初始设置为数组首元素。然后遍历数组，判断跟设置的众数变量是否相等，如果相等将votes加一，如果不相等，则重置votes为0，且将x设置为数组下一个元素。本题众因为已经声明了肯定存在众数，所以不需要进行验证，但是如果没有声明的话，需要验证，下列代码众添加了验证：</strong></p>
<pre class="language-java"><code>    /**
     * 摩尔投票法
     * @param nums
     */
    public static int majorityElement3(int[] nums){
        int votes = 0;
        int x = nums[0];
        int count = 0;
        for (int num : nums) {
            if(votes==0){
                x = num;
            }
            votes+=(num==x)?1:-1;
        }
        //验证数组众是否存在众数
        for (int num : nums) {
            if(num==x){
                count++;
            }
        }
        return count&gt;nums.length/2?x:0;
    }</code></pre>, blogGoods=0, blogRead=0, blogCollection=0, typeName=LeetCode, blogRemark=剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169, blogComment=0, blogSource=null, createdTime=2020-04-24 21:18:14, blogMonth=null, updateTime=2020-04-24 21:18:14), BlogVo(blogId=1253350612905598976, blogTitle=剑指offer----之从上到下打印二叉树----LeetCode102, blogImage=http://121.199.34.159/group1/M00/00/01/rBD3pF6huUyATZJ_AAAaZr2Bc1U363.jpg, blogContent=<h2><strong>一，从上到下打印二叉树-2</strong></h2>
<p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
<p>例如:<br />给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>
<p>3<br />/ \<br />9 20<br />/ \<br />15 7<br />返回其层次遍历结果：</p>
<p>[<br />[3],<br />[9,20],<br />[15,7]<br />]</p>
<h2><strong>二，题解</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;BFS（广度优先搜索）：层次遍历</strong></p>
<pre class="language-java"><code>    /**
     * BFS
     * @param root
     * @return
     */
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
        if (root == null) {
            return new ArrayList&lt;&gt;(0);
        }
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.add(root);
        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();
        TreeNode current;
        while (!queue.isEmpty()) {
            List&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();
            for (int i = queue.size(); i &gt; 0; i--) {
                current = queue.poll();
                arrayList.add(current.val);
                if (current.left != null) {
                    queue.add(current.left);
                }
                if (current.right != null) {
                    queue.add(current.right);
                }
            }
            list.add(arrayList);
        }
        return list;
    }</code></pre>, blogGoods=0, blogRead=1, blogCollection=0, typeName=LeetCode, blogRemark=剑指offer----之从上到下打印二叉树----LeetCode102, blogComment=0, blogSource=null, createdTime=2020-04-23 23:50:45, blogMonth=null, updateTime=2020-04-23 23:50:57), BlogVo(blogId=1253346228108894208, blogTitle=剑指offer----之从上到下打印二叉树, blogImage=http://121.199.34.159/group1/M00/00/01/rBD3pF6htTeAUHGlAAAaZr2Bc1U102.jpg, blogContent=<h2><strong>一，从上打印二叉树-1</strong></h2>
<p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>
<p>例如:<br />给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>
<p>3<br />/ \<br />9 20<br />/ \<br />15 7<br />返回：</p>
<p>[3,9,20,15,7]</p>
<h2><strong>二，题解</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;BFS（广度优先搜索）：也即是二叉树的层次遍历，代码和注意事项看代码注释</strong></p>
<pre class="language-java"><code>    /**
     * 二叉树的层次遍历
     * 这里是将层次遍历的结果存储在数组中
     * 但是因为二叉树的节点个数并不知道
     * 所以不能使用数组直接进行存储，因为无法初始化数组的大小
     * 所以可以想到使用容量能自动扩充的list集合
     * 然后再根据list集合的size来初始化数组的大小
     * 并且将list元素赋值到数组中
     * @param root
     * @return
     */
    public static int[] levelOrder(TreeNode root) {
        if(root==null){
            return new int[0];
        }
        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.add(root);
        TreeNode current;
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        while(!queue.isEmpty()){
            current = queue.poll();
            list.add(current.val);
            if(current.left!=null){
                queue.add(current.left);
            }
            if(current.right!=null){
                queue.add(current.right);
            }
        }
        int[] result = new int[list.size()];
        for (int i = 0; i &lt; list.size(); i++) {
            result[i] = list.get(i);
        }
        return result;
    }</code></pre>, blogGoods=0, blogRead=0, blogCollection=0, typeName=LeetCode, blogRemark=剑指offer----之从上到下打印二叉树, blogComment=0, blogSource=null, createdTime=2020-04-23 23:33:20, blogMonth=null, updateTime=2020-04-23 23:33:20), BlogVo(blogId=1253331349566234624, blogTitle=剑指offer----之包含min函数的栈---LeetCode155, blogImage=http://121.199.34.159/group1/M00/00/01/rBD3pF6hp12AMy2MAAAaZr2Bc1U568.jpg, blogContent=<h2><strong>一，包含min函数的栈</strong></h2>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
<p>&nbsp;</p>
<p>示例:</p>
<p>MinStack minStack = new MinStack();<br />minStack.push(-2);<br />minStack.push(0);<br />minStack.push(-3);<br />minStack.min(); --&gt; 返回 -3.<br />minStack.pop();<br />minStack.top(); --&gt; 返回 0.<br />minStack.min(); --&gt; 返回 -2.</p>
<h2><strong>二，题解</strong></h2>
<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>&nbsp;辅助栈法：即初始化两个栈A,B</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;A栈用于实现基本的push(),pop(),top()的正常逻辑</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;B栈用来存放A栈中的非严格降序元素（这个我也理解不了，看代码就知道是存放什么的啦），代码中的方法注释很清楚</strong></p>
<pre class="language-java"><code>public class MinStack {
    /** initialize your data structure here. */
    Stack&lt;Integer&gt; A,B;

    public MinStack() {
        A = new Stack&lt;&gt;();
        B = new Stack&lt;&gt;();
    }

    /**
     * 入栈操作，元素先入A栈
     * 如果B栈为空或者B栈的栈顶元素大于待入栈元素，则B栈也执行入栈操作
     * @param x
     */
    public void push(int x) {
        A.add(x);
        if(B.isEmpty()||B.peek()&gt;=x){
            B.add(x);
        }
    }

    /**
     * 这段代码优点巧妙
     * 注意这里使用的A.pop()而不是A.peek()
     * 所以这里实际上是分为两种情况的
     * 第一种：当A的栈顶元素不为当前栈中的最小元素，即不等于栈B的栈顶元素
     *         则只进行栈A的出栈操作，即A.pop()
     * 第二种：当A的栈顶元素为当前栈中的最小元素，即等于栈B的栈顶元素
     *        则不仅要A.pop(),而且为了保证A,B栈中最小元素的同步性
     *        B栈也要执行出栈操作
     */
    public void pop() {
        if(A.pop().equals(B.peek())){
            B.pop();
        }
    }

    /**
     * 正常获取A的栈顶元素
     * @return
     */
    public int top() {
        return A.peek();
    }

    /**
     * 获取A栈的最小元素，即B栈的栈顶元素
     * @return
     */
    public int min() {
        return B.peek();
    }
}</code></pre>, blogGoods=0, blogRead=4, blogCollection=0, typeName=LeetCode, blogRemark=剑指offer----之包含min函数的栈---LeetCode155, blogComment=0, blogSource=null, createdTime=2020-04-23 22:34:13, blogMonth=null, updateTime=2020-04-23 23:50:51), BlogVo(blogId=1253326423486144512, blogTitle=2020-4-23有感, blogImage=http://121.199.34.159/group1/M00/00/01/rBD3pF6hosWANYd2AAHQzo49lBU641.jpg, blogContent=<h3><strong>晚上九点多，坐在床上，面前摆放着电脑，屏幕显示的是LeetCode中的《剑指offer》的题解</strong></h3>
<h3><strong>此时的我毫无睡意，当然，这并不是因为解出一道题的喜悦冲淡了我的睡意</strong></h3>
<h3><strong>相反的，这是一种难以言明的心情，包含着对自己无知的羞愧，也包含着别人面对如此无知的自己也能给出耐心回应的感动</strong></h3>
<h3><strong>人有时或许就是这样，刻意的举动会让人心生防备，但是无意的善举却能温润人心</strong></h3>
<h3><strong>别人无意的一个回答，一个小举动，一句肯定的话</strong></h3>
<h3><strong>殊不知却能为对方赋予无穷无尽的能量</strong></h3>
<h3><strong>将这一天的疲惫和劳累都消除</strong></h3>
<h3><strong>赠人玫瑰，手有余香</strong></h3>
<h3><strong>我一直抱着这样的一种心态，或许我无法做到赠人玫瑰，但是我会尽量将自己的善意展现给别人</strong></h3>
<h3><strong>也许他刚刚好正处于某个难关，而你又刚刚好是他难关之初的引导者</strong></h3>
<h3><strong>一句话，或许对于你来说只是人生中微不足道的几秒钟</strong></h3>
<h3><strong>而对他来说，或许可能是多年之后回忆起来也能嘴角上扬的美好岁月</strong></h3>
<h3><strong>想起前段时间一部剧里面的话，在这里也送给屏幕前的你：愿你永怀善意，清澈明朗</strong></h3>
<p>&nbsp;</p>, blogGoods=0, blogRead=3, blogCollection=0, typeName=随心日记, blogRemark=2020-4-23有感, blogComment=0, blogSource=null, createdTime=2020-04-23 22:14:38, blogMonth=null, updateTime=2020-04-25 21:22:30), BlogVo(blogId=1253250557729087488, blogTitle=剑指offer-----之顺时针打印矩阵----LeetCode54, blogImage=http://121.199.34.159/group1/M00/00/01/rBD3pF6hXB2ASIQwAAAaZr2Bc1U016.jpg, blogContent=<h2><strong>一，顺时针打印矩阵</strong></h2>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<p>示例 1：</p>
<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br />输出：[1,2,3,6,9,8,7,4,5]<br />示例 2：</p>
<p>输入：matrix =&nbsp;[[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br />输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p>
<p>限制：</p>
<p>0 &lt;= matrix.length &lt;= 100<br />0 &lt;= matrix[i].length&nbsp;&lt;= 100</p>
<h2><strong>二，题解</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;模拟顺时针打印的这种循环结构：设置四个边界条件，l,r,t,b。按照从左往右，从上往下，从右往左，从下网往上的顺序依次读取矩阵的元素，并且每一次都判断边界是否相遇，直到将整个矩阵元素都加入到数组中即可。</strong></p>
<pre class="language-java"><code>    /**
     * 设置四个边界值，分别为left=0,right=matrix[0].length-1,top=0,bottom=matrix.length-1
     * 顺时针顺序即先从左到右，再从上到下，再从右向左，再从下向上，每一次执行都要判断边界值
     * @param matrix
     * @return
     */
    public static int[] spiralOrder(int[][] matrix) {
        if(matrix.length==0){
            return new int[0];
        }
        int l = 0;
        int r=matrix[0].length-1;
        int t=0;
        int b=matrix.length-1;
        int x=0;
        int[] res = new int[(r+1)*(b+1)];
        while(true){
            //从左向右
            for(int i=l;i&lt;=r;i++){
                res[x++]=matrix[t][i];
            }
            if(++t&gt;b) {
                break;
            }
            //从上向下
            for(int i=t;i&lt;=b;i++){
                res[x++] = matrix[i][r];
            }
            if(--r&lt;l){
                break;
            }
            //从右向左
            for(int i=r;i&gt;=l;i--){
                res[x++] = matrix[b][i];
            }
            if(--b&lt;t){
                break;
            }
            //从下往上
            for(int i=b;i&gt;=t;i--){
                res[x++] = matrix[i][l];
            }
            if(++l&gt;r){
                break;
            }
        }
        return res;
    }</code></pre>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>
<p>&nbsp;</p>, blogGoods=0, blogRead=0, blogCollection=0, typeName=LeetCode, blogRemark=剑指offer-----之顺时针打印矩阵----LeetCode54, blogComment=0, blogSource=null, createdTime=2020-04-23 17:13:11, blogMonth=null, updateTime=2020-04-23 17:13:11), BlogVo(blogId=1252992659794968576, blogTitle=剑指offer----之对称的二叉树----LeetCode101, blogImage=http://121.199.34.159/group1/M00/00/01/rBD3pF6ga--AKQdvAAAaZr2Bc1U862.jpg, blogContent=<h2><strong>一，对称的二叉树</strong></h2>
<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<p>例如，二叉树&nbsp;[1,2,2,3,4,4,3] 是对称的。</p>
<p>&nbsp; &nbsp; 1<br />&nbsp; &nbsp;/ \<br />&nbsp; 2 &nbsp; 2<br />&nbsp;/ \ / \<br />3 &nbsp;4 4 &nbsp;3<br />但是下面这个&nbsp;[1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<p>&nbsp; &nbsp; 1<br />&nbsp; &nbsp;/ \<br />&nbsp; 2 &nbsp; 2<br />&nbsp; &nbsp;\ &nbsp; \<br />&nbsp; &nbsp;3 &nbsp; &nbsp;3</p>
<p>示例 1：</p>
<p>输入：root = [1,2,2,3,4,4,3]<br />输出：true<br />示例 2：</p>
<p>输入：root = [1,2,2,null,3,null,3]<br />输出：false</p>
<h2>二，题解</h2>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>递归法：从对称的二叉树中我们可以找到如下规律</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果一个二叉树是对称的，则每一个节点的左右子树也是对称的,因此是递归的</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 设L = root.left，R=root.right，则满足L.left.val = R.right.val;L.right.val=R.left.val;</strong></p>
<pre class="language-java"><code>public boolean isSymmetric(TreeNode root) {
        return  root==null?true:recur(root.left,root.right);
    }
    public boolean recur(TreeNode L,TreeNode R){
        if(L==null&amp;&amp;R==null){
            return true;
        }
        if(L==null||R==null||L.val!=R.val){
            return false;
        }
        return recur(L.left,R.right)&amp;&amp;recur(L.right,R.left);
    }</code></pre>, blogGoods=0, blogRead=1, blogCollection=0, typeName=LeetCode, blogRemark=剑指offer----之对称的二叉树----LeetCode101, blogComment=0, blogSource=null, createdTime=2020-04-23 00:08:23, blogMonth=null, updateTime=2020-04-23 00:12:33), BlogVo(blogId=1252985443281027072, blogTitle=剑指offer----之二叉树的镜像----LeetCode226, blogImage=http://121.199.34.159/group1/M00/00/01/rBD3pF6gZTWABF55AAAaZr2Bc1U678.jpg, blogContent=<h2><strong>一，二叉树镜像</strong></h2>
<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<p>例如输入：</p>
<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \<br />&nbsp; 2 &nbsp; &nbsp; 7<br />&nbsp;/ \ &nbsp; / \<br />1 &nbsp; 3 6 &nbsp; 9<br />镜像输出：</p>
<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \<br />&nbsp; 7 &nbsp; &nbsp; 2<br />&nbsp;/ \ &nbsp; / \<br />9 &nbsp; 6 3&nbsp; &nbsp;1</p>
<p>示例 1：</p>
<p>输入：root = [4,2,7,1,3,6,9]<br />输出：[4,7,2,9,6,3,1]</p>
<p>限制：</p>
<p>0 &lt;= 节点个数 &lt;= 1000</p>
<h2><strong>二，题解</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;递归法：即递归的去交换根节点的左右子树，直到根节点为叶子节点</strong></p>
<pre class="language-java"><code>    /**
     * 使用递归的方法，交换根节点的左子树和右子树
     * 递归出口为，根节点为叶子节点
     * @param root
     * @return
     */
    public TreeNode mirrorTree(TreeNode root) {
        TreeNode center = root;
        if(center!=null){
            TreeNode temp = center.left;
            center.left = center.right;
            center.right = temp;
            mirrorTree(center.left);
            mirrorTree(center.right);
        }
        return root;
    }</code></pre>, blogGoods=0, blogRead=0, blogCollection=0, typeName=LeetCode, blogRemark=剑指offer----之二叉树的镜像----LeetCode226, blogComment=0, blogSource=null, createdTime=2020-04-22 23:39:43, blogMonth=null, updateTime=2020-04-22 23:39:43), BlogVo(blogId=1252980258446000128, blogTitle=剑指offer----之合并有序链表---LeetCode21, blogImage=http://121.199.34.159/group1/M00/00/01/rBD3pF6gYGWAe-MZAAAaZr2Bc1U550.jpg, blogContent=<h2><strong>一，合并两个有序链表</strong></h2>
<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<p>示例1：</p>
<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br />输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br />限制：</p>
<p>0 &lt;= 链表长度 &lt;= 1000</p>
<h2><strong>二，题解</strong></h2>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>伪头节点法：即创建一个伪头节点head和一个用于辅助的节点cur</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法：如果l1.val&lt;=l2.val,就让cur指向l1，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l1指向其next</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果l1.val&gt;l2.val,就让cur指向l2，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l2指向其next</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;直到l1和l2有一个为空为止，让cur指向剩余的一个非空链表即可，若两个链表的长度为M,N则时间复杂度为O(M+N)</strong></p>
<pre class="language-java"><code>    /**
     * 使用四节点，一个伪头节点，一个当前节点cur，已经链表的两个节点l1,l2
     * 每次比较l1,l2节点的val大小，将小的节点连接到当前节点cur上即可
     * 直到l1,l2有一个空，则将剩余的一个非空链表连接到cur尾部即可
     * @param l1
     * @param l2
     * @return
     */
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode head;
        ListNode cur;
        head = cur = new ListNode(0);
        while(l1!=null&amp;&amp;l2!=null){
            if(l1.val&lt;=l2.val){
                cur.next = l1;
                cur = cur.next;
                l1 = l1.next;
            }else{
                cur.next = l2;
                cur = cur.next;
                l2 = l2.next;
            }
        }
        if(l1!=null){
            cur.next = l1;
        }
        if(l2!=null){
            cur.next = l2;
        }
        return head.next;
    }</code></pre>, blogGoods=0, blogRead=0, blogCollection=0, typeName=LeetCode, blogRemark=剑指offer----之合并有序链表---LeetCode21, blogComment=0, blogSource=null, createdTime=2020-04-22 23:19:06, blogMonth=null, updateTime=2020-04-22 23:19:06)], params={}, sortColumn=created_time, sortMethod=DESC)]
2020-04-26 22:24:25.032 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 250
2020-04-26 22:24:25.032 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":6,"index":75,"list":[],"pageSize":15,"params":{},"sortColumn":"created_time","sortMethod":"DESC","totalCount":53,"totalPage":4},"msg":"操作成功!"}
2020-04-26 22:24:28.318 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/list
2020-04-26 22:24:28.318 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 22:24:28.319 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 22:24:28.319 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogList
2020-04-26 22:24:28.320 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=5, pageSize=15, totalPage=4, totalCount=53, list=[], params={}, sortColumn=created_time, sortMethod=DESC)]
2020-04-26 22:24:28.563 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 246
2020-04-26 22:24:28.564 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":5,"index":60,"list":[],"pageSize":15,"params":{},"sortColumn":"created_time","sortMethod":"DESC","totalCount":53,"totalPage":4},"msg":"操作成功!"}
2020-04-26 22:24:35.654 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/list
2020-04-26 22:24:35.655 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 22:24:35.655 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 22:24:35.655 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogList
2020-04-26 22:24:35.655 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=4, pageSize=15, totalPage=4, totalCount=53, list=[], params={}, sortColumn=created_time, sortMethod=DESC)]
2020-04-26 22:24:36.021 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 367
2020-04-26 22:24:36.022 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":4,"index":45,"list":[{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，redis简介</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>redis是NoSQL型系统之一，与之相似的还有Memcache，用来存储key-value这种键值型数据。相比于Memcache而言，redis不仅可以做临时缓存，还可以做数据持久化，将数据定时的存入硬盘或者将命令追加到日志文件当中。而Memcache只能做临时缓存，因而现在基本上已经被redis完全取代。redis的读写速度非常快，官方给出的数据是读110000次/s，写81000次/s；而且redis支持多种数据类型，例如String，list，hash，set，zset；redis支持主从复制（集群），进行数据持久化；还支持过期时间，事务等。</p>\n<h2><strong>二，redis的安装与启动（docker环境下）</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;docker安装完毕后，安装redis：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第一步：拉取redis镜像，docker&nbsp; pull&nbsp; redis</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第二步：启动redis，docker&nbsp; &nbsp;run&nbsp; &nbsp;redis&nbsp; &nbsp;</p>\n<p><strong>三，基本知识串讲</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>单进程单线程：redis只有一个进程，且内部为单线程，这样做的优势是不存在线程安全问题，且不需要进行线程间的切换，提高了性能，而且多线程可能会涉及到锁。劣势是无法发挥多核cpu的优势，不过可以通过开启搭建多个redis实例实现</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>redis中默认有16个数据库（0-15），可以通过select n来进行数据库之间的切换</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;常用的基本命令：flushDB（清空当前数据库），flushAll（清空所有数据库），dbSize（查看有多少数据库）</p>\n<h2><strong>四，redis基本数据类型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;string：</strong>字符串类型，数据库中存储Map&lt;String,String&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>list：</strong>列表数组类型，数据库中存储Map&lt;String,List&lt;Object&gt;&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>hash：</strong>哈希类型，数据库中存储Map&lt;String,Map&lt;Object,Object&gt;&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>set：</strong>集合类型，其中元素无序，数据库中存储Map&lt;String,Set&lt;Object,Object&gt;&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>Zset：</strong>有序集合类型，每个元素都有一个可用于排序的权重</p>\n<h2><strong>五，redis相关命令（这里详解一些常用的命令，不常用的一笔带过）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;string：</strong>(1)set&nbsp; key&nbsp; value,插入一条数据&nbsp; （2）mset&nbsp; key value...批量插入 （3）setnx&nbsp; key value&nbsp; 若无则插入（4）get&nbsp; key&nbsp; 获取某条数据&nbsp; （5）mget keys 批量获取&nbsp; （6）getrange key&nbsp; 0 -1获取数据库全部数据&nbsp; （7）incr age 递增&nbsp; (8) incrby&nbsp; age&nbsp; 10&nbsp; 递增 age 步长为10（9）decr&nbsp; age&nbsp; 递减&nbsp; （10）decrby&nbsp; age&nbsp; 10 步长递减&nbsp; &nbsp;（11）del&nbsp; key&nbsp; 删除某条数据&nbsp; <span style=\"background-color: #ffff00;\">（12）exists&nbsp; key&nbsp; 判断是否存在某个key&nbsp; &nbsp;(13)expire&nbsp; key&nbsp; 10&nbsp; 设置过期时间（单位为秒）&nbsp; （14）pexpire&nbsp; key&nbsp; 1000 设置过期时间，单位为毫秒&nbsp; （15）persist key删除过期时间 （</span><span style=\"background-color: #ffff00;\">16）ttl&nbsp; key&nbsp; 查看过期时间</span></p>\n<p><span style=\"background-color: #ffff00;\">&nbsp;<span style=\"background-color: #ffffff;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>list：&nbsp;&nbsp;</strong>（1）lpush&nbsp; key&nbsp; value 左插入一条数据&nbsp; &nbsp;（2）lpush mylist&nbsp; key&nbsp; value....批量左插入&nbsp; （3）rpush&nbsp; key value 右插入一条数据&nbsp; (4)rpush&nbsp; mylist&nbsp; key value...右批量插入&nbsp; （5）lrange&nbsp; mylist&nbsp; 0&nbsp; -1&nbsp; 取出数据集合&nbsp; （6）lpop mylist 左弹出集合中第一条数据&nbsp; （7）rpop&nbsp; </span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">mylist&nbsp; 右弹出集合中第一条数据&nbsp; （8）llen&nbsp; mylist&nbsp; 获取数据集合长度lrem&nbsp; mylist&nbsp; count&nbsp; value&nbsp; （count&gt;0,从表头开始搜索，移除count个与值与value相等的元素；count&lt;0,表尾开始；count=0，移除所有值与value相等的元素） （9）linsert mylist&nbsp; before/after&nbsp; a&nbsp; 在a元素前或后插入。</span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">(10) lpoplpush&nbsp; list&nbsp; list1 转移列表的元素到另一个列表</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>hash：</strong>（1）hset&nbsp; key&nbsp; &nbsp;val-key&nbsp; val-val&nbsp; 插入一条数据&nbsp; （2）hset&nbsp; myhash&nbsp; name&nbsp; xxx&nbsp; 用于给哈希表中的字段赋值，不存在则创建哈希表赋值，存在则覆盖旧值&nbsp; (3) hget&nbsp; &nbsp;myhash&nbsp; name&nbsp; 取哈希表中某个值&nbsp; （4）hmset&nbsp; myhash name&nbsp; xxx age xxx&nbsp; 批量插入字段&nbsp; （5）hmget</span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">批量获取 （6）hgetall&nbsp; myhash&nbsp; 获取哈希表中所有值&nbsp; (7)&nbsp; hexisets myhash&nbsp; name&nbsp; 判断哈希表中是否存在name字段&nbsp; （8）hsetnx&nbsp; myhash score 100 若存在则不插入，若不存在则插入数据&nbsp; （9）hincrby&nbsp; myhash id 1/hdecrby&nbsp; myhash id&nbsp; 10 递增递减 （10）hdel&nbsp; myhash name&nbsp; </span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">删除&nbsp; （11）hkeys&nbsp; myhash&nbsp; 只取key值&nbsp; （12）hvals&nbsp; myhash&nbsp; 只取value值&nbsp; （13）hlen&nbsp; myhash 获取哈希表长度</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>set：</strong>（1）sadd myset&nbsp; redis&nbsp; 添加一条数据&nbsp; （2）smembers myset&nbsp; 获取数据集合&nbsp; （3）srem&nbsp; myset&nbsp; set1&nbsp; 删除set1&nbsp; （4）sismember myset&nbsp; set1 判断set中是否存在set1&nbsp; (5)srandmember&nbsp; key count&nbsp; 随机获取count个元素（6）spop&nbsp; 从集合中弹出一个元素</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>zset：</strong>之后补充</span></span></p>\n<h2><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">六，redis配置文件（常见配置）</span></span></strong></h2>\n<p><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;daemonize no：</span></span></strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">redis默认不是以守护进程的方式运行的，可以更改为yes启用守护进程（即后台运行）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>pidfile&nbsp; /var/run/redis.pid&nbsp; :</strong>启用守护进程后，默认将pid写入/var/run/redis.pid文件，可以更改</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>port&nbsp; 6379 ：</strong>redis默认端口</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp; &nbsp; &nbsp; &nbsp; <strong>bind&nbsp; 127.0.0.1：</strong>绑定的主机地址</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\"> &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>timeout&nbsp; 300</strong><strong>：</strong>redis客户端闲置多长时间后关闭连接，改为0的话，表示关闭该功能</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>loglevel&nbsp; verbose：</strong>默认日志级别（还有debug，notice，warning）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>database 16：</strong>redis默认有16个数据库可以修改</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>save&nbsp; 900&nbsp; 1/save&nbsp; 300&nbsp; 10/save&nbsp; 60&nbsp; 10000：&nbsp;</strong>表示一定时间内有多少条数据发生修改，就将其同步到数据文件一次，例如第一个表示15分钟内有一条数据发生改变就同步</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>rdbcompression yes&nbsp; ：</strong>表示数据存储到本地数据库时是否进行压缩</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>dbfilename&nbsp; dump.rdb：</strong>指定本地数据库文件名</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>dir&nbsp; /...../redis安装目录/bin ：</strong>本地数据库存放目录，默认在redis安装目录的bin目录下</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>slaveof&nbsp; &nbsp;masterip&nbsp; masterport ：</strong>设置当本机为从机时，它的主机的ip和端口</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>masterauth&nbsp; &lt;master-password&gt;：</strong>当master服务设置了密码时，slav服务连接master的密码</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>requirepass&nbsp; foobared：</strong>默认关闭redis连接需要密码，当给redis设置了密码，就需要打开</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>maxclients&nbsp; &nbsp;128：</strong>redis同一时间最大连接客户端的数量</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>appendonly&nbsp; &nbsp;no：</strong>是否开启aof持久化，默认不开启，采用rdb</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>appendfilename&nbsp; appendonlu.aof：</strong>指定aof持久化的文件名</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>appendfsync&nbsp; everysec :</strong>指定更新日志条件，默认每秒更新一次（还有no，指等操作系统进行数据缓存到磁盘，快；always指每次更新操作后都手动写入磁盘，慢但安全）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;虚拟机方面的配置暂不说明</span></span></p>\n<h2><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">七，redis持久化</span></span></strong></h2>\n<p><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;概述：</span></span></strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">redis持久化主要有两种方式，即rdb和aof</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>rdb：</strong>适用于大数据集的恢复，数据的备份，但是因为设置周期时间进行数据的快照，所以如果redis宕机，可能会丢失最后一个写操作的数据，因为数据完整性较差。数据保存在dump.db文件中，只需要移动到redis安装目录，重启即可恢复数据</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>aof：</strong>适用于对数据的完整性要求较高的情况，因为可以设置不同的持久化策略，例如每秒保存一次，这样即时redis宕机，也只会丢失最后一秒的数据。但是因为其日志文件存储的是写入命令，因而其文件大小要大于rdb的数据文件，且每次重启，都要从头执行数据文件中的命令，因而恢复速度也</span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">要慢于rdb。</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>注意：</strong>当rdb和aof同时开启的时候，redis重启，默认会采用aof的形式进行数据的重新构建</span></span></p>\n<h2><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">八，redis事务</span></span></strong></h2>\n<p><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;概述：</span></span></strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">什么是事务？事务即是一系列的命令要买全部执行，要么全部回滚</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <strong>常用命令：</strong>multi(启动事务)，discard（取消事务）,exec（执行事务块内命令）,watch key(监控某个key的变化)，unwatch（取消对所有key的监控）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>注意：</strong>redis的事务中在命令本身出错的情况下会造成命令的全部回滚，但是在命令无错，执行某个命令的时候发生异常的时候，则谁的错，谁停止（这一点和mysql是不同的）</span></span></p>\n<h2><strong>九，redis的主从复制</strong></h2>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>redis的主从复制，即主机数据更新后根据我们设置的策略将数据同步到从机上，主机以写为主，从机以读为主<strong>。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 使用：</strong>配主不配从，在从机中使用slaveof&nbsp; 主机ip&nbsp; &nbsp;主机端口配置从机，但是这种配置方式当redis重启之后就会失效，如果想要redis重启仍然可用，则需要配置redis.conf配置文件中的slaveof&nbsp; masterip&nbsp; masterport。这种配置方式的问题所在，中心化只有一台极其支持写操作，如果主机宕机，则从机等待，且从机宕机重启后不会跟上大部队（即重启后变为主机）。当然我们可以采用命令slave&nbsp; no&nbsp; one 使从机反客为主，成为主机。但是这种手动操作太过麻烦。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>哨兵模式：</strong>即配置之后，如果主机宕机，则哨兵会自动根据投票规则在从机中进行选举，从而产生新的主机顶替。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>主从复制的缺点：</strong>因为所有的写操作都是子主机上进行，从而在同步到从机上，所以存在着一定的延迟，当系统繁忙或者从机数量较多的时候，这种问题就更加明显。</p>\n<h2><strong>十，redis集群</strong></h2>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;概述：</strong>集群是一种去中心化的模式，与中心化模式不同的是，中心化模式中如果主服务挂掉了，那么服务就挂掉了。但是集群模式下，没有主路由，每个节点自身都可以成为路由</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;redis集群：即配置多台主机，多台从机，不同的主机中有不同的槽点，当执行数据写入时，会根据crc16算法计算出数据的槽点，从而将数据存入到对应的主机中，并同步到与其对应的从机中</p>\n<p>&nbsp;</p>\n<h1>水平有限，如有错误，还望指出！</h1>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1249588251598041088","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6caUuADBI7AAAb07iHSRw500.jpg","blogRead":4,"blogRemark":"redis基础（一）","blogTitle":"redis基础（一）","createdTime":"2020-04-13 06:40:30","typeName":"redis","updateTime":"2020-04-20 16:47:37"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，JAVA线程的创建方式</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>JAVA线程的创建有四种方式，分别为，继承Thread类，实现Runable接口，实现Callable&lt;Class&gt;接口，基于线程池。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>1，继承Thread方式：创建一个类继承Thread类，创建类的实例对象，调用start方法，继而执行线程的run（）方法，代码如下：</strong></p>\n<pre class=\"language-java\"><code>public class NewThread extends Thread{\n    public static void main(String[] args) {\n        NewThread thread = new NewThread();\n        thread.start();\n    }\n    @Override\n    public void run(){\n        System.out.println(\"create  a  new thread by Thread!\");\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>2，当子类已经继承了一个类，这时候就没法再继承Thread类了，这时候就可以实现Runable接口，实例化类的线程实例，创建Thread实例传入类的实例，执行start方法，继而执行run（）方法代码如下：</strong></p>\n<p>&nbsp;</p>\n<pre class=\"language-java\"><code>public class ThreadExample2 implements Runnable {\n    public static void main(String[] args) {\n        ThreadExample2 threadExample2 = new ThreadExample2();\n        Thread thread = new Thread(threadExample2);\n        thread.start();\n    }\n    @Override\n    public void run() {\n        System.out.println(\"create a new thread by Runnable!\");\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，有些情况下，我们需要再一个主线程中并发多个子线程执行同一个任务，然后回收子线程的返回值整理汇总，这时候就需要实现Callable&lt;Class&gt;接口，重写其call（）方法，用于计算结果。然床创建一个线程池用于提交线程，继而执行call方法，并且创建一个Future的list用于接收子线程逻辑代码即call方法的返回，最终遍历list，得到想要的返回值，如下：</strong></p>\n<pre class=\"language-java\"><code>public class ThreadExample3 implements Callable&lt;String&gt; {\n\n    private String name;\n\n    public ThreadExample3(String name){\n        this.name = name;\n    }\n\n    @Override\n    public String call() throws Exception {\n        return name;\n    }\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        ExecutorService pool = Executors.newFixedThreadPool(3);\n        List&lt;Future&gt; list = new ArrayList&lt;&gt;();\n        for(int i=0;i&lt;3;i++){\n            ThreadExample3 threadExample3 = new ThreadExample3(i+\"\");\n            Future future =pool.submit(threadExample3);\n            System.out.println(future.get().toString()+\" is running\");\n            list.add(future);\n        }\n        pool.shutdown();\n        for (Future future : list) {\n            System.out.println(\"currentThread's result is \"+future.get().toString());\n        }\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，基于线程池创建线程</strong></p>\n<pre class=\"language-java\"><code>public class ThreadExample4 {\n    public static void main(String[] args){\n        ExecutorService pool = Executors.newFixedThreadPool(3);\n        for(int i=0;i&lt;3;i++){\n            pool.execute(new Runnable() {\n                @Override\n                public void run() {\n                    System.out.println(\"thread  is running by FixedThreadPool\");\n                }\n            });\n        }\n        pool.shutdown();\n    }\n}</code></pre>\n<h2>二，线程池的工作原理</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong> &nbsp;1，概述：</strong>JVM根据用户提供的参数创建一定数量的线程任务，将其放入队列中，线程创建之后启动这些任务，如果线程的数量大于核心线程数量（用户设置的线程数量），则超出数量的线程排在队列中等待，当有线程任务执行完毕后，线程池调度器就会发现有可用可用线程，继而从队列中取出任务继续执行<strong>。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; </strong><strong>2，线程复用：</strong>（参见JDK源码解读，这里只做简单描述），由前可知，JVM会根据用户提供的参数创建一定数量的线程任务，且将其添加到任务队列中。JVM通过start（）方法创建一个线程之后， 会相应的为其创建一个任务队列，线程会不停的查看任务队列，如果任务队列中有任务，则调用run方法，执行，这样就达到了一次start（）创建线程，多次使用，完成线程复用的任务。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>3，线程池的核心组件和核心类（见JDK源码分类中关于线程的总结）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; </strong><strong>4，JAVA线程的工作流程：</strong>线程池刚被创建的时候，只是向系统申请一个执行线程队列和管理线程池的线程资源，当调用execute方法之后，执行下列流程：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果正在运行的线程数量小于corePoolSize（核心线程数量，即用户定义的的线程数量），则立即创建线程执行线程任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果正在运行的线程数量大于或等于corePoolSize，则将超过数量的线程加入到阻塞队列中</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在阻塞队列已满且线程数量小于MaximumPoolSize（即线程池能够容纳的最大线程数），线程池会创建非核心线程立即执行任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在阻塞队列已满且线程数量大于或等于MaximumPoolSize的时候，线程池会拒绝该线程任务且抛出异常</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在线程任务执行完毕之后，会将其从任务队列中移除，从队列中取出下一个线程任务执行</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在线程处于空闲状态且空闲时间超过KeepAliveTime，且线程数量大于corePoolSize的时候，会停止该线程，这样在没有任务的时候，线程池中的线程数始终维持在corePoolSize。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，线程池的拒绝策略：</strong>分为四种，分别为AbortPolicy，CallerRunsPolicy，DiscardOldestPolicy，DiscardPolicy</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; AbortPolicy：直接抛出异常，阻止线程运行，源码如下：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</p>\n<pre class=\"language-java\"><code>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n            throw new RejectedExecutionException(\"Task \" + r.toString() +\n                                                 \" rejected from \" +\n                                                 e.toString());\n        }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CallerRunsPolicy：如果线程任务没有关闭，则尝试执行该线程任务，源码如下：</p>\n<pre class=\"language-java\"><code>* @param r the runnable task requested to be executed\n* @param e the executor attempting to execute this task\n*/\npublic void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n     if (!e.isShutdown()) {\n         r.run()\n     }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DiscardOldestPolicy：移除任务队列中最早进入的线程任务，执行当前任务线程，源码如下：</p>\n<pre class=\"language-java\"><code>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n       if (!e.isShutdown()) {\n           e.getQueue().poll();\n           e.execute(r);\n       }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DiscardPolicy：直接丢弃线程任务，不做任何处理</p>\n<h2><strong>三，五种常用的线程池</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;newCachedThreadPool（可缓存线程池）：</strong>当线程池创建线程的时候如果发现有可复用的线程（执行完任务，且未关闭的线程），则直接复用，如果没有则创建新线程。可缓存线程池可以高效的利用执行任务时间短的线程，提高系统的性能，且线程池中的线程如果空闲时间超过60s，则会被终止且从缓存中移除，这样可缓存线程池不会占用系统资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>newFixedThreadPool（固定大小的线程池）：</strong>即线程池中的线程是初始化固定的，当任务线程大于线程池中线程数量时，任务线程就会进入阻塞队列等待。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newScheduledThreadPool（可做任务调度的线程池）：</strong>即可以设置线程执行的停顿时间和执行周期，进行定期定时的执行某个任务。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newSingleThreadPool（单个线程的线程池）:&nbsp;</strong>即线程池中永远只有一个线程进行工作，如果下称停止或者异常，则线程池创建新的线程替代当前线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newWorkStealingPool（足够大小的线程池）：</strong>即创建足够数量的线程的线程池，保证更快的进行运算，提高效率。</p>\n<h2><strong>四，线程的生命周期</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;线程的生命周期大致分为五个阶段：新建（new），就绪（Runnable），运行（Running），阻塞（Blocked），死亡（Dead）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;新建：</strong>即使用new创建一个线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>就绪：</strong>调用start方法，</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>运行：</strong>即线程获取cpu资源，执行run（）方法，进入运行状态，运行状态的线程如果调用yield（线程让步方法）或者失去cpu资源，都会导致线程重新回到就绪态；如果调用sleep方法，I/O阻塞，等待同步锁，等待通知以及suspend挂起都会导致线程进入阻塞态。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞：</strong>即线程被放入Blocked池。阻塞状态的线程如果结束了sleep方法，I/O方法返回，获取同步锁，收到通知或者resume都会导致其重新进入就绪态，与其它线程竞争cpu时间片。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>死亡：</strong>线程正常执行完run（）或者call（）方法，或者执行stop方法，或者发生异常或者错误都会导致线程死亡。（stop方法会导致锁混乱和死锁，不建议使用）</p>\n<h2><strong>五，线程的基本方法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;wait（线程等待）：</strong>会让线程进入WAITING状态，并且会释放对象的锁。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>sleep（线程睡眠）：</strong>会让线程进入睡眠，进入TIMED_WAITING状态，但是不会释放对象锁，睡眠时间到了之后，再次恢复运行状态</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>yield（线程让步）:</strong>&nbsp; 当前线程会让出其占有的cpu资源，重新回到就绪态和其它线程竞争cpu时间片</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>interrupt（线程中断）:&nbsp; </strong>中断当前线程，但是并不会导致其停止，只是改变其内部的终端标识位，在使用了thread.sleep()之后使用该方法，会导致抛出异常，且我们可以利用中断标识位进行线程的安全退出</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>join（线程加入）：</strong>即将当前线程进入阻塞态，等待下一个线程执行完毕后进入就绪态，重新竞争锁资源。通常用于主线程下面执行子线程，需要主线程阻塞，等待子线程执行完毕后返回其结果给主线程，主线程再执行的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>notify（线程唤醒）/notifyAll：</strong>前者随机唤醒一个等待线程，后者全部唤醒</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>setDaemon（守护线程）:</strong>级别较低的线程，用于后台运行，服务用户用户线程，例如垃圾收集线程就是典型的守护线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>sleep方法和wait方法的区别：</strong>前者属于Thread，后者属于Object，前者不会释放锁资源，后者会释放锁资源</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>start方法和run方法：</strong>start方法只是创建一个线程，并没有运行，run方法时执行线程的真正代码逻辑。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>线程退出的方式：</strong>见四中最后一条</p>\n<h2><strong>六，JAVA中的锁（知识比较杂乱）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述:JAVA中的锁是为了保护数据的一致性。按照不同的标准可分为乐观锁和悲观锁，公平锁和非公平锁，共享锁和独占锁，偏向锁，轻量级锁，重量级锁，自旋锁，可重入锁。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;乐观锁：</strong>即认为每次读取数据都不会被修改，当修改操作的时候再判断当前数据是否被修改，未修改则修改，若已被修改，则返回失败状态。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>悲观锁：</strong>即认为每次读取数据都会被修改，因而每次读取数据都对其进行加锁，这样只有当前用户可以修改，其它用户阻塞等待直到当前用户修改完毕释放锁资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>自旋锁：</strong>即有些线程任务的执行很短，很快就可以释放锁资源，为了避免在这种情况下竞争线程仍然进行内核态和用户态之间的转换，因而让线程自旋（即等一会），如果有可用锁，则获取，减少了线程在用户态和内核态之间切换的时间损耗。提高了性能（优势）。当然线程自旋是占用cpu资源的，因而需要设置一个自旋的最大等待时间，如果超过此时间，则线程退出自旋模式。对于线程竞争锁资源激烈的情况，自旋有可能会导致cpu资源的损耗（劣势）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>公平锁和非公平锁：</strong>即根据线程竞争锁资源的机制判定，一般如果依据先到先得的原则，则位公平锁；如果依据就近原则，则位非公平锁。公平锁相比于非公平锁会更加耗费性能，因为要维护一个线程任务丢列，根据线程任务在队列中的顺序分配锁资源，因而不常用。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>可重入锁：</strong>又被称为递归锁，即该锁可以然后线程对其进行多次的加锁操作。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>偏向锁：</strong>当线程获取到锁的时候，用来消除线程的锁重入的开销（看起来是偏袒这个线程）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>共享锁和独占锁：</strong>共享锁即多线程共享锁资源（典型例子，读锁）；独占锁即当前锁只能有一个线程获取，其它线程阻塞</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>轻量级锁：</strong>没有多线程竞争的前提下，减少重量级锁的使用提高性能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>重量级锁：</strong>基于操作系统的互斥量而实现的锁，会导致进程在用户态和内核态之间切换，耗费性能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>synchronized：独占式悲观锁，可重入锁，非公平锁，重量级锁。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 作用范围：</strong>作用于成员变量和非静态方法，相当于锁住的是对象的实例，即this对象</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;作用于静态方法，相当于锁住的是class实例</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;作用域代码块，相当于锁住的代码块中的对象</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>实现原理：</strong>内部包括ContentionList（锁竞争队列），EntryList（竞争候选列表），WaitSet（等待集合），OnDeck（竞争候选者），Owner，!Owner，其中ContentionList是用来存放竞争锁资源的线程。EntryList是用来存放有资格竞争锁资源的线程。调用wait方法后放入WaitSet中，onDeck指的是同一时刻，只有一个线程竞争锁资源，Owner指的是得到锁资源的线程，!Owner指的是线程执行完毕，释放锁资源的线程。需要注意的是线程首先采用的都是自旋模式获取锁资源，如果自旋获取不到再加入ContentionList，而且Owner状态的线程并不是直接把锁资源交给onDeck状态线程，而是给它竞争锁资源的权利，因而onDeck状态的线程还需要跟自旋线程竞争锁资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>ReentrantLock：独占式，可重入锁，并且可以实现公平锁和非公平锁，重量级锁。</strong></p>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;用法：</strong>lock()加锁，后跟try代码块，finally中进行释放锁unlock()</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;避免死锁的方法：</strong>响应中断（即可以根据情况中断对锁资源的请求），可轮询锁（tryLock（）即尝试获取锁，如果有可用锁则获取返回true，没有则返回。和lock（）的区别在于lock获取锁资源如果没有则一直等待直到获取到锁资源），定时所（tryLock（time,unit）即再一定时间内如果有可用锁，且线程未中断则获取锁，否则禁用当前线程。）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>Semaphore（信号量）:</strong>机制和ReentrantLock类似</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ReadWriteLock（读写锁）：</strong>如果系统要求支持多线程共享读，但不能多线程写，使用读锁；如果要求同一时刻只能有一个线程写，写的过程中不能读取该共享数据，则使用写锁。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; <strong>分段锁：</strong>一种思想，将数据分段加锁，例如ConcurrentHashMap</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;死锁：</strong>即线程之间互相共享资源会导致死锁</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; <strong>锁优化：</strong>第一，减少锁的持有时间；第二：减小锁粒度，例如分段锁；第三：锁分离，例如读写锁；第四：锁粗化，放置锁粒度太小，造成频繁加锁释放锁；第五：锁消除，消除程序代码不规范而造成的乱用了锁</p>\n<p>&nbsp;</p>\n<h3><strong>并发编程（上）的思维导图送上：<a href=\"https://images-cdn.shimo.im/1UcHkyrlJyGRPYnn.png__thumbnail\" target=\"_blank\" rel=\"noopener\">并发编程（上）</a></strong></h3>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>\n<h1>水平有限，如果错误，还望指出！</h1>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;</p>","blogGoods":0,"blogId":"1249313090567143424","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHM2AQOeZAABJTVJPTfk967.jpg","blogRead":8,"blogRemark":"面试（三）------之并发编程篇（上）","blogTitle":"面试（三）------之并发编程篇（上）","createdTime":"2020-04-12 12:27:07","typeName":"java面试篇","updateTime":"2020-04-20 11:53:51"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，集合</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，List：</strong>list是java中一种有序的集合，下有三个实现类，分别为ArrayList，Vector，LinkedList</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ArrayList：基于数组实现，增删慢，查询快，线程不安全。因为其基于数组实现，所以查询的时候可以直接根据数组的索引下标进行快速查询，但是进行增删操作的时候，需要将待增删元素后的元素全部移动，因而效率较低。且ArrayList创建时不需要分配初始大小，其空间不够的时候，会自动创建一个更大的list，然后复制数据。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Vector：基于数组实现，和ArrayList一样增删慢，查询快。但是线程安全，因为同一时间只支持一个线程对Vector进行写操作，然而因为要进行频繁的加锁和释放锁的操作，所以效率要低于ArrayList。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; LinkedList：基于双向链表实现，增删快，查询慢。因为基于链表实现，增删元素的时候，只需要改变元素的指针即可，改动较小，效率较高。然而进行查询操作的时候，需要从链表头部进行遍历，因而效率较低。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，Queue：</strong>队列，满足先进先出，种类较多。（不作详细解释）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，set：</strong>具有独一无二的特性，常用来存储无序且不重复的元素，对象相等的本质是hashcode的值相同，而如果想要比较两个对象是否相等，需要重写对象的hashcode方法和equals方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;hashset：基于hashTable实现，无序。存放的是对象的散列值，即通过hashcode计算得到的值</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;treeset：基于二叉树实现，即其中的对象按照一定的排序方式进行排列（升序，降序），每次添加对象的时候，都会进行排序，将其插入指定位置。基本的数据类型例如Integer，String等可以使用treeset默认的排序方法，而自定义数据类型需要实现compareable接口，实现compareTo方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;LinkHashSet：继承自hashset，只不过使用双向链表记录数据的顺序。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，map：</strong>一种键值对形式的集合</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;hashmap：基于数组+链表实现，增删改查操作快，但是每次遍历hashmap元素的顺序无法保证且线程不安全。如果想要其线程安全，可以使用synchronizedMap和ConcurrentHashmap，hashmap的内部是数组，数组中的每一个元素又是一个单向链表，链表中的每个元素嵌套一个Entry实例，其中包括Key，Value，Hash值，指向下一个节点的next。每次查询的时候，可以根据元素的hash值很快定位所在数组，但是定位之后需要遍历链表查找元素，因而时间复杂度为O（n），但是Java8之后对其进行了优化，将其改为了数组+链表或红黑树的结构，即当链表中的元素大于8个的时候，链表会转换为红黑树（红黑树是一种特化的二叉平衡树，因为其左右子树的深度差可以大于1），这样查询的时间复杂度就缩短到了O（logN）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ConcurrentHashmap：采用分段锁的思想进行并发操作，因而使线程安全的。由多个Segment组成，只要保证每个Segment线程安全就可以保证全局线程安全。ConcurrentHashmap的默认Segment即并发度为16，可以在初始化的时候修改，但是初始化之后不能再修改。每个Segment内部的实现和hashmap一样&middot;。Java8之后也和hashmap进行了一样的优化。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;HashTable：线程安全，即同一时刻只能有一个线程对其进行操作，并发度不如ConcurrentHashmap。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;TreeMap：基于二叉树数据结构实现，实现了SortedMap，默认按照键值的升序进行排列。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;LinkedHashMap：Hashmap的子类，只不过使用链表保存元素的插入顺序。使用迭代器遍历的时候按照插入顺序遍历。</p>\n<h2><strong>二，异常分类及处理</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;1，异常分类：</strong>Throwable是所有异常类的父类，其下有error和Exception，Error下有AwtError，ThreadDeath；Exception下有RuntimeException和CheckedException。</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</strong>对于Error类异常通常是由内部错误和资源耗尽造成的，无法在程序运行期间对其进行捕获和处理，对于这类错误我们只能记录错误的原因和终止程序。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; Exception中的RuntimeException异常（运行时异常）：这类异常是我们程序中异常处理的核心，可以在程序中进行捕获并处理。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Exception中的CheckedException异常（检查异常）：这类异常时程序中需要强制捕获的异常，通常有IO异常，SQL异常等等。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，异常处理：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>异常处理有两种方式：抛出异常和捕获异常</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;抛出异常有三种方法：throws，throw，系统自动抛出。其中throws是作用在方法上，后面跟的是可能产生的异常类。throw是作用在方法内部，后面跟的是具体的异常对象。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 捕获异常：即使用try{}catch语句进行捕获</p>\n<h2><strong>三，反射机制</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，什么叫做反射机制？</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>即在程序运行的过程中，可以获取类的属性和方法，并且可以调用任意一个类的方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，反射机制的使用</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 首先，获取类的class对象，有三种方式，className.getClass()，类对象.class，Class.forName(\"类路径\")，其中最后一种最为安全，性能最好。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 然后利用反射的API可以实现对类中信息的操作，例如getDeclareFields（），getDeclareMethods（），getConstroctors（）等等。反射创建类的对像有两种方法，一，class.newInstance()初始化一个类实例；二，先获取其构造器，然后利用构造器初始化一个实例。利用反射调用类的方法：先获取方法，然后调用method.invoke()执行方法。</p>\n<h2><strong>四，注解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，四种元注解：</strong>@Target（指定注解的使用范围），@Retention（定义注解的保留级别，有三级，SOURCE源程序中保存，CLASS文件中保存，RUNTIME运行时保存），@Documented（可以工具文档化），@Inherited（<span style=\"background-color: #ffff00;\">这个没怎么看懂</span>）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，注解使用示例：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>第一步，定义注解接口</p>\n<pre class=\"language-java\"><code>@Target(ElementType.FIELD)  \n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface FruitProvider {\n\n    //id\n    public int id() default  -1;\n\n    //供应商名称\n    public String name() default \"\";\n\n    //供应商地址\n    public String address() default \"\";\n\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 第二步，使用注解</p>\n<pre class=\"language-java\"><code>public class Apple {\n\n    @FruitProvider(id = 1,name = \"红富士苹果\",address = \"陕西\")\n    private String appleProvider;\n\n    public String getAppleProvider() {\n        return appleProvider;\n    }\n\n    public void setAppleProvider(String appleProvider) {\n        this.appleProvider = appleProvider;\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第三步，定义注解处理器</p>\n<pre class=\"language-java\"><code>public class FruitInfoUtil {\n    public static void getFruitInfo(Class&lt;?&gt; clazz) {\n        String strFruitProvider = \"供应商信息:\";\n        Field[] declaredFields = clazz.getDeclaredFields();\n        for (int i = 0; i &lt; declaredFields.length; i++) {\n            if (declaredFields[i].isAnnotationPresent(FruitProvider.class)) {\n                FruitProvider annotation = declaredFields[i].getAnnotation(FruitProvider.class);\n                strFruitProvider += annotation.id() + \",\" + annotation.name() + \",\" + annotation.address();\n                System.out.println(strFruitProvider);\n            }\n        }\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第四步，主方法入口</p>\n<pre class=\"language-java\"><code>public class FruitRun {\n    public static void main(String[] args) {\n        FruitInfoUtil.getFruitInfo(Apple.class);\n    }\n}</code></pre>\n<h2><strong>五，内部类</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 1，静态内部类：</strong>即在类的内部定义的静态类，静态内部类可以访问外部了的静态变量和方法，外部也可以通过outClassName.innerClassName调用内部类</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2，成员内部类：</strong>在类的内部定义的没有用static修饰的内部类，使用方式和静态内部类一样。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>3，局部内部类：</strong>即一个类只在一个方法中使用，则完全可以将这个类定义为这个方法的内部类，即局部内部类，局部内部类可以实现真正的对外隐藏</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>4，匿名内部类：</strong>通常用于继承一个类或者实现一个接口的时候，使用new关键字定义，例如:Person person = new Student(){new Pupil(){}}</p>\n<h2><strong>六，泛型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 1，为什么要使用泛型：</strong>其根本目的是为了实现代码的复用，举个开发中常见的例子，我们需要定义返回类Result，返回类中包含状态码code，信息msg，以及数据data（任意类型），这个时候我们就需要使用泛型，因为我们返回的数据类型有各种vo，pojo类对象，list等。这时候泛型类result就可以被各种对象使用，实现代码的复用，简化开发。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>2，泛型标记和泛型限定：</strong>E表示集合中的元素，K表示键值，V表示value，N表示数值类型，T表示任意类型（包含基础类型，所有的对象类型），？（不确定的java类型）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>泛型限定：</strong>向上限定，&lt;?&nbsp; extends T&gt;，向下限定，&lt;? super&nbsp; T&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; <strong>3，泛型方法：</strong>即参数类型定义为泛型类型，以便于接收不同类型的参数，做出不同的处理。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>4，泛型类：</strong>例如public class Pair&lt;T&gt;{private T data;}</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>5，泛型接口：</strong>与放泛型类类似</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>6，类型擦除：</strong>即在泛型编译的过程中，会将泛型类型替换为限定类型的操作</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>7，明确的一点：</strong>虚拟机在运行程序的过程中，内部是没有泛型的，只有普通的类和方法。</p>\n<h2><strong>7，序列化</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 序列化是为了确保对象及其状态的持久化</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>序列化的使用：</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </strong>首先，实现序列化接口java.io.Serializble</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 然后，声明序列化ID，通常private static final&nbsp; long&nbsp; serialVersionUid&nbsp; = ***</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 因为序列化是保证对象及其状态的持久化，而静态变量是不属于对象，属于类本身的，所以序列化无法保存静态变量。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果需要序列化父类变量，则父类也要实现Serializable接口</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t'ransient修饰的属性不会序列化</p>\n<h3><strong>最后，提供一张思维导图供大家学习：<a href=\"https://images-cdn.shimo.im/es83SQH0CggucT7f__thumbnail\" target=\"_blank\" rel=\"noopener\">JAVA基础</a></strong></h3>\n<p>&nbsp;</p>\n<h2>水平有限，如有错误，还望指出！</h2>","blogGoods":0,"blogId":"1248605157059497984","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHMKAcvZ8AABJTVJPTfk020.jpg","blogRead":27,"blogRemark":"面试（二）------之JAVA基础篇","blogTitle":"面试（二）------之JAVA基础篇","createdTime":"2020-04-10 13:34:02","typeName":"java面试篇","updateTime":"2020-04-20 11:53:39"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，Linux的发展历史</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; </strong>1965年之前，电脑并不像现在这么普遍，除了军事机构和研究即构，一般人基本接触不到电脑，而且那时候的一台大型主机最多也就只能支持30台终端。为了解决数量问题，1965年之后，由贝尔实验室，麻省理工学院以及通用电气一起放弃了Multics项目，准备让大型主机能够支持300台终端，但是在开发过程中，进度缓慢，最终由于资金的短缺，贝尔实验室推出了研究。1969年，从这个项目中退出的Ken Thompson在家无聊，为了让电脑能够运行&ldquo;星际旅行&rdquo;游戏，因而趁着妻子回家探亲的一个月，独自写出了Unix操作系统的原型（！！！！牛批）。1970年，这个人以BCPL语言为基础，又写出了很接近硬件的B语言，并且用B语言写出了第一个Unix操作系统。但是由于B语言的跨平台性比较差，为了解决这个问题。Dennis Ritchie和Ken Thompson决定以B语言为基础开发一种新的语言，1972年，Dennis Ritchie最终设计出了一种新语言，他以BCPL的第二个字母命名，也就是我们后来熟知的C语言。随后两人便迫不及待的用C语言重现Unix操作系统。Unix系统起初开源，但是在Unix7之后，由于政策的变化，代码闭源化，因而大学中不能使用Unix的源代码进行教学。Andrew S. Tanenbaum教授为了能够让学生更好的理解代码细节，在完全不使用任何源代码的情况下开发除了Minix---小型Unix。但是因为其只用于教学，功能并不强大，因而Torvalds以此为基础，开发除了Linux，但是起初Linux并不支持Unix，最终经过全世界网友的帮助，最终让其能够兼容各种硬件。</p>\n<p><strong>二，文件和目录</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; 1，windows和linux的区别：</strong>我们熟知的windows系统，它的文件系统是分盘符的，盘符下的文件构成一个树形结构，但是Linux文件系统没有盘符，所有文件目录都在根目录/之下</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;<strong>2，Linux需要记住的目录：</strong>/bin（存放系统命令的目录），/sbin（只有超级管理员能访问的命令文件目录），/root（存放和root用户相关文件的目录），/etc（存放系统配置文件的目录），/usr（存放系统共享资源的目录），/opt（存放安装的第三方软件的目录，通常在/usr/local下）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;<strong>3，文件权限：</strong>Linux中的文件权限有读（r，可用于数字4表示），写操作（w，可用数字2表示），执行权限（x，可用数字1表示）</p>\n<p><strong>三，常用命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，ls：</strong>列出目录中的所有目录和文件名&nbsp; -a（列出所有，包括隐藏文件和目录），-l（以列表形式列出所有），-h（人性化列出，需要配合-l使用，即文件大小转换为我们熟知的kb，mb等），-d（显示当前目录属性），命令可以联合使用，例如-al，-lh等等。&nbsp;&nbsp;&nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，cd：</strong>用于切换目录，需知（.和..是相对路径，.表示当前目录，..表示上级目录；/表示绝对路径），cd ~（切换到root目录），cd - （切换到前一次切换的目录）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，clear：</strong>清屏</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，pwd：</strong>显示当前所在目录</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，mkdir：</strong>创建目录，-p（如果目录存在则不创建，如果不存在则创建目录再创建自目录），可以一次性创建多级目录，例如：mkdir&nbsp; -p test/test1</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，touch：</strong>创建空文件</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>7，cp：</strong>复制，-r（递归复制目录下的文件目录信息），-i(提示是否覆盖)，-v（显示复制进度）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>8，mv：</strong>移动文件，不过经常用来给文件进行重命名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>9，rm：</strong>删除目录或者文件，-r（递归删除），-f（强制删除），-v（显示删除进度）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>10，cat：</strong>查看文件内部信息</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>11，ln：</strong>文件创建链接，ln 源文件 目标链接文件（创建硬链接，硬链接和源文件大小相同，修改同步，但是删除不同步，使用较少），ln -s（创建软连接，相当于我们平时创建快捷方式，使用较多）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>12，which：</strong>搜索命令所在位置，例如：which&nbsp; &nbsp;ls</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>13，find：</strong>搜索文件所在位置&nbsp; 例如：find&nbsp; &nbsp;test.conf</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>14，grep：</strong>文件内容搜索，例如：grep &ldquo;想要搜索的内容&rdquo;&nbsp; 源文件</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>15，tar：</strong>归档命令，-c（打包成.tar文件），-z（打包的同时压缩），-v（打包的同时显示进度），-f（放在最后，后面跟.tar.gz），-x(解压)，常用：tar -zcvf&nbsp; <em><strong>.tar.gz&nbsp; &nbsp; ;&nbsp; &nbsp; tar -zxvf</strong> tar.gz</em> -C&nbsp; 指定解压目录&nbsp;&nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;还有more，head，tail等命令，不过这些不常用。</p>\n<p><strong>四，用户权限命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，whoami：</strong>查看当前账户的用户名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，who：</strong>查看当前登录用户</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，exit：</strong>退出登录</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，adduser/useradd：</strong>添加用户，-d（指定用户主目录），-g（指定用户用户组），-m（自动建立目录），默认情况下用户主目录和用户组名都和用户名一样</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，passwd：</strong>只有root用户才能使用，用于修改用户密码</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，userdel：</strong>删除用户，默认不删除用户的主目录，-r（删除用户主目录）</p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;7，su：</strong>切换账户</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>8，groupadd/groupdel：</strong>添加用户组和删除用户组</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>9，groups：</strong>查看用户所在用户组，例如：groups&nbsp; 用户名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>10，usermod：</strong>修改用户所在用户组，例如：usermod&nbsp; 用户组名 用户名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>11，chmod：</strong>修改文件权限，例如：chmod&nbsp; 777&nbsp; test</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>12，chown：</strong>修改文件所有者，例如：chown&nbsp; &nbsp;用户&nbsp; 文件名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>13，chgrp：</strong>修改文件所在组，例如：chgrp&nbsp; 组名&nbsp; 文件名</p>\n<p><strong>五，系统命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，cal：</strong>查看日历</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，date：</strong>查看时间，可以设置格式，例如：date '+<span class=\"ql-token hljs-built_in\">%Y</span>-<span class=\"ql-token hljs-built_in\">%m</span>-<span class=\"ql-token hljs-built_in\">%d</span> <span class=\"ql-token hljs-built_in\">%H</span>:<span class=\"ql-token hljs-built_in\">%M</span>:<span class=\"ql-token hljs-built_in\">%S</span>'</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，ps：</strong>查看线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，kill：</strong>杀死线程，-9（强制杀死）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，查看网卡信息：</strong>centos6：ifconfig ；centos7：ip addr</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，ping：</strong>查看网址或者链接的连通性</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>7，防火墙：</strong>centos6：service&nbsp; iptables&nbsp; status（查看防火墙状态），service&nbsp; &nbsp;iptables&nbsp; &nbsp;start(开启),service&nbsp; iptables&nbsp; stop(关闭);centos7:firewall-cmd&nbsp; --state（查看防火墙状态），systemctl&nbsp; start&nbsp; firewalld.service(启动)，systemctl&nbsp; &nbsp;stop&nbsp; firewalld.service（关闭）</p>\n<p><strong>六，网络命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，wget：</strong>下载，例如：wget&nbsp; &nbsp;链接地址</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，yum：</strong>下载安装</p>\n<p><strong>七，vim（这里只说几个常用的命令）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;</strong>vim有三种模式：命令模式，插入模式，编辑模式&nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;vim&nbsp; 文件名：进入文件，且处于命令模式；iao任意一键进入插入模式（i表示在贯标之前插入，a光标之后插入，o在下一行插入），：进入编辑模式</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;命令：set:nu显示行号，set:nonu不显示行号；/strinng，向后搜索字符串，？string向后搜索字符串；：w保存，：wq保存并退出，：q不保存退出</p>","blogGoods":0,"blogId":"1248500061625745408","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dDA6AfCOJAAAyfL52jxY706.jpg","blogRead":2,"blogRemark":"Linux基本命令总结","blogTitle":"Linux基本命令","createdTime":"2020-04-10 06:36:25","typeName":"Linux","updateTime":"2020-04-20 10:42:25"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2 style=\"text-align: left;\"><strong>一，JVM运行机制</strong></h2>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;jvm即java虚拟机，一共由四个部分组成，分别是类加载器子系统，运行时数据区（程序计数器，本地方法区，jvm栈，方法区，jvm堆），执行引擎（即时编译器，垃圾收集器），本地接口库。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;一个java源程序的运行先是经过编译器将其编译成字节码文件（class文件），然后通过类加载器子系统将其加载进入jvm&mdash;&mdash;&gt;程序运行过程中，运行时数据区存放程序运行过程产生的数据&mdash;&mdash;&gt;执行引擎中的垃圾收集器收集程序运行过程中创建的不再使用的对象，即时编译器将程序的字节码文件编译成机器码&mdash;&mdash;&gt;然后本地接口库利用机器码调用本地方法库中的方法，和操作系统实现交互。</p>\n<h2><strong>二，多线程</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;</strong>在多核操作系统中，jvm支持一个进程中同时并发执行多个线程，且这些线程和本地操作系统的线程相对应。当jvm中的对象初始化，内存空间分配等一系列准备工作完成之后，会调用操作系统中的接口创建一个原生线程，原生线程初始化完毕后，会调用java线程的run（）方法执行该线程，线程结束之后，jvm会释放原生线程和java线程资源。</p>\n<h2><strong>三，JVM的内存区域</strong></h2>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM的内存区域主要分为线程私有区域（程序计数器，本地方法区，JVM栈），线程共享区（方法区，JVM堆）和直接内存。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;程序计数器：线程私有区域，无内存溢出，用来记录程序运行过程中的字节码指令地址，如果是Native方法，则程序计数器为空。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM栈：线程私有区域，用来描述java程序的运行过程，java程序运行每次运行的时候，都会创建一个栈帧，方法的执行和返回对应着栈帧的入栈和出栈操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;本地方法区：线程私有区域，和JVM栈的功能一样，只不过是用来记录Native方法的运行过程。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM堆：线程共享区，主要用来存放程序运行过程中产生的数据，同时也是垃圾收集器进行垃圾回收的主要区域。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;方法区：也被称为永久代，用来存放常量，静态变量，类信息等等。</p>\n<h2><strong>四，JVM的运行时内存</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>JVM的运行时内存又被称为JVM堆，因为JVM的GC算法使用的是分代收集算法，所以JVM堆按照GC标准可以分为三个区域分别为：新生代，老年代，永久代。其中新生代占1/3，老年代占2/3，永久代很少，</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;新生代：存放短生命周期，小对象的区域。新生代又分为Eden区，ServivorTo区，ServivorFrom区，区域的GC算法采用复制算法。Eden区是用来存放新创建的对象（大对象除外），ServivorTo区是用来保存MinorGC幸存下来的对象，ServivorFrom区是用来将上一次MinorGC幸存下来的对象作为下一次MinorGC的扫描对象。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;老年代：存放长生命周期的大对象，区域的GC算法采用标记整理算法</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;永久代：主要用来存放class和meta数据信息的。程序运行过程中不会进行永久代的垃圾回收，这也就导致永久代区域的数据会越来越多，最终造成内存溢出。java8之后永久代已经被元数据区取代，元数据区和永久代的功能都是一样的，但是最大的不同在于永久代区域依赖于虚拟机的内存大小，因而可以存储的class，meta信息非常有限。但是元数据区依赖的是本地操作系统，因而不会受到虚拟机内存的限制。</p>\n<h2><strong>五，垃圾回收与算法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;(1)垃圾回收：</strong>Jvm的垃圾回收判定依赖于两种方法，引用计数法和可达性分析法。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;引用计数法：即如果想要在程序中使用对象，就必须赋予一个引用，这样在对象赋予引用的时候将其引用计数加1，删除一个引用时，将对象引用计数减1，如果引用计数为0，就说明该对象已经不使用，作为垃圾。但是引用计数法存在一个缺陷，即循环引用的问题，如果两个对象相互引用，则这两个对象的引用计数永远都不会为0，造成对象无法被回收。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;可达性分析法：即先创建一些根节点对象ROOTS，然后通过这些根节点对象向下搜索，如果一个对象到任意一个ROOTS之间都没有可达路径，在经过两次标记（下文解释为什么进行两次标记），还是没有可达路径，则说明该对象可回收。</p>\n<p>&nbsp;&nbsp; &nbsp;<strong>（2）GC算法：</strong>常见的GC算法有四种，分别为标记清除算法，复制算法，标记整理算法，分代收集算法</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;标记清除算法：即在进行垃圾回收前，对所有对象进行一次标记，标记可回收的对象，然后进行清理即可。但是标记清除算法在清除回收对象之后，并不会对堆内存进行整理，这样的话如果内存中的对象大部分为小对象，清理之后就会导致没有大片连续的内存空间，即造成了内存碎片化，这样大对象存储的时候就无法找到相应的完整连续内存。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;复制算法：即将内存分为两块同等大小的区域，区域1和区域2，创建的新对象都存储在区域1中，当区域1中的内存占满之后，会对内存中的所有对象进行一次标记，标记存活的对象，将存活的对象复制到区域2，这时区域1中的对象都是可回收对象，回收区域1中的所有对象即可。但是复制算法也存在着一定的缺陷，即每次都只能使用一半的内存空间，造成了大量的内存浪费。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;标记整理算法：即结合标记清除算法和复制算法的优点，先对所有的对象进行标记，标记存活的对象，将存活的对象复制到内存的另一端，然后清除当前端的对象即可。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;分代收集算法：前面的三种算法，都无法按照对象的类型进行收集，分代收集算法正是解决这个问题，按照对象的不同类型采用不同的GC算法。以JVM的分代收集算法为例，JVM的堆内存分为新生代，老年代，永久代。新生代又分为Eden区，ServivorTo区和ServivorFrom区。新生代因为其存储生命周期短的小对象，GC比较频繁，所以采用复制算法。程序运行过程中创建的对象都存储在Eden区（大对象除外，大对象直接复制到老年代区域）。当Eden区的内存不够的时候进行MinorGC，然后将Eden区和ServivorFrom区的存活对象都复制到ServivorTo区，然后将ServivorTo区和ServivorFrom区进行交换，再次进行MinorGC。老年代因为存放的都是生命周期长的大对象，因而进行GC的不会太频繁，且清除的对象并不会太多，因而采用标记整理算法。老年代每次进行MajorGC之前都会先进行一次MinorGC，当MinorGC之后新生代的内存仍然不够的时候，将对象复制到老年代进行MajorGC。永久代区域主要回收常量，无用class等。</p>\n<h2><strong>六，JAVA中的四种引用类型</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;强引用类型<strong>：</strong>即把对象赋给一个引用变量，强引用的对象一定为可达状态，所以不会进行垃圾回收。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;软引用类型：通过SoftReference类实现，当内存不够的时候对其进行GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;弱引用类型：只有弱引用类型的对象，一定会被GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;虚引用类型：虚引用对象主要是用来跟踪对象的GC状态</p>\n<h2><strong>七，分代收集算法和分区收集算法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>分代收集算法：新生代因其存放大量短生命周期小对象，且GC频繁，所以采用复制算法。老年代因其存放长生命周期大对象，且GC不平凡，所以采用标记整理算法。永久代，回收常量，类信息等。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;分区收集算法：即将堆内存区域分为大小不同的区，可以按照不同的区进行快速垃圾回收，减少系统的停顿时间。然后再以并行的方式逐步完成整个GC。</p>\n<h2><strong>八，垃圾收集器</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>新生代区域：Serial垃圾收集器，单线程复制算法，因为单线程无需进行线程之间的交互和切换，所以效率非常高，是JVM默认的client模式下的默认垃圾回收策略，工作期间需要暂停其它所有的线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ParNew垃圾收集器，多线程复制算法，跟单线程Serial一样，是JVM默认的server模式下的垃圾回收策略，工作期间需要暂停所有其它线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Parallel Scavenge垃圾收集器：多线程复制算法，不同的是优先考虑系统吞吐量，可以利用更高效的利用CPU完成GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;老年代区域：Serial Old垃圾收集器，单线程标记整理算法，同新生代的Serial功能一样，只是采取的算法不同而已。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Parallel Old垃圾收集器：多线程标记整理算法，优先考虑了系统的吞吐量，其次考虑停顿时间。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CMS,多线程标记清除算法，优先考虑系统GC时的停顿时间，且过程分为四步（<span style=\"background-color: #ffff00;\">解释上文的可达性分析中的两次标记</span>，第一步：标记GC ROOTS可达对象，暂停其它工作线程；第二步：和用户线程一起工作，跟踪GC ROOTS；第三步，因为第二步用户进程没有暂停，所以有些对象状态</p>\n<p>可能发生了改变，重新进行标记；第四步，清除不可达对象）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; G1垃圾收集器，多线程标记整理算法，将内存分区，与CMS相比，一方面不会产生内存碎片，一方面，可以精确的控制系统停顿时间。</p>\n<h2><strong>九，JAVA的网络编程模型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;</strong>阻塞I/O模型：即用户线程发出I/O请求之后，内核会检查数据是否准备就绪，这时候用户线程始终处于阻塞状态等待数据准备就绪。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;非阻塞I/O模型：即用户线程不断的给内核发出I/O请求，内核接受到I/O请求之后会返回一个状态，如果数据准备就绪，就将数据复制进入用户线程，如果数据没有准备好，返回一个false，用户线程无需阻塞，可以去处理其它事情，而当数据准备好了且刚好用户线程发起I/O请求进行操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;多路复用I/O模型：多路复用I/O模型通过一个Selector线程轮询Socket的状态，如果Socket有读写事件，则进行I/O操作。此模型的优势在于可以更好的处理连接数众多但消息体不大的情况下。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;信号驱动I/O模型：即用户线程发出一个I/O请求，系统会为该请求创建一个信号函数，用户请求可继续执行其它业务逻辑，当内核数据准备就绪之后会返回给用户线程一个信号，用户线程接收到之后进行I/O操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;异步I/O模型：用户线程给内核发起一个asynchronous read操作，内核接收到之后，返回其请求是否成功，然后等待数据准备成功之后复制到用户线程。整个过程中请求的发起和数据读取都在内核中进行，最终发送一个信号告知用户线程I/O操作已经完成，用户直接使用数据就行。（说实话个人感</p>\n<p>觉和信号驱动很像）</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;java NIO：没怎么读懂（<span style=\"background-color: #993300;\">记得补充！</span>）</p>\n<h2><strong>十，JVM的类加载机制</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>JVM类加载分为五个阶段：加载，验证，准备，解析，初始化</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;加载：即将class文件加载到JVM中，且创建class对象，封装其数据结构。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;验证：对class文件进行验证，确保符合JVM的标准，保证JVM的安全。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;准备：即方法区中给类变量分配空间和赋初值。static修改的会在初始化阶段赋值，final修饰的会在准备阶段赋值。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;解析：即将常量池中的引用替换为直接引用</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;初始化：执行类构造器进行初始化。（因为内部流程不是很清楚，所以对于其几种不进行初始化的情况不做说明）</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;类加载器：JVM提供了三种类加载器，启动类加载器（/lib），扩展类加载器(/lib/ext)，应用程序类加载器(classpath)。还可以再应用程序类加载器自定义类加载器。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;双亲委派机制：即当一个类接收到类加载请求的时候，不会自己进行加载，而是将其加载请求委派给其父类加载器，这样一路委派，最终加载请求都会委派到启动类加载器.启动类加载器接收到加载请求之后会去lib目录下寻找相关的class文件，若找不到，则将其加载请求再委培给子类加载器，一路委派，直到能够加载。</p>\n<h3><strong>最后，送给大家一张博主画的JVM的思维导图，以后读《深入JVM虚拟机》的时候可能会出一个JVM专题：<a href=\"https://uploader.shimo.im/f/X0MX3hLaHrevltxW.png!thumbnail\" target=\"_blank\" rel=\"noopener\">JVM思维导图</a></strong></h3>\n<p>&nbsp;</p>\n<h2>水平有限，若发现有误，还望指出！</h2>","blogGoods":0,"blogId":"1248224512563068928","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHLeALxSjAABJTVJPTfk677.jpg","blogRead":17,"blogRemark":"面试（一）------之JVM篇","blogTitle":"面试（一）------之JVM篇","createdTime":"2020-04-09 12:21:30","typeName":"java面试篇","updateTime":"2020-04-20 11:53:29"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，css之弹性布局</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，</strong>何为弹性布局？</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 弹性布局是css的一种新的布局方式，所谓&ldquo;弹性布局&rdquo;，即页面随着不同设备的屏幕大小拉伸会自适应页面的大小。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，</strong>弹性布局的两种主要元素，container（弹性容器），item（弹性子元素），一个弹性容器中可以放入多个弹性子元素，元素之间是可以进行嵌套的，弹性子元素也可以设置为弹性容器，里面再嵌套弹性子元素。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，</strong>弹性布局的基本属性</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （1）display：flex，声明容器为弹性布局</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （2）flex-direction：声明弹性容器内部元素的排列方式，默认为row。row（横向布局），row-reverse（横向布局，但是元素反方向码），column（纵向布局），column-reverse（纵向布局，但是元素反着码）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （3）flex-wrap：声明弹性盒子中的元素是否可以换行，默认为nowrap（不换行），wrap（换行），wrap-reverse（换行，但是反着码）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （4）align-items：设置容器中元素在纵轴方向上的对齐方式，默认为stretch（即如果不设置子元素高度，则默认拉伸至于容器同宽度），flex-start（子元素位于容器的开始位置），flex-end（子元素位于容器的结尾处），center（元素依纵轴方向居中），baseline（元素位于容器基线，不过没怎么用过，所以不是很清楚）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （5）justify-content（设置元素在主轴上的对齐方式），默认为flex-start（元素从容器主轴开始位置码），flex-end（元素从容器主轴结尾处码），center（元素位于主轴居中处），space-between（元素布局在容器的两端），space-around（元素布局在容器两端，但是元素前后都留有空白）因为项目中大多数只使用了对于容器的操作，对于容器中元素的操作很少，所以这里只介绍这点。谢谢阅读！</p>","blogGoods":0,"blogId":"1248135765829918720","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dGnuAWkLLAAAaRXQXNms575.jpg","blogRead":3,"blogRemark":"CSS----之flex弹性布局","blogTitle":"CSS----之flex弹性布局","createdTime":"2020-04-09 06:28:51","typeName":"CSS","updateTime":"2020-04-20 11:43:57"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，前后端分离开发优势</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，</strong>项目开发过程中，前后端完全解耦，前端只需要负责页面的实现，只需要通过接口拿数据。后端不需要管页面的跳转，只需要负责接口的编写</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，</strong>前后端人员有更多的精力去负责自己的工作，前端人员可以将更多的精力投放在页面的编写，页面的美化，页面特效的制作和用户体验上；而后端人员可以将更多的精力放在接口代码的优化，sql优化，jvm调优上面</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，</strong>前后端分离的项目部署的时候，前端项目往往都是部署在nginx服务器上，而前后端不分离的项目往往都是部署再一台服务器上。因此前后端分离项目大大降低了服务器的负担</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>4，</strong>前后端不分离的项目使用模板引擎例如freemaker，thymeleaf等，前后端人员交流起来较为困难。且前端项目使用原生的DOM操作，极大的增加了前端工作人员的工作量。而前后端分离项目前端通常都是用各种ui框架，框架采用MVVM模式，极大的减轻了前端工作人员的工作量</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，</strong>前后端分离开发，前端可以通过easy-mock来伪造接口数据进行测试，后端人员可以通过postman进行接口测试，开发效率大大提升。</p>","blogGoods":0,"blogId":"1247867141693128704","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dG6CAI6ipAACiM2P5LtI65.jpeg","blogRead":7,"blogRemark":"前后端分离开发的优势所在","blogTitle":"闲谈前后端分离开发","createdTime":"2020-04-08 12:41:25","typeName":"随笔","updateTime":"2020-04-20 11:48:53"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，数据库设计--表的命名规范等</strong></p>\n<p>（1），统一采用bl_开头对表进行命名</p>\n<p>（2），对于数据比较重要的表统一添加四个字段，分别为：created_time(创建时间),update_time(修改时间),version(版本号),deleted(删除字段)</p>\n<p>（3），数据库表的字段尽量都设置为NOT_NULL</p>\n<p>（4），数据库中表varchar类型字段需要设置长度的尽量设置为2<sup>n</sup>-1</p>\n<p>（5），因为博客系统分为前台展示界面和后台管理，所以对于有些表，例如bl_type（博客类型表），bl_music（音乐表）等设置了enable（启用字段）</p>\n<p><strong>二，上述第二条--四个字段的解释</strong></p>\n<p>（1），为什么要设置created_time和update_time字段：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;其一，从数据库的通用性上来说，设计这两个字段是必要的，但也需要根据业务的需要来合理添加这两个字段，因为无用的字段会浪费空间，性能，影响系统的运行。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 其二，大部分的应用都有需要根据时间进行排序的功能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 其三，当系统发生异常的时候，我们可以通过这两个字段对异常进行排查和定位。</p>\n<p>（2），为什么要设置version字段：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 1，version字段含义：字段的含义与其字面意思一样，代表版本，在这里作为乐观锁进行使用，从而保证不会出现脏数据的情况。下面解释一下什么叫乐观锁，以及乐观锁和悲观锁</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 2，乐观锁：总是假定最好的情况，即每次用户调用接口从数据库中取出数据到修改数据前的过程中，不会有其它用户对当前数据进行修改，这样在当前用户修改数据的时候，利用版本机制即判断取出的version字段和当前数据库该条数据的version字段是否相等来判断该条数据是否已经被修改，如果未修改，则予以修改（且version字段递增），如果已经修改，则提示用户更新失败。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 悲观锁：总是假定最坏的情况，即每次用户调用接口从数据库取出数据的时候，都认为该条数据会被修改，因此每次取出数据都对数据进行加锁处理，只允许当前用户进行修改，其它用户阻塞，直到当前用户修改完毕。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3，为什么使用乐观锁而不使用悲观锁：因为悲观锁比较浪费性能</p>\n<p>（3），为什么设置deleted字段：deleted字段在这里作为一个逻辑删除字段（0否1是），何为逻辑删除，即执行删除操作操作的时候，不会真正的删除数据库中的数据，而是将deleted字段设置为1即可。&nbsp;这样如果用户出现误删的操作，可以通过数据库修改该字段进行数据的恢复。</p>\n<p><strong>三，上述第三条--数据库表字段尽量设置为NOT_NULL</strong></p>\n<p>（1），数据库表字段尽量设置为NOT_NULL：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 1，有些人可能认为设置为NULL相比于NOT_NULL不是更节省空间吗？但是实际上不是这样的，设计为NULL相比于NOT_NULL要多占用一个字节的空间</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 2，设计为NOT_NULL，这样在做查询的时候能够更好的避免空指针异常，且发生该类错误的时候能够更好的进行排查</p>\n<p><strong>四，上述第四条--表varchar类型字段长度尽量设置为2<sup>n</sup>-1</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>因为计算机只识别二进制，且有一定的范围，例如2<sup>8</sup>，在计算机中的范围为-128~127,因此对于varchar字段长度来说，如果设置为255，则正好是一个字节，而如果设置为256，则占用两个字节，这样会浪费计算机的内存空间，因此数据库varchar类型字段的长度最好设置为2<sup>n</sup>-1</p>\n<p><strong>五，上述第五条--对于设置enable字段的解释</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>enable字段，字面意思启用，在这里表明是否启用（0否1是），因为系统分为前台博客页面和后台管理，对于这两个不同的前端项目，后台可以通过启用字段来控制内容在前台博客页面的展示与否，与deleted字段不同的是，如果执行删除操作，那么我们只能通过手动修改数据库中的字段进行数据的恢复，且如果执行删除操作，则该数据在前台博客页面和后台管理页面都无法看见。但是如果将数据弃用（即修改enable字段值为1），则表明该数据被弃用，在前台博客页面无法显示，但是在后台管理页面可以看见，且无需通过手动修改数据库来恢复数据，可以在后台管理页面操作启用数据。</p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1247745014683947008","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dDViAcnjvAACb6PL1tzA485.jpg","blogRead":21,"blogRemark":"博客开发总结（一）-----之数据库设计篇","blogTitle":"博客开发总结（一）-----之数据库设计篇","createdTime":"2020-04-08 04:36:07","typeName":"博客开发和维护总结","updateTime":"2020-04-20 10:47:54"}],"pageSize":15,"params":{},"sortColumn":"created_time","sortMethod":"DESC","totalCount":53,"totalPage":4},"msg":"操作成功!"}
2020-04-26 22:24:43.827 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/list
2020-04-26 22:24:43.828 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 22:24:43.828 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 22:24:43.828 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogList
2020-04-26 22:24:43.829 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=5, pageSize=15, totalPage=4, totalCount=53, list=[BlogVo(blogId=1249588251598041088, blogTitle=redis基础（一）, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6caUuADBI7AAAb07iHSRw500.jpg, blogContent=<h2><strong>一，redis简介</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>redis是NoSQL型系统之一，与之相似的还有Memcache，用来存储key-value这种键值型数据。相比于Memcache而言，redis不仅可以做临时缓存，还可以做数据持久化，将数据定时的存入硬盘或者将命令追加到日志文件当中。而Memcache只能做临时缓存，因而现在基本上已经被redis完全取代。redis的读写速度非常快，官方给出的数据是读110000次/s，写81000次/s；而且redis支持多种数据类型，例如String，list，hash，set，zset；redis支持主从复制（集群），进行数据持久化；还支持过期时间，事务等。</p>
<h2><strong>二，redis的安装与启动（docker环境下）</strong></h2>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;docker安装完毕后，安装redis：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第一步：拉取redis镜像，docker&nbsp; pull&nbsp; redis</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第二步：启动redis，docker&nbsp; &nbsp;run&nbsp; &nbsp;redis&nbsp; &nbsp;</p>
<p><strong>三，基本知识串讲</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>单进程单线程：redis只有一个进程，且内部为单线程，这样做的优势是不存在线程安全问题，且不需要进行线程间的切换，提高了性能，而且多线程可能会涉及到锁。劣势是无法发挥多核cpu的优势，不过可以通过开启搭建多个redis实例实现</p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>redis中默认有16个数据库（0-15），可以通过select n来进行数据库之间的切换</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;常用的基本命令：flushDB（清空当前数据库），flushAll（清空所有数据库），dbSize（查看有多少数据库）</p>
<h2><strong>四，redis基本数据类型</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;string：</strong>字符串类型，数据库中存储Map&lt;String,String&gt;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>list：</strong>列表数组类型，数据库中存储Map&lt;String,List&lt;Object&gt;&gt;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>hash：</strong>哈希类型，数据库中存储Map&lt;String,Map&lt;Object,Object&gt;&gt;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>set：</strong>集合类型，其中元素无序，数据库中存储Map&lt;String,Set&lt;Object,Object&gt;&gt;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>Zset：</strong>有序集合类型，每个元素都有一个可用于排序的权重</p>
<h2><strong>五，redis相关命令（这里详解一些常用的命令，不常用的一笔带过）</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;string：</strong>(1)set&nbsp; key&nbsp; value,插入一条数据&nbsp; （2）mset&nbsp; key value...批量插入 （3）setnx&nbsp; key value&nbsp; 若无则插入（4）get&nbsp; key&nbsp; 获取某条数据&nbsp; （5）mget keys 批量获取&nbsp; （6）getrange key&nbsp; 0 -1获取数据库全部数据&nbsp; （7）incr age 递增&nbsp; (8) incrby&nbsp; age&nbsp; 10&nbsp; 递增 age 步长为10（9）decr&nbsp; age&nbsp; 递减&nbsp; （10）decrby&nbsp; age&nbsp; 10 步长递减&nbsp; &nbsp;（11）del&nbsp; key&nbsp; 删除某条数据&nbsp; <span style="background-color: #ffff00;">（12）exists&nbsp; key&nbsp; 判断是否存在某个key&nbsp; &nbsp;(13)expire&nbsp; key&nbsp; 10&nbsp; 设置过期时间（单位为秒）&nbsp; （14）pexpire&nbsp; key&nbsp; 1000 设置过期时间，单位为毫秒&nbsp; （15）persist key删除过期时间 （</span><span style="background-color: #ffff00;">16）ttl&nbsp; key&nbsp; 查看过期时间</span></p>
<p><span style="background-color: #ffff00;">&nbsp;<span style="background-color: #ffffff;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>list：&nbsp;&nbsp;</strong>（1）lpush&nbsp; key&nbsp; value 左插入一条数据&nbsp; &nbsp;（2）lpush mylist&nbsp; key&nbsp; value....批量左插入&nbsp; （3）rpush&nbsp; key value 右插入一条数据&nbsp; (4)rpush&nbsp; mylist&nbsp; key value...右批量插入&nbsp; （5）lrange&nbsp; mylist&nbsp; 0&nbsp; -1&nbsp; 取出数据集合&nbsp; （6）lpop mylist 左弹出集合中第一条数据&nbsp; （7）rpop&nbsp; </span></span><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">mylist&nbsp; 右弹出集合中第一条数据&nbsp; （8）llen&nbsp; mylist&nbsp; 获取数据集合长度lrem&nbsp; mylist&nbsp; count&nbsp; value&nbsp; （count&gt;0,从表头开始搜索，移除count个与值与value相等的元素；count&lt;0,表尾开始；count=0，移除所有值与value相等的元素） （9）linsert mylist&nbsp; before/after&nbsp; a&nbsp; 在a元素前或后插入。</span></span><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">(10) lpoplpush&nbsp; list&nbsp; list1 转移列表的元素到另一个列表</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>hash：</strong>（1）hset&nbsp; key&nbsp; &nbsp;val-key&nbsp; val-val&nbsp; 插入一条数据&nbsp; （2）hset&nbsp; myhash&nbsp; name&nbsp; xxx&nbsp; 用于给哈希表中的字段赋值，不存在则创建哈希表赋值，存在则覆盖旧值&nbsp; (3) hget&nbsp; &nbsp;myhash&nbsp; name&nbsp; 取哈希表中某个值&nbsp; （4）hmset&nbsp; myhash name&nbsp; xxx age xxx&nbsp; 批量插入字段&nbsp; （5）hmget</span></span><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">批量获取 （6）hgetall&nbsp; myhash&nbsp; 获取哈希表中所有值&nbsp; (7)&nbsp; hexisets myhash&nbsp; name&nbsp; 判断哈希表中是否存在name字段&nbsp; （8）hsetnx&nbsp; myhash score 100 若存在则不插入，若不存在则插入数据&nbsp; （9）hincrby&nbsp; myhash id 1/hdecrby&nbsp; myhash id&nbsp; 10 递增递减 （10）hdel&nbsp; myhash name&nbsp; </span></span><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">删除&nbsp; （11）hkeys&nbsp; myhash&nbsp; 只取key值&nbsp; （12）hvals&nbsp; myhash&nbsp; 只取value值&nbsp; （13）hlen&nbsp; myhash 获取哈希表长度</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>set：</strong>（1）sadd myset&nbsp; redis&nbsp; 添加一条数据&nbsp; （2）smembers myset&nbsp; 获取数据集合&nbsp; （3）srem&nbsp; myset&nbsp; set1&nbsp; 删除set1&nbsp; （4）sismember myset&nbsp; set1 判断set中是否存在set1&nbsp; (5)srandmember&nbsp; key count&nbsp; 随机获取count个元素（6）spop&nbsp; 从集合中弹出一个元素</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>zset：</strong>之后补充</span></span></p>
<h2><strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">六，redis配置文件（常见配置）</span></span></strong></h2>
<p><strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;daemonize no：</span></span></strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">redis默认不是以守护进程的方式运行的，可以更改为yes启用守护进程（即后台运行）</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>pidfile&nbsp; /var/run/redis.pid&nbsp; :</strong>启用守护进程后，默认将pid写入/var/run/redis.pid文件，可以更改</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>port&nbsp; 6379 ：</strong>redis默认端口</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp; &nbsp; &nbsp; &nbsp; <strong>bind&nbsp; 127.0.0.1：</strong>绑定的主机地址</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;"> &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>timeout&nbsp; 300</strong><strong>：</strong>redis客户端闲置多长时间后关闭连接，改为0的话，表示关闭该功能</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>loglevel&nbsp; verbose：</strong>默认日志级别（还有debug，notice，warning）</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>database 16：</strong>redis默认有16个数据库可以修改</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>save&nbsp; 900&nbsp; 1/save&nbsp; 300&nbsp; 10/save&nbsp; 60&nbsp; 10000：&nbsp;</strong>表示一定时间内有多少条数据发生修改，就将其同步到数据文件一次，例如第一个表示15分钟内有一条数据发生改变就同步</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>rdbcompression yes&nbsp; ：</strong>表示数据存储到本地数据库时是否进行压缩</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>dbfilename&nbsp; dump.rdb：</strong>指定本地数据库文件名</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>dir&nbsp; /...../redis安装目录/bin ：</strong>本地数据库存放目录，默认在redis安装目录的bin目录下</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>slaveof&nbsp; &nbsp;masterip&nbsp; masterport ：</strong>设置当本机为从机时，它的主机的ip和端口</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>masterauth&nbsp; &lt;master-password&gt;：</strong>当master服务设置了密码时，slav服务连接master的密码</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>requirepass&nbsp; foobared：</strong>默认关闭redis连接需要密码，当给redis设置了密码，就需要打开</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>maxclients&nbsp; &nbsp;128：</strong>redis同一时间最大连接客户端的数量</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>appendonly&nbsp; &nbsp;no：</strong>是否开启aof持久化，默认不开启，采用rdb</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>appendfilename&nbsp; appendonlu.aof：</strong>指定aof持久化的文件名</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>appendfsync&nbsp; everysec :</strong>指定更新日志条件，默认每秒更新一次（还有no，指等操作系统进行数据缓存到磁盘，快；always指每次更新操作后都手动写入磁盘，慢但安全）</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;虚拟机方面的配置暂不说明</span></span></p>
<h2><strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">七，redis持久化</span></span></strong></h2>
<p><strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;概述：</span></span></strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">redis持久化主要有两种方式，即rdb和aof</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>rdb：</strong>适用于大数据集的恢复，数据的备份，但是因为设置周期时间进行数据的快照，所以如果redis宕机，可能会丢失最后一个写操作的数据，因为数据完整性较差。数据保存在dump.db文件中，只需要移动到redis安装目录，重启即可恢复数据</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>aof：</strong>适用于对数据的完整性要求较高的情况，因为可以设置不同的持久化策略，例如每秒保存一次，这样即时redis宕机，也只会丢失最后一秒的数据。但是因为其日志文件存储的是写入命令，因而其文件大小要大于rdb的数据文件，且每次重启，都要从头执行数据文件中的命令，因而恢复速度也</span></span><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">要慢于rdb。</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>注意：</strong>当rdb和aof同时开启的时候，redis重启，默认会采用aof的形式进行数据的重新构建</span></span></p>
<h2><strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">八，redis事务</span></span></strong></h2>
<p><strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;概述：</span></span></strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">什么是事务？事务即是一系列的命令要买全部执行，要么全部回滚</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <strong>常用命令：</strong>multi(启动事务)，discard（取消事务）,exec（执行事务块内命令）,watch key(监控某个key的变化)，unwatch（取消对所有key的监控）</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>注意：</strong>redis的事务中在命令本身出错的情况下会造成命令的全部回滚，但是在命令无错，执行某个命令的时候发生异常的时候，则谁的错，谁停止（这一点和mysql是不同的）</span></span></p>
<h2><strong>九，redis的主从复制</strong></h2>
<p><strong>&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>redis的主从复制，即主机数据更新后根据我们设置的策略将数据同步到从机上，主机以写为主，从机以读为主<strong>。</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 使用：</strong>配主不配从，在从机中使用slaveof&nbsp; 主机ip&nbsp; &nbsp;主机端口配置从机，但是这种配置方式当redis重启之后就会失效，如果想要redis重启仍然可用，则需要配置redis.conf配置文件中的slaveof&nbsp; masterip&nbsp; masterport。这种配置方式的问题所在，中心化只有一台极其支持写操作，如果主机宕机，则从机等待，且从机宕机重启后不会跟上大部队（即重启后变为主机）。当然我们可以采用命令slave&nbsp; no&nbsp; one 使从机反客为主，成为主机。但是这种手动操作太过麻烦。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>哨兵模式：</strong>即配置之后，如果主机宕机，则哨兵会自动根据投票规则在从机中进行选举，从而产生新的主机顶替。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>主从复制的缺点：</strong>因为所有的写操作都是子主机上进行，从而在同步到从机上，所以存在着一定的延迟，当系统繁忙或者从机数量较多的时候，这种问题就更加明显。</p>
<h2><strong>十，redis集群</strong></h2>
<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;概述：</strong>集群是一种去中心化的模式，与中心化模式不同的是，中心化模式中如果主服务挂掉了，那么服务就挂掉了。但是集群模式下，没有主路由，每个节点自身都可以成为路由</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;redis集群：即配置多台主机，多台从机，不同的主机中有不同的槽点，当执行数据写入时，会根据crc16算法计算出数据的槽点，从而将数据存入到对应的主机中，并同步到与其对应的从机中</p>
<p>&nbsp;</p>
<h1>水平有限，如有错误，还望指出！</h1>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong></p>, blogGoods=0, blogRead=4, blogCollection=0, typeName=redis, blogRemark=redis基础（一）, blogComment=0, blogSource=null, createdTime=2020-04-13 06:40:30, blogMonth=null, updateTime=2020-04-20 16:47:37), BlogVo(blogId=1249313090567143424, blogTitle=面试（三）------之并发编程篇（上）, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dHM2AQOeZAABJTVJPTfk967.jpg, blogContent=<h2><strong>一，JAVA线程的创建方式</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>JAVA线程的创建有四种方式，分别为，继承Thread类，实现Runable接口，实现Callable&lt;Class&gt;接口，基于线程池。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>1，继承Thread方式：创建一个类继承Thread类，创建类的实例对象，调用start方法，继而执行线程的run（）方法，代码如下：</strong></p>
<pre class="language-java"><code>public class NewThread extends Thread{
    public static void main(String[] args) {
        NewThread thread = new NewThread();
        thread.start();
    }
    @Override
    public void run(){
        System.out.println("create  a  new thread by Thread!");
    }
}</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>2，当子类已经继承了一个类，这时候就没法再继承Thread类了，这时候就可以实现Runable接口，实例化类的线程实例，创建Thread实例传入类的实例，执行start方法，继而执行run（）方法代码如下：</strong></p>
<p>&nbsp;</p>
<pre class="language-java"><code>public class ThreadExample2 implements Runnable {
    public static void main(String[] args) {
        ThreadExample2 threadExample2 = new ThreadExample2();
        Thread thread = new Thread(threadExample2);
        thread.start();
    }
    @Override
    public void run() {
        System.out.println("create a new thread by Runnable!");
    }
}</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，有些情况下，我们需要再一个主线程中并发多个子线程执行同一个任务，然后回收子线程的返回值整理汇总，这时候就需要实现Callable&lt;Class&gt;接口，重写其call（）方法，用于计算结果。然床创建一个线程池用于提交线程，继而执行call方法，并且创建一个Future的list用于接收子线程逻辑代码即call方法的返回，最终遍历list，得到想要的返回值，如下：</strong></p>
<pre class="language-java"><code>public class ThreadExample3 implements Callable&lt;String&gt; {

    private String name;

    public ThreadExample3(String name){
        this.name = name;
    }

    @Override
    public String call() throws Exception {
        return name;
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService pool = Executors.newFixedThreadPool(3);
        List&lt;Future&gt; list = new ArrayList&lt;&gt;();
        for(int i=0;i&lt;3;i++){
            ThreadExample3 threadExample3 = new ThreadExample3(i+"");
            Future future =pool.submit(threadExample3);
            System.out.println(future.get().toString()+" is running");
            list.add(future);
        }
        pool.shutdown();
        for (Future future : list) {
            System.out.println("currentThread's result is "+future.get().toString());
        }
    }
}</code></pre>
<p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，基于线程池创建线程</strong></p>
<pre class="language-java"><code>public class ThreadExample4 {
    public static void main(String[] args){
        ExecutorService pool = Executors.newFixedThreadPool(3);
        for(int i=0;i&lt;3;i++){
            pool.execute(new Runnable() {
                @Override
                public void run() {
                    System.out.println("thread  is running by FixedThreadPool");
                }
            });
        }
        pool.shutdown();
    }
}</code></pre>
<h2>二，线程池的工作原理</h2>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong> &nbsp;1，概述：</strong>JVM根据用户提供的参数创建一定数量的线程任务，将其放入队列中，线程创建之后启动这些任务，如果线程的数量大于核心线程数量（用户设置的线程数量），则超出数量的线程排在队列中等待，当有线程任务执行完毕后，线程池调度器就会发现有可用可用线程，继而从队列中取出任务继续执行<strong>。</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; </strong><strong>2，线程复用：</strong>（参见JDK源码解读，这里只做简单描述），由前可知，JVM会根据用户提供的参数创建一定数量的线程任务，且将其添加到任务队列中。JVM通过start（）方法创建一个线程之后， 会相应的为其创建一个任务队列，线程会不停的查看任务队列，如果任务队列中有任务，则调用run方法，执行，这样就达到了一次start（）创建线程，多次使用，完成线程复用的任务。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>3，线程池的核心组件和核心类（见JDK源码分类中关于线程的总结）</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; </strong><strong>4，JAVA线程的工作流程：</strong>线程池刚被创建的时候，只是向系统申请一个执行线程队列和管理线程池的线程资源，当调用execute方法之后，执行下列流程：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果正在运行的线程数量小于corePoolSize（核心线程数量，即用户定义的的线程数量），则立即创建线程执行线程任务</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果正在运行的线程数量大于或等于corePoolSize，则将超过数量的线程加入到阻塞队列中</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在阻塞队列已满且线程数量小于MaximumPoolSize（即线程池能够容纳的最大线程数），线程池会创建非核心线程立即执行任务</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在阻塞队列已满且线程数量大于或等于MaximumPoolSize的时候，线程池会拒绝该线程任务且抛出异常</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在线程任务执行完毕之后，会将其从任务队列中移除，从队列中取出下一个线程任务执行</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在线程处于空闲状态且空闲时间超过KeepAliveTime，且线程数量大于corePoolSize的时候，会停止该线程，这样在没有任务的时候，线程池中的线程数始终维持在corePoolSize。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，线程池的拒绝策略：</strong>分为四种，分别为AbortPolicy，CallerRunsPolicy，DiscardOldestPolicy，DiscardPolicy</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; AbortPolicy：直接抛出异常，阻止线程运行，源码如下：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</p>
<pre class="language-java"><code>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
            throw new RejectedExecutionException("Task " + r.toString() +
                                                 " rejected from " +
                                                 e.toString());
        }</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CallerRunsPolicy：如果线程任务没有关闭，则尝试执行该线程任务，源码如下：</p>
<pre class="language-java"><code>* @param r the runnable task requested to be executed
* @param e the executor attempting to execute this task
*/
public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
     if (!e.isShutdown()) {
         r.run()
     }
}</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DiscardOldestPolicy：移除任务队列中最早进入的线程任务，执行当前任务线程，源码如下：</p>
<pre class="language-java"><code>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
       if (!e.isShutdown()) {
           e.getQueue().poll();
           e.execute(r);
       }
}</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DiscardPolicy：直接丢弃线程任务，不做任何处理</p>
<h2><strong>三，五种常用的线程池</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;newCachedThreadPool（可缓存线程池）：</strong>当线程池创建线程的时候如果发现有可复用的线程（执行完任务，且未关闭的线程），则直接复用，如果没有则创建新线程。可缓存线程池可以高效的利用执行任务时间短的线程，提高系统的性能，且线程池中的线程如果空闲时间超过60s，则会被终止且从缓存中移除，这样可缓存线程池不会占用系统资源。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>newFixedThreadPool（固定大小的线程池）：</strong>即线程池中的线程是初始化固定的，当任务线程大于线程池中线程数量时，任务线程就会进入阻塞队列等待。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newScheduledThreadPool（可做任务调度的线程池）：</strong>即可以设置线程执行的停顿时间和执行周期，进行定期定时的执行某个任务。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newSingleThreadPool（单个线程的线程池）:&nbsp;</strong>即线程池中永远只有一个线程进行工作，如果下称停止或者异常，则线程池创建新的线程替代当前线程</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newWorkStealingPool（足够大小的线程池）：</strong>即创建足够数量的线程的线程池，保证更快的进行运算，提高效率。</p>
<h2><strong>四，线程的生命周期</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;线程的生命周期大致分为五个阶段：新建（new），就绪（Runnable），运行（Running），阻塞（Blocked），死亡（Dead）</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;新建：</strong>即使用new创建一个线程</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>就绪：</strong>调用start方法，</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>运行：</strong>即线程获取cpu资源，执行run（）方法，进入运行状态，运行状态的线程如果调用yield（线程让步方法）或者失去cpu资源，都会导致线程重新回到就绪态；如果调用sleep方法，I/O阻塞，等待同步锁，等待通知以及suspend挂起都会导致线程进入阻塞态。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞：</strong>即线程被放入Blocked池。阻塞状态的线程如果结束了sleep方法，I/O方法返回，获取同步锁，收到通知或者resume都会导致其重新进入就绪态，与其它线程竞争cpu时间片。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>死亡：</strong>线程正常执行完run（）或者call（）方法，或者执行stop方法，或者发生异常或者错误都会导致线程死亡。（stop方法会导致锁混乱和死锁，不建议使用）</p>
<h2><strong>五，线程的基本方法</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;wait（线程等待）：</strong>会让线程进入WAITING状态，并且会释放对象的锁。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>sleep（线程睡眠）：</strong>会让线程进入睡眠，进入TIMED_WAITING状态，但是不会释放对象锁，睡眠时间到了之后，再次恢复运行状态</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>yield（线程让步）:</strong>&nbsp; 当前线程会让出其占有的cpu资源，重新回到就绪态和其它线程竞争cpu时间片</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>interrupt（线程中断）:&nbsp; </strong>中断当前线程，但是并不会导致其停止，只是改变其内部的终端标识位，在使用了thread.sleep()之后使用该方法，会导致抛出异常，且我们可以利用中断标识位进行线程的安全退出</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>join（线程加入）：</strong>即将当前线程进入阻塞态，等待下一个线程执行完毕后进入就绪态，重新竞争锁资源。通常用于主线程下面执行子线程，需要主线程阻塞，等待子线程执行完毕后返回其结果给主线程，主线程再执行的情况。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>notify（线程唤醒）/notifyAll：</strong>前者随机唤醒一个等待线程，后者全部唤醒</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>setDaemon（守护线程）:</strong>级别较低的线程，用于后台运行，服务用户用户线程，例如垃圾收集线程就是典型的守护线程。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>sleep方法和wait方法的区别：</strong>前者属于Thread，后者属于Object，前者不会释放锁资源，后者会释放锁资源</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>start方法和run方法：</strong>start方法只是创建一个线程，并没有运行，run方法时执行线程的真正代码逻辑。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>线程退出的方式：</strong>见四中最后一条</p>
<h2><strong>六，JAVA中的锁（知识比较杂乱）</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述:JAVA中的锁是为了保护数据的一致性。按照不同的标准可分为乐观锁和悲观锁，公平锁和非公平锁，共享锁和独占锁，偏向锁，轻量级锁，重量级锁，自旋锁，可重入锁。</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;乐观锁：</strong>即认为每次读取数据都不会被修改，当修改操作的时候再判断当前数据是否被修改，未修改则修改，若已被修改，则返回失败状态。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>悲观锁：</strong>即认为每次读取数据都会被修改，因而每次读取数据都对其进行加锁，这样只有当前用户可以修改，其它用户阻塞等待直到当前用户修改完毕释放锁资源。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>自旋锁：</strong>即有些线程任务的执行很短，很快就可以释放锁资源，为了避免在这种情况下竞争线程仍然进行内核态和用户态之间的转换，因而让线程自旋（即等一会），如果有可用锁，则获取，减少了线程在用户态和内核态之间切换的时间损耗。提高了性能（优势）。当然线程自旋是占用cpu资源的，因而需要设置一个自旋的最大等待时间，如果超过此时间，则线程退出自旋模式。对于线程竞争锁资源激烈的情况，自旋有可能会导致cpu资源的损耗（劣势）。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>公平锁和非公平锁：</strong>即根据线程竞争锁资源的机制判定，一般如果依据先到先得的原则，则位公平锁；如果依据就近原则，则位非公平锁。公平锁相比于非公平锁会更加耗费性能，因为要维护一个线程任务丢列，根据线程任务在队列中的顺序分配锁资源，因而不常用。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>可重入锁：</strong>又被称为递归锁，即该锁可以然后线程对其进行多次的加锁操作。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>偏向锁：</strong>当线程获取到锁的时候，用来消除线程的锁重入的开销（看起来是偏袒这个线程）。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>共享锁和独占锁：</strong>共享锁即多线程共享锁资源（典型例子，读锁）；独占锁即当前锁只能有一个线程获取，其它线程阻塞</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>轻量级锁：</strong>没有多线程竞争的前提下，减少重量级锁的使用提高性能。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>重量级锁：</strong>基于操作系统的互斥量而实现的锁，会导致进程在用户态和内核态之间切换，耗费性能。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>synchronized：独占式悲观锁，可重入锁，非公平锁，重量级锁。</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 作用范围：</strong>作用于成员变量和非静态方法，相当于锁住的是对象的实例，即this对象</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;作用于静态方法，相当于锁住的是class实例</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;作用域代码块，相当于锁住的代码块中的对象</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>实现原理：</strong>内部包括ContentionList（锁竞争队列），EntryList（竞争候选列表），WaitSet（等待集合），OnDeck（竞争候选者），Owner，!Owner，其中ContentionList是用来存放竞争锁资源的线程。EntryList是用来存放有资格竞争锁资源的线程。调用wait方法后放入WaitSet中，onDeck指的是同一时刻，只有一个线程竞争锁资源，Owner指的是得到锁资源的线程，!Owner指的是线程执行完毕，释放锁资源的线程。需要注意的是线程首先采用的都是自旋模式获取锁资源，如果自旋获取不到再加入ContentionList，而且Owner状态的线程并不是直接把锁资源交给onDeck状态线程，而是给它竞争锁资源的权利，因而onDeck状态的线程还需要跟自旋线程竞争锁资源。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>ReentrantLock：独占式，可重入锁，并且可以实现公平锁和非公平锁，重量级锁。</strong></p>
<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;用法：</strong>lock()加锁，后跟try代码块，finally中进行释放锁unlock()</p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;避免死锁的方法：</strong>响应中断（即可以根据情况中断对锁资源的请求），可轮询锁（tryLock（）即尝试获取锁，如果有可用锁则获取返回true，没有则返回。和lock（）的区别在于lock获取锁资源如果没有则一直等待直到获取到锁资源），定时所（tryLock（time,unit）即再一定时间内如果有可用锁，且线程未中断则获取锁，否则禁用当前线程。）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>Semaphore（信号量）:</strong>机制和ReentrantLock类似</p>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ReadWriteLock（读写锁）：</strong>如果系统要求支持多线程共享读，但不能多线程写，使用读锁；如果要求同一时刻只能有一个线程写，写的过程中不能读取该共享数据，则使用写锁。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; <strong>分段锁：</strong>一种思想，将数据分段加锁，例如ConcurrentHashMap</p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;死锁：</strong>即线程之间互相共享资源会导致死锁</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; <strong>锁优化：</strong>第一，减少锁的持有时间；第二：减小锁粒度，例如分段锁；第三：锁分离，例如读写锁；第四：锁粗化，放置锁粒度太小，造成频繁加锁释放锁；第五：锁消除，消除程序代码不规范而造成的乱用了锁</p>
<p>&nbsp;</p>
<h3><strong>并发编程（上）的思维导图送上：<a href="https://images-cdn.shimo.im/1UcHkyrlJyGRPYnn.png__thumbnail" target="_blank" rel="noopener">并发编程（上）</a></strong></h3>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>
<h1>水平有限，如果错误，还望指出！</h1>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;</p>, blogGoods=0, blogRead=8, blogCollection=0, typeName=java面试篇, blogRemark=面试（三）------之并发编程篇（上）, blogComment=0, blogSource=null, createdTime=2020-04-12 12:27:07, blogMonth=null, updateTime=2020-04-20 11:53:51), BlogVo(blogId=1248605157059497984, blogTitle=面试（二）------之JAVA基础篇, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dHMKAcvZ8AABJTVJPTfk020.jpg, blogContent=<h2><strong>一，集合</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，List：</strong>list是java中一种有序的集合，下有三个实现类，分别为ArrayList，Vector，LinkedList</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ArrayList：基于数组实现，增删慢，查询快，线程不安全。因为其基于数组实现，所以查询的时候可以直接根据数组的索引下标进行快速查询，但是进行增删操作的时候，需要将待增删元素后的元素全部移动，因而效率较低。且ArrayList创建时不需要分配初始大小，其空间不够的时候，会自动创建一个更大的list，然后复制数据。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Vector：基于数组实现，和ArrayList一样增删慢，查询快。但是线程安全，因为同一时间只支持一个线程对Vector进行写操作，然而因为要进行频繁的加锁和释放锁的操作，所以效率要低于ArrayList。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; LinkedList：基于双向链表实现，增删快，查询慢。因为基于链表实现，增删元素的时候，只需要改变元素的指针即可，改动较小，效率较高。然而进行查询操作的时候，需要从链表头部进行遍历，因而效率较低。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，Queue：</strong>队列，满足先进先出，种类较多。（不作详细解释）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，set：</strong>具有独一无二的特性，常用来存储无序且不重复的元素，对象相等的本质是hashcode的值相同，而如果想要比较两个对象是否相等，需要重写对象的hashcode方法和equals方法。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;hashset：基于hashTable实现，无序。存放的是对象的散列值，即通过hashcode计算得到的值</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;treeset：基于二叉树实现，即其中的对象按照一定的排序方式进行排列（升序，降序），每次添加对象的时候，都会进行排序，将其插入指定位置。基本的数据类型例如Integer，String等可以使用treeset默认的排序方法，而自定义数据类型需要实现compareable接口，实现compareTo方法。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;LinkHashSet：继承自hashset，只不过使用双向链表记录数据的顺序。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，map：</strong>一种键值对形式的集合</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;hashmap：基于数组+链表实现，增删改查操作快，但是每次遍历hashmap元素的顺序无法保证且线程不安全。如果想要其线程安全，可以使用synchronizedMap和ConcurrentHashmap，hashmap的内部是数组，数组中的每一个元素又是一个单向链表，链表中的每个元素嵌套一个Entry实例，其中包括Key，Value，Hash值，指向下一个节点的next。每次查询的时候，可以根据元素的hash值很快定位所在数组，但是定位之后需要遍历链表查找元素，因而时间复杂度为O（n），但是Java8之后对其进行了优化，将其改为了数组+链表或红黑树的结构，即当链表中的元素大于8个的时候，链表会转换为红黑树（红黑树是一种特化的二叉平衡树，因为其左右子树的深度差可以大于1），这样查询的时间复杂度就缩短到了O（logN）。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ConcurrentHashmap：采用分段锁的思想进行并发操作，因而使线程安全的。由多个Segment组成，只要保证每个Segment线程安全就可以保证全局线程安全。ConcurrentHashmap的默认Segment即并发度为16，可以在初始化的时候修改，但是初始化之后不能再修改。每个Segment内部的实现和hashmap一样&middot;。Java8之后也和hashmap进行了一样的优化。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;HashTable：线程安全，即同一时刻只能有一个线程对其进行操作，并发度不如ConcurrentHashmap。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;TreeMap：基于二叉树数据结构实现，实现了SortedMap，默认按照键值的升序进行排列。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;LinkedHashMap：Hashmap的子类，只不过使用链表保存元素的插入顺序。使用迭代器遍历的时候按照插入顺序遍历。</p>
<h2><strong>二，异常分类及处理</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;1，异常分类：</strong>Throwable是所有异常类的父类，其下有error和Exception，Error下有AwtError，ThreadDeath；Exception下有RuntimeException和CheckedException。</p>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</strong>对于Error类异常通常是由内部错误和资源耗尽造成的，无法在程序运行期间对其进行捕获和处理，对于这类错误我们只能记录错误的原因和终止程序。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; Exception中的RuntimeException异常（运行时异常）：这类异常是我们程序中异常处理的核心，可以在程序中进行捕获并处理。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Exception中的CheckedException异常（检查异常）：这类异常时程序中需要强制捕获的异常，通常有IO异常，SQL异常等等。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，异常处理：</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>异常处理有两种方式：抛出异常和捕获异常</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;抛出异常有三种方法：throws，throw，系统自动抛出。其中throws是作用在方法上，后面跟的是可能产生的异常类。throw是作用在方法内部，后面跟的是具体的异常对象。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 捕获异常：即使用try{}catch语句进行捕获</p>
<h2><strong>三，反射机制</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，什么叫做反射机制？</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>即在程序运行的过程中，可以获取类的属性和方法，并且可以调用任意一个类的方法。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，反射机制的使用</strong></p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 首先，获取类的class对象，有三种方式，className.getClass()，类对象.class，Class.forName("类路径")，其中最后一种最为安全，性能最好。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 然后利用反射的API可以实现对类中信息的操作，例如getDeclareFields（），getDeclareMethods（），getConstroctors（）等等。反射创建类的对像有两种方法，一，class.newInstance()初始化一个类实例；二，先获取其构造器，然后利用构造器初始化一个实例。利用反射调用类的方法：先获取方法，然后调用method.invoke()执行方法。</p>
<h2><strong>四，注解</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，四种元注解：</strong>@Target（指定注解的使用范围），@Retention（定义注解的保留级别，有三级，SOURCE源程序中保存，CLASS文件中保存，RUNTIME运行时保存），@Documented（可以工具文档化），@Inherited（<span style="background-color: #ffff00;">这个没怎么看懂</span>）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，注解使用示例：</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>第一步，定义注解接口</p>
<pre class="language-java"><code>@Target(ElementType.FIELD)  
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FruitProvider {

    //id
    public int id() default  -1;

    //供应商名称
    public String name() default "";

    //供应商地址
    public String address() default "";

}</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 第二步，使用注解</p>
<pre class="language-java"><code>public class Apple {

    @FruitProvider(id = 1,name = "红富士苹果",address = "陕西")
    private String appleProvider;

    public String getAppleProvider() {
        return appleProvider;
    }

    public void setAppleProvider(String appleProvider) {
        this.appleProvider = appleProvider;
    }
}</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第三步，定义注解处理器</p>
<pre class="language-java"><code>public class FruitInfoUtil {
    public static void getFruitInfo(Class&lt;?&gt; clazz) {
        String strFruitProvider = "供应商信息:";
        Field[] declaredFields = clazz.getDeclaredFields();
        for (int i = 0; i &lt; declaredFields.length; i++) {
            if (declaredFields[i].isAnnotationPresent(FruitProvider.class)) {
                FruitProvider annotation = declaredFields[i].getAnnotation(FruitProvider.class);
                strFruitProvider += annotation.id() + "," + annotation.name() + "," + annotation.address();
                System.out.println(strFruitProvider);
            }
        }
    }
}</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第四步，主方法入口</p>
<pre class="language-java"><code>public class FruitRun {
    public static void main(String[] args) {
        FruitInfoUtil.getFruitInfo(Apple.class);
    }
}</code></pre>
<h2><strong>五，内部类</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 1，静态内部类：</strong>即在类的内部定义的静态类，静态内部类可以访问外部了的静态变量和方法，外部也可以通过outClassName.innerClassName调用内部类</p>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2，成员内部类：</strong>在类的内部定义的没有用static修饰的内部类，使用方式和静态内部类一样。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>3，局部内部类：</strong>即一个类只在一个方法中使用，则完全可以将这个类定义为这个方法的内部类，即局部内部类，局部内部类可以实现真正的对外隐藏</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>4，匿名内部类：</strong>通常用于继承一个类或者实现一个接口的时候，使用new关键字定义，例如:Person person = new Student(){new Pupil(){}}</p>
<h2><strong>六，泛型</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 1，为什么要使用泛型：</strong>其根本目的是为了实现代码的复用，举个开发中常见的例子，我们需要定义返回类Result，返回类中包含状态码code，信息msg，以及数据data（任意类型），这个时候我们就需要使用泛型，因为我们返回的数据类型有各种vo，pojo类对象，list等。这时候泛型类result就可以被各种对象使用，实现代码的复用，简化开发。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>2，泛型标记和泛型限定：</strong>E表示集合中的元素，K表示键值，V表示value，N表示数值类型，T表示任意类型（包含基础类型，所有的对象类型），？（不确定的java类型）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>泛型限定：</strong>向上限定，&lt;?&nbsp; extends T&gt;，向下限定，&lt;? super&nbsp; T&gt;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; <strong>3，泛型方法：</strong>即参数类型定义为泛型类型，以便于接收不同类型的参数，做出不同的处理。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>4，泛型类：</strong>例如public class Pair&lt;T&gt;{private T data;}</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>5，泛型接口：</strong>与放泛型类类似</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>6，类型擦除：</strong>即在泛型编译的过程中，会将泛型类型替换为限定类型的操作</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>7，明确的一点：</strong>虚拟机在运行程序的过程中，内部是没有泛型的，只有普通的类和方法。</p>
<h2><strong>7，序列化</strong></h2>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 序列化是为了确保对象及其状态的持久化</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>序列化的使用：</strong></p>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </strong>首先，实现序列化接口java.io.Serializble</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 然后，声明序列化ID，通常private static final&nbsp; long&nbsp; serialVersionUid&nbsp; = ***</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 因为序列化是保证对象及其状态的持久化，而静态变量是不属于对象，属于类本身的，所以序列化无法保存静态变量。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果需要序列化父类变量，则父类也要实现Serializable接口</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t'ransient修饰的属性不会序列化</p>
<h3><strong>最后，提供一张思维导图供大家学习：<a href="https://images-cdn.shimo.im/es83SQH0CggucT7f__thumbnail" target="_blank" rel="noopener">JAVA基础</a></strong></h3>
<p>&nbsp;</p>
<h2>水平有限，如有错误，还望指出！</h2>, blogGoods=0, blogRead=27, blogCollection=0, typeName=java面试篇, blogRemark=面试（二）------之JAVA基础篇, blogComment=0, blogSource=null, createdTime=2020-04-10 13:34:02, blogMonth=null, updateTime=2020-04-20 11:53:39), BlogVo(blogId=1248500061625745408, blogTitle=Linux基本命令, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dDA6AfCOJAAAyfL52jxY706.jpg, blogContent=<p><strong>一，Linux的发展历史</strong></p>
<p><strong>&nbsp; &nbsp; &nbsp; </strong>1965年之前，电脑并不像现在这么普遍，除了军事机构和研究即构，一般人基本接触不到电脑，而且那时候的一台大型主机最多也就只能支持30台终端。为了解决数量问题，1965年之后，由贝尔实验室，麻省理工学院以及通用电气一起放弃了Multics项目，准备让大型主机能够支持300台终端，但是在开发过程中，进度缓慢，最终由于资金的短缺，贝尔实验室推出了研究。1969年，从这个项目中退出的Ken Thompson在家无聊，为了让电脑能够运行&ldquo;星际旅行&rdquo;游戏，因而趁着妻子回家探亲的一个月，独自写出了Unix操作系统的原型（！！！！牛批）。1970年，这个人以BCPL语言为基础，又写出了很接近硬件的B语言，并且用B语言写出了第一个Unix操作系统。但是由于B语言的跨平台性比较差，为了解决这个问题。Dennis Ritchie和Ken Thompson决定以B语言为基础开发一种新的语言，1972年，Dennis Ritchie最终设计出了一种新语言，他以BCPL的第二个字母命名，也就是我们后来熟知的C语言。随后两人便迫不及待的用C语言重现Unix操作系统。Unix系统起初开源，但是在Unix7之后，由于政策的变化，代码闭源化，因而大学中不能使用Unix的源代码进行教学。Andrew S. Tanenbaum教授为了能够让学生更好的理解代码细节，在完全不使用任何源代码的情况下开发除了Minix---小型Unix。但是因为其只用于教学，功能并不强大，因而Torvalds以此为基础，开发除了Linux，但是起初Linux并不支持Unix，最终经过全世界网友的帮助，最终让其能够兼容各种硬件。</p>
<p><strong>二，文件和目录</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp; 1，windows和linux的区别：</strong>我们熟知的windows系统，它的文件系统是分盘符的，盘符下的文件构成一个树形结构，但是Linux文件系统没有盘符，所有文件目录都在根目录/之下</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;<strong>2，Linux需要记住的目录：</strong>/bin（存放系统命令的目录），/sbin（只有超级管理员能访问的命令文件目录），/root（存放和root用户相关文件的目录），/etc（存放系统配置文件的目录），/usr（存放系统共享资源的目录），/opt（存放安装的第三方软件的目录，通常在/usr/local下）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;<strong>3，文件权限：</strong>Linux中的文件权限有读（r，可用于数字4表示），写操作（w，可用数字2表示），执行权限（x，可用数字1表示）</p>
<p><strong>三，常用命令</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，ls：</strong>列出目录中的所有目录和文件名&nbsp; -a（列出所有，包括隐藏文件和目录），-l（以列表形式列出所有），-h（人性化列出，需要配合-l使用，即文件大小转换为我们熟知的kb，mb等），-d（显示当前目录属性），命令可以联合使用，例如-al，-lh等等。&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，cd：</strong>用于切换目录，需知（.和..是相对路径，.表示当前目录，..表示上级目录；/表示绝对路径），cd ~（切换到root目录），cd - （切换到前一次切换的目录）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，clear：</strong>清屏</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，pwd：</strong>显示当前所在目录</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，mkdir：</strong>创建目录，-p（如果目录存在则不创建，如果不存在则创建目录再创建自目录），可以一次性创建多级目录，例如：mkdir&nbsp; -p test/test1</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，touch：</strong>创建空文件</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>7，cp：</strong>复制，-r（递归复制目录下的文件目录信息），-i(提示是否覆盖)，-v（显示复制进度）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>8，mv：</strong>移动文件，不过经常用来给文件进行重命名</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>9，rm：</strong>删除目录或者文件，-r（递归删除），-f（强制删除），-v（显示删除进度）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>10，cat：</strong>查看文件内部信息</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>11，ln：</strong>文件创建链接，ln 源文件 目标链接文件（创建硬链接，硬链接和源文件大小相同，修改同步，但是删除不同步，使用较少），ln -s（创建软连接，相当于我们平时创建快捷方式，使用较多）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>12，which：</strong>搜索命令所在位置，例如：which&nbsp; &nbsp;ls</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>13，find：</strong>搜索文件所在位置&nbsp; 例如：find&nbsp; &nbsp;test.conf</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>14，grep：</strong>文件内容搜索，例如：grep &ldquo;想要搜索的内容&rdquo;&nbsp; 源文件</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>15，tar：</strong>归档命令，-c（打包成.tar文件），-z（打包的同时压缩），-v（打包的同时显示进度），-f（放在最后，后面跟.tar.gz），-x(解压)，常用：tar -zcvf&nbsp; <em><strong>.tar.gz&nbsp; &nbsp; ;&nbsp; &nbsp; tar -zxvf</strong> tar.gz</em> -C&nbsp; 指定解压目录&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;还有more，head，tail等命令，不过这些不常用。</p>
<p><strong>四，用户权限命令</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，whoami：</strong>查看当前账户的用户名</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，who：</strong>查看当前登录用户</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，exit：</strong>退出登录</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，adduser/useradd：</strong>添加用户，-d（指定用户主目录），-g（指定用户用户组），-m（自动建立目录），默认情况下用户主目录和用户组名都和用户名一样</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，passwd：</strong>只有root用户才能使用，用于修改用户密码</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，userdel：</strong>删除用户，默认不删除用户的主目录，-r（删除用户主目录）</p>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;7，su：</strong>切换账户</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>8，groupadd/groupdel：</strong>添加用户组和删除用户组</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>9，groups：</strong>查看用户所在用户组，例如：groups&nbsp; 用户名</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>10，usermod：</strong>修改用户所在用户组，例如：usermod&nbsp; 用户组名 用户名</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>11，chmod：</strong>修改文件权限，例如：chmod&nbsp; 777&nbsp; test</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>12，chown：</strong>修改文件所有者，例如：chown&nbsp; &nbsp;用户&nbsp; 文件名</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>13，chgrp：</strong>修改文件所在组，例如：chgrp&nbsp; 组名&nbsp; 文件名</p>
<p><strong>五，系统命令</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，cal：</strong>查看日历</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，date：</strong>查看时间，可以设置格式，例如：date '+<span class="ql-token hljs-built_in">%Y</span>-<span class="ql-token hljs-built_in">%m</span>-<span class="ql-token hljs-built_in">%d</span> <span class="ql-token hljs-built_in">%H</span>:<span class="ql-token hljs-built_in">%M</span>:<span class="ql-token hljs-built_in">%S</span>'</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，ps：</strong>查看线程</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，kill：</strong>杀死线程，-9（强制杀死）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，查看网卡信息：</strong>centos6：ifconfig ；centos7：ip addr</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，ping：</strong>查看网址或者链接的连通性</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>7，防火墙：</strong>centos6：service&nbsp; iptables&nbsp; status（查看防火墙状态），service&nbsp; &nbsp;iptables&nbsp; &nbsp;start(开启),service&nbsp; iptables&nbsp; stop(关闭);centos7:firewall-cmd&nbsp; --state（查看防火墙状态），systemctl&nbsp; start&nbsp; firewalld.service(启动)，systemctl&nbsp; &nbsp;stop&nbsp; firewalld.service（关闭）</p>
<p><strong>六，网络命令</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，wget：</strong>下载，例如：wget&nbsp; &nbsp;链接地址</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，yum：</strong>下载安装</p>
<p><strong>七，vim（这里只说几个常用的命令）</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;</strong>vim有三种模式：命令模式，插入模式，编辑模式&nbsp; &nbsp;</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;vim&nbsp; 文件名：进入文件，且处于命令模式；iao任意一键进入插入模式（i表示在贯标之前插入，a光标之后插入，o在下一行插入），：进入编辑模式</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;命令：set:nu显示行号，set:nonu不显示行号；/strinng，向后搜索字符串，？string向后搜索字符串；：w保存，：wq保存并退出，：q不保存退出</p>, blogGoods=0, blogRead=2, blogCollection=0, typeName=Linux, blogRemark=Linux基本命令总结, blogComment=0, blogSource=null, createdTime=2020-04-10 06:36:25, blogMonth=null, updateTime=2020-04-20 10:42:25), BlogVo(blogId=1248224512563068928, blogTitle=面试（一）------之JVM篇, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dHLeALxSjAABJTVJPTfk677.jpg, blogContent=<h2 style="text-align: left;"><strong>一，JVM运行机制</strong></h2>
<p>&nbsp;&nbsp; &nbsp; &nbsp;jvm即java虚拟机，一共由四个部分组成，分别是类加载器子系统，运行时数据区（程序计数器，本地方法区，jvm栈，方法区，jvm堆），执行引擎（即时编译器，垃圾收集器），本地接口库。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;一个java源程序的运行先是经过编译器将其编译成字节码文件（class文件），然后通过类加载器子系统将其加载进入jvm&mdash;&mdash;&gt;程序运行过程中，运行时数据区存放程序运行过程产生的数据&mdash;&mdash;&gt;执行引擎中的垃圾收集器收集程序运行过程中创建的不再使用的对象，即时编译器将程序的字节码文件编译成机器码&mdash;&mdash;&gt;然后本地接口库利用机器码调用本地方法库中的方法，和操作系统实现交互。</p>
<h2><strong>二，多线程</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;</strong>在多核操作系统中，jvm支持一个进程中同时并发执行多个线程，且这些线程和本地操作系统的线程相对应。当jvm中的对象初始化，内存空间分配等一系列准备工作完成之后，会调用操作系统中的接口创建一个原生线程，原生线程初始化完毕后，会调用java线程的run（）方法执行该线程，线程结束之后，jvm会释放原生线程和java线程资源。</p>
<h2><strong>三，JVM的内存区域</strong></h2>
<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM的内存区域主要分为线程私有区域（程序计数器，本地方法区，JVM栈），线程共享区（方法区，JVM堆）和直接内存。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;程序计数器：线程私有区域，无内存溢出，用来记录程序运行过程中的字节码指令地址，如果是Native方法，则程序计数器为空。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM栈：线程私有区域，用来描述java程序的运行过程，java程序运行每次运行的时候，都会创建一个栈帧，方法的执行和返回对应着栈帧的入栈和出栈操作。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;本地方法区：线程私有区域，和JVM栈的功能一样，只不过是用来记录Native方法的运行过程。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM堆：线程共享区，主要用来存放程序运行过程中产生的数据，同时也是垃圾收集器进行垃圾回收的主要区域。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;方法区：也被称为永久代，用来存放常量，静态变量，类信息等等。</p>
<h2><strong>四，JVM的运行时内存</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>JVM的运行时内存又被称为JVM堆，因为JVM的GC算法使用的是分代收集算法，所以JVM堆按照GC标准可以分为三个区域分别为：新生代，老年代，永久代。其中新生代占1/3，老年代占2/3，永久代很少，</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;新生代：存放短生命周期，小对象的区域。新生代又分为Eden区，ServivorTo区，ServivorFrom区，区域的GC算法采用复制算法。Eden区是用来存放新创建的对象（大对象除外），ServivorTo区是用来保存MinorGC幸存下来的对象，ServivorFrom区是用来将上一次MinorGC幸存下来的对象作为下一次MinorGC的扫描对象。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;老年代：存放长生命周期的大对象，区域的GC算法采用标记整理算法</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;永久代：主要用来存放class和meta数据信息的。程序运行过程中不会进行永久代的垃圾回收，这也就导致永久代区域的数据会越来越多，最终造成内存溢出。java8之后永久代已经被元数据区取代，元数据区和永久代的功能都是一样的，但是最大的不同在于永久代区域依赖于虚拟机的内存大小，因而可以存储的class，meta信息非常有限。但是元数据区依赖的是本地操作系统，因而不会受到虚拟机内存的限制。</p>
<h2><strong>五，垃圾回收与算法</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;(1)垃圾回收：</strong>Jvm的垃圾回收判定依赖于两种方法，引用计数法和可达性分析法。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;引用计数法：即如果想要在程序中使用对象，就必须赋予一个引用，这样在对象赋予引用的时候将其引用计数加1，删除一个引用时，将对象引用计数减1，如果引用计数为0，就说明该对象已经不使用，作为垃圾。但是引用计数法存在一个缺陷，即循环引用的问题，如果两个对象相互引用，则这两个对象的引用计数永远都不会为0，造成对象无法被回收。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;可达性分析法：即先创建一些根节点对象ROOTS，然后通过这些根节点对象向下搜索，如果一个对象到任意一个ROOTS之间都没有可达路径，在经过两次标记（下文解释为什么进行两次标记），还是没有可达路径，则说明该对象可回收。</p>
<p>&nbsp;&nbsp; &nbsp;<strong>（2）GC算法：</strong>常见的GC算法有四种，分别为标记清除算法，复制算法，标记整理算法，分代收集算法</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;标记清除算法：即在进行垃圾回收前，对所有对象进行一次标记，标记可回收的对象，然后进行清理即可。但是标记清除算法在清除回收对象之后，并不会对堆内存进行整理，这样的话如果内存中的对象大部分为小对象，清理之后就会导致没有大片连续的内存空间，即造成了内存碎片化，这样大对象存储的时候就无法找到相应的完整连续内存。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;复制算法：即将内存分为两块同等大小的区域，区域1和区域2，创建的新对象都存储在区域1中，当区域1中的内存占满之后，会对内存中的所有对象进行一次标记，标记存活的对象，将存活的对象复制到区域2，这时区域1中的对象都是可回收对象，回收区域1中的所有对象即可。但是复制算法也存在着一定的缺陷，即每次都只能使用一半的内存空间，造成了大量的内存浪费。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;标记整理算法：即结合标记清除算法和复制算法的优点，先对所有的对象进行标记，标记存活的对象，将存活的对象复制到内存的另一端，然后清除当前端的对象即可。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;分代收集算法：前面的三种算法，都无法按照对象的类型进行收集，分代收集算法正是解决这个问题，按照对象的不同类型采用不同的GC算法。以JVM的分代收集算法为例，JVM的堆内存分为新生代，老年代，永久代。新生代又分为Eden区，ServivorTo区和ServivorFrom区。新生代因为其存储生命周期短的小对象，GC比较频繁，所以采用复制算法。程序运行过程中创建的对象都存储在Eden区（大对象除外，大对象直接复制到老年代区域）。当Eden区的内存不够的时候进行MinorGC，然后将Eden区和ServivorFrom区的存活对象都复制到ServivorTo区，然后将ServivorTo区和ServivorFrom区进行交换，再次进行MinorGC。老年代因为存放的都是生命周期长的大对象，因而进行GC的不会太频繁，且清除的对象并不会太多，因而采用标记整理算法。老年代每次进行MajorGC之前都会先进行一次MinorGC，当MinorGC之后新生代的内存仍然不够的时候，将对象复制到老年代进行MajorGC。永久代区域主要回收常量，无用class等。</p>
<h2><strong>六，JAVA中的四种引用类型</strong></h2>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;强引用类型<strong>：</strong>即把对象赋给一个引用变量，强引用的对象一定为可达状态，所以不会进行垃圾回收。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;软引用类型：通过SoftReference类实现，当内存不够的时候对其进行GC</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;弱引用类型：只有弱引用类型的对象，一定会被GC</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;虚引用类型：虚引用对象主要是用来跟踪对象的GC状态</p>
<h2><strong>七，分代收集算法和分区收集算法</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>分代收集算法：新生代因其存放大量短生命周期小对象，且GC频繁，所以采用复制算法。老年代因其存放长生命周期大对象，且GC不平凡，所以采用标记整理算法。永久代，回收常量，类信息等。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;分区收集算法：即将堆内存区域分为大小不同的区，可以按照不同的区进行快速垃圾回收，减少系统的停顿时间。然后再以并行的方式逐步完成整个GC。</p>
<h2><strong>八，垃圾收集器</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>新生代区域：Serial垃圾收集器，单线程复制算法，因为单线程无需进行线程之间的交互和切换，所以效率非常高，是JVM默认的client模式下的默认垃圾回收策略，工作期间需要暂停其它所有的线程。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ParNew垃圾收集器，多线程复制算法，跟单线程Serial一样，是JVM默认的server模式下的垃圾回收策略，工作期间需要暂停所有其它线程</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Parallel Scavenge垃圾收集器：多线程复制算法，不同的是优先考虑系统吞吐量，可以利用更高效的利用CPU完成GC</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;老年代区域：Serial Old垃圾收集器，单线程标记整理算法，同新生代的Serial功能一样，只是采取的算法不同而已。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Parallel Old垃圾收集器：多线程标记整理算法，优先考虑了系统的吞吐量，其次考虑停顿时间。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CMS,多线程标记清除算法，优先考虑系统GC时的停顿时间，且过程分为四步（<span style="background-color: #ffff00;">解释上文的可达性分析中的两次标记</span>，第一步：标记GC ROOTS可达对象，暂停其它工作线程；第二步：和用户线程一起工作，跟踪GC ROOTS；第三步，因为第二步用户进程没有暂停，所以有些对象状态</p>
<p>可能发生了改变，重新进行标记；第四步，清除不可达对象）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; G1垃圾收集器，多线程标记整理算法，将内存分区，与CMS相比，一方面不会产生内存碎片，一方面，可以精确的控制系统停顿时间。</p>
<h2><strong>九，JAVA的网络编程模型</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;</strong>阻塞I/O模型：即用户线程发出I/O请求之后，内核会检查数据是否准备就绪，这时候用户线程始终处于阻塞状态等待数据准备就绪。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;非阻塞I/O模型：即用户线程不断的给内核发出I/O请求，内核接受到I/O请求之后会返回一个状态，如果数据准备就绪，就将数据复制进入用户线程，如果数据没有准备好，返回一个false，用户线程无需阻塞，可以去处理其它事情，而当数据准备好了且刚好用户线程发起I/O请求进行操作。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;多路复用I/O模型：多路复用I/O模型通过一个Selector线程轮询Socket的状态，如果Socket有读写事件，则进行I/O操作。此模型的优势在于可以更好的处理连接数众多但消息体不大的情况下。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;信号驱动I/O模型：即用户线程发出一个I/O请求，系统会为该请求创建一个信号函数，用户请求可继续执行其它业务逻辑，当内核数据准备就绪之后会返回给用户线程一个信号，用户线程接收到之后进行I/O操作。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;异步I/O模型：用户线程给内核发起一个asynchronous read操作，内核接收到之后，返回其请求是否成功，然后等待数据准备成功之后复制到用户线程。整个过程中请求的发起和数据读取都在内核中进行，最终发送一个信号告知用户线程I/O操作已经完成，用户直接使用数据就行。（说实话个人感</p>
<p>觉和信号驱动很像）</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;java NIO：没怎么读懂（<span style="background-color: #993300;">记得补充！</span>）</p>
<h2><strong>十，JVM的类加载机制</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>JVM类加载分为五个阶段：加载，验证，准备，解析，初始化</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;加载：即将class文件加载到JVM中，且创建class对象，封装其数据结构。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;验证：对class文件进行验证，确保符合JVM的标准，保证JVM的安全。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;准备：即方法区中给类变量分配空间和赋初值。static修改的会在初始化阶段赋值，final修饰的会在准备阶段赋值。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;解析：即将常量池中的引用替换为直接引用</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;初始化：执行类构造器进行初始化。（因为内部流程不是很清楚，所以对于其几种不进行初始化的情况不做说明）</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;类加载器：JVM提供了三种类加载器，启动类加载器（/lib），扩展类加载器(/lib/ext)，应用程序类加载器(classpath)。还可以再应用程序类加载器自定义类加载器。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;双亲委派机制：即当一个类接收到类加载请求的时候，不会自己进行加载，而是将其加载请求委派给其父类加载器，这样一路委派，最终加载请求都会委派到启动类加载器.启动类加载器接收到加载请求之后会去lib目录下寻找相关的class文件，若找不到，则将其加载请求再委培给子类加载器，一路委派，直到能够加载。</p>
<h3><strong>最后，送给大家一张博主画的JVM的思维导图，以后读《深入JVM虚拟机》的时候可能会出一个JVM专题：<a href="https://uploader.shimo.im/f/X0MX3hLaHrevltxW.png!thumbnail" target="_blank" rel="noopener">JVM思维导图</a></strong></h3>
<p>&nbsp;</p>
<h2>水平有限，若发现有误，还望指出！</h2>, blogGoods=0, blogRead=17, blogCollection=0, typeName=java面试篇, blogRemark=面试（一）------之JVM篇, blogComment=0, blogSource=null, createdTime=2020-04-09 12:21:30, blogMonth=null, updateTime=2020-04-20 11:53:29), BlogVo(blogId=1248135765829918720, blogTitle=CSS----之flex弹性布局, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dGnuAWkLLAAAaRXQXNms575.jpg, blogContent=<p><strong>一，css之弹性布局</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，</strong>何为弹性布局？</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 弹性布局是css的一种新的布局方式，所谓&ldquo;弹性布局&rdquo;，即页面随着不同设备的屏幕大小拉伸会自适应页面的大小。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，</strong>弹性布局的两种主要元素，container（弹性容器），item（弹性子元素），一个弹性容器中可以放入多个弹性子元素，元素之间是可以进行嵌套的，弹性子元素也可以设置为弹性容器，里面再嵌套弹性子元素。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，</strong>弹性布局的基本属性</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （1）display：flex，声明容器为弹性布局</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （2）flex-direction：声明弹性容器内部元素的排列方式，默认为row。row（横向布局），row-reverse（横向布局，但是元素反方向码），column（纵向布局），column-reverse（纵向布局，但是元素反着码）。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （3）flex-wrap：声明弹性盒子中的元素是否可以换行，默认为nowrap（不换行），wrap（换行），wrap-reverse（换行，但是反着码）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （4）align-items：设置容器中元素在纵轴方向上的对齐方式，默认为stretch（即如果不设置子元素高度，则默认拉伸至于容器同宽度），flex-start（子元素位于容器的开始位置），flex-end（子元素位于容器的结尾处），center（元素依纵轴方向居中），baseline（元素位于容器基线，不过没怎么用过，所以不是很清楚）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （5）justify-content（设置元素在主轴上的对齐方式），默认为flex-start（元素从容器主轴开始位置码），flex-end（元素从容器主轴结尾处码），center（元素位于主轴居中处），space-between（元素布局在容器的两端），space-around（元素布局在容器两端，但是元素前后都留有空白）因为项目中大多数只使用了对于容器的操作，对于容器中元素的操作很少，所以这里只介绍这点。谢谢阅读！</p>, blogGoods=0, blogRead=3, blogCollection=0, typeName=CSS, blogRemark=CSS----之flex弹性布局, blogComment=0, blogSource=null, createdTime=2020-04-09 06:28:51, blogMonth=null, updateTime=2020-04-20 11:43:57), BlogVo(blogId=1247867141693128704, blogTitle=闲谈前后端分离开发, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dG6CAI6ipAACiM2P5LtI65.jpeg, blogContent=<p><strong>一，前后端分离开发优势</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，</strong>项目开发过程中，前后端完全解耦，前端只需要负责页面的实现，只需要通过接口拿数据。后端不需要管页面的跳转，只需要负责接口的编写</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，</strong>前后端人员有更多的精力去负责自己的工作，前端人员可以将更多的精力投放在页面的编写，页面的美化，页面特效的制作和用户体验上；而后端人员可以将更多的精力放在接口代码的优化，sql优化，jvm调优上面</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，</strong>前后端分离的项目部署的时候，前端项目往往都是部署在nginx服务器上，而前后端不分离的项目往往都是部署再一台服务器上。因此前后端分离项目大大降低了服务器的负担</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>4，</strong>前后端不分离的项目使用模板引擎例如freemaker，thymeleaf等，前后端人员交流起来较为困难。且前端项目使用原生的DOM操作，极大的增加了前端工作人员的工作量。而前后端分离项目前端通常都是用各种ui框架，框架采用MVVM模式，极大的减轻了前端工作人员的工作量</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，</strong>前后端分离开发，前端可以通过easy-mock来伪造接口数据进行测试，后端人员可以通过postman进行接口测试，开发效率大大提升。</p>, blogGoods=0, blogRead=7, blogCollection=0, typeName=随笔, blogRemark=前后端分离开发的优势所在, blogComment=0, blogSource=null, createdTime=2020-04-08 12:41:25, blogMonth=null, updateTime=2020-04-20 11:48:53), BlogVo(blogId=1247745014683947008, blogTitle=博客开发总结（一）-----之数据库设计篇, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dDViAcnjvAACb6PL1tzA485.jpg, blogContent=<p><strong>一，数据库设计--表的命名规范等</strong></p>
<p>（1），统一采用bl_开头对表进行命名</p>
<p>（2），对于数据比较重要的表统一添加四个字段，分别为：created_time(创建时间),update_time(修改时间),version(版本号),deleted(删除字段)</p>
<p>（3），数据库表的字段尽量都设置为NOT_NULL</p>
<p>（4），数据库中表varchar类型字段需要设置长度的尽量设置为2<sup>n</sup>-1</p>
<p>（5），因为博客系统分为前台展示界面和后台管理，所以对于有些表，例如bl_type（博客类型表），bl_music（音乐表）等设置了enable（启用字段）</p>
<p><strong>二，上述第二条--四个字段的解释</strong></p>
<p>（1），为什么要设置created_time和update_time字段：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;其一，从数据库的通用性上来说，设计这两个字段是必要的，但也需要根据业务的需要来合理添加这两个字段，因为无用的字段会浪费空间，性能，影响系统的运行。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 其二，大部分的应用都有需要根据时间进行排序的功能。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 其三，当系统发生异常的时候，我们可以通过这两个字段对异常进行排查和定位。</p>
<p>（2），为什么要设置version字段：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 1，version字段含义：字段的含义与其字面意思一样，代表版本，在这里作为乐观锁进行使用，从而保证不会出现脏数据的情况。下面解释一下什么叫乐观锁，以及乐观锁和悲观锁</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 2，乐观锁：总是假定最好的情况，即每次用户调用接口从数据库中取出数据到修改数据前的过程中，不会有其它用户对当前数据进行修改，这样在当前用户修改数据的时候，利用版本机制即判断取出的version字段和当前数据库该条数据的version字段是否相等来判断该条数据是否已经被修改，如果未修改，则予以修改（且version字段递增），如果已经修改，则提示用户更新失败。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 悲观锁：总是假定最坏的情况，即每次用户调用接口从数据库取出数据的时候，都认为该条数据会被修改，因此每次取出数据都对数据进行加锁处理，只允许当前用户进行修改，其它用户阻塞，直到当前用户修改完毕。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3，为什么使用乐观锁而不使用悲观锁：因为悲观锁比较浪费性能</p>
<p>（3），为什么设置deleted字段：deleted字段在这里作为一个逻辑删除字段（0否1是），何为逻辑删除，即执行删除操作操作的时候，不会真正的删除数据库中的数据，而是将deleted字段设置为1即可。&nbsp;这样如果用户出现误删的操作，可以通过数据库修改该字段进行数据的恢复。</p>
<p><strong>三，上述第三条--数据库表字段尽量设置为NOT_NULL</strong></p>
<p>（1），数据库表字段尽量设置为NOT_NULL：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 1，有些人可能认为设置为NULL相比于NOT_NULL不是更节省空间吗？但是实际上不是这样的，设计为NULL相比于NOT_NULL要多占用一个字节的空间</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 2，设计为NOT_NULL，这样在做查询的时候能够更好的避免空指针异常，且发生该类错误的时候能够更好的进行排查</p>
<p><strong>四，上述第四条--表varchar类型字段长度尽量设置为2<sup>n</sup>-1</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>因为计算机只识别二进制，且有一定的范围，例如2<sup>8</sup>，在计算机中的范围为-128~127,因此对于varchar字段长度来说，如果设置为255，则正好是一个字节，而如果设置为256，则占用两个字节，这样会浪费计算机的内存空间，因此数据库varchar类型字段的长度最好设置为2<sup>n</sup>-1</p>
<p><strong>五，上述第五条--对于设置enable字段的解释</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>enable字段，字面意思启用，在这里表明是否启用（0否1是），因为系统分为前台博客页面和后台管理，对于这两个不同的前端项目，后台可以通过启用字段来控制内容在前台博客页面的展示与否，与deleted字段不同的是，如果执行删除操作，那么我们只能通过手动修改数据库中的字段进行数据的恢复，且如果执行删除操作，则该数据在前台博客页面和后台管理页面都无法看见。但是如果将数据弃用（即修改enable字段值为1），则表明该数据被弃用，在前台博客页面无法显示，但是在后台管理页面可以看见，且无需通过手动修改数据库来恢复数据，可以在后台管理页面操作启用数据。</p>
<p>&nbsp;</p>, blogGoods=0, blogRead=21, blogCollection=0, typeName=博客开发和维护总结, blogRemark=博客开发总结（一）-----之数据库设计篇, blogComment=0, blogSource=null, createdTime=2020-04-08 04:36:07, blogMonth=null, updateTime=2020-04-20 10:47:54)], params={}, sortColumn=created_time, sortMethod=DESC)]
2020-04-26 22:24:44.079 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 252
2020-04-26 22:24:44.080 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":5,"index":60,"list":[],"pageSize":15,"params":{},"sortColumn":"created_time","sortMethod":"DESC","totalCount":53,"totalPage":4},"msg":"操作成功!"}
2020-04-26 22:24:48.211 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/list
2020-04-26 22:24:48.211 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 22:24:48.212 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 22:24:48.212 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogList
2020-04-26 22:24:48.212 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=15, totalPage=4, totalCount=53, list=[], params={}, sortColumn=created_time, sortMethod=DESC)]
2020-04-26 22:24:48.555 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 344
2020-04-26 22:24:48.556 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，0~n-1中缺失的数字</strong></h2>\n<p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>\n<p>示例 1:</p>\n<p>输入: [0,1,3]<br />输出: 2<br />示例&nbsp;2:</p>\n<p>输入: [0,1,2,3,4,5,6,7,9]<br />输出: 8</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主能想到的并且写出来的方法有：使用map存储数组中的所有元素，然后遍历0-n-1找出不在map中的元素。此种方法时间复杂度O（N），空间复杂度O（N）-----垃圾</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 统计0-n-1所有数字的数字和，再统计数组中所有数字的数字和，两和只差即为所求数字，时间复杂度O（N），空间复杂度O（1）-----垃圾</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;最优解法（二分查找法）：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;通常来说，我们使用二分查找法是查找一个存在于数组中的元素，但是本题需要求不在数组中的一个元素，因此到这很多人就会迷惑，不知道该怎么求了。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;但是我们首先要搞明白二分查找法的本质是什么：1，并不局限于仅仅查找存在于数组中的元素；2，二分查找的本质是对数组根据mid中间值在某一条件上进行二分（例如：通常的num[mid]&gt;target或者nums[mid]&lt;target进行左右切分）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;因此明白这一点，就好解决问题了。拿到这道题，使用二分，我们首先想到的应该是寻找根据mid中间值进行二分的条件</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;审题：题目中提及数组为递增数组，而且0-n-1内的n个数字有一个不在数组中，则不在的这个数字之前的数字满足nums[i]=i即元素本身等于数组下标，而之后的数字nums[i]!=i,所以这就是进行二分的条件了</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 二分查找法\n     * 算法思想：二分查找法的本质是能够有一个条件将数组根据mid中间值进行左右切分\n     * 所以我们想到二分查找法之后，首先需要做的是找出切分数组的条件\n     * 题目中给出了数组是一个递增数组，且0-n-1内的n个数字有一个不在这个长度为n-1的数组内\n     * 因此，不在的这个元素其左边元素必有数组下标值等于元素本身即nums[i]=i\n     * 而不在的这个元素的右边必有nums[i]!=i\n     * 所以根据此条件进行划分数组即可\n     * @param nums\n     * @return\n     */\n    public static int missingNumber(int[] nums) {\n        int low = 0;\n        int high = nums.length-1;\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]==mid){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        return low;\n    }</code></pre>","blogGoods":0,"blogId":"1254063045920022528","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kUM-AON88AAAaZr2Bc1U903.jpg","blogRead":0,"blogRemark":"剑指offer----0~n-1中缺失的数字","blogTitle":"剑指offer----0~n-1中缺失的数字","createdTime":"2020-04-25 23:01:44","typeName":"LeetCode","updateTime":"2020-04-25 23:01:44"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，在排序数组中查找数字I</strong></h2>\n<p>统计一个数字在排序数组中出现的次数。</p>\n<p>示例 1:</p>\n<p>输入: nums = [5,7,7,8,8,10], target = 8<br />输出: 2<br />示例&nbsp;2:</p>\n<p>输入: nums = [5,7,7,8,8,10], target = 6<br />输出: 0</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解法一：直接遍历统计，时间复杂度为O（N）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 遍历数组\n     * 找到第一个与目标元素相等的元素，res+1\n     * 然后往后找到第一个与目标元素不相等的元素,返回res即可\n     * 时间复杂度为O(N)\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static int search(int[] nums, int target) {\n        int res = 0;\n        for (int num : nums) {\n            if(num==target){\n                res++;\n            }\n        }\n        return res;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解法二：二分法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：利用二分法查找数字在排序数组中的左边界Left和右边界Right.如下，如果要寻找数组中的8，则其左边界为left=2,有边界right=5.所以出现次数为right-left-1.时间复杂度为O（logN）</strong></p>\n<table style=\"width: 20%; border-collapse: collapse; margin-left: auto; margin-right: auto;\" border=\"1\" cellpadding=\"5\">\n<tbody>\n<tr>\n<td style=\"width: 16.6667%;\">5</td>\n<td style=\"width: 16.6667%;\">7</td>\n<td style=\"width: 16.6667%;\">7</td>\n<td style=\"width: 16.6667%;\">8</td>\n<td style=\"width: 16.6667%;\">8</td>\n<td style=\"width: 16.6667%;\">10</td>\n</tr>\n</tbody>\n</table>\n<pre class=\"language-java\"><code>    /**\n     * 二分查找法\n     * 时间复杂度为O（logN）\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static int search2(int[] nums, int target){\n        int low = 0;\n        int high = nums.length-1;\n        int left,right;\n        left = right = 0;\n        //一次二分\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]&lt;=target){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        right = low;\n\n        low = 0;\n        high = nums.length -1;\n        //二次二分\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]&lt;target){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        left = high;\n        return right -left -1;\n    }</code></pre>","blogGoods":0,"blogId":"1254055163115724800","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kSXiAYRyFAAAaZr2Bc1U379.jpg","blogRead":0,"blogRemark":"剑指offer----在排序数组中查找数字I----LeetCode34","blogTitle":"剑指offer----在排序数组中查找数字I----LeetCode34","createdTime":"2020-04-25 22:30:24","typeName":"LeetCode","updateTime":"2020-04-25 22:30:24"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，两个链表的第一个公共节点</strong></h2>\n<p><strong><img src=\"https://images-cdn.shimo.im/Wd1NC8pveQYp9iIL.png__thumbnail\" alt=\"示例图\" width=\"742\" height=\"241\" /></strong></p>\n<p><strong>这是我从官方截下的一张图，也是有些人疑惑的地方，因为官方这张图给出的公共节点为8，而大多数人看到这张图，认为公共节点应该是1.</strong></p>\n<p><strong>但是实际上这里的公共节点不仅要节点的value相等，同时还需要节点的地址相等。从图中可以看出两个1节点虽然值相等，但是地址却不同，因而不是公共节点</strong></p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解法一：双指针</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：初始化两个指针p1=headA,p2=headB</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;分别遍历两个链表，求出两个链表的长度l1,l2</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;然后重置p1,p2指针指向头节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;让长链表的指针先走多的步数（l1-l2或者l2-l1）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;然后让两个指针同时走，直到两者相遇，即找到公共节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解疑：弄清楚第一个value相等的节点和指针相遇的节点，这两种节点是不同的，指针相遇的节点，不仅包含value相等，同时地址也相等。（如图中的8）；而第一个value相等的节点则可能并不在同一个地址，因此不一定是公共节点</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法\n     * @param headA\n     * @param headB\n     * @return\n     */\n    public static ListNode getIntersectionNode2(ListNode headA, ListNode headB){\n        ListNode p1 =headA;\n        ListNode p2 = headB;\n        int l1 = 0;\n        int l2 = 0;\n        //计算链表1的长度\n        while(p1!=null){\n            l1++;\n            p1 = p1.next;\n        }\n        //计算链表2的长度\n        while(p2!=null){\n            l2++;\n            p2 = p2.next;\n        }\n        p1 = headA;\n        p2 = headB;\n        //让长链表指针先走长的步数\n        if(l1&gt;l2){\n            for (int i = 0; i &lt; l1-l2; i++) {\n                p1 = p1.next;\n            }\n        }else{\n            for (int i = 0; i &lt; l2-l1; i++) {\n                p2 = p2.next;\n            }\n        }\n        //然后让两个指针同时走，直到相遇\n        while(p1!=p2){\n            p1 = p1.next;\n            p2 = p2.next;\n        }\n        return p1;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;解法二（大神解法）：丘比特相遇法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;利用两个指针p1=headA,p2=headB,让两个指针同时走，</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果p1先走到底，就将p1置为headB，</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果p2,先走到底，就将p2置为headA,</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;当两个指针相遇的时候，他们就相爱了（当然是找到公共节点了）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法p1=headA,p2=headB\n     * 思想是：两个节点同时从各自的链表出发\n     * p1走到末尾时，回到headB的头部\n     * p2走到末尾时，回到headA的头部\n     * 两个指针相遇的时候，即使要找的公共节点\n     * @param headA\n     * @param headB\n     * @return\n     */\n    public static ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode p1 = headA;\n        ListNode p2 = headB;\n        while(p1!=p2){\n            p1 = (p1==null)?headB:p1.next;\n            p2 = (p2==null)?headA:p2.next;\n        }\n        return p1;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1253992797703364608","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kD2OADD3mAAAaZr2Bc1U709.jpg","blogRead":0,"blogRemark":"剑指offer----之两个链表的第一个公共节点----LeetCode160","blogTitle":"剑指offer----之两个链表的第一个公共节点----LeetCode160","createdTime":"2020-04-25 18:22:35","typeName":"LeetCode","updateTime":"2020-04-25 18:22:35"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，第一个只出现一次的字符</strong></h2>\n<p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。</p>\n<p>示例:</p>\n<p>s = \"abaccdeff\"<br />返回 \"b\"</p>\n<p>s = \"\" <br />返回 \" \"</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主现在发现，做一道算法题的时候，最重要的一步就是读题，审题，在草稿纸上写下自己的思路（当然那种望眼欲穿的大佬除外）。然后才开始动笔，对于IT人来说，真的，多将时间花费在思考上面，而不是无意义的重复搬砖。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;题目分析：看到这道题，抓住两个关键字：第一个，只出现一次。什么意思呢，例如\"abaccdeff\"，其中只出现一次的字符有'b','d','e'三个，然后在三个字符中第一个出现在字符串中的是'b'，因此本题的答案是'b'.</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法分析：根据题目分析，我们最直观的解法应该是，先找出字符串中只出现一次的字符，然后再找出只出现一次字符中，第一个在字符串中出现的。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;所以我们需要做两件事，一是统计字符串中各个字符的出现次数，并且记录；二，统计完毕后，找出第一个出现次数为1的字符，返回即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;因此我们既要存字符，还要存字符对应的出现次数，所以理所当然我们选择map集合。当然对于本题而言，因为求第一个出现一次的字符，所以我们更好的是可以使用LinkedHashMap。这样免去最后的一次遍历字符串</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;下面提供两种解法：三种解法都是使用map集合，但是略有不同</strong></p>\n<p><strong>LinkedHashMap：（这是博主写的，代码冗余，这里用来和大神的写法做比较，警醒自己）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 用LinkedHashMap\n     * 思想：遍历字符串，如果map为空或者map中不含当前字符，则将其存入map\n     * 如果map中已经含有当前字符，则从map中移除\n     * 最终map中只剩出现一次的字符\n     * 返货map中的第一个即可\n     * @param s\n     * @return\n     */\n    public static char firstUniqChar(String s) {\n        Map&lt;Character,Integer&gt;map = new LinkedHashMap&lt;&gt;();\n        for (int i = 0; i &lt; s.length(); i++) {\n            char ch = s.charAt(i);\n            if(map.isEmpty()||!map.containsKey(ch)){\n                map.put(ch,1);\n            }else{\n                Integer val = map.get(ch);\n                map.put(ch,++val);\n            }\n        }\n        //返回map中第一个元素即可\n        Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entries = map.entrySet();\n        for (Map.Entry&lt;Character, Integer&gt; entry : entries) {\n            if(entry.getValue()==1){\n                return entry.getKey();\n            }\n        }\n        return ' ';\n    }</code></pre>\n<p><strong>HashMap（大神解法）：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 哈希表法\n     * @param s\n     * @return\n     */\n    public char firstUniqChar2(String s) {\n        Map&lt;Character,Boolean&gt; map = new HashMap&lt;&gt;();\n        char[] chars = s.toCharArray();\n        for (char ch : chars) {\n            map.put(ch,!map.containsKey(ch));\n        }\n        for (char ch : chars) {\n            if(map.get(ch)){\n                return ch;\n            }\n        }\n        return ' ';\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;分析：首先，这里提供了两种解法，一种为LinkedHashMap，一种为HashMap，这两种解法的不同之处就在于最后获取值的时候，LinkedHashMap获取最终值是遍历LinkedHashMap的entrySet，但是HashMap获取最终值是遍历原字符串。因而当数据庞大的时候，显然使用LinkedHashMap性能更高。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;然后，再分析一下这两种解法不另外一个不同之处，没错！就是大神的解法中使用map存放key对应的value值是Boolean型！（<span style=\"background-color: #ffcc00;\">这个真的是神一般的存在</span>），既省去了计算次数的麻烦，同时最后取的时候也不需要判断次数。wc！同一种解法，为什么天差地别！</strong></p>","blogGoods":0,"blogId":"1253956468789600256","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6j7Y6ACrySAAAaZr2Bc1U825.jpg","blogRead":0,"blogRemark":"剑指offer----第一次只出现一次的字符","blogTitle":"剑指offer----第一次只出现一次的字符","createdTime":"2020-04-25 15:58:14","typeName":"LeetCode","updateTime":"2020-04-25 15:58:14"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，连续子数组的最大和</strong></h2>\n<p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>\n<p>要求时间复杂度为O(n)。</p>\n<p>示例1:</p>\n<p>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br />输出: 6<br />解释:&nbsp;连续子数组&nbsp;[4,-1,2,1] 的和最大，为&nbsp;6。</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;看到这道题，最简单的想法肯定是求出所有连续子数组的值，然后进行比较，找出最大的即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;但是随后会想到既然要找出所有的子数组，那么我们可以使用分治的思想，因为分治的分过程即可以得到所有子序列</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;随后，再深一步，既然可以分治的思想，分的过程即是递归的过程，而且子数组的最大值依赖与前一子数组，所以可以想到使用动态规划</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：设dp[i]为以nums[i]为结尾的最大子数组和，初始值dp[0] = nums[0]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;遍历数组，如果dp[i-1]&gt;=0。则说明前面的最大子数组对当前子数组有增益效果，所以dp[i] = dp[i-1]+nums[i]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果dp[i-1]&lt;0。说明前面的最大子数组对当前子数组有夫负效果，还不如nums[i]本身，所以dp[i]=nums[i]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主的这样的写法：时间复杂度为O（N），空间复杂度也为O（N），但是实际上不需要使用dp数组，使用nums原数组就行，所以可以减小空间复杂度为O（1）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 动态规划\n     * 算法思想：因为求的是连续子数组的最大和\n     * 所以我们可以设dp[i]为以nums[i]结尾的最大连续子数组\n     * 如果dp[i]&lt;=nums[i],dp[i]=nums[i]\n     * 如果dp[i]&gt;nums[i],则dp[i]=dp[i]+nums[i]\n     * @param nums\n     * @return\n     */\n    public static int maxSubArray(int[] nums) {\n        int[] dp  = new int[nums.length];\n        dp[0] = nums[0];\n        int res = nums[0];\n        for (int i = 1; i &lt; nums.length; i++) {\n            if(dp[i-1]&lt;0){\n                dp[i] = nums[i];\n            }else{\n                dp[i] = dp[i-1]+nums[i];\n            }\n            res = Math.max(res,dp[i]);\n        }\n        return res;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1253938714590175232","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6j3QSACLxRAAAaZr2Bc1U017.jpg","blogRead":0,"blogRemark":"剑指offer---连续子数组的最大和---LeetCode53","blogTitle":"剑指offer---连续子数组的最大和---LeetCode53","createdTime":"2020-04-25 14:47:41","typeName":"LeetCode","updateTime":"2020-04-25 14:47:41"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，最小的k个数</strong></h2>\n<p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>\n<p>示例 1：</p>\n<p>输入：arr = [3,2,1], k = 2<br />输出：[1,2] 或者 [2,1]<br />示例 2：</p>\n<p>输入：arr = [0,1,2,1], k = 1<br />输出：[0]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;1,可以采用快排的思想，将原数组按照升序排序，然后取出前k个数即可，时间复杂度为O（NlogN）。但是其实跟API中的sort方法好像差别不大</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 对原数组升序排序，然后取前k个元素\n     * @param arr\n     * @param k\n     * @return\n     */\n    public static int[] getLeastNumbers(int[] arr, int k) {\n        quickSort(arr,0,arr.length-1);\n        int[] result = new int[k];\n        for (int i = 0; i &lt; k; i++) {\n            result[i] = arr[i];\n        }\n        return result;\n    }\n\n    /**\n     * 快排\n     * @param nums\n     * @param low\n     * @param high\n     */\n    public static void quickSort(int[] nums,int low,int high){\n        int base = nums[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //先从右向左找到第一个小于基准元素的元素\n            while(L&lt;R&amp;&amp;nums[R]&gt;=base){\n                R--;\n            }\n            if(nums[R]&lt;base){\n                swap(nums,L,R);\n            }\n            //再从左向右找到第一个大于基准元素的元素\n            while(L&lt;R&amp;&amp;nums[L]&lt;=base){\n                L++;\n            }\n            if(nums[L]&gt;base){\n                swap(nums,L,R);\n            }\n        }\n        //左递归\n        if(L&gt;low){\n            quickSort(nums,low,L-1);\n        }\n        //右递归\n        if(high&gt;R){\n            quickSort(nums,R+1,high);\n        }\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>2，堆排序：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;先讲解一下堆排序：堆排序是一种完全二叉树的结构，常见的存在两种堆结构，小根堆（即满足arr[2i+1]&gt;=arr[i]&amp;&amp;arr[2i+2]&gt;=arr[i]），大根堆（即满足arr[2i+1]&lt;=arr[i]&amp;&amp;arr[2i+2]&lt;=arr[i]）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;基本算法思想：第一步，初始化堆，即堆初始化为大根堆或者小根堆（这里我们简称调整堆）；第二步，将堆顶元素与堆的末尾元素进行交换，然后重新调整堆。在java中堆通常用来实现优先级队列PriorityQueue(默认的采用小根堆，若想使用大根堆，需要在创建时实现comparator)</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;使用情况：这里以java中的优先级队列为例，堆的使用情况不能按照堆名断章取义，例如小根堆实际上是将元素升序存放，因为在算法第二步中将堆顶元素与末尾元素进行交换，然后重新调整，交换的堆顶元素为最小元素，也是最先从堆中进入队列的。所以小根堆适用于TOPk大的算法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;相反的，大根堆适用于TOPk小的算法，下面分别给出小根堆和大根堆的算法：</strong></p>\n<p><strong>小根堆：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 堆排序---小根堆\n     * @param nums\n     */\n    public static void HeapSort(int[] nums){\n        //先初始化堆\n        for (int i = nums.length/2-1; i &gt;=0 ; i--) {\n            adjustHeap(nums,i,nums.length);\n        }\n        //交换堆顶与末尾节点+重新调整为小根堆\n        for (int i = nums.length-1; i &gt;0; i--) {\n            //先交换\n            swap(nums,0,i);\n            //再调整\n            adjustHeap(nums,0,i);\n        }\n    }\n\n    /**\n     * 调整为小根堆\n     * @param nums\n     * @param i\n     * @param length\n     */\n    public static void adjustHeap(int[] nums,int i,int length){\n        int temp = nums[i];\n        for (int j = 2*i+1; j &lt; length; j=2*j+1) {\n            //找出左右节点中的最小值\n            if(j+1&lt;length&amp;&amp;nums[j]&gt;nums[j+1]){\n                j++;\n            }\n            if(nums[j]&lt;temp){\n                nums[i] = nums[j];\n                i = j;\n            }\n        }\n        nums[i] = temp;\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p><strong>大根堆：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 堆排序---大根堆\n     * @param nums\n     */\n    public static void heapSort(int[] nums){\n\n        //初始化堆的过程\n        for (int i = nums.length/2-1; i &gt;=0; i--) {\n            adjustHeap(nums,i,nums.length);\n        }\n        //调整+交换堆顶和末尾的元素\n        for (int i = nums.length-1; i &gt;0; i--) {\n            //先交换，再重新调整\n            swap(nums,0,i);\n            adjustHeap(nums,0,i);\n        }\n    }\n\n    /**\n     * 调整大顶堆的过程\n     * @param nums\n     * @param i\n     * @param length\n     */\n    public static void adjustHeap(int[] nums,int i,int length){\n        int temp = nums[i];\n        for (int j = 2*i+1; j &lt; length; j=2*j+1) {\n            //找出左右节点中的最大值\n            if(j+1&lt;length&amp;&amp;nums[j]&lt;nums[j+1]){\n                j++;\n            }\n            if(nums[j]&gt;temp){\n                nums[i] = nums[j];\n                i = j;\n            }\n        }\n        nums[i] = temp;\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>本题利用大根堆解法，且使用java中自带的优先级队列PriorityQueue：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用堆数据结构，java中的优先级队列对应着最小堆\n     * 实现其comparator即可\n     * @param arr\n     * @param k\n     * @return\n     */\n    public static int[] getLeastNumbers2(int[] arr, int k){\n        Queue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(k,(v1,v2)-&gt;v2-v1);\n        for (int i : arr) {\n            if(heap.isEmpty()||heap.size()&lt;k||i&lt;heap.peek()){\n                heap.offer(i);\n            }\n            if(heap.size()&gt;k){\n                heap.poll();\n            }\n        }\n        int[] result = new int[k];\n        int j = 0;\n        for (Integer val : heap) {\n            result[j++] = val;\n        }\n        return result;\n    }</code></pre>","blogGoods":0,"blogId":"1253874832811089920","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6joYWAF3oqAAAaZr2Bc1U671.jpg","blogRead":2,"blogRemark":"剑指offer----之最小的k个数","blogTitle":"剑指offer----之最小的k个数","createdTime":"2020-04-25 10:33:50","typeName":"LeetCode","updateTime":"2020-04-25 11:53:15"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，数组中出现次数超过一半的元素---即众数</strong></h2>\n<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>\n<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>\n<p>示例&nbsp;1:</p>\n<p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br />输出: 2</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>方法有三：哈希表统计法，数组排序法，摩尔投票法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;哈希统计法：时间复杂度O（N），空间复杂度O（N）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 博主刚开始看到这道题的时候，首先想到的是哈希表统计法，因为博主想的是要找到众数，那么肯定得统计每个数字的出现次数，然后按照次数比较。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 单单是想到这些，用了map集合之后发现还是不行，因为即便用map集合统计出了每个数字和其对应的出现次数之后，你会发现没有办法按照出现的次数进行比较并且得到次数最多的数字（众数</strong><strong>）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 然后，就又审了一遍题目，结果发现了一个本题很关键的点，（<span style=\"background-color: #ffcc00;\">数组中有一个数字出现的次数超过数组长度的一半</span>），也就是说数组中有且仅有一个数字的出现次数会超过数组长度的一半（别笑博主笨，我是真的刚开始没反应过来）</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 那么我为什么要把数组中的所有元素和其次数全部存放进入map集合，然后再取次数进行比较呢？我为什么不在将元素和其次数存入集合的过程中判断次数是否已经超过数组长度的一半了呢？如果超过一半了，那它肯定是众数了呀！</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 思路：根据题意需要找出两个东西，一是多素元素，二是多素元素的出现次数\n     * 所以我们首先想到的是采用map集合\n     * 然后遍历数组，如果元素不存在与集合中，我们就将其加入map，value置为1\n     * 如果元素存在于map中，则我们取出其value将其加1与数组长度的一半做比较\n     * 如果大于数组长度一半，直接返回该元素即可\n     * 小于数组长度一半，则将其value加1存入map覆盖原有的值即可\n     *\n     * @param nums\n     * @return\n     */\n    public static int majorityElement(int[] nums) {\n        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(nums.length);\n        for (int num : nums) {\n            if(!map.containsKey(num)){\n                map.put(num,1);\n            }else{\n                Integer val = map.get(num);\n                if(++val&gt;nums.length/2){\n                    return num;\n                }else{\n                    map.put(num,val);\n                }\n            }\n        }\n        throw new RuntimeException(\"\");\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>数组排序法：由题可知，数组众必然存在一个多数元素，且出现次数超过数组长度的一半。所以我们可以对原数组进行排序，然后取数组中间的元素即可。（我擦，我当时看到这个，就在想，好简单，这个思路，但是我为什么没想到，对，因为我没有仔细的分析题目，超过一半看见没）。既然进行排序，那么我们可以选择快排，这样时间复杂度就是O（NlogN），空间复杂度O（1）.</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 数组排序法，因为多数元素的出现次数超过数组长度一半，\n     * 所以我们可以先对其进行排序，采用快排，时间复杂度O（NlogN）\n     * 然后取数组中点元素即可\n     * @param nums\n     * @return\n     */\n    public static int majorityElement2(int[] nums){\n        quickSort(nums,0,nums.length-1);\n        return nums[nums.length/2];\n    }\n\n    /**\n     * 快排\n     * @param nums\n     * @param low\n     * @param high\n     */\n    public static void quickSort(int[] nums,int low,int high){\n        int base = nums[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //从右向左找到第一个比基准元素小的元素\n            while(L&lt;R&amp;&amp;nums[R]&gt;=base){\n                R--;\n            }\n            if(nums[R]&lt;base){\n                swap(nums,L,R);\n            }\n            //从左向右找到第一个比基准元素大的元素\n            while(L&lt;R&amp;&amp;nums[L]&lt;=base){\n                L++;\n            }\n            if(nums[L]&gt;base){\n                swap(nums,L,R);\n            }\n        }\n        //左递归\n        if(L&gt;low){\n            quickSort(nums,low,L-1);\n        }\n        //右递归\n        if(high&gt;R){\n            quickSort(nums,R+1,high);\n        }\n    }\n\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>摩尔投票法（我将其称为大佬解法）：大概的意思就是采用正负抵消的方法，设置一个投票变量votes，初始设置为0；设置一个本题中的众数变量x，初始设置为数组首元素。然后遍历数组，判断跟设置的众数变量是否相等，如果相等将votes加一，如果不相等，则重置votes为0，且将x设置为数组下一个元素。本题众因为已经声明了肯定存在众数，所以不需要进行验证，但是如果没有声明的话，需要验证，下列代码众添加了验证：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 摩尔投票法\n     * @param nums\n     */\n    public static int majorityElement3(int[] nums){\n        int votes = 0;\n        int x = nums[0];\n        int count = 0;\n        for (int num : nums) {\n            if(votes==0){\n                x = num;\n            }\n            votes+=(num==x)?1:-1;\n        }\n        //验证数组众是否存在众数\n        for (int num : nums) {\n            if(num==x){\n                count++;\n            }\n        }\n        return count&gt;nums.length/2?x:0;\n    }</code></pre>","blogGoods":0,"blogId":"1253674617332162560","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6i5v-AUh39AAAaZr2Bc1U885.jpg","blogRead":0,"blogRemark":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","blogTitle":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","createdTime":"2020-04-24 21:18:14","typeName":"LeetCode","updateTime":"2020-04-24 21:18:14"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，从上到下打印二叉树-2</strong></h2>\n<p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>\n<p>例如:<br />给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>\n<p>3<br />/ \\<br />9 20<br />/ \\<br />15 7<br />返回其层次遍历结果：</p>\n<p>[<br />[3],<br />[9,20],<br />[15,7]<br />]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;BFS（广度优先搜索）：层次遍历</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * BFS\n     * @param root\n     * @return\n     */\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {\n        if (root == null) {\n            return new ArrayList&lt;&gt;(0);\n        }\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();\n        TreeNode current;\n        while (!queue.isEmpty()) {\n            List&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();\n            for (int i = queue.size(); i &gt; 0; i--) {\n                current = queue.poll();\n                arrayList.add(current.val);\n                if (current.left != null) {\n                    queue.add(current.left);\n                }\n                if (current.right != null) {\n                    queue.add(current.right);\n                }\n            }\n            list.add(arrayList);\n        }\n        return list;\n    }</code></pre>","blogGoods":0,"blogId":"1253350612905598976","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6huUyATZJ_AAAaZr2Bc1U363.jpg","blogRead":1,"blogRemark":"剑指offer----之从上到下打印二叉树----LeetCode102","blogTitle":"剑指offer----之从上到下打印二叉树----LeetCode102","createdTime":"2020-04-23 23:50:45","typeName":"LeetCode","updateTime":"2020-04-23 23:50:57"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，从上打印二叉树-1</strong></h2>\n<p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>\n<p>例如:<br />给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>\n<p>3<br />/ \\<br />9 20<br />/ \\<br />15 7<br />返回：</p>\n<p>[3,9,20,15,7]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;BFS（广度优先搜索）：也即是二叉树的层次遍历，代码和注意事项看代码注释</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 二叉树的层次遍历\n     * 这里是将层次遍历的结果存储在数组中\n     * 但是因为二叉树的节点个数并不知道\n     * 所以不能使用数组直接进行存储，因为无法初始化数组的大小\n     * 所以可以想到使用容量能自动扩充的list集合\n     * 然后再根据list集合的size来初始化数组的大小\n     * 并且将list元素赋值到数组中\n     * @param root\n     * @return\n     */\n    public static int[] levelOrder(TreeNode root) {\n        if(root==null){\n            return new int[0];\n        }\n        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n        TreeNode current;\n        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n        while(!queue.isEmpty()){\n            current = queue.poll();\n            list.add(current.val);\n            if(current.left!=null){\n                queue.add(current.left);\n            }\n            if(current.right!=null){\n                queue.add(current.right);\n            }\n        }\n        int[] result = new int[list.size()];\n        for (int i = 0; i &lt; list.size(); i++) {\n            result[i] = list.get(i);\n        }\n        return result;\n    }</code></pre>","blogGoods":0,"blogId":"1253346228108894208","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6htTeAUHGlAAAaZr2Bc1U102.jpg","blogRead":0,"blogRemark":"剑指offer----之从上到下打印二叉树","blogTitle":"剑指offer----之从上到下打印二叉树","createdTime":"2020-04-23 23:33:20","typeName":"LeetCode","updateTime":"2020-04-23 23:33:20"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，包含min函数的栈</strong></h2>\n<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>\n<p>&nbsp;</p>\n<p>示例:</p>\n<p>MinStack minStack = new MinStack();<br />minStack.push(-2);<br />minStack.push(0);<br />minStack.push(-3);<br />minStack.min(); --&gt; 返回 -3.<br />minStack.pop();<br />minStack.top(); --&gt; 返回 0.<br />minStack.min(); --&gt; 返回 -2.</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>&nbsp;辅助栈法：即初始化两个栈A,B</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;A栈用于实现基本的push(),pop(),top()的正常逻辑</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;B栈用来存放A栈中的非严格降序元素（这个我也理解不了，看代码就知道是存放什么的啦），代码中的方法注释很清楚</strong></p>\n<pre class=\"language-java\"><code>public class MinStack {\n    /** initialize your data structure here. */\n    Stack&lt;Integer&gt; A,B;\n\n    public MinStack() {\n        A = new Stack&lt;&gt;();\n        B = new Stack&lt;&gt;();\n    }\n\n    /**\n     * 入栈操作，元素先入A栈\n     * 如果B栈为空或者B栈的栈顶元素大于待入栈元素，则B栈也执行入栈操作\n     * @param x\n     */\n    public void push(int x) {\n        A.add(x);\n        if(B.isEmpty()||B.peek()&gt;=x){\n            B.add(x);\n        }\n    }\n\n    /**\n     * 这段代码优点巧妙\n     * 注意这里使用的A.pop()而不是A.peek()\n     * 所以这里实际上是分为两种情况的\n     * 第一种：当A的栈顶元素不为当前栈中的最小元素，即不等于栈B的栈顶元素\n     *         则只进行栈A的出栈操作，即A.pop()\n     * 第二种：当A的栈顶元素为当前栈中的最小元素，即等于栈B的栈顶元素\n     *        则不仅要A.pop(),而且为了保证A,B栈中最小元素的同步性\n     *        B栈也要执行出栈操作\n     */\n    public void pop() {\n        if(A.pop().equals(B.peek())){\n            B.pop();\n        }\n    }\n\n    /**\n     * 正常获取A的栈顶元素\n     * @return\n     */\n    public int top() {\n        return A.peek();\n    }\n\n    /**\n     * 获取A栈的最小元素，即B栈的栈顶元素\n     * @return\n     */\n    public int min() {\n        return B.peek();\n    }\n}</code></pre>","blogGoods":0,"blogId":"1253331349566234624","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hp12AMy2MAAAaZr2Bc1U568.jpg","blogRead":4,"blogRemark":"剑指offer----之包含min函数的栈---LeetCode155","blogTitle":"剑指offer----之包含min函数的栈---LeetCode155","createdTime":"2020-04-23 22:34:13","typeName":"LeetCode","updateTime":"2020-04-23 23:50:51"},{"blogCollection":0,"blogComment":0,"blogContent":"<h3><strong>晚上九点多，坐在床上，面前摆放着电脑，屏幕显示的是LeetCode中的《剑指offer》的题解</strong></h3>\n<h3><strong>此时的我毫无睡意，当然，这并不是因为解出一道题的喜悦冲淡了我的睡意</strong></h3>\n<h3><strong>相反的，这是一种难以言明的心情，包含着对自己无知的羞愧，也包含着别人面对如此无知的自己也能给出耐心回应的感动</strong></h3>\n<h3><strong>人有时或许就是这样，刻意的举动会让人心生防备，但是无意的善举却能温润人心</strong></h3>\n<h3><strong>别人无意的一个回答，一个小举动，一句肯定的话</strong></h3>\n<h3><strong>殊不知却能为对方赋予无穷无尽的能量</strong></h3>\n<h3><strong>将这一天的疲惫和劳累都消除</strong></h3>\n<h3><strong>赠人玫瑰，手有余香</strong></h3>\n<h3><strong>我一直抱着这样的一种心态，或许我无法做到赠人玫瑰，但是我会尽量将自己的善意展现给别人</strong></h3>\n<h3><strong>也许他刚刚好正处于某个难关，而你又刚刚好是他难关之初的引导者</strong></h3>\n<h3><strong>一句话，或许对于你来说只是人生中微不足道的几秒钟</strong></h3>\n<h3><strong>而对他来说，或许可能是多年之后回忆起来也能嘴角上扬的美好岁月</strong></h3>\n<h3><strong>想起前段时间一部剧里面的话，在这里也送给屏幕前的你：愿你永怀善意，清澈明朗</strong></h3>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1253326423486144512","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hosWANYd2AAHQzo49lBU641.jpg","blogRead":3,"blogRemark":"2020-4-23有感","blogTitle":"2020-4-23有感","createdTime":"2020-04-23 22:14:38","typeName":"随心日记","updateTime":"2020-04-25 21:22:30"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，顺时针打印矩阵</strong></h2>\n<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>\n<p>示例 1：</p>\n<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br />输出：[1,2,3,6,9,8,7,4,5]<br />示例 2：</p>\n<p>输入：matrix =&nbsp;[[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br />输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p>\n<p>限制：</p>\n<p>0 &lt;= matrix.length &lt;= 100<br />0 &lt;= matrix[i].length&nbsp;&lt;= 100</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;模拟顺时针打印的这种循环结构：设置四个边界条件，l,r,t,b。按照从左往右，从上往下，从右往左，从下网往上的顺序依次读取矩阵的元素，并且每一次都判断边界是否相遇，直到将整个矩阵元素都加入到数组中即可。</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 设置四个边界值，分别为left=0,right=matrix[0].length-1,top=0,bottom=matrix.length-1\n     * 顺时针顺序即先从左到右，再从上到下，再从右向左，再从下向上，每一次执行都要判断边界值\n     * @param matrix\n     * @return\n     */\n    public static int[] spiralOrder(int[][] matrix) {\n        if(matrix.length==0){\n            return new int[0];\n        }\n        int l = 0;\n        int r=matrix[0].length-1;\n        int t=0;\n        int b=matrix.length-1;\n        int x=0;\n        int[] res = new int[(r+1)*(b+1)];\n        while(true){\n            //从左向右\n            for(int i=l;i&lt;=r;i++){\n                res[x++]=matrix[t][i];\n            }\n            if(++t&gt;b) {\n                break;\n            }\n            //从上向下\n            for(int i=t;i&lt;=b;i++){\n                res[x++] = matrix[i][r];\n            }\n            if(--r&lt;l){\n                break;\n            }\n            //从右向左\n            for(int i=r;i&gt;=l;i--){\n                res[x++] = matrix[b][i];\n            }\n            if(--b&lt;t){\n                break;\n            }\n            //从下往上\n            for(int i=b;i&gt;=t;i--){\n                res[x++] = matrix[i][l];\n            }\n            if(++l&gt;r){\n                break;\n            }\n        }\n        return res;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1253250557729087488","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hXB2ASIQwAAAaZr2Bc1U016.jpg","blogRead":0,"blogRemark":"剑指offer-----之顺时针打印矩阵----LeetCode54","blogTitle":"剑指offer-----之顺时针打印矩阵----LeetCode54","createdTime":"2020-04-23 17:13:11","typeName":"LeetCode","updateTime":"2020-04-23 17:13:11"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，对称的二叉树</strong></h2>\n<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>\n<p>例如，二叉树&nbsp;[1,2,2,3,4,4,3] 是对称的。</p>\n<p>&nbsp; &nbsp; 1<br />&nbsp; &nbsp;/ \\<br />&nbsp; 2 &nbsp; 2<br />&nbsp;/ \\ / \\<br />3 &nbsp;4 4 &nbsp;3<br />但是下面这个&nbsp;[1,2,2,null,3,null,3] 则不是镜像对称的:</p>\n<p>&nbsp; &nbsp; 1<br />&nbsp; &nbsp;/ \\<br />&nbsp; 2 &nbsp; 2<br />&nbsp; &nbsp;\\ &nbsp; \\<br />&nbsp; &nbsp;3 &nbsp; &nbsp;3</p>\n<p>示例 1：</p>\n<p>输入：root = [1,2,2,3,4,4,3]<br />输出：true<br />示例 2：</p>\n<p>输入：root = [1,2,2,null,3,null,3]<br />输出：false</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>递归法：从对称的二叉树中我们可以找到如下规律</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果一个二叉树是对称的，则每一个节点的左右子树也是对称的,因此是递归的</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 设L = root.left，R=root.right，则满足L.left.val = R.right.val;L.right.val=R.left.val;</strong></p>\n<pre class=\"language-java\"><code>public boolean isSymmetric(TreeNode root) {\n        return  root==null?true:recur(root.left,root.right);\n    }\n    public boolean recur(TreeNode L,TreeNode R){\n        if(L==null&amp;&amp;R==null){\n            return true;\n        }\n        if(L==null||R==null||L.val!=R.val){\n            return false;\n        }\n        return recur(L.left,R.right)&amp;&amp;recur(L.right,R.left);\n    }</code></pre>","blogGoods":0,"blogId":"1252992659794968576","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6ga--AKQdvAAAaZr2Bc1U862.jpg","blogRead":1,"blogRemark":"剑指offer----之对称的二叉树----LeetCode101","blogTitle":"剑指offer----之对称的二叉树----LeetCode101","createdTime":"2020-04-23 00:08:23","typeName":"LeetCode","updateTime":"2020-04-23 00:12:33"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，二叉树镜像</strong></h2>\n<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>\n<p>例如输入：</p>\n<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; 2 &nbsp; &nbsp; 7<br />&nbsp;/ \\ &nbsp; / \\<br />1 &nbsp; 3 6 &nbsp; 9<br />镜像输出：</p>\n<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; 7 &nbsp; &nbsp; 2<br />&nbsp;/ \\ &nbsp; / \\<br />9 &nbsp; 6 3&nbsp; &nbsp;1</p>\n<p>示例 1：</p>\n<p>输入：root = [4,2,7,1,3,6,9]<br />输出：[4,7,2,9,6,3,1]</p>\n<p>限制：</p>\n<p>0 &lt;= 节点个数 &lt;= 1000</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;递归法：即递归的去交换根节点的左右子树，直到根节点为叶子节点</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用递归的方法，交换根节点的左子树和右子树\n     * 递归出口为，根节点为叶子节点\n     * @param root\n     * @return\n     */\n    public TreeNode mirrorTree(TreeNode root) {\n        TreeNode center = root;\n        if(center!=null){\n            TreeNode temp = center.left;\n            center.left = center.right;\n            center.right = temp;\n            mirrorTree(center.left);\n            mirrorTree(center.right);\n        }\n        return root;\n    }</code></pre>","blogGoods":0,"blogId":"1252985443281027072","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6gZTWABF55AAAaZr2Bc1U678.jpg","blogRead":0,"blogRemark":"剑指offer----之二叉树的镜像----LeetCode226","blogTitle":"剑指offer----之二叉树的镜像----LeetCode226","createdTime":"2020-04-22 23:39:43","typeName":"LeetCode","updateTime":"2020-04-22 23:39:43"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，合并两个有序链表</strong></h2>\n<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>\n<p>示例1：</p>\n<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br />输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br />限制：</p>\n<p>0 &lt;= 链表长度 &lt;= 1000</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>伪头节点法：即创建一个伪头节点head和一个用于辅助的节点cur</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法：如果l1.val&lt;=l2.val,就让cur指向l1，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l1指向其next</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果l1.val&gt;l2.val,就让cur指向l2，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l2指向其next</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;直到l1和l2有一个为空为止，让cur指向剩余的一个非空链表即可，若两个链表的长度为M,N则时间复杂度为O(M+N)</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用四节点，一个伪头节点，一个当前节点cur，已经链表的两个节点l1,l2\n     * 每次比较l1,l2节点的val大小，将小的节点连接到当前节点cur上即可\n     * 直到l1,l2有一个空，则将剩余的一个非空链表连接到cur尾部即可\n     * @param l1\n     * @param l2\n     * @return\n     */\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode head;\n        ListNode cur;\n        head = cur = new ListNode(0);\n        while(l1!=null&amp;&amp;l2!=null){\n            if(l1.val&lt;=l2.val){\n                cur.next = l1;\n                cur = cur.next;\n                l1 = l1.next;\n            }else{\n                cur.next = l2;\n                cur = cur.next;\n                l2 = l2.next;\n            }\n        }\n        if(l1!=null){\n            cur.next = l1;\n        }\n        if(l2!=null){\n            cur.next = l2;\n        }\n        return head.next;\n    }</code></pre>","blogGoods":0,"blogId":"1252980258446000128","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6gYGWAe-MZAAAaZr2Bc1U550.jpg","blogRead":0,"blogRemark":"剑指offer----之合并有序链表---LeetCode21","blogTitle":"剑指offer----之合并有序链表---LeetCode21","createdTime":"2020-04-22 23:19:06","typeName":"LeetCode","updateTime":"2020-04-22 23:19:06"}],"pageSize":15,"params":{},"sortColumn":"created_time","sortMethod":"DESC","totalCount":53,"totalPage":4},"msg":"操作成功!"}
2020-04-26 22:39:47.638 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listFront
2020-04-26 22:39:47.642 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 22:39:47.642 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 22:39:47.643 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeLists
2020-04-26 22:39:47.644 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 22:39:47.656 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/list
2020-04-26 22:39:47.658 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 22:39:47.658 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 22:39:47.658 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogList
2020-04-26 22:39:47.660 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=ASC)]
2020-04-26 22:39:50.104 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 2448
2020-04-26 22:39:50.112 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，数据库设计--表的命名规范等</strong></p>\n<p>（1），统一采用bl_开头对表进行命名</p>\n<p>（2），对于数据比较重要的表统一添加四个字段，分别为：created_time(创建时间),update_time(修改时间),version(版本号),deleted(删除字段)</p>\n<p>（3），数据库表的字段尽量都设置为NOT_NULL</p>\n<p>（4），数据库中表varchar类型字段需要设置长度的尽量设置为2<sup>n</sup>-1</p>\n<p>（5），因为博客系统分为前台展示界面和后台管理，所以对于有些表，例如bl_type（博客类型表），bl_music（音乐表）等设置了enable（启用字段）</p>\n<p><strong>二，上述第二条--四个字段的解释</strong></p>\n<p>（1），为什么要设置created_time和update_time字段：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;其一，从数据库的通用性上来说，设计这两个字段是必要的，但也需要根据业务的需要来合理添加这两个字段，因为无用的字段会浪费空间，性能，影响系统的运行。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 其二，大部分的应用都有需要根据时间进行排序的功能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 其三，当系统发生异常的时候，我们可以通过这两个字段对异常进行排查和定位。</p>\n<p>（2），为什么要设置version字段：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 1，version字段含义：字段的含义与其字面意思一样，代表版本，在这里作为乐观锁进行使用，从而保证不会出现脏数据的情况。下面解释一下什么叫乐观锁，以及乐观锁和悲观锁</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 2，乐观锁：总是假定最好的情况，即每次用户调用接口从数据库中取出数据到修改数据前的过程中，不会有其它用户对当前数据进行修改，这样在当前用户修改数据的时候，利用版本机制即判断取出的version字段和当前数据库该条数据的version字段是否相等来判断该条数据是否已经被修改，如果未修改，则予以修改（且version字段递增），如果已经修改，则提示用户更新失败。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 悲观锁：总是假定最坏的情况，即每次用户调用接口从数据库取出数据的时候，都认为该条数据会被修改，因此每次取出数据都对数据进行加锁处理，只允许当前用户进行修改，其它用户阻塞，直到当前用户修改完毕。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3，为什么使用乐观锁而不使用悲观锁：因为悲观锁比较浪费性能</p>\n<p>（3），为什么设置deleted字段：deleted字段在这里作为一个逻辑删除字段（0否1是），何为逻辑删除，即执行删除操作操作的时候，不会真正的删除数据库中的数据，而是将deleted字段设置为1即可。&nbsp;这样如果用户出现误删的操作，可以通过数据库修改该字段进行数据的恢复。</p>\n<p><strong>三，上述第三条--数据库表字段尽量设置为NOT_NULL</strong></p>\n<p>（1），数据库表字段尽量设置为NOT_NULL：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 1，有些人可能认为设置为NULL相比于NOT_NULL不是更节省空间吗？但是实际上不是这样的，设计为NULL相比于NOT_NULL要多占用一个字节的空间</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 2，设计为NOT_NULL，这样在做查询的时候能够更好的避免空指针异常，且发生该类错误的时候能够更好的进行排查</p>\n<p><strong>四，上述第四条--表varchar类型字段长度尽量设置为2<sup>n</sup>-1</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>因为计算机只识别二进制，且有一定的范围，例如2<sup>8</sup>，在计算机中的范围为-128~127,因此对于varchar字段长度来说，如果设置为255，则正好是一个字节，而如果设置为256，则占用两个字节，这样会浪费计算机的内存空间，因此数据库varchar类型字段的长度最好设置为2<sup>n</sup>-1</p>\n<p><strong>五，上述第五条--对于设置enable字段的解释</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>enable字段，字面意思启用，在这里表明是否启用（0否1是），因为系统分为前台博客页面和后台管理，对于这两个不同的前端项目，后台可以通过启用字段来控制内容在前台博客页面的展示与否，与deleted字段不同的是，如果执行删除操作，那么我们只能通过手动修改数据库中的字段进行数据的恢复，且如果执行删除操作，则该数据在前台博客页面和后台管理页面都无法看见。但是如果将数据弃用（即修改enable字段值为1），则表明该数据被弃用，在前台博客页面无法显示，但是在后台管理页面可以看见，且无需通过手动修改数据库来恢复数据，可以在后台管理页面操作启用数据。</p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1247745014683947008","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dDViAcnjvAACb6PL1tzA485.jpg","blogRead":21,"blogRemark":"博客开发总结（一）-----之数据库设计篇","blogTitle":"博客开发总结（一）-----之数据库设计篇","createdTime":"2020-04-08 04:36:07","typeName":"博客开发和维护总结","updateTime":"2020-04-20 10:47:54"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，前后端分离开发优势</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，</strong>项目开发过程中，前后端完全解耦，前端只需要负责页面的实现，只需要通过接口拿数据。后端不需要管页面的跳转，只需要负责接口的编写</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，</strong>前后端人员有更多的精力去负责自己的工作，前端人员可以将更多的精力投放在页面的编写，页面的美化，页面特效的制作和用户体验上；而后端人员可以将更多的精力放在接口代码的优化，sql优化，jvm调优上面</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，</strong>前后端分离的项目部署的时候，前端项目往往都是部署在nginx服务器上，而前后端不分离的项目往往都是部署再一台服务器上。因此前后端分离项目大大降低了服务器的负担</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>4，</strong>前后端不分离的项目使用模板引擎例如freemaker，thymeleaf等，前后端人员交流起来较为困难。且前端项目使用原生的DOM操作，极大的增加了前端工作人员的工作量。而前后端分离项目前端通常都是用各种ui框架，框架采用MVVM模式，极大的减轻了前端工作人员的工作量</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，</strong>前后端分离开发，前端可以通过easy-mock来伪造接口数据进行测试，后端人员可以通过postman进行接口测试，开发效率大大提升。</p>","blogGoods":0,"blogId":"1247867141693128704","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dG6CAI6ipAACiM2P5LtI65.jpeg","blogRead":7,"blogRemark":"前后端分离开发的优势所在","blogTitle":"闲谈前后端分离开发","createdTime":"2020-04-08 12:41:25","typeName":"随笔","updateTime":"2020-04-20 11:48:53"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，css之弹性布局</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，</strong>何为弹性布局？</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 弹性布局是css的一种新的布局方式，所谓&ldquo;弹性布局&rdquo;，即页面随着不同设备的屏幕大小拉伸会自适应页面的大小。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，</strong>弹性布局的两种主要元素，container（弹性容器），item（弹性子元素），一个弹性容器中可以放入多个弹性子元素，元素之间是可以进行嵌套的，弹性子元素也可以设置为弹性容器，里面再嵌套弹性子元素。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，</strong>弹性布局的基本属性</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （1）display：flex，声明容器为弹性布局</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （2）flex-direction：声明弹性容器内部元素的排列方式，默认为row。row（横向布局），row-reverse（横向布局，但是元素反方向码），column（纵向布局），column-reverse（纵向布局，但是元素反着码）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （3）flex-wrap：声明弹性盒子中的元素是否可以换行，默认为nowrap（不换行），wrap（换行），wrap-reverse（换行，但是反着码）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （4）align-items：设置容器中元素在纵轴方向上的对齐方式，默认为stretch（即如果不设置子元素高度，则默认拉伸至于容器同宽度），flex-start（子元素位于容器的开始位置），flex-end（子元素位于容器的结尾处），center（元素依纵轴方向居中），baseline（元素位于容器基线，不过没怎么用过，所以不是很清楚）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （5）justify-content（设置元素在主轴上的对齐方式），默认为flex-start（元素从容器主轴开始位置码），flex-end（元素从容器主轴结尾处码），center（元素位于主轴居中处），space-between（元素布局在容器的两端），space-around（元素布局在容器两端，但是元素前后都留有空白）因为项目中大多数只使用了对于容器的操作，对于容器中元素的操作很少，所以这里只介绍这点。谢谢阅读！</p>","blogGoods":0,"blogId":"1248135765829918720","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dGnuAWkLLAAAaRXQXNms575.jpg","blogRead":3,"blogRemark":"CSS----之flex弹性布局","blogTitle":"CSS----之flex弹性布局","createdTime":"2020-04-09 06:28:51","typeName":"CSS","updateTime":"2020-04-20 11:43:57"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2 style=\"text-align: left;\"><strong>一，JVM运行机制</strong></h2>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;jvm即java虚拟机，一共由四个部分组成，分别是类加载器子系统，运行时数据区（程序计数器，本地方法区，jvm栈，方法区，jvm堆），执行引擎（即时编译器，垃圾收集器），本地接口库。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;一个java源程序的运行先是经过编译器将其编译成字节码文件（class文件），然后通过类加载器子系统将其加载进入jvm&mdash;&mdash;&gt;程序运行过程中，运行时数据区存放程序运行过程产生的数据&mdash;&mdash;&gt;执行引擎中的垃圾收集器收集程序运行过程中创建的不再使用的对象，即时编译器将程序的字节码文件编译成机器码&mdash;&mdash;&gt;然后本地接口库利用机器码调用本地方法库中的方法，和操作系统实现交互。</p>\n<h2><strong>二，多线程</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;</strong>在多核操作系统中，jvm支持一个进程中同时并发执行多个线程，且这些线程和本地操作系统的线程相对应。当jvm中的对象初始化，内存空间分配等一系列准备工作完成之后，会调用操作系统中的接口创建一个原生线程，原生线程初始化完毕后，会调用java线程的run（）方法执行该线程，线程结束之后，jvm会释放原生线程和java线程资源。</p>\n<h2><strong>三，JVM的内存区域</strong></h2>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM的内存区域主要分为线程私有区域（程序计数器，本地方法区，JVM栈），线程共享区（方法区，JVM堆）和直接内存。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;程序计数器：线程私有区域，无内存溢出，用来记录程序运行过程中的字节码指令地址，如果是Native方法，则程序计数器为空。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM栈：线程私有区域，用来描述java程序的运行过程，java程序运行每次运行的时候，都会创建一个栈帧，方法的执行和返回对应着栈帧的入栈和出栈操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;本地方法区：线程私有区域，和JVM栈的功能一样，只不过是用来记录Native方法的运行过程。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM堆：线程共享区，主要用来存放程序运行过程中产生的数据，同时也是垃圾收集器进行垃圾回收的主要区域。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;方法区：也被称为永久代，用来存放常量，静态变量，类信息等等。</p>\n<h2><strong>四，JVM的运行时内存</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>JVM的运行时内存又被称为JVM堆，因为JVM的GC算法使用的是分代收集算法，所以JVM堆按照GC标准可以分为三个区域分别为：新生代，老年代，永久代。其中新生代占1/3，老年代占2/3，永久代很少，</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;新生代：存放短生命周期，小对象的区域。新生代又分为Eden区，ServivorTo区，ServivorFrom区，区域的GC算法采用复制算法。Eden区是用来存放新创建的对象（大对象除外），ServivorTo区是用来保存MinorGC幸存下来的对象，ServivorFrom区是用来将上一次MinorGC幸存下来的对象作为下一次MinorGC的扫描对象。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;老年代：存放长生命周期的大对象，区域的GC算法采用标记整理算法</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;永久代：主要用来存放class和meta数据信息的。程序运行过程中不会进行永久代的垃圾回收，这也就导致永久代区域的数据会越来越多，最终造成内存溢出。java8之后永久代已经被元数据区取代，元数据区和永久代的功能都是一样的，但是最大的不同在于永久代区域依赖于虚拟机的内存大小，因而可以存储的class，meta信息非常有限。但是元数据区依赖的是本地操作系统，因而不会受到虚拟机内存的限制。</p>\n<h2><strong>五，垃圾回收与算法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;(1)垃圾回收：</strong>Jvm的垃圾回收判定依赖于两种方法，引用计数法和可达性分析法。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;引用计数法：即如果想要在程序中使用对象，就必须赋予一个引用，这样在对象赋予引用的时候将其引用计数加1，删除一个引用时，将对象引用计数减1，如果引用计数为0，就说明该对象已经不使用，作为垃圾。但是引用计数法存在一个缺陷，即循环引用的问题，如果两个对象相互引用，则这两个对象的引用计数永远都不会为0，造成对象无法被回收。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;可达性分析法：即先创建一些根节点对象ROOTS，然后通过这些根节点对象向下搜索，如果一个对象到任意一个ROOTS之间都没有可达路径，在经过两次标记（下文解释为什么进行两次标记），还是没有可达路径，则说明该对象可回收。</p>\n<p>&nbsp;&nbsp; &nbsp;<strong>（2）GC算法：</strong>常见的GC算法有四种，分别为标记清除算法，复制算法，标记整理算法，分代收集算法</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;标记清除算法：即在进行垃圾回收前，对所有对象进行一次标记，标记可回收的对象，然后进行清理即可。但是标记清除算法在清除回收对象之后，并不会对堆内存进行整理，这样的话如果内存中的对象大部分为小对象，清理之后就会导致没有大片连续的内存空间，即造成了内存碎片化，这样大对象存储的时候就无法找到相应的完整连续内存。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;复制算法：即将内存分为两块同等大小的区域，区域1和区域2，创建的新对象都存储在区域1中，当区域1中的内存占满之后，会对内存中的所有对象进行一次标记，标记存活的对象，将存活的对象复制到区域2，这时区域1中的对象都是可回收对象，回收区域1中的所有对象即可。但是复制算法也存在着一定的缺陷，即每次都只能使用一半的内存空间，造成了大量的内存浪费。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;标记整理算法：即结合标记清除算法和复制算法的优点，先对所有的对象进行标记，标记存活的对象，将存活的对象复制到内存的另一端，然后清除当前端的对象即可。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;分代收集算法：前面的三种算法，都无法按照对象的类型进行收集，分代收集算法正是解决这个问题，按照对象的不同类型采用不同的GC算法。以JVM的分代收集算法为例，JVM的堆内存分为新生代，老年代，永久代。新生代又分为Eden区，ServivorTo区和ServivorFrom区。新生代因为其存储生命周期短的小对象，GC比较频繁，所以采用复制算法。程序运行过程中创建的对象都存储在Eden区（大对象除外，大对象直接复制到老年代区域）。当Eden区的内存不够的时候进行MinorGC，然后将Eden区和ServivorFrom区的存活对象都复制到ServivorTo区，然后将ServivorTo区和ServivorFrom区进行交换，再次进行MinorGC。老年代因为存放的都是生命周期长的大对象，因而进行GC的不会太频繁，且清除的对象并不会太多，因而采用标记整理算法。老年代每次进行MajorGC之前都会先进行一次MinorGC，当MinorGC之后新生代的内存仍然不够的时候，将对象复制到老年代进行MajorGC。永久代区域主要回收常量，无用class等。</p>\n<h2><strong>六，JAVA中的四种引用类型</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;强引用类型<strong>：</strong>即把对象赋给一个引用变量，强引用的对象一定为可达状态，所以不会进行垃圾回收。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;软引用类型：通过SoftReference类实现，当内存不够的时候对其进行GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;弱引用类型：只有弱引用类型的对象，一定会被GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;虚引用类型：虚引用对象主要是用来跟踪对象的GC状态</p>\n<h2><strong>七，分代收集算法和分区收集算法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>分代收集算法：新生代因其存放大量短生命周期小对象，且GC频繁，所以采用复制算法。老年代因其存放长生命周期大对象，且GC不平凡，所以采用标记整理算法。永久代，回收常量，类信息等。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;分区收集算法：即将堆内存区域分为大小不同的区，可以按照不同的区进行快速垃圾回收，减少系统的停顿时间。然后再以并行的方式逐步完成整个GC。</p>\n<h2><strong>八，垃圾收集器</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>新生代区域：Serial垃圾收集器，单线程复制算法，因为单线程无需进行线程之间的交互和切换，所以效率非常高，是JVM默认的client模式下的默认垃圾回收策略，工作期间需要暂停其它所有的线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ParNew垃圾收集器，多线程复制算法，跟单线程Serial一样，是JVM默认的server模式下的垃圾回收策略，工作期间需要暂停所有其它线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Parallel Scavenge垃圾收集器：多线程复制算法，不同的是优先考虑系统吞吐量，可以利用更高效的利用CPU完成GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;老年代区域：Serial Old垃圾收集器，单线程标记整理算法，同新生代的Serial功能一样，只是采取的算法不同而已。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Parallel Old垃圾收集器：多线程标记整理算法，优先考虑了系统的吞吐量，其次考虑停顿时间。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CMS,多线程标记清除算法，优先考虑系统GC时的停顿时间，且过程分为四步（<span style=\"background-color: #ffff00;\">解释上文的可达性分析中的两次标记</span>，第一步：标记GC ROOTS可达对象，暂停其它工作线程；第二步：和用户线程一起工作，跟踪GC ROOTS；第三步，因为第二步用户进程没有暂停，所以有些对象状态</p>\n<p>可能发生了改变，重新进行标记；第四步，清除不可达对象）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; G1垃圾收集器，多线程标记整理算法，将内存分区，与CMS相比，一方面不会产生内存碎片，一方面，可以精确的控制系统停顿时间。</p>\n<h2><strong>九，JAVA的网络编程模型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;</strong>阻塞I/O模型：即用户线程发出I/O请求之后，内核会检查数据是否准备就绪，这时候用户线程始终处于阻塞状态等待数据准备就绪。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;非阻塞I/O模型：即用户线程不断的给内核发出I/O请求，内核接受到I/O请求之后会返回一个状态，如果数据准备就绪，就将数据复制进入用户线程，如果数据没有准备好，返回一个false，用户线程无需阻塞，可以去处理其它事情，而当数据准备好了且刚好用户线程发起I/O请求进行操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;多路复用I/O模型：多路复用I/O模型通过一个Selector线程轮询Socket的状态，如果Socket有读写事件，则进行I/O操作。此模型的优势在于可以更好的处理连接数众多但消息体不大的情况下。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;信号驱动I/O模型：即用户线程发出一个I/O请求，系统会为该请求创建一个信号函数，用户请求可继续执行其它业务逻辑，当内核数据准备就绪之后会返回给用户线程一个信号，用户线程接收到之后进行I/O操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;异步I/O模型：用户线程给内核发起一个asynchronous read操作，内核接收到之后，返回其请求是否成功，然后等待数据准备成功之后复制到用户线程。整个过程中请求的发起和数据读取都在内核中进行，最终发送一个信号告知用户线程I/O操作已经完成，用户直接使用数据就行。（说实话个人感</p>\n<p>觉和信号驱动很像）</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;java NIO：没怎么读懂（<span style=\"background-color: #993300;\">记得补充！</span>）</p>\n<h2><strong>十，JVM的类加载机制</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>JVM类加载分为五个阶段：加载，验证，准备，解析，初始化</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;加载：即将class文件加载到JVM中，且创建class对象，封装其数据结构。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;验证：对class文件进行验证，确保符合JVM的标准，保证JVM的安全。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;准备：即方法区中给类变量分配空间和赋初值。static修改的会在初始化阶段赋值，final修饰的会在准备阶段赋值。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;解析：即将常量池中的引用替换为直接引用</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;初始化：执行类构造器进行初始化。（因为内部流程不是很清楚，所以对于其几种不进行初始化的情况不做说明）</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;类加载器：JVM提供了三种类加载器，启动类加载器（/lib），扩展类加载器(/lib/ext)，应用程序类加载器(classpath)。还可以再应用程序类加载器自定义类加载器。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;双亲委派机制：即当一个类接收到类加载请求的时候，不会自己进行加载，而是将其加载请求委派给其父类加载器，这样一路委派，最终加载请求都会委派到启动类加载器.启动类加载器接收到加载请求之后会去lib目录下寻找相关的class文件，若找不到，则将其加载请求再委培给子类加载器，一路委派，直到能够加载。</p>\n<h3><strong>最后，送给大家一张博主画的JVM的思维导图，以后读《深入JVM虚拟机》的时候可能会出一个JVM专题：<a href=\"https://uploader.shimo.im/f/X0MX3hLaHrevltxW.png!thumbnail\" target=\"_blank\" rel=\"noopener\">JVM思维导图</a></strong></h3>\n<p>&nbsp;</p>\n<h2>水平有限，若发现有误，还望指出！</h2>","blogGoods":0,"blogId":"1248224512563068928","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHLeALxSjAABJTVJPTfk677.jpg","blogRead":17,"blogRemark":"面试（一）------之JVM篇","blogTitle":"面试（一）------之JVM篇","createdTime":"2020-04-09 12:21:30","typeName":"java面试篇","updateTime":"2020-04-20 11:53:29"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，Linux的发展历史</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; </strong>1965年之前，电脑并不像现在这么普遍，除了军事机构和研究即构，一般人基本接触不到电脑，而且那时候的一台大型主机最多也就只能支持30台终端。为了解决数量问题，1965年之后，由贝尔实验室，麻省理工学院以及通用电气一起放弃了Multics项目，准备让大型主机能够支持300台终端，但是在开发过程中，进度缓慢，最终由于资金的短缺，贝尔实验室推出了研究。1969年，从这个项目中退出的Ken Thompson在家无聊，为了让电脑能够运行&ldquo;星际旅行&rdquo;游戏，因而趁着妻子回家探亲的一个月，独自写出了Unix操作系统的原型（！！！！牛批）。1970年，这个人以BCPL语言为基础，又写出了很接近硬件的B语言，并且用B语言写出了第一个Unix操作系统。但是由于B语言的跨平台性比较差，为了解决这个问题。Dennis Ritchie和Ken Thompson决定以B语言为基础开发一种新的语言，1972年，Dennis Ritchie最终设计出了一种新语言，他以BCPL的第二个字母命名，也就是我们后来熟知的C语言。随后两人便迫不及待的用C语言重现Unix操作系统。Unix系统起初开源，但是在Unix7之后，由于政策的变化，代码闭源化，因而大学中不能使用Unix的源代码进行教学。Andrew S. Tanenbaum教授为了能够让学生更好的理解代码细节，在完全不使用任何源代码的情况下开发除了Minix---小型Unix。但是因为其只用于教学，功能并不强大，因而Torvalds以此为基础，开发除了Linux，但是起初Linux并不支持Unix，最终经过全世界网友的帮助，最终让其能够兼容各种硬件。</p>\n<p><strong>二，文件和目录</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; 1，windows和linux的区别：</strong>我们熟知的windows系统，它的文件系统是分盘符的，盘符下的文件构成一个树形结构，但是Linux文件系统没有盘符，所有文件目录都在根目录/之下</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;<strong>2，Linux需要记住的目录：</strong>/bin（存放系统命令的目录），/sbin（只有超级管理员能访问的命令文件目录），/root（存放和root用户相关文件的目录），/etc（存放系统配置文件的目录），/usr（存放系统共享资源的目录），/opt（存放安装的第三方软件的目录，通常在/usr/local下）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;<strong>3，文件权限：</strong>Linux中的文件权限有读（r，可用于数字4表示），写操作（w，可用数字2表示），执行权限（x，可用数字1表示）</p>\n<p><strong>三，常用命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，ls：</strong>列出目录中的所有目录和文件名&nbsp; -a（列出所有，包括隐藏文件和目录），-l（以列表形式列出所有），-h（人性化列出，需要配合-l使用，即文件大小转换为我们熟知的kb，mb等），-d（显示当前目录属性），命令可以联合使用，例如-al，-lh等等。&nbsp;&nbsp;&nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，cd：</strong>用于切换目录，需知（.和..是相对路径，.表示当前目录，..表示上级目录；/表示绝对路径），cd ~（切换到root目录），cd - （切换到前一次切换的目录）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，clear：</strong>清屏</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，pwd：</strong>显示当前所在目录</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，mkdir：</strong>创建目录，-p（如果目录存在则不创建，如果不存在则创建目录再创建自目录），可以一次性创建多级目录，例如：mkdir&nbsp; -p test/test1</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，touch：</strong>创建空文件</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>7，cp：</strong>复制，-r（递归复制目录下的文件目录信息），-i(提示是否覆盖)，-v（显示复制进度）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>8，mv：</strong>移动文件，不过经常用来给文件进行重命名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>9，rm：</strong>删除目录或者文件，-r（递归删除），-f（强制删除），-v（显示删除进度）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>10，cat：</strong>查看文件内部信息</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>11，ln：</strong>文件创建链接，ln 源文件 目标链接文件（创建硬链接，硬链接和源文件大小相同，修改同步，但是删除不同步，使用较少），ln -s（创建软连接，相当于我们平时创建快捷方式，使用较多）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>12，which：</strong>搜索命令所在位置，例如：which&nbsp; &nbsp;ls</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>13，find：</strong>搜索文件所在位置&nbsp; 例如：find&nbsp; &nbsp;test.conf</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>14，grep：</strong>文件内容搜索，例如：grep &ldquo;想要搜索的内容&rdquo;&nbsp; 源文件</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>15，tar：</strong>归档命令，-c（打包成.tar文件），-z（打包的同时压缩），-v（打包的同时显示进度），-f（放在最后，后面跟.tar.gz），-x(解压)，常用：tar -zcvf&nbsp; <em><strong>.tar.gz&nbsp; &nbsp; ;&nbsp; &nbsp; tar -zxvf</strong> tar.gz</em> -C&nbsp; 指定解压目录&nbsp;&nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;还有more，head，tail等命令，不过这些不常用。</p>\n<p><strong>四，用户权限命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，whoami：</strong>查看当前账户的用户名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，who：</strong>查看当前登录用户</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，exit：</strong>退出登录</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，adduser/useradd：</strong>添加用户，-d（指定用户主目录），-g（指定用户用户组），-m（自动建立目录），默认情况下用户主目录和用户组名都和用户名一样</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，passwd：</strong>只有root用户才能使用，用于修改用户密码</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，userdel：</strong>删除用户，默认不删除用户的主目录，-r（删除用户主目录）</p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;7，su：</strong>切换账户</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>8，groupadd/groupdel：</strong>添加用户组和删除用户组</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>9，groups：</strong>查看用户所在用户组，例如：groups&nbsp; 用户名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>10，usermod：</strong>修改用户所在用户组，例如：usermod&nbsp; 用户组名 用户名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>11，chmod：</strong>修改文件权限，例如：chmod&nbsp; 777&nbsp; test</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>12，chown：</strong>修改文件所有者，例如：chown&nbsp; &nbsp;用户&nbsp; 文件名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>13，chgrp：</strong>修改文件所在组，例如：chgrp&nbsp; 组名&nbsp; 文件名</p>\n<p><strong>五，系统命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，cal：</strong>查看日历</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，date：</strong>查看时间，可以设置格式，例如：date '+<span class=\"ql-token hljs-built_in\">%Y</span>-<span class=\"ql-token hljs-built_in\">%m</span>-<span class=\"ql-token hljs-built_in\">%d</span> <span class=\"ql-token hljs-built_in\">%H</span>:<span class=\"ql-token hljs-built_in\">%M</span>:<span class=\"ql-token hljs-built_in\">%S</span>'</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，ps：</strong>查看线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，kill：</strong>杀死线程，-9（强制杀死）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，查看网卡信息：</strong>centos6：ifconfig ；centos7：ip addr</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，ping：</strong>查看网址或者链接的连通性</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>7，防火墙：</strong>centos6：service&nbsp; iptables&nbsp; status（查看防火墙状态），service&nbsp; &nbsp;iptables&nbsp; &nbsp;start(开启),service&nbsp; iptables&nbsp; stop(关闭);centos7:firewall-cmd&nbsp; --state（查看防火墙状态），systemctl&nbsp; start&nbsp; firewalld.service(启动)，systemctl&nbsp; &nbsp;stop&nbsp; firewalld.service（关闭）</p>\n<p><strong>六，网络命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，wget：</strong>下载，例如：wget&nbsp; &nbsp;链接地址</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，yum：</strong>下载安装</p>\n<p><strong>七，vim（这里只说几个常用的命令）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;</strong>vim有三种模式：命令模式，插入模式，编辑模式&nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;vim&nbsp; 文件名：进入文件，且处于命令模式；iao任意一键进入插入模式（i表示在贯标之前插入，a光标之后插入，o在下一行插入），：进入编辑模式</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;命令：set:nu显示行号，set:nonu不显示行号；/strinng，向后搜索字符串，？string向后搜索字符串；：w保存，：wq保存并退出，：q不保存退出</p>","blogGoods":0,"blogId":"1248500061625745408","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dDA6AfCOJAAAyfL52jxY706.jpg","blogRead":2,"blogRemark":"Linux基本命令总结","blogTitle":"Linux基本命令","createdTime":"2020-04-10 06:36:25","typeName":"Linux","updateTime":"2020-04-20 10:42:25"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，集合</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，List：</strong>list是java中一种有序的集合，下有三个实现类，分别为ArrayList，Vector，LinkedList</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ArrayList：基于数组实现，增删慢，查询快，线程不安全。因为其基于数组实现，所以查询的时候可以直接根据数组的索引下标进行快速查询，但是进行增删操作的时候，需要将待增删元素后的元素全部移动，因而效率较低。且ArrayList创建时不需要分配初始大小，其空间不够的时候，会自动创建一个更大的list，然后复制数据。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Vector：基于数组实现，和ArrayList一样增删慢，查询快。但是线程安全，因为同一时间只支持一个线程对Vector进行写操作，然而因为要进行频繁的加锁和释放锁的操作，所以效率要低于ArrayList。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; LinkedList：基于双向链表实现，增删快，查询慢。因为基于链表实现，增删元素的时候，只需要改变元素的指针即可，改动较小，效率较高。然而进行查询操作的时候，需要从链表头部进行遍历，因而效率较低。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，Queue：</strong>队列，满足先进先出，种类较多。（不作详细解释）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，set：</strong>具有独一无二的特性，常用来存储无序且不重复的元素，对象相等的本质是hashcode的值相同，而如果想要比较两个对象是否相等，需要重写对象的hashcode方法和equals方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;hashset：基于hashTable实现，无序。存放的是对象的散列值，即通过hashcode计算得到的值</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;treeset：基于二叉树实现，即其中的对象按照一定的排序方式进行排列（升序，降序），每次添加对象的时候，都会进行排序，将其插入指定位置。基本的数据类型例如Integer，String等可以使用treeset默认的排序方法，而自定义数据类型需要实现compareable接口，实现compareTo方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;LinkHashSet：继承自hashset，只不过使用双向链表记录数据的顺序。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，map：</strong>一种键值对形式的集合</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;hashmap：基于数组+链表实现，增删改查操作快，但是每次遍历hashmap元素的顺序无法保证且线程不安全。如果想要其线程安全，可以使用synchronizedMap和ConcurrentHashmap，hashmap的内部是数组，数组中的每一个元素又是一个单向链表，链表中的每个元素嵌套一个Entry实例，其中包括Key，Value，Hash值，指向下一个节点的next。每次查询的时候，可以根据元素的hash值很快定位所在数组，但是定位之后需要遍历链表查找元素，因而时间复杂度为O（n），但是Java8之后对其进行了优化，将其改为了数组+链表或红黑树的结构，即当链表中的元素大于8个的时候，链表会转换为红黑树（红黑树是一种特化的二叉平衡树，因为其左右子树的深度差可以大于1），这样查询的时间复杂度就缩短到了O（logN）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ConcurrentHashmap：采用分段锁的思想进行并发操作，因而使线程安全的。由多个Segment组成，只要保证每个Segment线程安全就可以保证全局线程安全。ConcurrentHashmap的默认Segment即并发度为16，可以在初始化的时候修改，但是初始化之后不能再修改。每个Segment内部的实现和hashmap一样&middot;。Java8之后也和hashmap进行了一样的优化。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;HashTable：线程安全，即同一时刻只能有一个线程对其进行操作，并发度不如ConcurrentHashmap。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;TreeMap：基于二叉树数据结构实现，实现了SortedMap，默认按照键值的升序进行排列。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;LinkedHashMap：Hashmap的子类，只不过使用链表保存元素的插入顺序。使用迭代器遍历的时候按照插入顺序遍历。</p>\n<h2><strong>二，异常分类及处理</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;1，异常分类：</strong>Throwable是所有异常类的父类，其下有error和Exception，Error下有AwtError，ThreadDeath；Exception下有RuntimeException和CheckedException。</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</strong>对于Error类异常通常是由内部错误和资源耗尽造成的，无法在程序运行期间对其进行捕获和处理，对于这类错误我们只能记录错误的原因和终止程序。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; Exception中的RuntimeException异常（运行时异常）：这类异常是我们程序中异常处理的核心，可以在程序中进行捕获并处理。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Exception中的CheckedException异常（检查异常）：这类异常时程序中需要强制捕获的异常，通常有IO异常，SQL异常等等。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，异常处理：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>异常处理有两种方式：抛出异常和捕获异常</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;抛出异常有三种方法：throws，throw，系统自动抛出。其中throws是作用在方法上，后面跟的是可能产生的异常类。throw是作用在方法内部，后面跟的是具体的异常对象。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 捕获异常：即使用try{}catch语句进行捕获</p>\n<h2><strong>三，反射机制</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，什么叫做反射机制？</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>即在程序运行的过程中，可以获取类的属性和方法，并且可以调用任意一个类的方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，反射机制的使用</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 首先，获取类的class对象，有三种方式，className.getClass()，类对象.class，Class.forName(\"类路径\")，其中最后一种最为安全，性能最好。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 然后利用反射的API可以实现对类中信息的操作，例如getDeclareFields（），getDeclareMethods（），getConstroctors（）等等。反射创建类的对像有两种方法，一，class.newInstance()初始化一个类实例；二，先获取其构造器，然后利用构造器初始化一个实例。利用反射调用类的方法：先获取方法，然后调用method.invoke()执行方法。</p>\n<h2><strong>四，注解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，四种元注解：</strong>@Target（指定注解的使用范围），@Retention（定义注解的保留级别，有三级，SOURCE源程序中保存，CLASS文件中保存，RUNTIME运行时保存），@Documented（可以工具文档化），@Inherited（<span style=\"background-color: #ffff00;\">这个没怎么看懂</span>）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，注解使用示例：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>第一步，定义注解接口</p>\n<pre class=\"language-java\"><code>@Target(ElementType.FIELD)  \n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface FruitProvider {\n\n    //id\n    public int id() default  -1;\n\n    //供应商名称\n    public String name() default \"\";\n\n    //供应商地址\n    public String address() default \"\";\n\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 第二步，使用注解</p>\n<pre class=\"language-java\"><code>public class Apple {\n\n    @FruitProvider(id = 1,name = \"红富士苹果\",address = \"陕西\")\n    private String appleProvider;\n\n    public String getAppleProvider() {\n        return appleProvider;\n    }\n\n    public void setAppleProvider(String appleProvider) {\n        this.appleProvider = appleProvider;\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第三步，定义注解处理器</p>\n<pre class=\"language-java\"><code>public class FruitInfoUtil {\n    public static void getFruitInfo(Class&lt;?&gt; clazz) {\n        String strFruitProvider = \"供应商信息:\";\n        Field[] declaredFields = clazz.getDeclaredFields();\n        for (int i = 0; i &lt; declaredFields.length; i++) {\n            if (declaredFields[i].isAnnotationPresent(FruitProvider.class)) {\n                FruitProvider annotation = declaredFields[i].getAnnotation(FruitProvider.class);\n                strFruitProvider += annotation.id() + \",\" + annotation.name() + \",\" + annotation.address();\n                System.out.println(strFruitProvider);\n            }\n        }\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第四步，主方法入口</p>\n<pre class=\"language-java\"><code>public class FruitRun {\n    public static void main(String[] args) {\n        FruitInfoUtil.getFruitInfo(Apple.class);\n    }\n}</code></pre>\n<h2><strong>五，内部类</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 1，静态内部类：</strong>即在类的内部定义的静态类，静态内部类可以访问外部了的静态变量和方法，外部也可以通过outClassName.innerClassName调用内部类</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2，成员内部类：</strong>在类的内部定义的没有用static修饰的内部类，使用方式和静态内部类一样。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>3，局部内部类：</strong>即一个类只在一个方法中使用，则完全可以将这个类定义为这个方法的内部类，即局部内部类，局部内部类可以实现真正的对外隐藏</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>4，匿名内部类：</strong>通常用于继承一个类或者实现一个接口的时候，使用new关键字定义，例如:Person person = new Student(){new Pupil(){}}</p>\n<h2><strong>六，泛型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 1，为什么要使用泛型：</strong>其根本目的是为了实现代码的复用，举个开发中常见的例子，我们需要定义返回类Result，返回类中包含状态码code，信息msg，以及数据data（任意类型），这个时候我们就需要使用泛型，因为我们返回的数据类型有各种vo，pojo类对象，list等。这时候泛型类result就可以被各种对象使用，实现代码的复用，简化开发。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>2，泛型标记和泛型限定：</strong>E表示集合中的元素，K表示键值，V表示value，N表示数值类型，T表示任意类型（包含基础类型，所有的对象类型），？（不确定的java类型）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>泛型限定：</strong>向上限定，&lt;?&nbsp; extends T&gt;，向下限定，&lt;? super&nbsp; T&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; <strong>3，泛型方法：</strong>即参数类型定义为泛型类型，以便于接收不同类型的参数，做出不同的处理。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>4，泛型类：</strong>例如public class Pair&lt;T&gt;{private T data;}</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>5，泛型接口：</strong>与放泛型类类似</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>6，类型擦除：</strong>即在泛型编译的过程中，会将泛型类型替换为限定类型的操作</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>7，明确的一点：</strong>虚拟机在运行程序的过程中，内部是没有泛型的，只有普通的类和方法。</p>\n<h2><strong>7，序列化</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 序列化是为了确保对象及其状态的持久化</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>序列化的使用：</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </strong>首先，实现序列化接口java.io.Serializble</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 然后，声明序列化ID，通常private static final&nbsp; long&nbsp; serialVersionUid&nbsp; = ***</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 因为序列化是保证对象及其状态的持久化，而静态变量是不属于对象，属于类本身的，所以序列化无法保存静态变量。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果需要序列化父类变量，则父类也要实现Serializable接口</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t'ransient修饰的属性不会序列化</p>\n<h3><strong>最后，提供一张思维导图供大家学习：<a href=\"https://images-cdn.shimo.im/es83SQH0CggucT7f__thumbnail\" target=\"_blank\" rel=\"noopener\">JAVA基础</a></strong></h3>\n<p>&nbsp;</p>\n<h2>水平有限，如有错误，还望指出！</h2>","blogGoods":0,"blogId":"1248605157059497984","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHMKAcvZ8AABJTVJPTfk020.jpg","blogRead":27,"blogRemark":"面试（二）------之JAVA基础篇","blogTitle":"面试（二）------之JAVA基础篇","createdTime":"2020-04-10 13:34:02","typeName":"java面试篇","updateTime":"2020-04-20 11:53:39"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，JAVA线程的创建方式</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>JAVA线程的创建有四种方式，分别为，继承Thread类，实现Runable接口，实现Callable&lt;Class&gt;接口，基于线程池。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>1，继承Thread方式：创建一个类继承Thread类，创建类的实例对象，调用start方法，继而执行线程的run（）方法，代码如下：</strong></p>\n<pre class=\"language-java\"><code>public class NewThread extends Thread{\n    public static void main(String[] args) {\n        NewThread thread = new NewThread();\n        thread.start();\n    }\n    @Override\n    public void run(){\n        System.out.println(\"create  a  new thread by Thread!\");\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>2，当子类已经继承了一个类，这时候就没法再继承Thread类了，这时候就可以实现Runable接口，实例化类的线程实例，创建Thread实例传入类的实例，执行start方法，继而执行run（）方法代码如下：</strong></p>\n<p>&nbsp;</p>\n<pre class=\"language-java\"><code>public class ThreadExample2 implements Runnable {\n    public static void main(String[] args) {\n        ThreadExample2 threadExample2 = new ThreadExample2();\n        Thread thread = new Thread(threadExample2);\n        thread.start();\n    }\n    @Override\n    public void run() {\n        System.out.println(\"create a new thread by Runnable!\");\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，有些情况下，我们需要再一个主线程中并发多个子线程执行同一个任务，然后回收子线程的返回值整理汇总，这时候就需要实现Callable&lt;Class&gt;接口，重写其call（）方法，用于计算结果。然床创建一个线程池用于提交线程，继而执行call方法，并且创建一个Future的list用于接收子线程逻辑代码即call方法的返回，最终遍历list，得到想要的返回值，如下：</strong></p>\n<pre class=\"language-java\"><code>public class ThreadExample3 implements Callable&lt;String&gt; {\n\n    private String name;\n\n    public ThreadExample3(String name){\n        this.name = name;\n    }\n\n    @Override\n    public String call() throws Exception {\n        return name;\n    }\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        ExecutorService pool = Executors.newFixedThreadPool(3);\n        List&lt;Future&gt; list = new ArrayList&lt;&gt;();\n        for(int i=0;i&lt;3;i++){\n            ThreadExample3 threadExample3 = new ThreadExample3(i+\"\");\n            Future future =pool.submit(threadExample3);\n            System.out.println(future.get().toString()+\" is running\");\n            list.add(future);\n        }\n        pool.shutdown();\n        for (Future future : list) {\n            System.out.println(\"currentThread's result is \"+future.get().toString());\n        }\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，基于线程池创建线程</strong></p>\n<pre class=\"language-java\"><code>public class ThreadExample4 {\n    public static void main(String[] args){\n        ExecutorService pool = Executors.newFixedThreadPool(3);\n        for(int i=0;i&lt;3;i++){\n            pool.execute(new Runnable() {\n                @Override\n                public void run() {\n                    System.out.println(\"thread  is running by FixedThreadPool\");\n                }\n            });\n        }\n        pool.shutdown();\n    }\n}</code></pre>\n<h2>二，线程池的工作原理</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong> &nbsp;1，概述：</strong>JVM根据用户提供的参数创建一定数量的线程任务，将其放入队列中，线程创建之后启动这些任务，如果线程的数量大于核心线程数量（用户设置的线程数量），则超出数量的线程排在队列中等待，当有线程任务执行完毕后，线程池调度器就会发现有可用可用线程，继而从队列中取出任务继续执行<strong>。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; </strong><strong>2，线程复用：</strong>（参见JDK源码解读，这里只做简单描述），由前可知，JVM会根据用户提供的参数创建一定数量的线程任务，且将其添加到任务队列中。JVM通过start（）方法创建一个线程之后， 会相应的为其创建一个任务队列，线程会不停的查看任务队列，如果任务队列中有任务，则调用run方法，执行，这样就达到了一次start（）创建线程，多次使用，完成线程复用的任务。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>3，线程池的核心组件和核心类（见JDK源码分类中关于线程的总结）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; </strong><strong>4，JAVA线程的工作流程：</strong>线程池刚被创建的时候，只是向系统申请一个执行线程队列和管理线程池的线程资源，当调用execute方法之后，执行下列流程：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果正在运行的线程数量小于corePoolSize（核心线程数量，即用户定义的的线程数量），则立即创建线程执行线程任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果正在运行的线程数量大于或等于corePoolSize，则将超过数量的线程加入到阻塞队列中</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在阻塞队列已满且线程数量小于MaximumPoolSize（即线程池能够容纳的最大线程数），线程池会创建非核心线程立即执行任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在阻塞队列已满且线程数量大于或等于MaximumPoolSize的时候，线程池会拒绝该线程任务且抛出异常</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在线程任务执行完毕之后，会将其从任务队列中移除，从队列中取出下一个线程任务执行</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在线程处于空闲状态且空闲时间超过KeepAliveTime，且线程数量大于corePoolSize的时候，会停止该线程，这样在没有任务的时候，线程池中的线程数始终维持在corePoolSize。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，线程池的拒绝策略：</strong>分为四种，分别为AbortPolicy，CallerRunsPolicy，DiscardOldestPolicy，DiscardPolicy</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; AbortPolicy：直接抛出异常，阻止线程运行，源码如下：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</p>\n<pre class=\"language-java\"><code>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n            throw new RejectedExecutionException(\"Task \" + r.toString() +\n                                                 \" rejected from \" +\n                                                 e.toString());\n        }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CallerRunsPolicy：如果线程任务没有关闭，则尝试执行该线程任务，源码如下：</p>\n<pre class=\"language-java\"><code>* @param r the runnable task requested to be executed\n* @param e the executor attempting to execute this task\n*/\npublic void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n     if (!e.isShutdown()) {\n         r.run()\n     }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DiscardOldestPolicy：移除任务队列中最早进入的线程任务，执行当前任务线程，源码如下：</p>\n<pre class=\"language-java\"><code>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n       if (!e.isShutdown()) {\n           e.getQueue().poll();\n           e.execute(r);\n       }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DiscardPolicy：直接丢弃线程任务，不做任何处理</p>\n<h2><strong>三，五种常用的线程池</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;newCachedThreadPool（可缓存线程池）：</strong>当线程池创建线程的时候如果发现有可复用的线程（执行完任务，且未关闭的线程），则直接复用，如果没有则创建新线程。可缓存线程池可以高效的利用执行任务时间短的线程，提高系统的性能，且线程池中的线程如果空闲时间超过60s，则会被终止且从缓存中移除，这样可缓存线程池不会占用系统资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>newFixedThreadPool（固定大小的线程池）：</strong>即线程池中的线程是初始化固定的，当任务线程大于线程池中线程数量时，任务线程就会进入阻塞队列等待。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newScheduledThreadPool（可做任务调度的线程池）：</strong>即可以设置线程执行的停顿时间和执行周期，进行定期定时的执行某个任务。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newSingleThreadPool（单个线程的线程池）:&nbsp;</strong>即线程池中永远只有一个线程进行工作，如果下称停止或者异常，则线程池创建新的线程替代当前线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newWorkStealingPool（足够大小的线程池）：</strong>即创建足够数量的线程的线程池，保证更快的进行运算，提高效率。</p>\n<h2><strong>四，线程的生命周期</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;线程的生命周期大致分为五个阶段：新建（new），就绪（Runnable），运行（Running），阻塞（Blocked），死亡（Dead）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;新建：</strong>即使用new创建一个线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>就绪：</strong>调用start方法，</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>运行：</strong>即线程获取cpu资源，执行run（）方法，进入运行状态，运行状态的线程如果调用yield（线程让步方法）或者失去cpu资源，都会导致线程重新回到就绪态；如果调用sleep方法，I/O阻塞，等待同步锁，等待通知以及suspend挂起都会导致线程进入阻塞态。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞：</strong>即线程被放入Blocked池。阻塞状态的线程如果结束了sleep方法，I/O方法返回，获取同步锁，收到通知或者resume都会导致其重新进入就绪态，与其它线程竞争cpu时间片。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>死亡：</strong>线程正常执行完run（）或者call（）方法，或者执行stop方法，或者发生异常或者错误都会导致线程死亡。（stop方法会导致锁混乱和死锁，不建议使用）</p>\n<h2><strong>五，线程的基本方法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;wait（线程等待）：</strong>会让线程进入WAITING状态，并且会释放对象的锁。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>sleep（线程睡眠）：</strong>会让线程进入睡眠，进入TIMED_WAITING状态，但是不会释放对象锁，睡眠时间到了之后，再次恢复运行状态</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>yield（线程让步）:</strong>&nbsp; 当前线程会让出其占有的cpu资源，重新回到就绪态和其它线程竞争cpu时间片</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>interrupt（线程中断）:&nbsp; </strong>中断当前线程，但是并不会导致其停止，只是改变其内部的终端标识位，在使用了thread.sleep()之后使用该方法，会导致抛出异常，且我们可以利用中断标识位进行线程的安全退出</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>join（线程加入）：</strong>即将当前线程进入阻塞态，等待下一个线程执行完毕后进入就绪态，重新竞争锁资源。通常用于主线程下面执行子线程，需要主线程阻塞，等待子线程执行完毕后返回其结果给主线程，主线程再执行的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>notify（线程唤醒）/notifyAll：</strong>前者随机唤醒一个等待线程，后者全部唤醒</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>setDaemon（守护线程）:</strong>级别较低的线程，用于后台运行，服务用户用户线程，例如垃圾收集线程就是典型的守护线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>sleep方法和wait方法的区别：</strong>前者属于Thread，后者属于Object，前者不会释放锁资源，后者会释放锁资源</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>start方法和run方法：</strong>start方法只是创建一个线程，并没有运行，run方法时执行线程的真正代码逻辑。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>线程退出的方式：</strong>见四中最后一条</p>\n<h2><strong>六，JAVA中的锁（知识比较杂乱）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述:JAVA中的锁是为了保护数据的一致性。按照不同的标准可分为乐观锁和悲观锁，公平锁和非公平锁，共享锁和独占锁，偏向锁，轻量级锁，重量级锁，自旋锁，可重入锁。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;乐观锁：</strong>即认为每次读取数据都不会被修改，当修改操作的时候再判断当前数据是否被修改，未修改则修改，若已被修改，则返回失败状态。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>悲观锁：</strong>即认为每次读取数据都会被修改，因而每次读取数据都对其进行加锁，这样只有当前用户可以修改，其它用户阻塞等待直到当前用户修改完毕释放锁资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>自旋锁：</strong>即有些线程任务的执行很短，很快就可以释放锁资源，为了避免在这种情况下竞争线程仍然进行内核态和用户态之间的转换，因而让线程自旋（即等一会），如果有可用锁，则获取，减少了线程在用户态和内核态之间切换的时间损耗。提高了性能（优势）。当然线程自旋是占用cpu资源的，因而需要设置一个自旋的最大等待时间，如果超过此时间，则线程退出自旋模式。对于线程竞争锁资源激烈的情况，自旋有可能会导致cpu资源的损耗（劣势）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>公平锁和非公平锁：</strong>即根据线程竞争锁资源的机制判定，一般如果依据先到先得的原则，则位公平锁；如果依据就近原则，则位非公平锁。公平锁相比于非公平锁会更加耗费性能，因为要维护一个线程任务丢列，根据线程任务在队列中的顺序分配锁资源，因而不常用。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>可重入锁：</strong>又被称为递归锁，即该锁可以然后线程对其进行多次的加锁操作。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>偏向锁：</strong>当线程获取到锁的时候，用来消除线程的锁重入的开销（看起来是偏袒这个线程）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>共享锁和独占锁：</strong>共享锁即多线程共享锁资源（典型例子，读锁）；独占锁即当前锁只能有一个线程获取，其它线程阻塞</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>轻量级锁：</strong>没有多线程竞争的前提下，减少重量级锁的使用提高性能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>重量级锁：</strong>基于操作系统的互斥量而实现的锁，会导致进程在用户态和内核态之间切换，耗费性能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>synchronized：独占式悲观锁，可重入锁，非公平锁，重量级锁。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 作用范围：</strong>作用于成员变量和非静态方法，相当于锁住的是对象的实例，即this对象</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;作用于静态方法，相当于锁住的是class实例</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;作用域代码块，相当于锁住的代码块中的对象</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>实现原理：</strong>内部包括ContentionList（锁竞争队列），EntryList（竞争候选列表），WaitSet（等待集合），OnDeck（竞争候选者），Owner，!Owner，其中ContentionList是用来存放竞争锁资源的线程。EntryList是用来存放有资格竞争锁资源的线程。调用wait方法后放入WaitSet中，onDeck指的是同一时刻，只有一个线程竞争锁资源，Owner指的是得到锁资源的线程，!Owner指的是线程执行完毕，释放锁资源的线程。需要注意的是线程首先采用的都是自旋模式获取锁资源，如果自旋获取不到再加入ContentionList，而且Owner状态的线程并不是直接把锁资源交给onDeck状态线程，而是给它竞争锁资源的权利，因而onDeck状态的线程还需要跟自旋线程竞争锁资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>ReentrantLock：独占式，可重入锁，并且可以实现公平锁和非公平锁，重量级锁。</strong></p>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;用法：</strong>lock()加锁，后跟try代码块，finally中进行释放锁unlock()</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;避免死锁的方法：</strong>响应中断（即可以根据情况中断对锁资源的请求），可轮询锁（tryLock（）即尝试获取锁，如果有可用锁则获取返回true，没有则返回。和lock（）的区别在于lock获取锁资源如果没有则一直等待直到获取到锁资源），定时所（tryLock（time,unit）即再一定时间内如果有可用锁，且线程未中断则获取锁，否则禁用当前线程。）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>Semaphore（信号量）:</strong>机制和ReentrantLock类似</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ReadWriteLock（读写锁）：</strong>如果系统要求支持多线程共享读，但不能多线程写，使用读锁；如果要求同一时刻只能有一个线程写，写的过程中不能读取该共享数据，则使用写锁。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; <strong>分段锁：</strong>一种思想，将数据分段加锁，例如ConcurrentHashMap</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;死锁：</strong>即线程之间互相共享资源会导致死锁</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; <strong>锁优化：</strong>第一，减少锁的持有时间；第二：减小锁粒度，例如分段锁；第三：锁分离，例如读写锁；第四：锁粗化，放置锁粒度太小，造成频繁加锁释放锁；第五：锁消除，消除程序代码不规范而造成的乱用了锁</p>\n<p>&nbsp;</p>\n<h3><strong>并发编程（上）的思维导图送上：<a href=\"https://images-cdn.shimo.im/1UcHkyrlJyGRPYnn.png__thumbnail\" target=\"_blank\" rel=\"noopener\">并发编程（上）</a></strong></h3>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>\n<h1>水平有限，如果错误，还望指出！</h1>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;</p>","blogGoods":0,"blogId":"1249313090567143424","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHM2AQOeZAABJTVJPTfk967.jpg","blogRead":8,"blogRemark":"面试（三）------之并发编程篇（上）","blogTitle":"面试（三）------之并发编程篇（上）","createdTime":"2020-04-12 12:27:07","typeName":"java面试篇","updateTime":"2020-04-20 11:53:51"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，redis简介</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>redis是NoSQL型系统之一，与之相似的还有Memcache，用来存储key-value这种键值型数据。相比于Memcache而言，redis不仅可以做临时缓存，还可以做数据持久化，将数据定时的存入硬盘或者将命令追加到日志文件当中。而Memcache只能做临时缓存，因而现在基本上已经被redis完全取代。redis的读写速度非常快，官方给出的数据是读110000次/s，写81000次/s；而且redis支持多种数据类型，例如String，list，hash，set，zset；redis支持主从复制（集群），进行数据持久化；还支持过期时间，事务等。</p>\n<h2><strong>二，redis的安装与启动（docker环境下）</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;docker安装完毕后，安装redis：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第一步：拉取redis镜像，docker&nbsp; pull&nbsp; redis</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第二步：启动redis，docker&nbsp; &nbsp;run&nbsp; &nbsp;redis&nbsp; &nbsp;</p>\n<p><strong>三，基本知识串讲</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>单进程单线程：redis只有一个进程，且内部为单线程，这样做的优势是不存在线程安全问题，且不需要进行线程间的切换，提高了性能，而且多线程可能会涉及到锁。劣势是无法发挥多核cpu的优势，不过可以通过开启搭建多个redis实例实现</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>redis中默认有16个数据库（0-15），可以通过select n来进行数据库之间的切换</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;常用的基本命令：flushDB（清空当前数据库），flushAll（清空所有数据库），dbSize（查看有多少数据库）</p>\n<h2><strong>四，redis基本数据类型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;string：</strong>字符串类型，数据库中存储Map&lt;String,String&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>list：</strong>列表数组类型，数据库中存储Map&lt;String,List&lt;Object&gt;&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>hash：</strong>哈希类型，数据库中存储Map&lt;String,Map&lt;Object,Object&gt;&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>set：</strong>集合类型，其中元素无序，数据库中存储Map&lt;String,Set&lt;Object,Object&gt;&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>Zset：</strong>有序集合类型，每个元素都有一个可用于排序的权重</p>\n<h2><strong>五，redis相关命令（这里详解一些常用的命令，不常用的一笔带过）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;string：</strong>(1)set&nbsp; key&nbsp; value,插入一条数据&nbsp; （2）mset&nbsp; key value...批量插入 （3）setnx&nbsp; key value&nbsp; 若无则插入（4）get&nbsp; key&nbsp; 获取某条数据&nbsp; （5）mget keys 批量获取&nbsp; （6）getrange key&nbsp; 0 -1获取数据库全部数据&nbsp; （7）incr age 递增&nbsp; (8) incrby&nbsp; age&nbsp; 10&nbsp; 递增 age 步长为10（9）decr&nbsp; age&nbsp; 递减&nbsp; （10）decrby&nbsp; age&nbsp; 10 步长递减&nbsp; &nbsp;（11）del&nbsp; key&nbsp; 删除某条数据&nbsp; <span style=\"background-color: #ffff00;\">（12）exists&nbsp; key&nbsp; 判断是否存在某个key&nbsp; &nbsp;(13)expire&nbsp; key&nbsp; 10&nbsp; 设置过期时间（单位为秒）&nbsp; （14）pexpire&nbsp; key&nbsp; 1000 设置过期时间，单位为毫秒&nbsp; （15）persist key删除过期时间 （</span><span style=\"background-color: #ffff00;\">16）ttl&nbsp; key&nbsp; 查看过期时间</span></p>\n<p><span style=\"background-color: #ffff00;\">&nbsp;<span style=\"background-color: #ffffff;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>list：&nbsp;&nbsp;</strong>（1）lpush&nbsp; key&nbsp; value 左插入一条数据&nbsp; &nbsp;（2）lpush mylist&nbsp; key&nbsp; value....批量左插入&nbsp; （3）rpush&nbsp; key value 右插入一条数据&nbsp; (4)rpush&nbsp; mylist&nbsp; key value...右批量插入&nbsp; （5）lrange&nbsp; mylist&nbsp; 0&nbsp; -1&nbsp; 取出数据集合&nbsp; （6）lpop mylist 左弹出集合中第一条数据&nbsp; （7）rpop&nbsp; </span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">mylist&nbsp; 右弹出集合中第一条数据&nbsp; （8）llen&nbsp; mylist&nbsp; 获取数据集合长度lrem&nbsp; mylist&nbsp; count&nbsp; value&nbsp; （count&gt;0,从表头开始搜索，移除count个与值与value相等的元素；count&lt;0,表尾开始；count=0，移除所有值与value相等的元素） （9）linsert mylist&nbsp; before/after&nbsp; a&nbsp; 在a元素前或后插入。</span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">(10) lpoplpush&nbsp; list&nbsp; list1 转移列表的元素到另一个列表</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>hash：</strong>（1）hset&nbsp; key&nbsp; &nbsp;val-key&nbsp; val-val&nbsp; 插入一条数据&nbsp; （2）hset&nbsp; myhash&nbsp; name&nbsp; xxx&nbsp; 用于给哈希表中的字段赋值，不存在则创建哈希表赋值，存在则覆盖旧值&nbsp; (3) hget&nbsp; &nbsp;myhash&nbsp; name&nbsp; 取哈希表中某个值&nbsp; （4）hmset&nbsp; myhash name&nbsp; xxx age xxx&nbsp; 批量插入字段&nbsp; （5）hmget</span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">批量获取 （6）hgetall&nbsp; myhash&nbsp; 获取哈希表中所有值&nbsp; (7)&nbsp; hexisets myhash&nbsp; name&nbsp; 判断哈希表中是否存在name字段&nbsp; （8）hsetnx&nbsp; myhash score 100 若存在则不插入，若不存在则插入数据&nbsp; （9）hincrby&nbsp; myhash id 1/hdecrby&nbsp; myhash id&nbsp; 10 递增递减 （10）hdel&nbsp; myhash name&nbsp; </span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">删除&nbsp; （11）hkeys&nbsp; myhash&nbsp; 只取key值&nbsp; （12）hvals&nbsp; myhash&nbsp; 只取value值&nbsp; （13）hlen&nbsp; myhash 获取哈希表长度</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>set：</strong>（1）sadd myset&nbsp; redis&nbsp; 添加一条数据&nbsp; （2）smembers myset&nbsp; 获取数据集合&nbsp; （3）srem&nbsp; myset&nbsp; set1&nbsp; 删除set1&nbsp; （4）sismember myset&nbsp; set1 判断set中是否存在set1&nbsp; (5)srandmember&nbsp; key count&nbsp; 随机获取count个元素（6）spop&nbsp; 从集合中弹出一个元素</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>zset：</strong>之后补充</span></span></p>\n<h2><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">六，redis配置文件（常见配置）</span></span></strong></h2>\n<p><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;daemonize no：</span></span></strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">redis默认不是以守护进程的方式运行的，可以更改为yes启用守护进程（即后台运行）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>pidfile&nbsp; /var/run/redis.pid&nbsp; :</strong>启用守护进程后，默认将pid写入/var/run/redis.pid文件，可以更改</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>port&nbsp; 6379 ：</strong>redis默认端口</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp; &nbsp; &nbsp; &nbsp; <strong>bind&nbsp; 127.0.0.1：</strong>绑定的主机地址</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\"> &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>timeout&nbsp; 300</strong><strong>：</strong>redis客户端闲置多长时间后关闭连接，改为0的话，表示关闭该功能</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>loglevel&nbsp; verbose：</strong>默认日志级别（还有debug，notice，warning）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>database 16：</strong>redis默认有16个数据库可以修改</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>save&nbsp; 900&nbsp; 1/save&nbsp; 300&nbsp; 10/save&nbsp; 60&nbsp; 10000：&nbsp;</strong>表示一定时间内有多少条数据发生修改，就将其同步到数据文件一次，例如第一个表示15分钟内有一条数据发生改变就同步</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>rdbcompression yes&nbsp; ：</strong>表示数据存储到本地数据库时是否进行压缩</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>dbfilename&nbsp; dump.rdb：</strong>指定本地数据库文件名</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>dir&nbsp; /...../redis安装目录/bin ：</strong>本地数据库存放目录，默认在redis安装目录的bin目录下</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>slaveof&nbsp; &nbsp;masterip&nbsp; masterport ：</strong>设置当本机为从机时，它的主机的ip和端口</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>masterauth&nbsp; &lt;master-password&gt;：</strong>当master服务设置了密码时，slav服务连接master的密码</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>requirepass&nbsp; foobared：</strong>默认关闭redis连接需要密码，当给redis设置了密码，就需要打开</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>maxclients&nbsp; &nbsp;128：</strong>redis同一时间最大连接客户端的数量</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>appendonly&nbsp; &nbsp;no：</strong>是否开启aof持久化，默认不开启，采用rdb</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>appendfilename&nbsp; appendonlu.aof：</strong>指定aof持久化的文件名</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>appendfsync&nbsp; everysec :</strong>指定更新日志条件，默认每秒更新一次（还有no，指等操作系统进行数据缓存到磁盘，快；always指每次更新操作后都手动写入磁盘，慢但安全）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;虚拟机方面的配置暂不说明</span></span></p>\n<h2><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">七，redis持久化</span></span></strong></h2>\n<p><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;概述：</span></span></strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">redis持久化主要有两种方式，即rdb和aof</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>rdb：</strong>适用于大数据集的恢复，数据的备份，但是因为设置周期时间进行数据的快照，所以如果redis宕机，可能会丢失最后一个写操作的数据，因为数据完整性较差。数据保存在dump.db文件中，只需要移动到redis安装目录，重启即可恢复数据</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>aof：</strong>适用于对数据的完整性要求较高的情况，因为可以设置不同的持久化策略，例如每秒保存一次，这样即时redis宕机，也只会丢失最后一秒的数据。但是因为其日志文件存储的是写入命令，因而其文件大小要大于rdb的数据文件，且每次重启，都要从头执行数据文件中的命令，因而恢复速度也</span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">要慢于rdb。</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>注意：</strong>当rdb和aof同时开启的时候，redis重启，默认会采用aof的形式进行数据的重新构建</span></span></p>\n<h2><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">八，redis事务</span></span></strong></h2>\n<p><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;概述：</span></span></strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">什么是事务？事务即是一系列的命令要买全部执行，要么全部回滚</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <strong>常用命令：</strong>multi(启动事务)，discard（取消事务）,exec（执行事务块内命令）,watch key(监控某个key的变化)，unwatch（取消对所有key的监控）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>注意：</strong>redis的事务中在命令本身出错的情况下会造成命令的全部回滚，但是在命令无错，执行某个命令的时候发生异常的时候，则谁的错，谁停止（这一点和mysql是不同的）</span></span></p>\n<h2><strong>九，redis的主从复制</strong></h2>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>redis的主从复制，即主机数据更新后根据我们设置的策略将数据同步到从机上，主机以写为主，从机以读为主<strong>。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 使用：</strong>配主不配从，在从机中使用slaveof&nbsp; 主机ip&nbsp; &nbsp;主机端口配置从机，但是这种配置方式当redis重启之后就会失效，如果想要redis重启仍然可用，则需要配置redis.conf配置文件中的slaveof&nbsp; masterip&nbsp; masterport。这种配置方式的问题所在，中心化只有一台极其支持写操作，如果主机宕机，则从机等待，且从机宕机重启后不会跟上大部队（即重启后变为主机）。当然我们可以采用命令slave&nbsp; no&nbsp; one 使从机反客为主，成为主机。但是这种手动操作太过麻烦。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>哨兵模式：</strong>即配置之后，如果主机宕机，则哨兵会自动根据投票规则在从机中进行选举，从而产生新的主机顶替。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>主从复制的缺点：</strong>因为所有的写操作都是子主机上进行，从而在同步到从机上，所以存在着一定的延迟，当系统繁忙或者从机数量较多的时候，这种问题就更加明显。</p>\n<h2><strong>十，redis集群</strong></h2>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;概述：</strong>集群是一种去中心化的模式，与中心化模式不同的是，中心化模式中如果主服务挂掉了，那么服务就挂掉了。但是集群模式下，没有主路由，每个节点自身都可以成为路由</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;redis集群：即配置多台主机，多台从机，不同的主机中有不同的槽点，当执行数据写入时，会根据crc16算法计算出数据的槽点，从而将数据存入到对应的主机中，并同步到与其对应的从机中</p>\n<p>&nbsp;</p>\n<h1>水平有限，如有错误，还望指出！</h1>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1249588251598041088","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6caUuADBI7AAAb07iHSRw500.jpg","blogRead":4,"blogRemark":"redis基础（一）","blogTitle":"redis基础（一）","createdTime":"2020-04-13 06:40:30","typeName":"redis","updateTime":"2020-04-20 16:47:37"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，线程上下文切换</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>cpu利用时间片轮询的方式来为每个任务都分配一定的时间片，任务的执行过程中保存任务的状态。任务状态的保存和在加载就叫做上下文切换。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>进程：</strong>指的是一个运行中的程序实例，一个进程中可以有多个线程，并且与进程共享同样的内存和系统资源</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong> 上下文：</strong>指的是寄存器和程序计数器保存的线程的信息</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>寄存器：</strong>指的是内存中很小但是运行速度很快的一块区域（相对于RAM外部内存）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>程序计数器：</strong>一种寄存器，用来保存当前执行指令的位置或者下一个待执行指令的位置</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>上下文切换：</strong>上下文切换指的是操作系统的内核在cpu上对进程或者线程的切换。上下文信息保存在进程控制块中（PCB）。流程如下：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;挂起当前进程，将进程的上下文信息保存在进程控制块中；</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;在进程控制块中寻找下一个任务的上下文信息。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;恢复进程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>上下文切换的原因：</strong>第一，任务正常执行完毕，调度下一个任务；第二，线程出现I/O阻塞，被挂起，cpu调度下一个任务；第三，线程等待同步锁，获取socket通知等，被挂起，cpu调度下一个任务；第四，用户调用sleep方法，让出cpu；第五，硬件中断</p>\n<h2><strong>二，JAVA阻塞队列</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>阻塞队列的是调度当前队列的线程处于阻塞状态</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 消费者阻塞：如果队列为空，则消费者线程被挂起，处于阻塞状态，当有新数据进入队列，则消费者线程被唤醒，消费数据</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 生产者阻塞：如果队列数据已满，则生产者线程挂起，处于阻塞状态，当队列有空闲位置，生产者线程被唤醒，生产数据。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞队列的主要操作：</strong>插入操作和移除（获取）操作</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>插入操作：</strong>add(e)，有空间则插入，无空间报异常；offer(e),有空间则插入，无空间返回false；offer(e,time,unit),有空间插入，无空间等待time时间，若超时返回false；put(e),有空间插入，无空间则线程挂起处于阻塞直到有空间</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>移除操作：</strong>poll(e),有值返回值，无值返回null;poll(e,time,unit),有值返回值，无值等待time时间，超时返回null;take(e),有值返回值，无值等待新数据进入再立即返回；drainTo(collection&lt;Object&gt;)批量移除，提高获取效率</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞队列的实现：</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong> ArrayBlockingQueue：</strong>基于数组的有界阻塞队列，按照先进先出顺序对元素进行排序</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>LinkedBlockingQueue：</strong>基于链表的有界阻塞队列，队头队尾采用不两个不同的锁控制数据同步，并发性高</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>PriorityBlockingQueue：</strong>基于优先级的无界队列，默认升序排列，可以自定义排序规则，根据优先级访问数据。但是有数据优先级一样的情况</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>DelayQueue：</strong>支持延时的队列，即从队列中取数据时等待一定的时间才能获取元素。可以用于缓存系统的设计，设计过期时间，也可以用来设置定时调度任务，即如果能够从队列中获取，说明到了任务的调度时间。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>SynchronousQueue</strong>：该队列是一个不存储元素的阻塞队列，每一个put操作都必须等待一个take操作的完成。吞吐量高于ArrayBlockingQueue和LinkedBlockingQueue。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>LinkedTransferQueue：</strong>基于链表的无界阻塞队列，多了transfer方法(如果消费者等待，直接将任务从生产者传递给消费者，无消费者等待，则将任务加到队尾直到被消费才返回)和tryTransfer（与transfer一致，只不过不管有没有消费者等待获取都会立即返回tryTransfer（e,time,unit）（与tryTransfer一致，只不过设置了超时时间）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>LinkedBlockingDeque：</strong>基于链表的双向阻塞队列，可以在两端同时进行读写操作，提高了队列的操作效率。</p>\n<h2><strong>三，并发关键字</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;CountDownLatch：</strong>适用于一个主线程等待子线程完成任务之后执行（原理：设置一个程序计数器，计数器的值为子线程的个数，子线程并发执行，每个子线程执行完毕后，调用CountDown方法，将其计数器的值减去1，值为0时，唤醒主线程执行）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>CyclicBarrier：</strong>即当所有线程到达一个状态共同执行。await（）方法：确保所有线程到达Barrier状态才执行；await（time,unit）：设置一个超时时间，超过这个时间，执行达到Barrier状态的线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>Semaphore：</strong>因为其限制了多线程访问资源的线程个数，所以适用于多线程并发访问有限资源的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>volatile：</strong>直接用来修饰变量，是一种比Synchronized更加轻量级的机制，用于多线程共享同一变量，可以同时对其进行读写操作。当多个线程共享变量的时候，读取变量将其从内存复制到cpu缓存中，然后线程对其操作进行修改，这样再多cpu的情况下，有可能出现线程修改原数据造成数据不一致的情况，使用volatile关键字直接将线程修改的变量存入内存，解决这个问题。</p>\n<h2><strong>四，多线程共享数据</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>多线程共享数据主要通过共享内存实现，而共享内存的可见性，有序性，原子性已经由JVM和锁解决。理想情况下我们需要解决同步和互斥的问题（<span style=\"background-color: #ffff00;\">怎么解决的有待考证！</span>）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>解决方法一：</strong>将数据抽象成一个类，将对数据的操作封装成类中的方法</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解决方法二：</strong>将Runnable对象作为一个内部类，将共享数据作为这个类的成员变量</p>\n<h2><strong>五，ConcurrentHashmap并发</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ConcurrentHashmap使用了减小锁粒度，这里具体为分段锁的思想优化了锁，因为如果直接对hashmap进行加锁，锁太大，而且同一时刻只能有一个线程操作hashmap，并发性能较差</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;实现原理：</strong>即内部采用分段锁思想，将hashmap分为多个segment，每次读取数据的时候，对数据所在的segment进行加锁，这样只要保证每个segment线程安全，就可以保证整个hashmap线程安全</p>\n<h2><strong>六，JAVA中的线程调度</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;抢占式调度：</strong>即线程对cpu资源进行抢占，这种策略下每个线程抢占到cpu资源的概率是相等的，这样就不会一个线程阻塞造成整个系统阻塞的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>协同式调度：</strong>即一个线程使用完cpu资源之后通知cpu调度下一个任务，适用于多线程交替执行任务。因为如果一个线程阻塞可能会造成整个系统阻塞甚至崩溃</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>JAVA采用的是抢占式调度，但同时又尽可能的保证公平性（即为每个线程分配优先级不同的cpu时间片）</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>&nbsp;线程让出cpu的情况</strong>：第一，线程调用yield方法；第二，I/O阻塞，socket等待等；第三，等待同步锁；第四，正常执行完毕</p>\n<h2>七，进程调度算法</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>优先调度算法：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;先来先服务调度算法：</strong>即遵循先来先被分配cpu资源运行的原则</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>短作业调度算法：</strong>即预估作业的时间长短，优先调度时间短的任务，可能会导致长时间大任务很长时间无法被调度 &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>高优先权调度算法：即每个任务会预先被分配优先级</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;非抢占式优先调度算法：</strong>按照优先级的高低一次分配cpu资源运行</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>抢占式优先调度算法：</strong>按照优先级的高低分配cpu资源运行，但是如果任务再运行过程中有优先级更高的任务加入，则将其cpu资源临时回收分配给紧急任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>高响应比调度算法：</strong>动态调度，即作业时间短，则优先级高；等待时间长，则优先级高。前者遵循短作业调度算法，后者遵循先来先服务原则。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>时间片轮转调度算法：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;时间片轮转法：</strong>按照任务再队列中的顺序进行调度</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>多级反馈队列调度算法：</strong>即再时间片轮转法的基础上维护了就绪队列，默认第一队列优先级高，先调度第一队列的任务，如果再分配的cpu时间片内未完成则将其加入第二队列队尾，以此类推直到其执行完毕。只有第1 -（n-1）队列为空，才会调度第n队列的任务，而且当前任务执行时，如果有优先级高的任务进来，会抢占其cpu资源。</p>\n<h2><strong>八，CAS</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>即比较和交换，CAS（V,E,N）三个参数，只有当V=E的时候才会将V设置为N。如果V!=E，则说明数据已经被其它线程修改，不做任何操作</p>\n<h2><strong>九，ABA问题</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>概述：</strong>即当1线程从V中取出A时，2线程也从中取出1，修改为B，再修改为A。而1线程仍然修改成功，实际上修改过程中V的实际值已经发生改变，只不过1没有发觉。解决这种问题，常采用乐观锁的版本号机制。</p>\n<h2><strong>另外有AQS问题没怎么读懂，下次完善！</strong></h2>\n<p>&nbsp;</p>\n<h3><strong>思维导图：<a href=\"https://images-cdn.shimo.im/myFodjsaVAA3PVV7__thumbnail\" target=\"_blank\" rel=\"noopener\">并发编程（下）</a></strong></h3>\n<p>&nbsp;</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</p>","blogGoods":0,"blogId":"1249742755949817856","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHNmAPuxmAABJTVJPTfk117.jpg","blogRead":17,"blogRemark":"面试（三）------之并发编程篇（下）","blogTitle":"面试（三）------之并发编程篇（下）","createdTime":"2020-04-13 16:54:26","typeName":"java面试篇","updateTime":"2020-04-20 11:54:02"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，栈及其JAVA实现</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：栈是一种先进后出的数据结构，对栈顶元素的添加，删除等操作较快，但是对于栈内的元素操作很慢</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA实现：实现需要定义栈的数据结构，写栈的入栈，出栈，获取栈顶元素的方法，如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n * 基于数组实现栈\n * @author wcj\n * @Date 2020/4/14 20:59\n * @Version 1.0\n */\npublic class StackExample&lt;E&gt; {\n\n    /**\n     * 站的深度\n     */\n    private int maxSize;\n    /**\n     * 存储数据的数组\n     */\n    private Object[] data;\n    /**\n     * 栈顶指针\n     */\n    private int top = -1;\n\n    /**\n     * 默认栈的深度为10\n     */\n    public StackExample(){\n        this(10);\n    }\n\n    /**\n     * 用户自定义栈的深度\n     * @param initialSize\n     */\n    public StackExample(int initialSize){\n        if(initialSize&gt;=0){\n            this.maxSize = initialSize;\n            this.data = new  Object[initialSize];\n            this.top = -1;\n        }else{\n            throw new RuntimeException(\"初始化栈的深度不能小于0!\");\n        }\n    }\n\n    /**\n     * 入栈操作\n     * @param e\n     * @return\n     */\n    public Boolean push(E e){\n        if(top == maxSize-1){\n            throw new RuntimeException(\"栈已满,不能入栈\");\n        }else{\n            data[++top] = e;\n        }\n        return true;\n    }\n\n    /**\n     * 出栈操作\n     * @return\n     */\n    public E pop(){\n        if(top==-1){\n            throw new RuntimeException(\"栈空，不能出栈！\");\n        }else{\n            return (E) data[top--];\n        }\n    }\n\n    /**\n     * 获取栈顶元素\n     * @return\n     */\n    public E peak(){\n        if(top==-1){\n            throw new RuntimeException(\"栈空异常！\");\n        }else{\n            return (E) data[top];\n        }\n    }  </code></pre>\n<h2><strong>二，队列极其JAVA实现</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：队列是一种先进先出的数据结构，对队头和队尾的操作简单，但是队内元素的操作复杂。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA实现：定义队列的数据结构，队列的出队，入队，获取队头元素。代码如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n * 基于数组实现队列\n * @author wcj\n * @Date 2020/4/14 21:14\n * @Version 1.0\n */\npublic class QueueExample&lt;E&gt; {\n\n    /**\n     * 队列长度\n     */\n    private int maxSize;\n    /**\n     * 存储数据数组\n     */\n    private Object[] data;\n    /**\n     * 队头指针\n     */\n    private int front;\n    /**\n     * 队尾指针\n     */\n    private int rear;\n\n    /**\n     * 默认构造器\n     */\n    public QueueExample(){\n        this(10);\n    }\n    /**\n     * 用户自定义队列长度构造器\n     * @param initialSize\n     */\n    public QueueExample(int initialSize){\n        if(initialSize&gt;=0){\n            this.maxSize = initialSize;\n            data = new Object[initialSize];\n            front = rear = 0;\n        }else{\n            throw new RuntimeException(\"初始化队列长度不能小于0！\");\n        }\n    }\n\n    /**\n     * 入队操作\n     * @param e\n     * @return\n     */\n    public Boolean add(E e){\n        if(rear == maxSize){\n            throw new RuntimeException(\"队列已满，无法入队!\");\n        }else{\n            data[rear++] = e;\n        }\n        return true;\n    }\n\n    /**\n     * 出队操作\n     * @return\n     */\n    public E poll(){\n        if(front==rear){\n            throw new RuntimeException(\"队空，无元素可出队！\");\n        }else{\n            E e = (E) data[front];\n            data[front] = null;\n            return e;\n        }\n    }\n\n    /**\n     * 获取队头元素\n     * @return\n     */\n    public E peek(){\n        if(front==rear){\n            throw new RuntimeException(\"队空，无元素可出队!\");\n        }else{\n            return (E) data[front];\n        }\n    }\n}\n</code></pre>\n<h2><strong>三，链表及其JAVA实现</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：链表是由一系列数据节点组成的数据结构，节点可以动态生成。对于元素的增加，删除操作快，查询操作慢</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;这里主要讲述几种有代表性的链表：单向链表，双向链表，双向循环链表</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;单链表的JAVA实现：数据结构定义，添加节点，删除节点，查找节点，代码如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n * 单向链表\n * @author wcj\n * @Date 2020/4/14 21:32\n * @Version 1.0\n */\npublic class SingleLinkedList {\n\n    /**\n     * 链表长度\n     */\n    private int length;\n    /**\n     * 链表头节点\n     */\n    private Node head;\n\n    public SingleLinkedList(){\n        this.length = 0;\n        this.head = null;\n    }\n    /**\n     * 内部类声明每个链表节点\n     * 每个节点包括数据域和指向下一个节点的指针\n     */\n    private class Node{\n        private Object data;\n        private Node next;\n        public Node(Object data){\n            this.data = data;\n        }\n    }\n\n    /**\n     * 插入节点（这里使用头插法）\n     * @param obj\n     * @return\n     */\n    public Boolean add(Object obj){\n        Node node = new Node(obj);\n        if(length==0){\n            head = node;\n        }else{\n            node.next= head;\n            head = node;\n        }\n        length++;\n        return true;\n    }\n\n    /**\n     * 删除某个节点\n     * 先对链表进行判空处理\n     * 然后找到要删除的节点\n     * 最后进行删除\n     * @param obj\n     * @return\n     */\n    public Boolean delete(Object obj){\n        if(length==0){\n            throw new RuntimeException(\"链表为空，无节点可删除!\");\n        }else{\n            Node prev = head;\n            Node current = head;\n            //查找待删除元素\n            while(!current.data.equals(obj)){\n                if(current.next==null){\n                    return false;\n                }else{\n                    prev = current;\n                    current = current.next;\n                }\n            }\n            prev.next = current.next;\n            length--;\n        }\n        return true;\n    }\n\n    /**\n     * 获取某个元素\n     * @param obj\n     * @return\n     */\n    public Object find(Object obj){\n        if(length==0){\n            throw new RuntimeException(\"链表为空\");\n        }else{\n            Node current = head;\n            while(current.data.equals(obj)){\n                if(current.next==null){\n                    return null;\n                }else{\n                    current = current.next;\n                }\n            }\n            return current.data;\n        }\n    }\n}\n</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>双向链表的JAVA实现：定义数据结构，头插法，尾插法，删除头部节点，删除尾部节点（这里只写尾插节点和删除尾部节点），代码如下：</strong></p>\n<pre class=\"language-java\"><code>import com.sun.org.apache.xpath.internal.operations.Bool;\n\n/**\n * 单向循环链表\n * @author wcj\n * @Date 2020/4/14 22:05\n * @Version 1.0\n */\npublic class CircleLinkedList {\n\n    /**\n     * 链表长度\n     */\n    private int length;\n    /**\n     * 头节点\n     */\n    private Node head;\n    /**\n     * 尾节点\n     */\n    private Node tail;\n\n    /**\n     * 初始化构造方法\n     */\n    public CircleLinkedList(){\n        this.length = 0;\n        this.head=this.tail = null;\n    }\n\n    /**\n     * 内部类实现的链表节点\n     */\n    private class Node{\n        private Object data;\n        private Node prev;\n        private Node next;\n        public Node(Object data){\n            this.data = data;\n        }\n    }\n\n    /**\n     * 尾插节点\n     * @param obj\n     * @return\n     */\n    public Boolean addTail(Object obj){\n        Node node = new Node(obj);\n        if(length==0){\n            head = tail= node;\n            length++;\n        }else{\n            tail.next = node;\n            node.prev = tail;\n            tail = node;\n            length++;\n        }\n        return true;\n    }\n\n    /**\n     * 删除尾部节点\n     * @return\n     */\n    public Boolean delTail(){\n        Node temp = tail;\n        if(length==0){\n            throw new RuntimeException(\"链表为空!\");\n        }else{\n            tail = tail.prev;\n            tail.next = null;\n            length--;\n        }\n        return true;\n    }\n}\n</code></pre>\n<h2><strong>四，散列表</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：有一张表M，一个映射函数f(key)，如果对于任意一个key，都有一个函数指与表中的内存地址相对应，则M就为散列表，f(key)就为散列函数。散列函数存储key-value键值对形式的数据，直接生成key与表中地址值的映射，因此查询非常迅速。同时散列表也经常被用于信息安全，用于加密操作。</strong></p>\n<h2><strong>五，二叉排序树</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：二叉查找树又成为二叉搜索树，二叉查找树</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;特征：根节点左边的数据小于根节点，根节点右边的数据大于根节点，且其左右子树还是二叉排序树</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现：定义数据结构，插入操作，删除操作，查找操作，代码如下：</strong></p>\n<pre class=\"language-java\"><code>package interviewFour.example4;\n\n/**\n * 二叉排序树\n * @author wcj\n * @Date 2020/4/14 17:17\n * @Version 1.0\n */\npublic class Node {\n\n    private Node root = null;\n    private int value;\n    private Node left;\n    private Node right;\n\n    public Node(){}\n\n    public Node(int value, Node left, Node right){\n        this.value = value;\n        this.left = left;\n        this.right = right;\n    }\n\n    public Node(int value){\n        this.left = null;\n        this.right = null;\n        this.value = value;\n    }\n\n    public int getValue() {\n        return value;\n    }\n\n    public void setValue(int value) {\n        this.value = value;\n    }\n\n    public Node getLeft() {\n        return left;\n    }\n\n    public void setLeft(Node left) {\n        this.left = left;\n    }\n\n    public Node getRight() {\n        return right;\n    }\n\n    public void setRight(Node right) {\n        this.right = right;\n    }\n\n    /**\n     * 插入节点\n     * @param value\n     * @return\n     */\n    public Boolean insert(int value){\n        //root代表根节点\n        Node p = root;\n        Node prev = null;\n        //创建一个节点\n        Node node = new Node(value);\n        //寻找节点的插入位置\n        while(p!=null){\n            prev = p;\n            if(value==p.getValue()){\n                return false;\n            }else if(value&lt;p.getValue()){\n                p = p.getLeft();\n            }else{\n                p = p.getRight();\n            }\n        }\n        if(root==null){\n            root = node;\n        }else if(value&lt;prev.getValue()){\n            prev.setLeft(node);\n        }else{\n            prev.setRight(node);\n        }\n        return true;\n    }\n\n    /**\n     * 删除某个节点\n     * 分为三种情况，待删除节点为叶子节点，则直接删除\n     * 待删除节点只有左子树或者右子树，则用左子树或者右子树替代当前节点位置\n     * 待删除节点即有左子树又有右子树，则寻找左子树最大节点或者右子树最小节点顶替当前节点(这里使用左子树的最大节点)\n     * @param value\n     * @return\n     */\n    public void deleteBST(int value){\n        deleteBST(root,value);\n    }\n\n    /**\n     * 递归删除左子树，或者右子树，或者根节点\n     * @param root\n     * @param value\n     * @return\n     */\n    public Boolean deleteBST(Node root,int value){\n        if(root==null){\n            return false;\n        }else{\n            if(root.getValue()==value){\n                delete(root);\n            }else if(value&lt;root.getValue()){\n                deleteBST(root.getLeft(),value);\n            }else{\n                deleteBST(root.getRight(),value);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * 分情况执行具体的删除逻辑\n     * @param node\n     * @return\n     */\n    public Boolean delete(Node node){\n        if(node.getLeft()==null){\n            node = node.getRight();\n        }else if(node.getRight()==null){\n            node = node.getLeft();\n        }else{\n            Node temp = node;\n            Node s = node;\n            //转向左子树，向右走到底\n            s = s.getLeft();\n            //寻找替换待删除节点的节点\n            while(s!=null){\n                temp = s;\n                s = s.getRight();\n            }\n            node.setValue(temp.getValue());\n            if(temp!=node){\n                node.setLeft(temp.getLeft());\n            }else{\n                node.setRight(temp.getRight());\n            }\n        }\n        return true;\n    }\n\n    /**\n     * 在二叉查找树中找到对应节点\n     * @param value\n     * @return\n     */\n    public Boolean searchBTS(int value){\n        Node node = root;\n        if(node==null){\n            throw new RuntimeException(\"无此节点！\");\n        }else{\n            if(value==node.getValue()){\n                return true;\n            }else if(value&lt;node.getValue()){\n                node = node.getLeft();\n            }else{\n                node = node.getRight();\n            }\n        }\n        return false;\n    }\n}\n</code></pre>\n<h2><strong>六，红黑树</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 概述：红黑树是一种特化的自平衡二叉排序树，即其左右子树的深度差可以超过1。（详细的插入等操作过段时间会补充）</strong></p>\n<h2><strong>七，图，位图</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;图的知识：定义，有向图/无向图，邻接矩阵/邻接表，BFS/DFS，位图的话没怎么搞清楚。</strong></p>\n<h3><strong>思维导图：<a href=\"https://images-cdn.shimo.im/YClQaLxx9e8uEb9U__thumbnail\" target=\"_blank\" rel=\"noopener\">数据结构</a></strong></h3>\n<h2>&nbsp;</h2>","blogGoods":0,"blogId":"1250068950784536576","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHQGAYlUxAABJTVJPTfk990.jpg","blogRead":7,"blogRemark":"面试（四）------之数据结构篇","blogTitle":"面试（四）------之数据结构篇","createdTime":"2020-04-14 14:30:37","typeName":"java面试篇","updateTime":"2020-04-23 22:14:43"}],"pageSize":10,"params":{},"sortMethod":"ASC","totalCount":53,"totalPage":6},"msg":"操作成功!"}
2020-04-26 22:39:50.196 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listBack
2020-04-26 22:39:50.197 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 22:39:50.198 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 22:39:50.198 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeList
2020-04-26 22:39:50.198 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 22:39:50.286 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 90
2020-04-26 22:39:50.288 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":1,"typeName":"Linux"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":2,"typeName":"Docker"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"SpringBoot"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":4,"typeName":"Mybatis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":5,"typeName":"爬虫"},{"deleted":0,"enable":1,"typeBlogCount":4,"typeId":6,"typeName":"博客开发和维护总结"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":7,"typeName":"CSS"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"JavaScript"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Vue"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":10,"typeName":"随笔"},{"deleted":0,"enable":1,"typeBlogCount":16,"typeId":11,"typeName":"java面试篇"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":13,"typeName":"JDK源码阅读"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":14,"typeName":"redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":15,"typeName":"MongoDB"},{"deleted":0,"enable":1,"typeBlogCount":28,"typeId":16,"typeName":"LeetCode"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":17,"typeName":"随心日记"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":18,"typeName":"计算机网络"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":19,"typeName":"操作系统"}],"msg":"操作成功!"}
2020-04-26 22:39:50.865 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 3228
2020-04-26 22:39:50.866 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":1,"typeName":"Linux"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":2,"typeName":"Docker"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"SpringBoot"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":4,"typeName":"Mybatis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":5,"typeName":"爬虫"},{"deleted":0,"enable":1,"typeBlogCount":4,"typeId":6,"typeName":"博客开发和维护总结"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":7,"typeName":"CSS"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"JavaScript"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Vue"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":10,"typeName":"随笔"},{"deleted":0,"enable":1,"typeBlogCount":16,"typeId":11,"typeName":"java面试篇"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":13,"typeName":"JDK源码阅读"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":14,"typeName":"redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":15,"typeName":"MongoDB"},{"deleted":0,"enable":1,"typeBlogCount":28,"typeId":16,"typeName":"LeetCode"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":17,"typeName":"随心日记"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":18,"typeName":"计算机网络"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":19,"typeName":"操作系统"}],"msg":"操作成功!"}
2020-04-26 22:39:57.911 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/add
2020-04-26 22:39:57.911 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 22:39:57.911 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 22:39:57.911 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.addType
2020-04-26 22:39:57.912 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Type(typeId=null, typeName=数据结构, typeBlogCount=null, enable=null, deleted=null)]
2020-04-26 22:39:58.131 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 220
2020-04-26 22:39:58.131 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"msg":"添加分类成功!"}
2020-04-26 22:39:58.269 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listBack
2020-04-26 22:39:58.270 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 22:39:58.270 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 22:39:58.270 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeList
2020-04-26 22:39:58.270 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 22:39:58.355 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 86
2020-04-26 22:39:58.356 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":1,"typeName":"Linux"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":2,"typeName":"Docker"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"SpringBoot"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":4,"typeName":"Mybatis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":5,"typeName":"爬虫"},{"deleted":0,"enable":1,"typeBlogCount":4,"typeId":6,"typeName":"博客开发和维护总结"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":7,"typeName":"CSS"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"JavaScript"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Vue"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":10,"typeName":"随笔"},{"deleted":0,"enable":1,"typeBlogCount":16,"typeId":11,"typeName":"java面试篇"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":13,"typeName":"JDK源码阅读"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":14,"typeName":"redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":15,"typeName":"MongoDB"},{"deleted":0,"enable":1,"typeBlogCount":28,"typeId":16,"typeName":"LeetCode"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":17,"typeName":"随心日记"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":18,"typeName":"计算机网络"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":19,"typeName":"操作系统"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":20,"typeName":"数据结构"}],"msg":"操作成功!"}
2020-04-26 23:01:29.413 INFO  [restartedMain]com.wcj.BlogApplication.logStarting:55 -Starting BlogApplication on LAPTOP-SF80F1HO with PID 22660 (D:\MyBlog\blog\target\classes started by 邬成军 in D:\MyBlog\blog)
2020-04-26 23:01:29.419 INFO  [restartedMain]com.wcj.BlogApplication.logStartupProfileInfo:655 -The following profiles are active: pro
2020-04-26 23:01:29.482 INFO  [restartedMain]o.s.b.devtools.env.DevToolsPropertyDefaultsPostProcessor.logTo:225 -Devtools property defaults active! Set 'spring.devtools.add-properties' to 'false' to disable
2020-04-26 23:01:29.482 INFO  [restartedMain]o.s.b.devtools.env.DevToolsPropertyDefaultsPostProcessor.logTo:225 -For additional web related logging consider setting the 'logging.level.web' property to 'DEBUG'
2020-04-26 23:01:30.640 INFO  [restartedMain]o.s.d.repository.config.RepositoryConfigurationDelegate.registerRepositoriesIn:127 -Bootstrapping Spring Data MongoDB repositories in DEFAULT mode.
2020-04-26 23:01:30.784 INFO  [restartedMain]o.s.d.repository.config.RepositoryConfigurationDelegate.registerRepositoriesIn:187 -Finished Spring Data repository scanning in 133ms. Found 4 MongoDB repository interfaces.
2020-04-26 23:01:31.307 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'shiroConfig' of type [com.wcj.config.ShiroConfig$$EnhancerBySpringCGLIB$$c4d8387d] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:31.333 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'hashedCredentialsMatcher' of type [org.apache.shiro.authc.credential.HashedCredentialsMatcher] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:31.367 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mybatis-org.mybatis.spring.boot.autoconfigure.MybatisProperties' of type [org.mybatis.spring.boot.autoconfigure.MybatisProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:31.378 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration' of type [org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration$$EnhancerBySpringCGLIB$$218a3a24] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:31.383 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceAutoConfigure' of type [com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceAutoConfigure$$EnhancerBySpringCGLIB$$861de66] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:31.388 INFO  [restartedMain]c.a.d.s.boot.autoconfigure.DruidDataSourceAutoConfigure.dataSource:56 -Init DruidDataSource
2020-04-26 23:01:31.470 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'spring.datasource-org.springframework.boot.autoconfigure.jdbc.DataSourceProperties' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:31.486 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'com.alibaba.druid.spring.boot.autoconfigure.stat.DruidFilterConfiguration' of type [com.alibaba.druid.spring.boot.autoconfigure.stat.DruidFilterConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:31.517 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'statFilter' of type [com.alibaba.druid.filter.stat.StatFilter] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:48.166 INFO  [restartedMain]com.wcj.BlogApplication.logStarting:55 -Starting BlogApplication on LAPTOP-SF80F1HO with PID 23272 (D:\MyBlog\blog\target\classes started by 邬成军 in D:\MyBlog\blog)
2020-04-26 23:01:48.170 INFO  [restartedMain]com.wcj.BlogApplication.logStartupProfileInfo:655 -The following profiles are active: pro
2020-04-26 23:01:48.228 INFO  [restartedMain]o.s.b.devtools.env.DevToolsPropertyDefaultsPostProcessor.logTo:225 -Devtools property defaults active! Set 'spring.devtools.add-properties' to 'false' to disable
2020-04-26 23:01:48.229 INFO  [restartedMain]o.s.b.devtools.env.DevToolsPropertyDefaultsPostProcessor.logTo:225 -For additional web related logging consider setting the 'logging.level.web' property to 'DEBUG'
2020-04-26 23:01:49.056 INFO  [restartedMain]o.s.d.repository.config.RepositoryConfigurationDelegate.registerRepositoriesIn:127 -Bootstrapping Spring Data MongoDB repositories in DEFAULT mode.
2020-04-26 23:01:49.152 INFO  [restartedMain]o.s.d.repository.config.RepositoryConfigurationDelegate.registerRepositoriesIn:187 -Finished Spring Data repository scanning in 89ms. Found 4 MongoDB repository interfaces.
2020-04-26 23:01:49.615 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'shiroConfig' of type [com.wcj.config.ShiroConfig$$EnhancerBySpringCGLIB$$34b547de] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:49.647 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'hashedCredentialsMatcher' of type [org.apache.shiro.authc.credential.HashedCredentialsMatcher] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:49.682 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mybatis-org.mybatis.spring.boot.autoconfigure.MybatisProperties' of type [org.mybatis.spring.boot.autoconfigure.MybatisProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:49.693 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration' of type [org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration$$EnhancerBySpringCGLIB$$91674985] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:49.697 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceAutoConfigure' of type [com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceAutoConfigure$$EnhancerBySpringCGLIB$$783eedc7] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:49.702 INFO  [restartedMain]c.a.d.s.boot.autoconfigure.DruidDataSourceAutoConfigure.dataSource:56 -Init DruidDataSource
2020-04-26 23:01:49.778 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'spring.datasource-org.springframework.boot.autoconfigure.jdbc.DataSourceProperties' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:49.794 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'com.alibaba.druid.spring.boot.autoconfigure.stat.DruidFilterConfiguration' of type [com.alibaba.druid.spring.boot.autoconfigure.stat.DruidFilterConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:49.819 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'statFilter' of type [com.alibaba.druid.filter.stat.StatFilter] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:53.245 INFO  [restartedMain]com.alibaba.druid.pool.DruidDataSource.init:930 -{dataSource-1} inited
2020-04-26 23:01:53.246 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'dataSource' of type [com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceWrapper] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:53.303 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:53.505 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'sqlSessionFactory' of type [org.apache.ibatis.session.defaults.DefaultSqlSessionFactory] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:53.510 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'sqlSessionTemplate' of type [org.mybatis.spring.SqlSessionTemplate] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:53.518 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'adminMapper' of type [org.mybatis.spring.mapper.MapperFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:53.521 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'adminMapper' of type [com.sun.proxy.$Proxy92] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:53.523 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'adminServiceImpl' of type [com.wcj.service.impl.AdminServiceImpl] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:53.527 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'userMapper' of type [org.mybatis.spring.mapper.MapperFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:53.528 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'userMapper' of type [com.sun.proxy.$Proxy95] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:53.545 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#62722e38' of type [org.springframework.beans.factory.config.PropertiesFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:53.547 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#62722e38' of type [java.util.Properties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:53.569 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#146c9538' of type [org.springframework.data.repository.core.support.PropertiesBasedNamedQueries] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:53.572 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#332200de' of type [org.springframework.data.repository.core.support.RepositoryFragmentsFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:53.575 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#332200de' of type [org.springframework.data.repository.core.support.RepositoryComposition$RepositoryFragments] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:53.597 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'spring.data.mongodb-org.springframework.boot.autoconfigure.mongo.MongoProperties' of type [org.springframework.boot.autoconfigure.mongo.MongoProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:53.599 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.data.mongo.MongoDbFactoryDependentConfiguration' of type [org.springframework.boot.autoconfigure.data.mongo.MongoDbFactoryDependentConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:53.601 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.data.mongo.MongoDbFactoryConfiguration' of type [org.springframework.boot.autoconfigure.data.mongo.MongoDbFactoryConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:53.602 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration' of type [org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:53.683 INFO  [restartedMain]org.mongodb.driver.cluster.info:71 -Cluster created with settings {hosts=[121.199.34.159:27017], mode=MULTIPLE, requiredClusterType=UNKNOWN, serverSelectionTimeout='30000 ms', maxWaitQueueSize=500}
2020-04-26 23:01:53.683 INFO  [restartedMain]org.mongodb.driver.cluster.info:71 -Adding discovered server 121.199.34.159:27017 to client view of cluster
2020-04-26 23:01:53.724 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongo' of type [com.mongodb.MongoClient] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:53.736 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongoDbFactory' of type [org.springframework.data.mongodb.core.SimpleMongoDbFactory] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:53.743 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.data.mongo.MongoDataConfiguration' of type [org.springframework.boot.autoconfigure.data.mongo.MongoDataConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:53.831 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongoCustomConversions' of type [org.springframework.data.mongodb.core.convert.MongoCustomConversions] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:53.844 INFO  [cluster-ClusterId{value='5ea5a261c791c905598038f6', description='null'}-121.199.34.159:27017]org.mongodb.driver.connection.info:71 -Opened connection [connectionId{localValue:1, serverValue:616}] to 121.199.34.159:27017
2020-04-26 23:01:53.858 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongoMappingContext' of type [org.springframework.data.mongodb.core.mapping.MongoMappingContext] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:53.888 INFO  [cluster-ClusterId{value='5ea5a261c791c905598038f6', description='null'}-121.199.34.159:27017]org.mongodb.driver.cluster.info:71 -Monitor thread successfully connected to server with description ServerDescription{address=121.199.34.159:27017, type=STANDALONE, state=CONNECTED, ok=true, version=ServerVersion{versionList=[4, 2, 5]}, minWireVersion=0, maxWireVersion=8, maxDocumentSize=16777216, logicalSessionTimeoutMinutes=30, roundTripTimeNanos=41805600}
2020-04-26 23:01:53.889 INFO  [cluster-ClusterId{value='5ea5a261c791c905598038f6', description='null'}-121.199.34.159:27017]org.mongodb.driver.cluster.info:71 -Discovered cluster type of STANDALONE
2020-04-26 23:01:53.908 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mappingMongoConverter' of type [org.springframework.data.mongodb.core.convert.MappingMongoConverter] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:53.970 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongoTemplate' of type [org.springframework.data.mongodb.core.MongoTemplate] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:54.228 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'blogCollectionDao' of type [org.springframework.data.mongodb.repository.support.MongoRepositoryFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:54.237 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'blogCollectionDao' of type [com.sun.proxy.$Proxy110] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:54.262 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'typeMapper' of type [org.mybatis.spring.mapper.MapperFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:54.263 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'typeMapper' of type [com.sun.proxy.$Proxy112] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:54.267 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#154e313e' of type [org.springframework.beans.factory.config.PropertiesFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:54.268 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#154e313e' of type [java.util.Properties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:54.269 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#68dccd2d' of type [org.springframework.data.repository.core.support.PropertiesBasedNamedQueries] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:54.270 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#78804b01' of type [org.springframework.data.repository.core.support.RepositoryFragmentsFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:54.270 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#78804b01' of type [org.springframework.data.repository.core.support.RepositoryComposition$RepositoryFragments] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:54.286 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'commentDao' of type [org.springframework.data.mongodb.repository.support.MongoRepositoryFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:54.286 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'commentDao' of type [com.sun.proxy.$Proxy116] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:54.303 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'userServiceImpl' of type [com.wcj.service.impl.UserServiceImpl] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:54.318 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'adminRealm' of type [com.wcj.realm.AdminRealm] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:54.354 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'securityManager' of type [org.apache.shiro.web.mgt.DefaultWebSecurityManager] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:01:54.652 INFO  [restartedMain]o.s.boot.web.embedded.tomcat.TomcatWebServer.initialize:92 -Tomcat initialized with port(s): 1000 (http)
2020-04-26 23:01:54.660 INFO  [restartedMain]org.apache.coyote.http11.Http11NioProtocol.log:173 -Initializing ProtocolHandler ["http-nio-1000"]
2020-04-26 23:01:54.660 INFO  [restartedMain]org.apache.catalina.core.StandardService.log:173 -Starting service [Tomcat]
2020-04-26 23:01:54.660 INFO  [restartedMain]org.apache.catalina.core.StandardEngine.log:173 -Starting Servlet engine: [Apache Tomcat/9.0.31]
2020-04-26 23:01:54.662 INFO  [restartedMain]org.apache.catalina.core.AprLifecycleListener.log:173 -Loaded APR based Apache Tomcat Native library [1.2.23] using APR version [1.7.0].
2020-04-26 23:01:54.663 INFO  [restartedMain]org.apache.catalina.core.AprLifecycleListener.log:173 -APR capabilities: IPv6 [true], sendfile [true], accept filters [false], random [true].
2020-04-26 23:01:54.663 INFO  [restartedMain]org.apache.catalina.core.AprLifecycleListener.log:173 -APR/OpenSSL configuration: useAprConnector [false], useOpenSSL [true]
2020-04-26 23:01:54.678 INFO  [restartedMain]org.apache.catalina.core.AprLifecycleListener.log:173 -OpenSSL successfully initialized [OpenSSL 1.1.1c  28 May 2019]
2020-04-26 23:01:54.774 INFO  [restartedMain]o.a.catalina.core.ContainerBase.[Tomcat].[localhost].[/].log:173 -Initializing Spring embedded WebApplicationContext
2020-04-26 23:01:54.775 INFO  [restartedMain]org.springframework.web.context.ContextLoader.prepareWebApplicationContext:284 -Root WebApplicationContext: initialization completed in 6545 ms
2020-04-26 23:01:54.886 INFO  [restartedMain]o.s.boot.devtools.autoconfigure.OptionalLiveReloadServer.startServer:58 -LiveReload server is running on port 35729
2020-04-26 23:01:56.199 INFO  [restartedMain]org.apache.coyote.http11.Http11NioProtocol.log:173 -Starting ProtocolHandler ["http-nio-1000"]
2020-04-26 23:01:56.221 INFO  [restartedMain]o.s.boot.web.embedded.tomcat.TomcatWebServer.start:204 -Tomcat started on port(s): 1000 (http) with context path ''
2020-04-26 23:01:56.223 INFO  [restartedMain]com.wcj.BlogApplication.logStarted:61 -Started BlogApplication in 8.763 seconds (JVM running for 10.814)
2020-04-26 23:02:00.502 INFO  [http-nio-1000-exec-1]o.a.catalina.core.ContainerBase.[Tomcat].[localhost].[/].log:173 -Initializing Spring DispatcherServlet 'dispatcherServlet'
2020-04-26 23:02:00.502 INFO  [http-nio-1000-exec-1]org.springframework.web.servlet.DispatcherServlet.initServletBean:525 -Initializing Servlet 'dispatcherServlet'
2020-04-26 23:02:00.515 INFO  [http-nio-1000-exec-1]org.springframework.web.servlet.DispatcherServlet.initServletBean:547 -Completed initialization in 12 ms
2020-04-26 23:02:02.168 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /admin/login
2020-04-26 23:02:02.169 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:02:02.171 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:02:02.173 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.AdminController.login
2020-04-26 23:02:02.173 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Admin(id=null, name=null, header=null, signature=null, comment=null, username=admin, password=admin)]
2020-04-26 23:02:02.337 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 169
2020-04-26 23:02:02.340 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"token":"8DA25483097E40AD0C5CB39E75D91060"},"msg":"操作成功!"}
2020-04-26 23:02:02.832 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /admin/info
2020-04-26 23:02:02.833 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:02:02.833 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:02:02.834 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.AdminController.getAdminInfo
2020-04-26 23:02:02.834 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:02:02.834 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 2
2020-04-26 23:02:02.838 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"header":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMSKACehsAACHOzTvceE295.jpg","name":"小屋","password":"","signature":"时光好不经用，转眼已是半生","username":"admin"},"msg":"操作成功!"}
2020-04-26 23:02:03.157 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listFront
2020-04-26 23:02:03.157 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:02:03.158 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:02:03.158 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeLists
2020-04-26 23:02:03.159 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:02:03.254 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 97
2020-04-26 23:02:03.257 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":1,"typeName":"Linux"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":2,"typeName":"Docker"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"SpringBoot"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":4,"typeName":"Mybatis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":5,"typeName":"爬虫"},{"deleted":0,"enable":1,"typeBlogCount":4,"typeId":6,"typeName":"博客开发和维护总结"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":7,"typeName":"CSS"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"JavaScript"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Vue"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":10,"typeName":"随笔"},{"deleted":0,"enable":1,"typeBlogCount":16,"typeId":11,"typeName":"java面试篇"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":13,"typeName":"JDK源码阅读"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":14,"typeName":"redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":15,"typeName":"MongoDB"},{"deleted":0,"enable":1,"typeBlogCount":28,"typeId":16,"typeName":"LeetCode"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":17,"typeName":"随心日记"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":18,"typeName":"计算机网络"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":19,"typeName":"操作系统"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":20,"typeName":"数据结构"}],"msg":"操作成功!"}
2020-04-26 23:03:45.120 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /admin/info
2020-04-26 23:03:45.121 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:03:45.121 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:03:45.121 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.AdminController.getAdminInfo
2020-04-26 23:03:45.121 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:03:45.121 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 1
2020-04-26 23:03:45.121 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"header":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMSKACehsAACHOzTvceE295.jpg","name":"小屋","password":"","signature":"时光好不经用，转眼已是半生","username":"admin"},"msg":"操作成功!"}
2020-04-26 23:03:45.569 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listFront
2020-04-26 23:03:45.569 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:03:45.569 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:03:45.570 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeLists
2020-04-26 23:03:45.570 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:03:45.688 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 119
2020-04-26 23:03:45.690 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":1,"typeName":"Linux"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":2,"typeName":"Docker"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"SpringBoot"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":4,"typeName":"Mybatis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":5,"typeName":"爬虫"},{"deleted":0,"enable":1,"typeBlogCount":4,"typeId":6,"typeName":"博客开发和维护总结"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":7,"typeName":"CSS"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"JavaScript"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Vue"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":10,"typeName":"随笔"},{"deleted":0,"enable":1,"typeBlogCount":16,"typeId":11,"typeName":"java面试篇"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":13,"typeName":"JDK源码阅读"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":14,"typeName":"redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":15,"typeName":"MongoDB"},{"deleted":0,"enable":1,"typeBlogCount":28,"typeId":16,"typeName":"LeetCode"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":17,"typeName":"随心日记"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":18,"typeName":"计算机网络"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":19,"typeName":"操作系统"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":20,"typeName":"数据结构"}],"msg":"操作成功!"}
2020-04-26 23:04:57.882 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /admin/info
2020-04-26 23:04:57.882 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:04:57.882 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:04:57.883 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.AdminController.getAdminInfo
2020-04-26 23:04:57.883 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:04:57.884 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 2
2020-04-26 23:04:57.884 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"header":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMSKACehsAACHOzTvceE295.jpg","name":"小屋","password":"","signature":"时光好不经用，转眼已是半生","username":"admin"},"msg":"操作成功!"}
2020-04-26 23:04:58.388 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listFront
2020-04-26 23:04:58.389 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:04:58.389 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:04:58.390 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeLists
2020-04-26 23:04:58.390 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:04:58.476 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 88
2020-04-26 23:04:58.478 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":1,"typeName":"Linux"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":2,"typeName":"Docker"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"SpringBoot"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":4,"typeName":"Mybatis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":5,"typeName":"爬虫"},{"deleted":0,"enable":1,"typeBlogCount":4,"typeId":6,"typeName":"博客开发和维护总结"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":7,"typeName":"CSS"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"JavaScript"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Vue"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":10,"typeName":"随笔"},{"deleted":0,"enable":1,"typeBlogCount":16,"typeId":11,"typeName":"java面试篇"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":13,"typeName":"JDK源码阅读"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":14,"typeName":"redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":15,"typeName":"MongoDB"},{"deleted":0,"enable":1,"typeBlogCount":28,"typeId":16,"typeName":"LeetCode"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":17,"typeName":"随心日记"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":18,"typeName":"计算机网络"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":19,"typeName":"操作系统"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":20,"typeName":"数据结构"}],"msg":"操作成功!"}
2020-04-26 23:07:25.440 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /admin/info
2020-04-26 23:07:25.440 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:07:25.440 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:07:25.440 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.AdminController.getAdminInfo
2020-04-26 23:07:25.441 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:07:25.441 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 1
2020-04-26 23:07:25.441 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"header":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMSKACehsAACHOzTvceE295.jpg","name":"小屋","password":"","signature":"时光好不经用，转眼已是半生","username":"admin"},"msg":"操作成功!"}
2020-04-26 23:07:26.242 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listFront
2020-04-26 23:07:26.242 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:07:26.243 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:07:26.244 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeLists
2020-04-26 23:07:26.244 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:07:26.336 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 94
2020-04-26 23:07:26.336 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":1,"typeName":"Linux"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":2,"typeName":"Docker"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"SpringBoot"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":4,"typeName":"Mybatis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":5,"typeName":"爬虫"},{"deleted":0,"enable":1,"typeBlogCount":4,"typeId":6,"typeName":"博客开发和维护总结"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":7,"typeName":"CSS"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"JavaScript"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Vue"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":10,"typeName":"随笔"},{"deleted":0,"enable":1,"typeBlogCount":16,"typeId":11,"typeName":"java面试篇"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":13,"typeName":"JDK源码阅读"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":14,"typeName":"redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":15,"typeName":"MongoDB"},{"deleted":0,"enable":1,"typeBlogCount":28,"typeId":16,"typeName":"LeetCode"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":17,"typeName":"随心日记"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":18,"typeName":"计算机网络"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":19,"typeName":"操作系统"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":20,"typeName":"数据结构"}],"msg":"操作成功!"}
2020-04-26 23:08:15.318 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /admin/info
2020-04-26 23:08:15.319 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:08:15.319 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:08:15.320 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.AdminController.getAdminInfo
2020-04-26 23:08:15.320 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:08:15.320 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 2
2020-04-26 23:08:15.320 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"header":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMSKACehsAACHOzTvceE295.jpg","name":"小屋","password":"","signature":"时光好不经用，转眼已是半生","username":"admin"},"msg":"操作成功!"}
2020-04-26 23:08:15.840 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listFront
2020-04-26 23:08:15.840 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:08:15.840 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:08:15.841 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeLists
2020-04-26 23:08:15.841 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:08:15.932 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 92
2020-04-26 23:08:15.933 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":1,"typeName":"Linux"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":2,"typeName":"Docker"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"SpringBoot"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":4,"typeName":"Mybatis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":5,"typeName":"爬虫"},{"deleted":0,"enable":1,"typeBlogCount":4,"typeId":6,"typeName":"博客开发和维护总结"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":7,"typeName":"CSS"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"JavaScript"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Vue"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":10,"typeName":"随笔"},{"deleted":0,"enable":1,"typeBlogCount":16,"typeId":11,"typeName":"java面试篇"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":13,"typeName":"JDK源码阅读"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":14,"typeName":"redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":15,"typeName":"MongoDB"},{"deleted":0,"enable":1,"typeBlogCount":28,"typeId":16,"typeName":"LeetCode"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":17,"typeName":"随心日记"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":18,"typeName":"计算机网络"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":19,"typeName":"操作系统"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":20,"typeName":"数据结构"}],"msg":"操作成功!"}
2020-04-26 23:08:58.500 INFO  [restartedMain]com.wcj.BlogApplication.logStarting:55 -Starting BlogApplication on LAPTOP-SF80F1HO with PID 25432 (D:\MyBlog\blog\target\classes started by 邬成军 in D:\MyBlog\blog)
2020-04-26 23:08:58.505 INFO  [restartedMain]com.wcj.BlogApplication.logStartupProfileInfo:655 -The following profiles are active: pro
2020-04-26 23:08:58.576 INFO  [restartedMain]o.s.b.devtools.env.DevToolsPropertyDefaultsPostProcessor.logTo:225 -Devtools property defaults active! Set 'spring.devtools.add-properties' to 'false' to disable
2020-04-26 23:08:58.577 INFO  [restartedMain]o.s.b.devtools.env.DevToolsPropertyDefaultsPostProcessor.logTo:225 -For additional web related logging consider setting the 'logging.level.web' property to 'DEBUG'
2020-04-26 23:08:59.534 INFO  [restartedMain]o.s.d.repository.config.RepositoryConfigurationDelegate.registerRepositoriesIn:127 -Bootstrapping Spring Data MongoDB repositories in DEFAULT mode.
2020-04-26 23:08:59.621 INFO  [restartedMain]o.s.d.repository.config.RepositoryConfigurationDelegate.registerRepositoriesIn:187 -Finished Spring Data repository scanning in 81ms. Found 4 MongoDB repository interfaces.
2020-04-26 23:09:00.113 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'shiroConfig' of type [com.wcj.config.ShiroConfig$$EnhancerBySpringCGLIB$$22b0a1cd] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:00.144 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'hashedCredentialsMatcher' of type [org.apache.shiro.authc.credential.HashedCredentialsMatcher] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:00.184 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mybatis-org.mybatis.spring.boot.autoconfigure.MybatisProperties' of type [org.mybatis.spring.boot.autoconfigure.MybatisProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:00.196 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration' of type [org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration$$EnhancerBySpringCGLIB$$7f62a374] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:00.202 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceAutoConfigure' of type [com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceAutoConfigure$$EnhancerBySpringCGLIB$$663a47b6] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:00.208 INFO  [restartedMain]c.a.d.s.boot.autoconfigure.DruidDataSourceAutoConfigure.dataSource:56 -Init DruidDataSource
2020-04-26 23:09:00.268 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'spring.datasource-org.springframework.boot.autoconfigure.jdbc.DataSourceProperties' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:00.293 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'com.alibaba.druid.spring.boot.autoconfigure.stat.DruidFilterConfiguration' of type [com.alibaba.druid.spring.boot.autoconfigure.stat.DruidFilterConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:00.320 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'statFilter' of type [com.alibaba.druid.filter.stat.StatFilter] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:03.628 INFO  [restartedMain]com.alibaba.druid.pool.DruidDataSource.init:930 -{dataSource-1} inited
2020-04-26 23:09:03.629 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'dataSource' of type [com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceWrapper] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:03.689 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:03.896 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'sqlSessionFactory' of type [org.apache.ibatis.session.defaults.DefaultSqlSessionFactory] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:03.902 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'sqlSessionTemplate' of type [org.mybatis.spring.SqlSessionTemplate] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:03.910 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'adminMapper' of type [org.mybatis.spring.mapper.MapperFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:03.913 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'adminMapper' of type [com.sun.proxy.$Proxy92] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:03.915 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'adminServiceImpl' of type [com.wcj.service.impl.AdminServiceImpl] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:03.920 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'userMapper' of type [org.mybatis.spring.mapper.MapperFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:03.921 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'userMapper' of type [com.sun.proxy.$Proxy95] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:03.938 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#12e7aa92' of type [org.springframework.beans.factory.config.PropertiesFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:03.941 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#12e7aa92' of type [java.util.Properties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:03.967 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#1c302178' of type [org.springframework.data.repository.core.support.PropertiesBasedNamedQueries] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:03.970 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#654bd376' of type [org.springframework.data.repository.core.support.RepositoryFragmentsFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:03.974 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#654bd376' of type [org.springframework.data.repository.core.support.RepositoryComposition$RepositoryFragments] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:03.996 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'spring.data.mongodb-org.springframework.boot.autoconfigure.mongo.MongoProperties' of type [org.springframework.boot.autoconfigure.mongo.MongoProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:03.998 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.data.mongo.MongoDbFactoryDependentConfiguration' of type [org.springframework.boot.autoconfigure.data.mongo.MongoDbFactoryDependentConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:04.000 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.data.mongo.MongoDbFactoryConfiguration' of type [org.springframework.boot.autoconfigure.data.mongo.MongoDbFactoryConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:04.002 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration' of type [org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:04.066 INFO  [restartedMain]org.mongodb.driver.cluster.info:71 -Cluster created with settings {hosts=[121.199.34.159:27017], mode=MULTIPLE, requiredClusterType=UNKNOWN, serverSelectionTimeout='30000 ms', maxWaitQueueSize=500}
2020-04-26 23:09:04.067 INFO  [restartedMain]org.mongodb.driver.cluster.info:71 -Adding discovered server 121.199.34.159:27017 to client view of cluster
2020-04-26 23:09:04.100 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongo' of type [com.mongodb.MongoClient] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:04.109 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongoDbFactory' of type [org.springframework.data.mongodb.core.SimpleMongoDbFactory] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:04.116 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.data.mongo.MongoDataConfiguration' of type [org.springframework.boot.autoconfigure.data.mongo.MongoDataConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:04.203 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongoCustomConversions' of type [org.springframework.data.mongodb.core.convert.MongoCustomConversions] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:04.225 INFO  [cluster-ClusterId{value='5ea5a410e88a891144a7891a', description='null'}-121.199.34.159:27017]org.mongodb.driver.connection.info:71 -Opened connection [connectionId{localValue:1, serverValue:617}] to 121.199.34.159:27017
2020-04-26 23:09:04.230 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongoMappingContext' of type [org.springframework.data.mongodb.core.mapping.MongoMappingContext] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:04.265 INFO  [cluster-ClusterId{value='5ea5a410e88a891144a7891a', description='null'}-121.199.34.159:27017]org.mongodb.driver.cluster.info:71 -Monitor thread successfully connected to server with description ServerDescription{address=121.199.34.159:27017, type=STANDALONE, state=CONNECTED, ok=true, version=ServerVersion{versionList=[4, 2, 5]}, minWireVersion=0, maxWireVersion=8, maxDocumentSize=16777216, logicalSessionTimeoutMinutes=30, roundTripTimeNanos=37489000}
2020-04-26 23:09:04.267 INFO  [cluster-ClusterId{value='5ea5a410e88a891144a7891a', description='null'}-121.199.34.159:27017]org.mongodb.driver.cluster.info:71 -Discovered cluster type of STANDALONE
2020-04-26 23:09:04.285 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mappingMongoConverter' of type [org.springframework.data.mongodb.core.convert.MappingMongoConverter] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:04.346 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongoTemplate' of type [org.springframework.data.mongodb.core.MongoTemplate] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:04.581 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'blogCollectionDao' of type [org.springframework.data.mongodb.repository.support.MongoRepositoryFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:04.591 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'blogCollectionDao' of type [com.sun.proxy.$Proxy110] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:04.620 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'typeMapper' of type [org.mybatis.spring.mapper.MapperFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:04.620 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'typeMapper' of type [com.sun.proxy.$Proxy112] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:04.624 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#27e1c0cc' of type [org.springframework.beans.factory.config.PropertiesFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:04.625 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#27e1c0cc' of type [java.util.Properties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:04.626 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#3cf9ec' of type [org.springframework.data.repository.core.support.PropertiesBasedNamedQueries] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:04.627 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#12cc47b6' of type [org.springframework.data.repository.core.support.RepositoryFragmentsFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:04.627 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#12cc47b6' of type [org.springframework.data.repository.core.support.RepositoryComposition$RepositoryFragments] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:04.645 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'commentDao' of type [org.springframework.data.mongodb.repository.support.MongoRepositoryFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:04.645 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'commentDao' of type [com.sun.proxy.$Proxy116] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:04.666 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'userServiceImpl' of type [com.wcj.service.impl.UserServiceImpl] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:04.680 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'adminRealm' of type [com.wcj.realm.AdminRealm] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:04.715 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'securityManager' of type [org.apache.shiro.web.mgt.DefaultWebSecurityManager] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:09:05.040 INFO  [restartedMain]o.s.boot.web.embedded.tomcat.TomcatWebServer.initialize:92 -Tomcat initialized with port(s): 1000 (http)
2020-04-26 23:09:05.048 INFO  [restartedMain]org.apache.coyote.http11.Http11NioProtocol.log:173 -Initializing ProtocolHandler ["http-nio-1000"]
2020-04-26 23:09:05.049 INFO  [restartedMain]org.apache.catalina.core.StandardService.log:173 -Starting service [Tomcat]
2020-04-26 23:09:05.050 INFO  [restartedMain]org.apache.catalina.core.StandardEngine.log:173 -Starting Servlet engine: [Apache Tomcat/9.0.31]
2020-04-26 23:09:05.052 INFO  [restartedMain]org.apache.catalina.core.AprLifecycleListener.log:173 -Loaded APR based Apache Tomcat Native library [1.2.23] using APR version [1.7.0].
2020-04-26 23:09:05.052 INFO  [restartedMain]org.apache.catalina.core.AprLifecycleListener.log:173 -APR capabilities: IPv6 [true], sendfile [true], accept filters [false], random [true].
2020-04-26 23:09:05.052 INFO  [restartedMain]org.apache.catalina.core.AprLifecycleListener.log:173 -APR/OpenSSL configuration: useAprConnector [false], useOpenSSL [true]
2020-04-26 23:09:05.057 INFO  [restartedMain]org.apache.catalina.core.AprLifecycleListener.log:173 -OpenSSL successfully initialized [OpenSSL 1.1.1c  28 May 2019]
2020-04-26 23:09:05.162 INFO  [restartedMain]o.a.catalina.core.ContainerBase.[Tomcat].[localhost].[/].log:173 -Initializing Spring embedded WebApplicationContext
2020-04-26 23:09:05.162 INFO  [restartedMain]org.springframework.web.context.ContextLoader.prepareWebApplicationContext:284 -Root WebApplicationContext: initialization completed in 6584 ms
2020-04-26 23:09:05.269 INFO  [restartedMain]o.s.boot.devtools.autoconfigure.OptionalLiveReloadServer.startServer:58 -LiveReload server is running on port 35729
2020-04-26 23:09:06.650 INFO  [restartedMain]org.apache.coyote.http11.Http11NioProtocol.log:173 -Starting ProtocolHandler ["http-nio-1000"]
2020-04-26 23:09:06.673 INFO  [restartedMain]o.s.boot.web.embedded.tomcat.TomcatWebServer.start:204 -Tomcat started on port(s): 1000 (http) with context path ''
2020-04-26 23:09:06.675 INFO  [restartedMain]com.wcj.BlogApplication.logStarted:61 -Started BlogApplication in 8.946 seconds (JVM running for 11.131)
2020-04-26 23:09:11.499 INFO  [http-nio-1000-exec-1]o.a.catalina.core.ContainerBase.[Tomcat].[localhost].[/].log:173 -Initializing Spring DispatcherServlet 'dispatcherServlet'
2020-04-26 23:09:11.499 INFO  [http-nio-1000-exec-1]org.springframework.web.servlet.DispatcherServlet.initServletBean:525 -Initializing Servlet 'dispatcherServlet'
2020-04-26 23:09:11.519 INFO  [http-nio-1000-exec-1]org.springframework.web.servlet.DispatcherServlet.initServletBean:547 -Completed initialization in 20 ms
2020-04-26 23:09:13.462 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /admin/login
2020-04-26 23:09:13.462 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:09:13.463 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:09:13.466 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.AdminController.login
2020-04-26 23:09:13.466 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Admin(id=null, name=null, header=null, signature=null, comment=null, username=admin, password=admin)]
2020-04-26 23:09:13.602 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 141
2020-04-26 23:09:13.604 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"token":"79DA308515CC0AF333EAA33146D6A025"},"msg":"操作成功!"}
2020-04-26 23:09:13.778 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /admin/info
2020-04-26 23:09:13.779 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:09:13.779 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:09:13.779 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.AdminController.getAdminInfo
2020-04-26 23:09:13.779 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:09:13.780 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 2
2020-04-26 23:09:13.786 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"header":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMSKACehsAACHOzTvceE295.jpg","name":"小屋","password":"","signature":"时光好不经用，转眼已是半生","username":"admin"},"msg":"操作成功!"}
2020-04-26 23:09:14.390 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listFront
2020-04-26 23:09:14.390 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:09:14.391 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:09:14.391 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeLists
2020-04-26 23:09:14.392 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:09:14.408 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listBack
2020-04-26 23:09:14.408 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:09:14.409 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:09:14.409 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeList
2020-04-26 23:09:14.410 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=ASC)]
2020-04-26 23:09:14.477 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 87
2020-04-26 23:09:14.482 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":1,"typeName":"Linux"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":2,"typeName":"Docker"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"SpringBoot"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":4,"typeName":"Mybatis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":5,"typeName":"爬虫"},{"deleted":0,"enable":1,"typeBlogCount":4,"typeId":6,"typeName":"博客开发和维护总结"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":7,"typeName":"CSS"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"JavaScript"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Vue"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":10,"typeName":"随笔"},{"deleted":0,"enable":1,"typeBlogCount":16,"typeId":11,"typeName":"java面试篇"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":13,"typeName":"JDK源码阅读"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":14,"typeName":"redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":15,"typeName":"MongoDB"},{"deleted":0,"enable":1,"typeBlogCount":28,"typeId":16,"typeName":"LeetCode"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":17,"typeName":"随心日记"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":18,"typeName":"计算机网络"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":19,"typeName":"操作系统"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":20,"typeName":"数据结构"}],"msg":"操作成功!"}
2020-04-26 23:09:19.134 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /admin/info
2020-04-26 23:09:19.134 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:09:19.135 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:09:19.135 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.AdminController.getAdminInfo
2020-04-26 23:09:19.135 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:09:19.135 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 1
2020-04-26 23:09:19.136 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"header":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMSKACehsAACHOzTvceE295.jpg","name":"小屋","password":"","signature":"时光好不经用，转眼已是半生","username":"admin"},"msg":"操作成功!"}
2020-04-26 23:09:19.391 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listFront
2020-04-26 23:09:19.391 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:09:19.392 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:09:19.392 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeLists
2020-04-26 23:09:19.392 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:09:19.477 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 86
2020-04-26 23:09:19.479 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":1,"typeName":"Linux"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":2,"typeName":"Docker"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"SpringBoot"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":4,"typeName":"Mybatis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":5,"typeName":"爬虫"},{"deleted":0,"enable":1,"typeBlogCount":4,"typeId":6,"typeName":"博客开发和维护总结"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":7,"typeName":"CSS"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"JavaScript"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Vue"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":10,"typeName":"随笔"},{"deleted":0,"enable":1,"typeBlogCount":16,"typeId":11,"typeName":"java面试篇"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":13,"typeName":"JDK源码阅读"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":14,"typeName":"redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":15,"typeName":"MongoDB"},{"deleted":0,"enable":1,"typeBlogCount":28,"typeId":16,"typeName":"LeetCode"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":17,"typeName":"随心日记"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":18,"typeName":"计算机网络"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":19,"typeName":"操作系统"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":20,"typeName":"数据结构"}],"msg":"操作成功!"}
2020-04-26 23:09:19.692 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listBack
2020-04-26 23:09:19.693 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:09:19.693 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:09:19.694 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeList
2020-04-26 23:09:19.694 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=ASC)]
2020-04-26 23:10:44.673 INFO  [restartedMain]com.wcj.BlogApplication.logStarting:55 -Starting BlogApplication on LAPTOP-SF80F1HO with PID 32488 (D:\MyBlog\blog\target\classes started by 邬成军 in D:\MyBlog\blog)
2020-04-26 23:10:44.677 INFO  [restartedMain]com.wcj.BlogApplication.logStartupProfileInfo:655 -The following profiles are active: pro
2020-04-26 23:10:44.738 INFO  [restartedMain]o.s.b.devtools.env.DevToolsPropertyDefaultsPostProcessor.logTo:225 -Devtools property defaults active! Set 'spring.devtools.add-properties' to 'false' to disable
2020-04-26 23:10:44.738 INFO  [restartedMain]o.s.b.devtools.env.DevToolsPropertyDefaultsPostProcessor.logTo:225 -For additional web related logging consider setting the 'logging.level.web' property to 'DEBUG'
2020-04-26 23:10:45.629 INFO  [restartedMain]o.s.d.repository.config.RepositoryConfigurationDelegate.registerRepositoriesIn:127 -Bootstrapping Spring Data MongoDB repositories in DEFAULT mode.
2020-04-26 23:10:45.716 INFO  [restartedMain]o.s.d.repository.config.RepositoryConfigurationDelegate.registerRepositoriesIn:187 -Finished Spring Data repository scanning in 81ms. Found 4 MongoDB repository interfaces.
2020-04-26 23:10:46.194 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'shiroConfig' of type [com.wcj.config.ShiroConfig$$EnhancerBySpringCGLIB$$80dc23c8] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:46.227 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'hashedCredentialsMatcher' of type [org.apache.shiro.authc.credential.HashedCredentialsMatcher] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:46.269 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mybatis-org.mybatis.spring.boot.autoconfigure.MybatisProperties' of type [org.mybatis.spring.boot.autoconfigure.MybatisProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:46.282 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration' of type [org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration$$EnhancerBySpringCGLIB$$dd8e256f] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:46.288 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceAutoConfigure' of type [com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceAutoConfigure$$EnhancerBySpringCGLIB$$c465c9b1] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:46.293 INFO  [restartedMain]c.a.d.s.boot.autoconfigure.DruidDataSourceAutoConfigure.dataSource:56 -Init DruidDataSource
2020-04-26 23:10:46.373 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'spring.datasource-org.springframework.boot.autoconfigure.jdbc.DataSourceProperties' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:46.389 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'com.alibaba.druid.spring.boot.autoconfigure.stat.DruidFilterConfiguration' of type [com.alibaba.druid.spring.boot.autoconfigure.stat.DruidFilterConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:46.423 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'statFilter' of type [com.alibaba.druid.filter.stat.StatFilter] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:49.712 INFO  [restartedMain]com.alibaba.druid.pool.DruidDataSource.init:930 -{dataSource-1} inited
2020-04-26 23:10:49.712 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'dataSource' of type [com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceWrapper] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:49.786 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:49.970 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'sqlSessionFactory' of type [org.apache.ibatis.session.defaults.DefaultSqlSessionFactory] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:49.977 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'sqlSessionTemplate' of type [org.mybatis.spring.SqlSessionTemplate] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:49.985 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'adminMapper' of type [org.mybatis.spring.mapper.MapperFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:49.989 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'adminMapper' of type [com.sun.proxy.$Proxy92] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:49.991 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'adminServiceImpl' of type [com.wcj.service.impl.AdminServiceImpl] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:49.995 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'userMapper' of type [org.mybatis.spring.mapper.MapperFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:49.996 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'userMapper' of type [com.sun.proxy.$Proxy95] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:50.012 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#544ff66b' of type [org.springframework.beans.factory.config.PropertiesFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:50.015 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#544ff66b' of type [java.util.Properties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:50.040 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#72f3b147' of type [org.springframework.data.repository.core.support.PropertiesBasedNamedQueries] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:50.043 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#5362ce74' of type [org.springframework.data.repository.core.support.RepositoryFragmentsFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:50.047 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#5362ce74' of type [org.springframework.data.repository.core.support.RepositoryComposition$RepositoryFragments] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:50.069 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'spring.data.mongodb-org.springframework.boot.autoconfigure.mongo.MongoProperties' of type [org.springframework.boot.autoconfigure.mongo.MongoProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:50.071 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.data.mongo.MongoDbFactoryDependentConfiguration' of type [org.springframework.boot.autoconfigure.data.mongo.MongoDbFactoryDependentConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:50.074 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.data.mongo.MongoDbFactoryConfiguration' of type [org.springframework.boot.autoconfigure.data.mongo.MongoDbFactoryConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:50.077 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration' of type [org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:50.148 INFO  [restartedMain]org.mongodb.driver.cluster.info:71 -Cluster created with settings {hosts=[121.199.34.159:27017], mode=MULTIPLE, requiredClusterType=UNKNOWN, serverSelectionTimeout='30000 ms', maxWaitQueueSize=500}
2020-04-26 23:10:50.149 INFO  [restartedMain]org.mongodb.driver.cluster.info:71 -Adding discovered server 121.199.34.159:27017 to client view of cluster
2020-04-26 23:10:50.189 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongo' of type [com.mongodb.MongoClient] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:50.201 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongoDbFactory' of type [org.springframework.data.mongodb.core.SimpleMongoDbFactory] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:50.210 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.data.mongo.MongoDataConfiguration' of type [org.springframework.boot.autoconfigure.data.mongo.MongoDataConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:50.301 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongoCustomConversions' of type [org.springframework.data.mongodb.core.convert.MongoCustomConversions] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:50.325 INFO  [cluster-ClusterId{value='5ea5a47a20f0af47fb61053b', description='null'}-121.199.34.159:27017]org.mongodb.driver.connection.info:71 -Opened connection [connectionId{localValue:1, serverValue:618}] to 121.199.34.159:27017
2020-04-26 23:10:50.331 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongoMappingContext' of type [org.springframework.data.mongodb.core.mapping.MongoMappingContext] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:50.372 INFO  [cluster-ClusterId{value='5ea5a47a20f0af47fb61053b', description='null'}-121.199.34.159:27017]org.mongodb.driver.cluster.info:71 -Monitor thread successfully connected to server with description ServerDescription{address=121.199.34.159:27017, type=STANDALONE, state=CONNECTED, ok=true, version=ServerVersion{versionList=[4, 2, 5]}, minWireVersion=0, maxWireVersion=8, maxDocumentSize=16777216, logicalSessionTimeoutMinutes=30, roundTripTimeNanos=45038699}
2020-04-26 23:10:50.374 INFO  [cluster-ClusterId{value='5ea5a47a20f0af47fb61053b', description='null'}-121.199.34.159:27017]org.mongodb.driver.cluster.info:71 -Discovered cluster type of STANDALONE
2020-04-26 23:10:50.386 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mappingMongoConverter' of type [org.springframework.data.mongodb.core.convert.MappingMongoConverter] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:50.487 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongoTemplate' of type [org.springframework.data.mongodb.core.MongoTemplate] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:50.854 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'blogCollectionDao' of type [org.springframework.data.mongodb.repository.support.MongoRepositoryFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:50.864 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'blogCollectionDao' of type [com.sun.proxy.$Proxy110] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:50.895 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'typeMapper' of type [org.mybatis.spring.mapper.MapperFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:50.897 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'typeMapper' of type [com.sun.proxy.$Proxy112] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:50.901 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#c35bca8' of type [org.springframework.beans.factory.config.PropertiesFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:50.902 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#c35bca8' of type [java.util.Properties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:50.903 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#604bd491' of type [org.springframework.data.repository.core.support.PropertiesBasedNamedQueries] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:50.904 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#27cd4efe' of type [org.springframework.data.repository.core.support.RepositoryFragmentsFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:50.905 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#27cd4efe' of type [org.springframework.data.repository.core.support.RepositoryComposition$RepositoryFragments] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:50.921 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'commentDao' of type [org.springframework.data.mongodb.repository.support.MongoRepositoryFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:50.922 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'commentDao' of type [com.sun.proxy.$Proxy116] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:50.944 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'userServiceImpl' of type [com.wcj.service.impl.UserServiceImpl] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:50.959 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'adminRealm' of type [com.wcj.realm.AdminRealm] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:50.996 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'securityManager' of type [org.apache.shiro.web.mgt.DefaultWebSecurityManager] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:10:51.303 INFO  [restartedMain]o.s.boot.web.embedded.tomcat.TomcatWebServer.initialize:92 -Tomcat initialized with port(s): 1000 (http)
2020-04-26 23:10:51.311 INFO  [restartedMain]org.apache.coyote.http11.Http11NioProtocol.log:173 -Initializing ProtocolHandler ["http-nio-1000"]
2020-04-26 23:10:51.311 INFO  [restartedMain]org.apache.catalina.core.StandardService.log:173 -Starting service [Tomcat]
2020-04-26 23:10:51.311 INFO  [restartedMain]org.apache.catalina.core.StandardEngine.log:173 -Starting Servlet engine: [Apache Tomcat/9.0.31]
2020-04-26 23:10:51.313 INFO  [restartedMain]org.apache.catalina.core.AprLifecycleListener.log:173 -Loaded APR based Apache Tomcat Native library [1.2.23] using APR version [1.7.0].
2020-04-26 23:10:51.314 INFO  [restartedMain]org.apache.catalina.core.AprLifecycleListener.log:173 -APR capabilities: IPv6 [true], sendfile [true], accept filters [false], random [true].
2020-04-26 23:10:51.314 INFO  [restartedMain]org.apache.catalina.core.AprLifecycleListener.log:173 -APR/OpenSSL configuration: useAprConnector [false], useOpenSSL [true]
2020-04-26 23:10:51.317 INFO  [restartedMain]org.apache.catalina.core.AprLifecycleListener.log:173 -OpenSSL successfully initialized [OpenSSL 1.1.1c  28 May 2019]
2020-04-26 23:10:51.415 INFO  [restartedMain]o.a.catalina.core.ContainerBase.[Tomcat].[localhost].[/].log:173 -Initializing Spring embedded WebApplicationContext
2020-04-26 23:10:51.415 INFO  [restartedMain]org.springframework.web.context.ContextLoader.prepareWebApplicationContext:284 -Root WebApplicationContext: initialization completed in 6677 ms
2020-04-26 23:10:51.532 INFO  [restartedMain]o.s.boot.devtools.autoconfigure.OptionalLiveReloadServer.startServer:58 -LiveReload server is running on port 35729
2020-04-26 23:10:52.931 INFO  [restartedMain]org.apache.coyote.http11.Http11NioProtocol.log:173 -Starting ProtocolHandler ["http-nio-1000"]
2020-04-26 23:10:52.953 INFO  [restartedMain]o.s.boot.web.embedded.tomcat.TomcatWebServer.start:204 -Tomcat started on port(s): 1000 (http) with context path ''
2020-04-26 23:10:52.954 INFO  [restartedMain]com.wcj.BlogApplication.logStarted:61 -Started BlogApplication in 8.977 seconds (JVM running for 11.295)
2020-04-26 23:10:59.286 INFO  [http-nio-1000-exec-1]o.a.catalina.core.ContainerBase.[Tomcat].[localhost].[/].log:173 -Initializing Spring DispatcherServlet 'dispatcherServlet'
2020-04-26 23:10:59.286 INFO  [http-nio-1000-exec-1]org.springframework.web.servlet.DispatcherServlet.initServletBean:525 -Initializing Servlet 'dispatcherServlet'
2020-04-26 23:10:59.307 INFO  [http-nio-1000-exec-1]org.springframework.web.servlet.DispatcherServlet.initServletBean:547 -Completed initialization in 21 ms
2020-04-26 23:11:01.801 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /admin/login
2020-04-26 23:11:01.801 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:11:01.803 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:11:01.804 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.AdminController.login
2020-04-26 23:11:01.804 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Admin(id=null, name=null, header=null, signature=null, comment=null, username=admin, password=admin)]
2020-04-26 23:11:01.935 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 134
2020-04-26 23:11:01.936 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"token":"ECAD36EFA19D28EA2A6D0192BA48016F"},"msg":"操作成功!"}
2020-04-26 23:11:02.120 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /admin/info
2020-04-26 23:11:02.121 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:11:02.121 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:11:02.121 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.AdminController.getAdminInfo
2020-04-26 23:11:02.121 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:11:02.122 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 2
2020-04-26 23:11:02.127 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"header":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMSKACehsAACHOzTvceE295.jpg","name":"小屋","password":"","signature":"时光好不经用，转眼已是半生","username":"admin"},"msg":"操作成功!"}
2020-04-26 23:11:02.684 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listFront
2020-04-26 23:11:02.686 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:11:02.686 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:11:02.686 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeLists
2020-04-26 23:11:02.687 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:11:02.704 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listBack
2020-04-26 23:11:02.704 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:11:02.705 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:11:02.705 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeList
2020-04-26 23:11:02.705 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=ASC)]
2020-04-26 23:11:02.778 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 94
2020-04-26 23:11:02.782 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":1,"typeName":"Linux"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":2,"typeName":"Docker"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"SpringBoot"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":4,"typeName":"Mybatis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":5,"typeName":"爬虫"},{"deleted":0,"enable":1,"typeBlogCount":4,"typeId":6,"typeName":"博客开发和维护总结"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":7,"typeName":"CSS"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"JavaScript"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Vue"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":10,"typeName":"随笔"},{"deleted":0,"enable":1,"typeBlogCount":16,"typeId":11,"typeName":"java面试篇"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":13,"typeName":"JDK源码阅读"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":14,"typeName":"redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":15,"typeName":"MongoDB"},{"deleted":0,"enable":1,"typeBlogCount":28,"typeId":16,"typeName":"LeetCode"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":17,"typeName":"随心日记"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":18,"typeName":"计算机网络"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":19,"typeName":"操作系统"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":20,"typeName":"数据结构"}],"msg":"操作成功!"}
2020-04-26 23:16:49.566 INFO  [restartedMain]com.wcj.BlogApplication.logStarting:55 -Starting BlogApplication on LAPTOP-SF80F1HO with PID 33580 (D:\MyBlog\blog\target\classes started by 邬成军 in D:\MyBlog\blog)
2020-04-26 23:16:49.570 INFO  [restartedMain]com.wcj.BlogApplication.logStartupProfileInfo:655 -The following profiles are active: pro
2020-04-26 23:16:49.625 INFO  [restartedMain]o.s.b.devtools.env.DevToolsPropertyDefaultsPostProcessor.logTo:225 -Devtools property defaults active! Set 'spring.devtools.add-properties' to 'false' to disable
2020-04-26 23:16:49.625 INFO  [restartedMain]o.s.b.devtools.env.DevToolsPropertyDefaultsPostProcessor.logTo:225 -For additional web related logging consider setting the 'logging.level.web' property to 'DEBUG'
2020-04-26 23:16:50.414 INFO  [restartedMain]o.s.d.repository.config.RepositoryConfigurationDelegate.registerRepositoriesIn:127 -Bootstrapping Spring Data MongoDB repositories in DEFAULT mode.
2020-04-26 23:16:50.500 INFO  [restartedMain]o.s.d.repository.config.RepositoryConfigurationDelegate.registerRepositoriesIn:187 -Finished Spring Data repository scanning in 80ms. Found 4 MongoDB repository interfaces.
2020-04-26 23:16:50.932 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'shiroConfig' of type [com.wcj.config.ShiroConfig$$EnhancerBySpringCGLIB$$31d8e9e2] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:50.958 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'hashedCredentialsMatcher' of type [org.apache.shiro.authc.credential.HashedCredentialsMatcher] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:50.990 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mybatis-org.mybatis.spring.boot.autoconfigure.MybatisProperties' of type [org.mybatis.spring.boot.autoconfigure.MybatisProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:51.001 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration' of type [org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration$$EnhancerBySpringCGLIB$$8e8aeb89] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:51.006 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceAutoConfigure' of type [com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceAutoConfigure$$EnhancerBySpringCGLIB$$75628fcb] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:51.010 INFO  [restartedMain]c.a.d.s.boot.autoconfigure.DruidDataSourceAutoConfigure.dataSource:56 -Init DruidDataSource
2020-04-26 23:16:51.082 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'spring.datasource-org.springframework.boot.autoconfigure.jdbc.DataSourceProperties' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:51.100 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'com.alibaba.druid.spring.boot.autoconfigure.stat.DruidFilterConfiguration' of type [com.alibaba.druid.spring.boot.autoconfigure.stat.DruidFilterConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:51.130 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'statFilter' of type [com.alibaba.druid.filter.stat.StatFilter] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:54.462 INFO  [restartedMain]com.alibaba.druid.pool.DruidDataSource.init:930 -{dataSource-1} inited
2020-04-26 23:16:54.462 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'dataSource' of type [com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceWrapper] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:54.514 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:54.691 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'sqlSessionFactory' of type [org.apache.ibatis.session.defaults.DefaultSqlSessionFactory] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:54.696 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'sqlSessionTemplate' of type [org.mybatis.spring.SqlSessionTemplate] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:54.703 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'adminMapper' of type [org.mybatis.spring.mapper.MapperFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:54.707 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'adminMapper' of type [com.sun.proxy.$Proxy92] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:54.709 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'adminServiceImpl' of type [com.wcj.service.impl.AdminServiceImpl] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:54.713 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'userMapper' of type [org.mybatis.spring.mapper.MapperFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:54.714 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'userMapper' of type [com.sun.proxy.$Proxy95] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:54.729 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#4e919800' of type [org.springframework.beans.factory.config.PropertiesFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:54.732 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#4e919800' of type [java.util.Properties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:54.761 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#4ab01831' of type [org.springframework.data.repository.core.support.PropertiesBasedNamedQueries] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:54.763 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#1a189718' of type [org.springframework.data.repository.core.support.RepositoryFragmentsFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:54.766 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#1a189718' of type [org.springframework.data.repository.core.support.RepositoryComposition$RepositoryFragments] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:54.782 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'spring.data.mongodb-org.springframework.boot.autoconfigure.mongo.MongoProperties' of type [org.springframework.boot.autoconfigure.mongo.MongoProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:54.784 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.data.mongo.MongoDbFactoryDependentConfiguration' of type [org.springframework.boot.autoconfigure.data.mongo.MongoDbFactoryDependentConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:54.786 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.data.mongo.MongoDbFactoryConfiguration' of type [org.springframework.boot.autoconfigure.data.mongo.MongoDbFactoryConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:54.788 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration' of type [org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:54.846 INFO  [restartedMain]org.mongodb.driver.cluster.info:71 -Cluster created with settings {hosts=[121.199.34.159:27017], mode=MULTIPLE, requiredClusterType=UNKNOWN, serverSelectionTimeout='30000 ms', maxWaitQueueSize=500}
2020-04-26 23:16:54.846 INFO  [restartedMain]org.mongodb.driver.cluster.info:71 -Adding discovered server 121.199.34.159:27017 to client view of cluster
2020-04-26 23:16:54.878 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongo' of type [com.mongodb.MongoClient] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:54.886 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongoDbFactory' of type [org.springframework.data.mongodb.core.SimpleMongoDbFactory] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:54.892 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.data.mongo.MongoDataConfiguration' of type [org.springframework.boot.autoconfigure.data.mongo.MongoDataConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:54.968 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongoCustomConversions' of type [org.springframework.data.mongodb.core.convert.MongoCustomConversions] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:54.996 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongoMappingContext' of type [org.springframework.data.mongodb.core.mapping.MongoMappingContext] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:55.013 INFO  [cluster-ClusterId{value='5ea5a5e6e30b86381b70214a', description='null'}-121.199.34.159:27017]org.mongodb.driver.connection.info:71 -Opened connection [connectionId{localValue:1, serverValue:619}] to 121.199.34.159:27017
2020-04-26 23:16:55.041 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mappingMongoConverter' of type [org.springframework.data.mongodb.core.convert.MappingMongoConverter] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:55.056 INFO  [cluster-ClusterId{value='5ea5a5e6e30b86381b70214a', description='null'}-121.199.34.159:27017]org.mongodb.driver.cluster.info:71 -Monitor thread successfully connected to server with description ServerDescription{address=121.199.34.159:27017, type=STANDALONE, state=CONNECTED, ok=true, version=ServerVersion{versionList=[4, 2, 5]}, minWireVersion=0, maxWireVersion=8, maxDocumentSize=16777216, logicalSessionTimeoutMinutes=30, roundTripTimeNanos=41875400}
2020-04-26 23:16:55.058 INFO  [cluster-ClusterId{value='5ea5a5e6e30b86381b70214a', description='null'}-121.199.34.159:27017]org.mongodb.driver.cluster.info:71 -Discovered cluster type of STANDALONE
2020-04-26 23:16:55.093 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongoTemplate' of type [org.springframework.data.mongodb.core.MongoTemplate] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:55.301 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'blogCollectionDao' of type [org.springframework.data.mongodb.repository.support.MongoRepositoryFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:55.310 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'blogCollectionDao' of type [com.sun.proxy.$Proxy110] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:55.334 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'typeMapper' of type [org.mybatis.spring.mapper.MapperFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:55.335 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'typeMapper' of type [com.sun.proxy.$Proxy112] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:55.338 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#66d7f7a' of type [org.springframework.beans.factory.config.PropertiesFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:55.339 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#66d7f7a' of type [java.util.Properties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:55.340 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#152dd8fc' of type [org.springframework.data.repository.core.support.PropertiesBasedNamedQueries] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:55.341 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#706baae4' of type [org.springframework.data.repository.core.support.RepositoryFragmentsFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:55.342 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#706baae4' of type [org.springframework.data.repository.core.support.RepositoryComposition$RepositoryFragments] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:55.356 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'commentDao' of type [org.springframework.data.mongodb.repository.support.MongoRepositoryFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:55.357 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'commentDao' of type [com.sun.proxy.$Proxy116] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:55.374 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'userServiceImpl' of type [com.wcj.service.impl.UserServiceImpl] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:55.388 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'adminRealm' of type [com.wcj.realm.AdminRealm] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:55.418 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'securityManager' of type [org.apache.shiro.web.mgt.DefaultWebSecurityManager] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:16:55.667 INFO  [restartedMain]o.s.boot.web.embedded.tomcat.TomcatWebServer.initialize:92 -Tomcat initialized with port(s): 1000 (http)
2020-04-26 23:16:55.674 INFO  [restartedMain]org.apache.coyote.http11.Http11NioProtocol.log:173 -Initializing ProtocolHandler ["http-nio-1000"]
2020-04-26 23:16:55.675 INFO  [restartedMain]org.apache.catalina.core.StandardService.log:173 -Starting service [Tomcat]
2020-04-26 23:16:55.675 INFO  [restartedMain]org.apache.catalina.core.StandardEngine.log:173 -Starting Servlet engine: [Apache Tomcat/9.0.31]
2020-04-26 23:16:55.677 INFO  [restartedMain]org.apache.catalina.core.AprLifecycleListener.log:173 -Loaded APR based Apache Tomcat Native library [1.2.23] using APR version [1.7.0].
2020-04-26 23:16:55.677 INFO  [restartedMain]org.apache.catalina.core.AprLifecycleListener.log:173 -APR capabilities: IPv6 [true], sendfile [true], accept filters [false], random [true].
2020-04-26 23:16:55.677 INFO  [restartedMain]org.apache.catalina.core.AprLifecycleListener.log:173 -APR/OpenSSL configuration: useAprConnector [false], useOpenSSL [true]
2020-04-26 23:16:55.680 INFO  [restartedMain]org.apache.catalina.core.AprLifecycleListener.log:173 -OpenSSL successfully initialized [OpenSSL 1.1.1c  28 May 2019]
2020-04-26 23:16:55.770 INFO  [restartedMain]o.a.catalina.core.ContainerBase.[Tomcat].[localhost].[/].log:173 -Initializing Spring embedded WebApplicationContext
2020-04-26 23:16:55.770 INFO  [restartedMain]org.springframework.web.context.ContextLoader.prepareWebApplicationContext:284 -Root WebApplicationContext: initialization completed in 6144 ms
2020-04-26 23:16:55.867 INFO  [restartedMain]o.s.boot.devtools.autoconfigure.OptionalLiveReloadServer.startServer:58 -LiveReload server is running on port 35729
2020-04-26 23:16:57.198 INFO  [restartedMain]org.apache.coyote.http11.Http11NioProtocol.log:173 -Starting ProtocolHandler ["http-nio-1000"]
2020-04-26 23:16:57.219 INFO  [restartedMain]o.s.boot.web.embedded.tomcat.TomcatWebServer.start:204 -Tomcat started on port(s): 1000 (http) with context path ''
2020-04-26 23:16:57.221 INFO  [restartedMain]com.wcj.BlogApplication.logStarted:61 -Started BlogApplication in 8.331 seconds (JVM running for 10.316)
2020-04-26 23:17:02.076 INFO  [http-nio-1000-exec-1]o.a.catalina.core.ContainerBase.[Tomcat].[localhost].[/].log:173 -Initializing Spring DispatcherServlet 'dispatcherServlet'
2020-04-26 23:17:02.077 INFO  [http-nio-1000-exec-1]org.springframework.web.servlet.DispatcherServlet.initServletBean:525 -Initializing Servlet 'dispatcherServlet'
2020-04-26 23:17:02.093 INFO  [http-nio-1000-exec-1]org.springframework.web.servlet.DispatcherServlet.initServletBean:547 -Completed initialization in 15 ms
2020-04-26 23:17:05.088 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /admin/login
2020-04-26 23:17:05.088 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:17:05.090 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:17:05.092 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.AdminController.login
2020-04-26 23:17:05.092 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Admin(id=null, name=null, header=null, signature=null, comment=null, username=admin, password=admin)]
2020-04-26 23:17:05.230 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 142
2020-04-26 23:17:05.232 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"token":"A7883791D238E1185A29ADDEF5352598"},"msg":"操作成功!"}
2020-04-26 23:17:05.399 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /admin/info
2020-04-26 23:17:05.400 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:17:05.400 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:17:05.401 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.AdminController.getAdminInfo
2020-04-26 23:17:05.401 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:17:05.401 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 2
2020-04-26 23:17:05.405 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"header":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMSKACehsAACHOzTvceE295.jpg","name":"小屋","password":"","signature":"时光好不经用，转眼已是半生","username":"admin"},"msg":"操作成功!"}
2020-04-26 23:17:05.940 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listFront
2020-04-26 23:17:05.941 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:17:05.942 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:17:05.942 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeLists
2020-04-26 23:17:05.943 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:17:05.958 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listBack
2020-04-26 23:17:05.959 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:17:05.959 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:17:05.960 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeList
2020-04-26 23:17:05.960 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=ASC)]
2020-04-26 23:17:06.031 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 91
2020-04-26 23:17:06.035 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":1,"typeName":"Linux"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":2,"typeName":"Docker"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"SpringBoot"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":4,"typeName":"Mybatis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":5,"typeName":"爬虫"},{"deleted":0,"enable":1,"typeBlogCount":4,"typeId":6,"typeName":"博客开发和维护总结"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":7,"typeName":"CSS"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"JavaScript"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Vue"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":10,"typeName":"随笔"},{"deleted":0,"enable":1,"typeBlogCount":16,"typeId":11,"typeName":"java面试篇"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":13,"typeName":"JDK源码阅读"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":14,"typeName":"redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":15,"typeName":"MongoDB"},{"deleted":0,"enable":1,"typeBlogCount":28,"typeId":16,"typeName":"LeetCode"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":17,"typeName":"随心日记"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":18,"typeName":"计算机网络"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":19,"typeName":"操作系统"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":20,"typeName":"数据结构"}],"msg":"操作成功!"}
2020-04-26 23:20:59.360 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listBack
2020-04-26 23:20:59.361 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:20:59.361 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:20:59.361 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeList
2020-04-26 23:20:59.361 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=ASC)]
2020-04-26 23:22:04.713 INFO  [restartedMain]com.wcj.BlogApplication.logStarting:55 -Starting BlogApplication on LAPTOP-SF80F1HO with PID 27780 (D:\MyBlog\blog\target\classes started by 邬成军 in D:\MyBlog\blog)
2020-04-26 23:22:04.716 INFO  [restartedMain]com.wcj.BlogApplication.logStartupProfileInfo:655 -The following profiles are active: pro
2020-04-26 23:22:04.773 INFO  [restartedMain]o.s.b.devtools.env.DevToolsPropertyDefaultsPostProcessor.logTo:225 -Devtools property defaults active! Set 'spring.devtools.add-properties' to 'false' to disable
2020-04-26 23:22:04.773 INFO  [restartedMain]o.s.b.devtools.env.DevToolsPropertyDefaultsPostProcessor.logTo:225 -For additional web related logging consider setting the 'logging.level.web' property to 'DEBUG'
2020-04-26 23:22:05.541 INFO  [restartedMain]o.s.d.repository.config.RepositoryConfigurationDelegate.registerRepositoriesIn:127 -Bootstrapping Spring Data MongoDB repositories in DEFAULT mode.
2020-04-26 23:22:05.628 INFO  [restartedMain]o.s.d.repository.config.RepositoryConfigurationDelegate.registerRepositoriesIn:187 -Finished Spring Data repository scanning in 81ms. Found 4 MongoDB repository interfaces.
2020-04-26 23:22:06.070 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'shiroConfig' of type [com.wcj.config.ShiroConfig$$EnhancerBySpringCGLIB$$855f7873] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:06.102 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'hashedCredentialsMatcher' of type [org.apache.shiro.authc.credential.HashedCredentialsMatcher] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:06.137 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mybatis-org.mybatis.spring.boot.autoconfigure.MybatisProperties' of type [org.mybatis.spring.boot.autoconfigure.MybatisProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:06.146 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration' of type [org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration$$EnhancerBySpringCGLIB$$e2117a1a] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:06.151 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceAutoConfigure' of type [com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceAutoConfigure$$EnhancerBySpringCGLIB$$c8e91e5c] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:06.155 INFO  [restartedMain]c.a.d.s.boot.autoconfigure.DruidDataSourceAutoConfigure.dataSource:56 -Init DruidDataSource
2020-04-26 23:22:06.213 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'spring.datasource-org.springframework.boot.autoconfigure.jdbc.DataSourceProperties' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:06.239 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'com.alibaba.druid.spring.boot.autoconfigure.stat.DruidFilterConfiguration' of type [com.alibaba.druid.spring.boot.autoconfigure.stat.DruidFilterConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:06.264 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'statFilter' of type [com.alibaba.druid.filter.stat.StatFilter] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:09.690 INFO  [restartedMain]com.alibaba.druid.pool.DruidDataSource.init:930 -{dataSource-1} inited
2020-04-26 23:22:09.691 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'dataSource' of type [com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceWrapper] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:09.752 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:09.925 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'sqlSessionFactory' of type [org.apache.ibatis.session.defaults.DefaultSqlSessionFactory] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:09.930 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'sqlSessionTemplate' of type [org.mybatis.spring.SqlSessionTemplate] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:09.937 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'adminMapper' of type [org.mybatis.spring.mapper.MapperFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:09.940 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'adminMapper' of type [com.sun.proxy.$Proxy92] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:09.942 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'adminServiceImpl' of type [com.wcj.service.impl.AdminServiceImpl] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:09.946 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'userMapper' of type [org.mybatis.spring.mapper.MapperFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:09.947 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'userMapper' of type [com.sun.proxy.$Proxy95] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:09.962 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#269a37cc' of type [org.springframework.beans.factory.config.PropertiesFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:09.964 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#269a37cc' of type [java.util.Properties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:09.988 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#4181ab14' of type [org.springframework.data.repository.core.support.PropertiesBasedNamedQueries] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:09.991 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#24b2cf3a' of type [org.springframework.data.repository.core.support.RepositoryFragmentsFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:09.995 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#24b2cf3a' of type [org.springframework.data.repository.core.support.RepositoryComposition$RepositoryFragments] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:10.020 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'spring.data.mongodb-org.springframework.boot.autoconfigure.mongo.MongoProperties' of type [org.springframework.boot.autoconfigure.mongo.MongoProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:10.022 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.data.mongo.MongoDbFactoryDependentConfiguration' of type [org.springframework.boot.autoconfigure.data.mongo.MongoDbFactoryDependentConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:10.024 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.data.mongo.MongoDbFactoryConfiguration' of type [org.springframework.boot.autoconfigure.data.mongo.MongoDbFactoryConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:10.026 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration' of type [org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:10.080 INFO  [restartedMain]org.mongodb.driver.cluster.info:71 -Cluster created with settings {hosts=[121.199.34.159:27017], mode=MULTIPLE, requiredClusterType=UNKNOWN, serverSelectionTimeout='30000 ms', maxWaitQueueSize=500}
2020-04-26 23:22:10.081 INFO  [restartedMain]org.mongodb.driver.cluster.info:71 -Adding discovered server 121.199.34.159:27017 to client view of cluster
2020-04-26 23:22:10.114 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongo' of type [com.mongodb.MongoClient] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:10.123 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongoDbFactory' of type [org.springframework.data.mongodb.core.SimpleMongoDbFactory] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:10.129 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.data.mongo.MongoDataConfiguration' of type [org.springframework.boot.autoconfigure.data.mongo.MongoDataConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:10.199 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongoCustomConversions' of type [org.springframework.data.mongodb.core.convert.MongoCustomConversions] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:10.223 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongoMappingContext' of type [org.springframework.data.mongodb.core.mapping.MongoMappingContext] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:10.240 INFO  [cluster-ClusterId{value='5ea5a7228e58e7434249e1b6', description='null'}-121.199.34.159:27017]org.mongodb.driver.connection.info:71 -Opened connection [connectionId{localValue:1, serverValue:620}] to 121.199.34.159:27017
2020-04-26 23:22:10.267 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mappingMongoConverter' of type [org.springframework.data.mongodb.core.convert.MappingMongoConverter] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:10.285 INFO  [cluster-ClusterId{value='5ea5a7228e58e7434249e1b6', description='null'}-121.199.34.159:27017]org.mongodb.driver.cluster.info:71 -Monitor thread successfully connected to server with description ServerDescription{address=121.199.34.159:27017, type=STANDALONE, state=CONNECTED, ok=true, version=ServerVersion{versionList=[4, 2, 5]}, minWireVersion=0, maxWireVersion=8, maxDocumentSize=16777216, logicalSessionTimeoutMinutes=30, roundTripTimeNanos=42105500}
2020-04-26 23:22:10.285 INFO  [cluster-ClusterId{value='5ea5a7228e58e7434249e1b6', description='null'}-121.199.34.159:27017]org.mongodb.driver.cluster.info:71 -Discovered cluster type of STANDALONE
2020-04-26 23:22:10.312 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongoTemplate' of type [org.springframework.data.mongodb.core.MongoTemplate] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:10.497 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'blogCollectionDao' of type [org.springframework.data.mongodb.repository.support.MongoRepositoryFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:10.508 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'blogCollectionDao' of type [com.sun.proxy.$Proxy110] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:10.532 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'typeMapper' of type [org.mybatis.spring.mapper.MapperFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:10.533 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'typeMapper' of type [com.sun.proxy.$Proxy112] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:10.536 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#95d4e2b' of type [org.springframework.beans.factory.config.PropertiesFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:10.537 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#95d4e2b' of type [java.util.Properties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:10.537 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#48fac980' of type [org.springframework.data.repository.core.support.PropertiesBasedNamedQueries] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:10.538 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#17c4bc37' of type [org.springframework.data.repository.core.support.RepositoryFragmentsFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:10.539 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#17c4bc37' of type [org.springframework.data.repository.core.support.RepositoryComposition$RepositoryFragments] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:10.553 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'commentDao' of type [org.springframework.data.mongodb.repository.support.MongoRepositoryFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:10.555 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'commentDao' of type [com.sun.proxy.$Proxy116] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:10.571 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'userServiceImpl' of type [com.wcj.service.impl.UserServiceImpl] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:10.584 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'adminRealm' of type [com.wcj.realm.AdminRealm] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:10.615 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'securityManager' of type [org.apache.shiro.web.mgt.DefaultWebSecurityManager] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:22:10.863 INFO  [restartedMain]o.s.boot.web.embedded.tomcat.TomcatWebServer.initialize:92 -Tomcat initialized with port(s): 1000 (http)
2020-04-26 23:22:10.870 INFO  [restartedMain]org.apache.coyote.http11.Http11NioProtocol.log:173 -Initializing ProtocolHandler ["http-nio-1000"]
2020-04-26 23:22:10.871 INFO  [restartedMain]org.apache.catalina.core.StandardService.log:173 -Starting service [Tomcat]
2020-04-26 23:22:10.871 INFO  [restartedMain]org.apache.catalina.core.StandardEngine.log:173 -Starting Servlet engine: [Apache Tomcat/9.0.31]
2020-04-26 23:22:10.872 INFO  [restartedMain]org.apache.catalina.core.AprLifecycleListener.log:173 -Loaded APR based Apache Tomcat Native library [1.2.23] using APR version [1.7.0].
2020-04-26 23:22:10.873 INFO  [restartedMain]org.apache.catalina.core.AprLifecycleListener.log:173 -APR capabilities: IPv6 [true], sendfile [true], accept filters [false], random [true].
2020-04-26 23:22:10.873 INFO  [restartedMain]org.apache.catalina.core.AprLifecycleListener.log:173 -APR/OpenSSL configuration: useAprConnector [false], useOpenSSL [true]
2020-04-26 23:22:10.876 INFO  [restartedMain]org.apache.catalina.core.AprLifecycleListener.log:173 -OpenSSL successfully initialized [OpenSSL 1.1.1c  28 May 2019]
2020-04-26 23:22:10.965 INFO  [restartedMain]o.a.catalina.core.ContainerBase.[Tomcat].[localhost].[/].log:173 -Initializing Spring embedded WebApplicationContext
2020-04-26 23:22:10.966 INFO  [restartedMain]org.springframework.web.context.ContextLoader.prepareWebApplicationContext:284 -Root WebApplicationContext: initialization completed in 6192 ms
2020-04-26 23:22:11.064 INFO  [restartedMain]o.s.boot.devtools.autoconfigure.OptionalLiveReloadServer.startServer:58 -LiveReload server is running on port 35729
2020-04-26 23:22:12.312 INFO  [restartedMain]org.apache.coyote.http11.Http11NioProtocol.log:173 -Starting ProtocolHandler ["http-nio-1000"]
2020-04-26 23:22:12.332 INFO  [restartedMain]o.s.boot.web.embedded.tomcat.TomcatWebServer.start:204 -Tomcat started on port(s): 1000 (http) with context path ''
2020-04-26 23:22:12.334 INFO  [restartedMain]com.wcj.BlogApplication.logStarted:61 -Started BlogApplication in 8.284 seconds (JVM running for 10.402)
2020-04-26 23:22:18.375 INFO  [http-nio-1000-exec-1]o.a.catalina.core.ContainerBase.[Tomcat].[localhost].[/].log:173 -Initializing Spring DispatcherServlet 'dispatcherServlet'
2020-04-26 23:22:18.375 INFO  [http-nio-1000-exec-1]org.springframework.web.servlet.DispatcherServlet.initServletBean:525 -Initializing Servlet 'dispatcherServlet'
2020-04-26 23:22:18.386 INFO  [http-nio-1000-exec-1]org.springframework.web.servlet.DispatcherServlet.initServletBean:547 -Completed initialization in 11 ms
2020-04-26 23:22:19.932 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /admin/login
2020-04-26 23:22:19.932 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:22:19.933 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:22:19.936 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.AdminController.login
2020-04-26 23:22:19.936 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Admin(id=null, name=null, header=null, signature=null, comment=null, username=admin, password=admin)]
2020-04-26 23:22:20.082 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 151
2020-04-26 23:22:20.083 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"token":"40CB82BDD0C6A552A4BE107B0AF48B21"},"msg":"操作成功!"}
2020-04-26 23:22:20.284 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /admin/info
2020-04-26 23:22:20.285 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:22:20.285 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:22:20.285 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.AdminController.getAdminInfo
2020-04-26 23:22:20.285 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:22:20.285 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 1
2020-04-26 23:22:20.291 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"header":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMSKACehsAACHOzTvceE295.jpg","name":"小屋","password":"","signature":"时光好不经用，转眼已是半生","username":"admin"},"msg":"操作成功!"}
2020-04-26 23:22:20.845 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listFront
2020-04-26 23:22:20.845 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:22:20.846 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:22:20.846 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeLists
2020-04-26 23:22:20.846 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:22:20.863 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listBack
2020-04-26 23:22:20.863 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:22:20.863 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:22:20.863 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeList
2020-04-26 23:22:20.864 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=ASC)]
2020-04-26 23:22:20.941 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 96
2020-04-26 23:22:20.946 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":1,"typeName":"Linux"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":2,"typeName":"Docker"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"SpringBoot"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":4,"typeName":"Mybatis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":5,"typeName":"爬虫"},{"deleted":0,"enable":1,"typeBlogCount":4,"typeId":6,"typeName":"博客开发和维护总结"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":7,"typeName":"CSS"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"JavaScript"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Vue"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":10,"typeName":"随笔"},{"deleted":0,"enable":1,"typeBlogCount":16,"typeId":11,"typeName":"java面试篇"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":13,"typeName":"JDK源码阅读"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":14,"typeName":"redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":15,"typeName":"MongoDB"},{"deleted":0,"enable":1,"typeBlogCount":28,"typeId":16,"typeName":"LeetCode"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":17,"typeName":"随心日记"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":18,"typeName":"计算机网络"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":19,"typeName":"操作系统"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":20,"typeName":"数据结构"}],"msg":"操作成功!"}
2020-04-26 23:22:21.082 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 219
2020-04-26 23:22:21.087 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"enable":1,"typeBlogCount":1,"typeId":1,"typeName":"Linux"},{"enable":1,"typeBlogCount":0,"typeId":2,"typeName":"Docker"},{"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"SpringBoot"},{"enable":1,"typeBlogCount":0,"typeId":4,"typeName":"Mybatis"},{"enable":1,"typeBlogCount":0,"typeId":5,"typeName":"爬虫"},{"enable":1,"typeBlogCount":4,"typeId":6,"typeName":"博客开发和维护总结"},{"enable":1,"typeBlogCount":1,"typeId":7,"typeName":"CSS"},{"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"JavaScript"},{"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Vue"},{"enable":1,"typeBlogCount":1,"typeId":10,"typeName":"随笔"}],"pageSize":10,"params":{},"sortMethod":"ASC","totalCount":19,"totalPage":2},"msg":"操作成功!"}
2020-04-26 23:23:44.289 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listBack
2020-04-26 23:23:44.289 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:23:44.290 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:23:44.291 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeList
2020-04-26 23:23:44.291 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=ASC)]
2020-04-26 23:23:44.479 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 190
2020-04-26 23:23:44.479 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"enable":1,"typeBlogCount":1,"typeId":1,"typeName":"Linux"},{"enable":1,"typeBlogCount":0,"typeId":2,"typeName":"Docker"},{"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"SpringBoot"},{"enable":1,"typeBlogCount":0,"typeId":4,"typeName":"Mybatis"},{"enable":1,"typeBlogCount":0,"typeId":5,"typeName":"爬虫"},{"enable":1,"typeBlogCount":4,"typeId":6,"typeName":"博客开发和维护总结"},{"enable":1,"typeBlogCount":1,"typeId":7,"typeName":"CSS"},{"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"JavaScript"},{"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Vue"},{"enable":1,"typeBlogCount":1,"typeId":10,"typeName":"随笔"}],"pageSize":10,"params":{},"sortMethod":"ASC","totalCount":19,"totalPage":2},"msg":"操作成功!"}
2020-04-26 23:24:30.808 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listBack
2020-04-26 23:24:30.809 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:24:30.810 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:24:30.811 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeList
2020-04-26 23:24:30.812 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=ASC)]
2020-04-26 23:24:31.000 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 192
2020-04-26 23:24:31.001 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"enable":1,"typeBlogCount":1,"typeId":1,"typeName":"Linux"},{"enable":1,"typeBlogCount":0,"typeId":2,"typeName":"Docker"},{"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"SpringBoot"},{"enable":1,"typeBlogCount":0,"typeId":4,"typeName":"Mybatis"},{"enable":1,"typeBlogCount":0,"typeId":5,"typeName":"爬虫"},{"enable":1,"typeBlogCount":4,"typeId":6,"typeName":"博客开发和维护总结"},{"enable":1,"typeBlogCount":1,"typeId":7,"typeName":"CSS"},{"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"JavaScript"},{"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Vue"},{"enable":1,"typeBlogCount":1,"typeId":10,"typeName":"随笔"}],"pageSize":10,"params":{},"sortMethod":"ASC","totalCount":19,"totalPage":2},"msg":"操作成功!"}
2020-04-26 23:24:59.406 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /admin/info
2020-04-26 23:24:59.407 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:24:59.407 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:24:59.408 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.AdminController.getAdminInfo
2020-04-26 23:24:59.408 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:24:59.408 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 2
2020-04-26 23:24:59.408 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"header":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMSKACehsAACHOzTvceE295.jpg","name":"小屋","password":"","signature":"时光好不经用，转眼已是半生","username":"admin"},"msg":"操作成功!"}
2020-04-26 23:24:59.668 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listFront
2020-04-26 23:24:59.668 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:24:59.668 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:24:59.669 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeLists
2020-04-26 23:24:59.669 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:24:59.760 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 93
2020-04-26 23:24:59.761 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":1,"typeName":"Linux"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":2,"typeName":"Docker"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"SpringBoot"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":4,"typeName":"Mybatis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":5,"typeName":"爬虫"},{"deleted":0,"enable":1,"typeBlogCount":4,"typeId":6,"typeName":"博客开发和维护总结"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":7,"typeName":"CSS"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"JavaScript"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Vue"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":10,"typeName":"随笔"},{"deleted":0,"enable":1,"typeBlogCount":16,"typeId":11,"typeName":"java面试篇"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":13,"typeName":"JDK源码阅读"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":14,"typeName":"redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":15,"typeName":"MongoDB"},{"deleted":0,"enable":1,"typeBlogCount":28,"typeId":16,"typeName":"LeetCode"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":17,"typeName":"随心日记"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":18,"typeName":"计算机网络"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":19,"typeName":"操作系统"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":20,"typeName":"数据结构"}],"msg":"操作成功!"}
2020-04-26 23:24:59.970 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listBack
2020-04-26 23:24:59.970 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:24:59.971 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:24:59.971 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeList
2020-04-26 23:24:59.971 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=ASC)]
2020-04-26 23:25:00.172 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 202
2020-04-26 23:25:00.173 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"enable":1,"typeBlogCount":1,"typeId":1,"typeName":"Linux"},{"enable":1,"typeBlogCount":0,"typeId":2,"typeName":"Docker"},{"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"SpringBoot"},{"enable":1,"typeBlogCount":0,"typeId":4,"typeName":"Mybatis"},{"enable":1,"typeBlogCount":0,"typeId":5,"typeName":"爬虫"},{"enable":1,"typeBlogCount":4,"typeId":6,"typeName":"博客开发和维护总结"},{"enable":1,"typeBlogCount":1,"typeId":7,"typeName":"CSS"},{"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"JavaScript"},{"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Vue"},{"enable":1,"typeBlogCount":1,"typeId":10,"typeName":"随笔"}],"pageSize":10,"params":{},"sortMethod":"ASC","totalCount":19,"totalPage":2},"msg":"操作成功!"}
2020-04-26 23:25:02.235 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listBack
2020-04-26 23:25:02.235 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:25:02.235 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:25:02.235 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeList
2020-04-26 23:25:02.235 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=2, pageSize=10, totalPage=2, totalCount=19, list=[Type(typeId=1, typeName=Linux, typeBlogCount=1, enable=1, deleted=null), Type(typeId=2, typeName=Docker, typeBlogCount=0, enable=1, deleted=null), Type(typeId=3, typeName=SpringBoot, typeBlogCount=0, enable=1, deleted=null), Type(typeId=4, typeName=Mybatis, typeBlogCount=0, enable=1, deleted=null), Type(typeId=5, typeName=爬虫, typeBlogCount=0, enable=1, deleted=null), Type(typeId=6, typeName=博客开发和维护总结, typeBlogCount=4, enable=1, deleted=null), Type(typeId=7, typeName=CSS, typeBlogCount=1, enable=1, deleted=null), Type(typeId=8, typeName=JavaScript, typeBlogCount=0, enable=1, deleted=null), Type(typeId=9, typeName=Vue, typeBlogCount=0, enable=1, deleted=null), Type(typeId=10, typeName=随笔, typeBlogCount=1, enable=1, deleted=null)], params={}, sortColumn=null, sortMethod=ASC)]
2020-04-26 23:25:02.425 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 190
2020-04-26 23:25:02.425 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":2,"index":10,"list":[{"enable":1,"typeBlogCount":16,"typeId":11,"typeName":"java面试篇"},{"enable":1,"typeBlogCount":0,"typeId":13,"typeName":"JDK源码阅读"},{"enable":1,"typeBlogCount":1,"typeId":14,"typeName":"redis"},{"enable":1,"typeBlogCount":0,"typeId":15,"typeName":"MongoDB"},{"enable":1,"typeBlogCount":28,"typeId":16,"typeName":"LeetCode"},{"enable":1,"typeBlogCount":1,"typeId":17,"typeName":"随心日记"},{"enable":1,"typeBlogCount":0,"typeId":18,"typeName":"计算机网络"},{"enable":1,"typeBlogCount":0,"typeId":19,"typeName":"操作系统"},{"enable":1,"typeBlogCount":0,"typeId":20,"typeName":"数据结构"}],"pageSize":10,"params":{},"sortMethod":"ASC","totalCount":19,"totalPage":2},"msg":"操作成功!"}
2020-04-26 23:25:06.582 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listBack
2020-04-26 23:25:06.582 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:25:06.582 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:25:06.582 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeList
2020-04-26 23:25:06.583 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=10, totalPage=2, totalCount=19, list=[Type(typeId=11, typeName=java面试篇, typeBlogCount=16, enable=1, deleted=null), Type(typeId=13, typeName=JDK源码阅读, typeBlogCount=0, enable=1, deleted=null), Type(typeId=14, typeName=redis, typeBlogCount=1, enable=1, deleted=null), Type(typeId=15, typeName=MongoDB, typeBlogCount=0, enable=1, deleted=null), Type(typeId=16, typeName=LeetCode, typeBlogCount=28, enable=1, deleted=null), Type(typeId=17, typeName=随心日记, typeBlogCount=1, enable=1, deleted=null), Type(typeId=18, typeName=计算机网络, typeBlogCount=0, enable=1, deleted=null), Type(typeId=19, typeName=操作系统, typeBlogCount=0, enable=1, deleted=null), Type(typeId=20, typeName=数据结构, typeBlogCount=0, enable=1, deleted=null)], params={}, sortColumn=null, sortMethod=ASC)]
2020-04-26 23:25:06.771 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 189
2020-04-26 23:25:06.771 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"enable":1,"typeBlogCount":1,"typeId":1,"typeName":"Linux"},{"enable":1,"typeBlogCount":0,"typeId":2,"typeName":"Docker"},{"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"SpringBoot"},{"enable":1,"typeBlogCount":0,"typeId":4,"typeName":"Mybatis"},{"enable":1,"typeBlogCount":0,"typeId":5,"typeName":"爬虫"},{"enable":1,"typeBlogCount":4,"typeId":6,"typeName":"博客开发和维护总结"},{"enable":1,"typeBlogCount":1,"typeId":7,"typeName":"CSS"},{"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"JavaScript"},{"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Vue"},{"enable":1,"typeBlogCount":1,"typeId":10,"typeName":"随笔"}],"pageSize":10,"params":{},"sortMethod":"ASC","totalCount":19,"totalPage":2},"msg":"操作成功!"}
2020-04-26 23:25:15.165 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listBack
2020-04-26 23:25:15.166 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:25:15.166 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:25:15.166 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeList
2020-04-26 23:25:15.166 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=2, pageSize=10, totalPage=2, totalCount=19, list=[Type(typeId=1, typeName=Linux, typeBlogCount=1, enable=1, deleted=null), Type(typeId=2, typeName=Docker, typeBlogCount=0, enable=1, deleted=null), Type(typeId=3, typeName=SpringBoot, typeBlogCount=0, enable=1, deleted=null), Type(typeId=4, typeName=Mybatis, typeBlogCount=0, enable=1, deleted=null), Type(typeId=5, typeName=爬虫, typeBlogCount=0, enable=1, deleted=null), Type(typeId=6, typeName=博客开发和维护总结, typeBlogCount=4, enable=1, deleted=null), Type(typeId=7, typeName=CSS, typeBlogCount=1, enable=1, deleted=null), Type(typeId=8, typeName=JavaScript, typeBlogCount=0, enable=1, deleted=null), Type(typeId=9, typeName=Vue, typeBlogCount=0, enable=1, deleted=null), Type(typeId=10, typeName=随笔, typeBlogCount=1, enable=1, deleted=null)], params={}, sortColumn=null, sortMethod=ASC)]
2020-04-26 23:25:15.344 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 179
2020-04-26 23:25:15.344 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":2,"index":10,"list":[{"enable":1,"typeBlogCount":16,"typeId":11,"typeName":"java面试篇"},{"enable":1,"typeBlogCount":0,"typeId":13,"typeName":"JDK源码阅读"},{"enable":1,"typeBlogCount":1,"typeId":14,"typeName":"redis"},{"enable":1,"typeBlogCount":0,"typeId":15,"typeName":"MongoDB"},{"enable":1,"typeBlogCount":28,"typeId":16,"typeName":"LeetCode"},{"enable":1,"typeBlogCount":1,"typeId":17,"typeName":"随心日记"},{"enable":1,"typeBlogCount":0,"typeId":18,"typeName":"计算机网络"},{"enable":1,"typeBlogCount":0,"typeId":19,"typeName":"操作系统"},{"enable":1,"typeBlogCount":0,"typeId":20,"typeName":"数据结构"}],"pageSize":10,"params":{},"sortMethod":"ASC","totalCount":19,"totalPage":2},"msg":"操作成功!"}
2020-04-26 23:25:23.685 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listBack
2020-04-26 23:25:23.685 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:25:23.686 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:25:23.686 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeList
2020-04-26 23:25:23.686 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=10, totalPage=2, totalCount=19, list=[Type(typeId=11, typeName=java面试篇, typeBlogCount=16, enable=1, deleted=null), Type(typeId=13, typeName=JDK源码阅读, typeBlogCount=0, enable=1, deleted=null), Type(typeId=14, typeName=redis, typeBlogCount=1, enable=1, deleted=null), Type(typeId=15, typeName=MongoDB, typeBlogCount=0, enable=1, deleted=null), Type(typeId=16, typeName=LeetCode, typeBlogCount=28, enable=1, deleted=null), Type(typeId=17, typeName=随心日记, typeBlogCount=1, enable=1, deleted=null), Type(typeId=18, typeName=计算机网络, typeBlogCount=0, enable=1, deleted=null), Type(typeId=19, typeName=操作系统, typeBlogCount=0, enable=1, deleted=null), Type(typeId=20, typeName=数据结构, typeBlogCount=0, enable=1, deleted=null)], params={}, sortColumn=null, sortMethod=ASC)]
2020-04-26 23:25:23.869 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 184
2020-04-26 23:25:23.869 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"enable":1,"typeBlogCount":1,"typeId":1,"typeName":"Linux"},{"enable":1,"typeBlogCount":0,"typeId":2,"typeName":"Docker"},{"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"SpringBoot"},{"enable":1,"typeBlogCount":0,"typeId":4,"typeName":"Mybatis"},{"enable":1,"typeBlogCount":0,"typeId":5,"typeName":"爬虫"},{"enable":1,"typeBlogCount":4,"typeId":6,"typeName":"博客开发和维护总结"},{"enable":1,"typeBlogCount":1,"typeId":7,"typeName":"CSS"},{"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"JavaScript"},{"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Vue"},{"enable":1,"typeBlogCount":1,"typeId":10,"typeName":"随笔"}],"pageSize":10,"params":{},"sortMethod":"ASC","totalCount":19,"totalPage":2},"msg":"操作成功!"}
2020-04-26 23:25:30.441 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/list
2020-04-26 23:25:30.441 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:25:30.442 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:25:30.442 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogList
2020-04-26 23:25:30.442 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=ASC)]
2020-04-26 23:25:30.890 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 449
2020-04-26 23:25:30.894 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，数据库设计--表的命名规范等</strong></p>\n<p>（1），统一采用bl_开头对表进行命名</p>\n<p>（2），对于数据比较重要的表统一添加四个字段，分别为：created_time(创建时间),update_time(修改时间),version(版本号),deleted(删除字段)</p>\n<p>（3），数据库表的字段尽量都设置为NOT_NULL</p>\n<p>（4），数据库中表varchar类型字段需要设置长度的尽量设置为2<sup>n</sup>-1</p>\n<p>（5），因为博客系统分为前台展示界面和后台管理，所以对于有些表，例如bl_type（博客类型表），bl_music（音乐表）等设置了enable（启用字段）</p>\n<p><strong>二，上述第二条--四个字段的解释</strong></p>\n<p>（1），为什么要设置created_time和update_time字段：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;其一，从数据库的通用性上来说，设计这两个字段是必要的，但也需要根据业务的需要来合理添加这两个字段，因为无用的字段会浪费空间，性能，影响系统的运行。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 其二，大部分的应用都有需要根据时间进行排序的功能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 其三，当系统发生异常的时候，我们可以通过这两个字段对异常进行排查和定位。</p>\n<p>（2），为什么要设置version字段：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 1，version字段含义：字段的含义与其字面意思一样，代表版本，在这里作为乐观锁进行使用，从而保证不会出现脏数据的情况。下面解释一下什么叫乐观锁，以及乐观锁和悲观锁</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 2，乐观锁：总是假定最好的情况，即每次用户调用接口从数据库中取出数据到修改数据前的过程中，不会有其它用户对当前数据进行修改，这样在当前用户修改数据的时候，利用版本机制即判断取出的version字段和当前数据库该条数据的version字段是否相等来判断该条数据是否已经被修改，如果未修改，则予以修改（且version字段递增），如果已经修改，则提示用户更新失败。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 悲观锁：总是假定最坏的情况，即每次用户调用接口从数据库取出数据的时候，都认为该条数据会被修改，因此每次取出数据都对数据进行加锁处理，只允许当前用户进行修改，其它用户阻塞，直到当前用户修改完毕。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3，为什么使用乐观锁而不使用悲观锁：因为悲观锁比较浪费性能</p>\n<p>（3），为什么设置deleted字段：deleted字段在这里作为一个逻辑删除字段（0否1是），何为逻辑删除，即执行删除操作操作的时候，不会真正的删除数据库中的数据，而是将deleted字段设置为1即可。&nbsp;这样如果用户出现误删的操作，可以通过数据库修改该字段进行数据的恢复。</p>\n<p><strong>三，上述第三条--数据库表字段尽量设置为NOT_NULL</strong></p>\n<p>（1），数据库表字段尽量设置为NOT_NULL：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 1，有些人可能认为设置为NULL相比于NOT_NULL不是更节省空间吗？但是实际上不是这样的，设计为NULL相比于NOT_NULL要多占用一个字节的空间</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 2，设计为NOT_NULL，这样在做查询的时候能够更好的避免空指针异常，且发生该类错误的时候能够更好的进行排查</p>\n<p><strong>四，上述第四条--表varchar类型字段长度尽量设置为2<sup>n</sup>-1</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>因为计算机只识别二进制，且有一定的范围，例如2<sup>8</sup>，在计算机中的范围为-128~127,因此对于varchar字段长度来说，如果设置为255，则正好是一个字节，而如果设置为256，则占用两个字节，这样会浪费计算机的内存空间，因此数据库varchar类型字段的长度最好设置为2<sup>n</sup>-1</p>\n<p><strong>五，上述第五条--对于设置enable字段的解释</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>enable字段，字面意思启用，在这里表明是否启用（0否1是），因为系统分为前台博客页面和后台管理，对于这两个不同的前端项目，后台可以通过启用字段来控制内容在前台博客页面的展示与否，与deleted字段不同的是，如果执行删除操作，那么我们只能通过手动修改数据库中的字段进行数据的恢复，且如果执行删除操作，则该数据在前台博客页面和后台管理页面都无法看见。但是如果将数据弃用（即修改enable字段值为1），则表明该数据被弃用，在前台博客页面无法显示，但是在后台管理页面可以看见，且无需通过手动修改数据库来恢复数据，可以在后台管理页面操作启用数据。</p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1247745014683947008","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dDViAcnjvAACb6PL1tzA485.jpg","blogRead":21,"blogRemark":"博客开发总结（一）-----之数据库设计篇","blogTitle":"博客开发总结（一）-----之数据库设计篇","createdTime":"2020-04-08 04:36:07","typeName":"博客开发和维护总结","updateTime":"2020-04-20 10:47:54"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，前后端分离开发优势</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，</strong>项目开发过程中，前后端完全解耦，前端只需要负责页面的实现，只需要通过接口拿数据。后端不需要管页面的跳转，只需要负责接口的编写</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，</strong>前后端人员有更多的精力去负责自己的工作，前端人员可以将更多的精力投放在页面的编写，页面的美化，页面特效的制作和用户体验上；而后端人员可以将更多的精力放在接口代码的优化，sql优化，jvm调优上面</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，</strong>前后端分离的项目部署的时候，前端项目往往都是部署在nginx服务器上，而前后端不分离的项目往往都是部署再一台服务器上。因此前后端分离项目大大降低了服务器的负担</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>4，</strong>前后端不分离的项目使用模板引擎例如freemaker，thymeleaf等，前后端人员交流起来较为困难。且前端项目使用原生的DOM操作，极大的增加了前端工作人员的工作量。而前后端分离项目前端通常都是用各种ui框架，框架采用MVVM模式，极大的减轻了前端工作人员的工作量</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，</strong>前后端分离开发，前端可以通过easy-mock来伪造接口数据进行测试，后端人员可以通过postman进行接口测试，开发效率大大提升。</p>","blogGoods":0,"blogId":"1247867141693128704","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dG6CAI6ipAACiM2P5LtI65.jpeg","blogRead":7,"blogRemark":"前后端分离开发的优势所在","blogTitle":"闲谈前后端分离开发","createdTime":"2020-04-08 12:41:25","typeName":"随笔","updateTime":"2020-04-20 11:48:53"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，css之弹性布局</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，</strong>何为弹性布局？</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 弹性布局是css的一种新的布局方式，所谓&ldquo;弹性布局&rdquo;，即页面随着不同设备的屏幕大小拉伸会自适应页面的大小。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，</strong>弹性布局的两种主要元素，container（弹性容器），item（弹性子元素），一个弹性容器中可以放入多个弹性子元素，元素之间是可以进行嵌套的，弹性子元素也可以设置为弹性容器，里面再嵌套弹性子元素。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，</strong>弹性布局的基本属性</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （1）display：flex，声明容器为弹性布局</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （2）flex-direction：声明弹性容器内部元素的排列方式，默认为row。row（横向布局），row-reverse（横向布局，但是元素反方向码），column（纵向布局），column-reverse（纵向布局，但是元素反着码）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （3）flex-wrap：声明弹性盒子中的元素是否可以换行，默认为nowrap（不换行），wrap（换行），wrap-reverse（换行，但是反着码）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （4）align-items：设置容器中元素在纵轴方向上的对齐方式，默认为stretch（即如果不设置子元素高度，则默认拉伸至于容器同宽度），flex-start（子元素位于容器的开始位置），flex-end（子元素位于容器的结尾处），center（元素依纵轴方向居中），baseline（元素位于容器基线，不过没怎么用过，所以不是很清楚）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （5）justify-content（设置元素在主轴上的对齐方式），默认为flex-start（元素从容器主轴开始位置码），flex-end（元素从容器主轴结尾处码），center（元素位于主轴居中处），space-between（元素布局在容器的两端），space-around（元素布局在容器两端，但是元素前后都留有空白）因为项目中大多数只使用了对于容器的操作，对于容器中元素的操作很少，所以这里只介绍这点。谢谢阅读！</p>","blogGoods":0,"blogId":"1248135765829918720","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dGnuAWkLLAAAaRXQXNms575.jpg","blogRead":3,"blogRemark":"CSS----之flex弹性布局","blogTitle":"CSS----之flex弹性布局","createdTime":"2020-04-09 06:28:51","typeName":"CSS","updateTime":"2020-04-20 11:43:57"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2 style=\"text-align: left;\"><strong>一，JVM运行机制</strong></h2>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;jvm即java虚拟机，一共由四个部分组成，分别是类加载器子系统，运行时数据区（程序计数器，本地方法区，jvm栈，方法区，jvm堆），执行引擎（即时编译器，垃圾收集器），本地接口库。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;一个java源程序的运行先是经过编译器将其编译成字节码文件（class文件），然后通过类加载器子系统将其加载进入jvm&mdash;&mdash;&gt;程序运行过程中，运行时数据区存放程序运行过程产生的数据&mdash;&mdash;&gt;执行引擎中的垃圾收集器收集程序运行过程中创建的不再使用的对象，即时编译器将程序的字节码文件编译成机器码&mdash;&mdash;&gt;然后本地接口库利用机器码调用本地方法库中的方法，和操作系统实现交互。</p>\n<h2><strong>二，多线程</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;</strong>在多核操作系统中，jvm支持一个进程中同时并发执行多个线程，且这些线程和本地操作系统的线程相对应。当jvm中的对象初始化，内存空间分配等一系列准备工作完成之后，会调用操作系统中的接口创建一个原生线程，原生线程初始化完毕后，会调用java线程的run（）方法执行该线程，线程结束之后，jvm会释放原生线程和java线程资源。</p>\n<h2><strong>三，JVM的内存区域</strong></h2>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM的内存区域主要分为线程私有区域（程序计数器，本地方法区，JVM栈），线程共享区（方法区，JVM堆）和直接内存。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;程序计数器：线程私有区域，无内存溢出，用来记录程序运行过程中的字节码指令地址，如果是Native方法，则程序计数器为空。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM栈：线程私有区域，用来描述java程序的运行过程，java程序运行每次运行的时候，都会创建一个栈帧，方法的执行和返回对应着栈帧的入栈和出栈操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;本地方法区：线程私有区域，和JVM栈的功能一样，只不过是用来记录Native方法的运行过程。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM堆：线程共享区，主要用来存放程序运行过程中产生的数据，同时也是垃圾收集器进行垃圾回收的主要区域。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;方法区：也被称为永久代，用来存放常量，静态变量，类信息等等。</p>\n<h2><strong>四，JVM的运行时内存</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>JVM的运行时内存又被称为JVM堆，因为JVM的GC算法使用的是分代收集算法，所以JVM堆按照GC标准可以分为三个区域分别为：新生代，老年代，永久代。其中新生代占1/3，老年代占2/3，永久代很少，</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;新生代：存放短生命周期，小对象的区域。新生代又分为Eden区，ServivorTo区，ServivorFrom区，区域的GC算法采用复制算法。Eden区是用来存放新创建的对象（大对象除外），ServivorTo区是用来保存MinorGC幸存下来的对象，ServivorFrom区是用来将上一次MinorGC幸存下来的对象作为下一次MinorGC的扫描对象。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;老年代：存放长生命周期的大对象，区域的GC算法采用标记整理算法</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;永久代：主要用来存放class和meta数据信息的。程序运行过程中不会进行永久代的垃圾回收，这也就导致永久代区域的数据会越来越多，最终造成内存溢出。java8之后永久代已经被元数据区取代，元数据区和永久代的功能都是一样的，但是最大的不同在于永久代区域依赖于虚拟机的内存大小，因而可以存储的class，meta信息非常有限。但是元数据区依赖的是本地操作系统，因而不会受到虚拟机内存的限制。</p>\n<h2><strong>五，垃圾回收与算法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;(1)垃圾回收：</strong>Jvm的垃圾回收判定依赖于两种方法，引用计数法和可达性分析法。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;引用计数法：即如果想要在程序中使用对象，就必须赋予一个引用，这样在对象赋予引用的时候将其引用计数加1，删除一个引用时，将对象引用计数减1，如果引用计数为0，就说明该对象已经不使用，作为垃圾。但是引用计数法存在一个缺陷，即循环引用的问题，如果两个对象相互引用，则这两个对象的引用计数永远都不会为0，造成对象无法被回收。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;可达性分析法：即先创建一些根节点对象ROOTS，然后通过这些根节点对象向下搜索，如果一个对象到任意一个ROOTS之间都没有可达路径，在经过两次标记（下文解释为什么进行两次标记），还是没有可达路径，则说明该对象可回收。</p>\n<p>&nbsp;&nbsp; &nbsp;<strong>（2）GC算法：</strong>常见的GC算法有四种，分别为标记清除算法，复制算法，标记整理算法，分代收集算法</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;标记清除算法：即在进行垃圾回收前，对所有对象进行一次标记，标记可回收的对象，然后进行清理即可。但是标记清除算法在清除回收对象之后，并不会对堆内存进行整理，这样的话如果内存中的对象大部分为小对象，清理之后就会导致没有大片连续的内存空间，即造成了内存碎片化，这样大对象存储的时候就无法找到相应的完整连续内存。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;复制算法：即将内存分为两块同等大小的区域，区域1和区域2，创建的新对象都存储在区域1中，当区域1中的内存占满之后，会对内存中的所有对象进行一次标记，标记存活的对象，将存活的对象复制到区域2，这时区域1中的对象都是可回收对象，回收区域1中的所有对象即可。但是复制算法也存在着一定的缺陷，即每次都只能使用一半的内存空间，造成了大量的内存浪费。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;标记整理算法：即结合标记清除算法和复制算法的优点，先对所有的对象进行标记，标记存活的对象，将存活的对象复制到内存的另一端，然后清除当前端的对象即可。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;分代收集算法：前面的三种算法，都无法按照对象的类型进行收集，分代收集算法正是解决这个问题，按照对象的不同类型采用不同的GC算法。以JVM的分代收集算法为例，JVM的堆内存分为新生代，老年代，永久代。新生代又分为Eden区，ServivorTo区和ServivorFrom区。新生代因为其存储生命周期短的小对象，GC比较频繁，所以采用复制算法。程序运行过程中创建的对象都存储在Eden区（大对象除外，大对象直接复制到老年代区域）。当Eden区的内存不够的时候进行MinorGC，然后将Eden区和ServivorFrom区的存活对象都复制到ServivorTo区，然后将ServivorTo区和ServivorFrom区进行交换，再次进行MinorGC。老年代因为存放的都是生命周期长的大对象，因而进行GC的不会太频繁，且清除的对象并不会太多，因而采用标记整理算法。老年代每次进行MajorGC之前都会先进行一次MinorGC，当MinorGC之后新生代的内存仍然不够的时候，将对象复制到老年代进行MajorGC。永久代区域主要回收常量，无用class等。</p>\n<h2><strong>六，JAVA中的四种引用类型</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;强引用类型<strong>：</strong>即把对象赋给一个引用变量，强引用的对象一定为可达状态，所以不会进行垃圾回收。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;软引用类型：通过SoftReference类实现，当内存不够的时候对其进行GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;弱引用类型：只有弱引用类型的对象，一定会被GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;虚引用类型：虚引用对象主要是用来跟踪对象的GC状态</p>\n<h2><strong>七，分代收集算法和分区收集算法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>分代收集算法：新生代因其存放大量短生命周期小对象，且GC频繁，所以采用复制算法。老年代因其存放长生命周期大对象，且GC不平凡，所以采用标记整理算法。永久代，回收常量，类信息等。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;分区收集算法：即将堆内存区域分为大小不同的区，可以按照不同的区进行快速垃圾回收，减少系统的停顿时间。然后再以并行的方式逐步完成整个GC。</p>\n<h2><strong>八，垃圾收集器</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>新生代区域：Serial垃圾收集器，单线程复制算法，因为单线程无需进行线程之间的交互和切换，所以效率非常高，是JVM默认的client模式下的默认垃圾回收策略，工作期间需要暂停其它所有的线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ParNew垃圾收集器，多线程复制算法，跟单线程Serial一样，是JVM默认的server模式下的垃圾回收策略，工作期间需要暂停所有其它线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Parallel Scavenge垃圾收集器：多线程复制算法，不同的是优先考虑系统吞吐量，可以利用更高效的利用CPU完成GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;老年代区域：Serial Old垃圾收集器，单线程标记整理算法，同新生代的Serial功能一样，只是采取的算法不同而已。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Parallel Old垃圾收集器：多线程标记整理算法，优先考虑了系统的吞吐量，其次考虑停顿时间。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CMS,多线程标记清除算法，优先考虑系统GC时的停顿时间，且过程分为四步（<span style=\"background-color: #ffff00;\">解释上文的可达性分析中的两次标记</span>，第一步：标记GC ROOTS可达对象，暂停其它工作线程；第二步：和用户线程一起工作，跟踪GC ROOTS；第三步，因为第二步用户进程没有暂停，所以有些对象状态</p>\n<p>可能发生了改变，重新进行标记；第四步，清除不可达对象）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; G1垃圾收集器，多线程标记整理算法，将内存分区，与CMS相比，一方面不会产生内存碎片，一方面，可以精确的控制系统停顿时间。</p>\n<h2><strong>九，JAVA的网络编程模型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;</strong>阻塞I/O模型：即用户线程发出I/O请求之后，内核会检查数据是否准备就绪，这时候用户线程始终处于阻塞状态等待数据准备就绪。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;非阻塞I/O模型：即用户线程不断的给内核发出I/O请求，内核接受到I/O请求之后会返回一个状态，如果数据准备就绪，就将数据复制进入用户线程，如果数据没有准备好，返回一个false，用户线程无需阻塞，可以去处理其它事情，而当数据准备好了且刚好用户线程发起I/O请求进行操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;多路复用I/O模型：多路复用I/O模型通过一个Selector线程轮询Socket的状态，如果Socket有读写事件，则进行I/O操作。此模型的优势在于可以更好的处理连接数众多但消息体不大的情况下。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;信号驱动I/O模型：即用户线程发出一个I/O请求，系统会为该请求创建一个信号函数，用户请求可继续执行其它业务逻辑，当内核数据准备就绪之后会返回给用户线程一个信号，用户线程接收到之后进行I/O操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;异步I/O模型：用户线程给内核发起一个asynchronous read操作，内核接收到之后，返回其请求是否成功，然后等待数据准备成功之后复制到用户线程。整个过程中请求的发起和数据读取都在内核中进行，最终发送一个信号告知用户线程I/O操作已经完成，用户直接使用数据就行。（说实话个人感</p>\n<p>觉和信号驱动很像）</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;java NIO：没怎么读懂（<span style=\"background-color: #993300;\">记得补充！</span>）</p>\n<h2><strong>十，JVM的类加载机制</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>JVM类加载分为五个阶段：加载，验证，准备，解析，初始化</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;加载：即将class文件加载到JVM中，且创建class对象，封装其数据结构。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;验证：对class文件进行验证，确保符合JVM的标准，保证JVM的安全。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;准备：即方法区中给类变量分配空间和赋初值。static修改的会在初始化阶段赋值，final修饰的会在准备阶段赋值。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;解析：即将常量池中的引用替换为直接引用</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;初始化：执行类构造器进行初始化。（因为内部流程不是很清楚，所以对于其几种不进行初始化的情况不做说明）</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;类加载器：JVM提供了三种类加载器，启动类加载器（/lib），扩展类加载器(/lib/ext)，应用程序类加载器(classpath)。还可以再应用程序类加载器自定义类加载器。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;双亲委派机制：即当一个类接收到类加载请求的时候，不会自己进行加载，而是将其加载请求委派给其父类加载器，这样一路委派，最终加载请求都会委派到启动类加载器.启动类加载器接收到加载请求之后会去lib目录下寻找相关的class文件，若找不到，则将其加载请求再委培给子类加载器，一路委派，直到能够加载。</p>\n<h3><strong>最后，送给大家一张博主画的JVM的思维导图，以后读《深入JVM虚拟机》的时候可能会出一个JVM专题：<a href=\"https://uploader.shimo.im/f/X0MX3hLaHrevltxW.png!thumbnail\" target=\"_blank\" rel=\"noopener\">JVM思维导图</a></strong></h3>\n<p>&nbsp;</p>\n<h2>水平有限，若发现有误，还望指出！</h2>","blogGoods":0,"blogId":"1248224512563068928","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHLeALxSjAABJTVJPTfk677.jpg","blogRead":17,"blogRemark":"面试（一）------之JVM篇","blogTitle":"面试（一）------之JVM篇","createdTime":"2020-04-09 12:21:30","typeName":"java面试篇","updateTime":"2020-04-20 11:53:29"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，Linux的发展历史</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; </strong>1965年之前，电脑并不像现在这么普遍，除了军事机构和研究即构，一般人基本接触不到电脑，而且那时候的一台大型主机最多也就只能支持30台终端。为了解决数量问题，1965年之后，由贝尔实验室，麻省理工学院以及通用电气一起放弃了Multics项目，准备让大型主机能够支持300台终端，但是在开发过程中，进度缓慢，最终由于资金的短缺，贝尔实验室推出了研究。1969年，从这个项目中退出的Ken Thompson在家无聊，为了让电脑能够运行&ldquo;星际旅行&rdquo;游戏，因而趁着妻子回家探亲的一个月，独自写出了Unix操作系统的原型（！！！！牛批）。1970年，这个人以BCPL语言为基础，又写出了很接近硬件的B语言，并且用B语言写出了第一个Unix操作系统。但是由于B语言的跨平台性比较差，为了解决这个问题。Dennis Ritchie和Ken Thompson决定以B语言为基础开发一种新的语言，1972年，Dennis Ritchie最终设计出了一种新语言，他以BCPL的第二个字母命名，也就是我们后来熟知的C语言。随后两人便迫不及待的用C语言重现Unix操作系统。Unix系统起初开源，但是在Unix7之后，由于政策的变化，代码闭源化，因而大学中不能使用Unix的源代码进行教学。Andrew S. Tanenbaum教授为了能够让学生更好的理解代码细节，在完全不使用任何源代码的情况下开发除了Minix---小型Unix。但是因为其只用于教学，功能并不强大，因而Torvalds以此为基础，开发除了Linux，但是起初Linux并不支持Unix，最终经过全世界网友的帮助，最终让其能够兼容各种硬件。</p>\n<p><strong>二，文件和目录</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; 1，windows和linux的区别：</strong>我们熟知的windows系统，它的文件系统是分盘符的，盘符下的文件构成一个树形结构，但是Linux文件系统没有盘符，所有文件目录都在根目录/之下</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;<strong>2，Linux需要记住的目录：</strong>/bin（存放系统命令的目录），/sbin（只有超级管理员能访问的命令文件目录），/root（存放和root用户相关文件的目录），/etc（存放系统配置文件的目录），/usr（存放系统共享资源的目录），/opt（存放安装的第三方软件的目录，通常在/usr/local下）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;<strong>3，文件权限：</strong>Linux中的文件权限有读（r，可用于数字4表示），写操作（w，可用数字2表示），执行权限（x，可用数字1表示）</p>\n<p><strong>三，常用命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，ls：</strong>列出目录中的所有目录和文件名&nbsp; -a（列出所有，包括隐藏文件和目录），-l（以列表形式列出所有），-h（人性化列出，需要配合-l使用，即文件大小转换为我们熟知的kb，mb等），-d（显示当前目录属性），命令可以联合使用，例如-al，-lh等等。&nbsp;&nbsp;&nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，cd：</strong>用于切换目录，需知（.和..是相对路径，.表示当前目录，..表示上级目录；/表示绝对路径），cd ~（切换到root目录），cd - （切换到前一次切换的目录）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，clear：</strong>清屏</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，pwd：</strong>显示当前所在目录</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，mkdir：</strong>创建目录，-p（如果目录存在则不创建，如果不存在则创建目录再创建自目录），可以一次性创建多级目录，例如：mkdir&nbsp; -p test/test1</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，touch：</strong>创建空文件</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>7，cp：</strong>复制，-r（递归复制目录下的文件目录信息），-i(提示是否覆盖)，-v（显示复制进度）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>8，mv：</strong>移动文件，不过经常用来给文件进行重命名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>9，rm：</strong>删除目录或者文件，-r（递归删除），-f（强制删除），-v（显示删除进度）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>10，cat：</strong>查看文件内部信息</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>11，ln：</strong>文件创建链接，ln 源文件 目标链接文件（创建硬链接，硬链接和源文件大小相同，修改同步，但是删除不同步，使用较少），ln -s（创建软连接，相当于我们平时创建快捷方式，使用较多）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>12，which：</strong>搜索命令所在位置，例如：which&nbsp; &nbsp;ls</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>13，find：</strong>搜索文件所在位置&nbsp; 例如：find&nbsp; &nbsp;test.conf</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>14，grep：</strong>文件内容搜索，例如：grep &ldquo;想要搜索的内容&rdquo;&nbsp; 源文件</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>15，tar：</strong>归档命令，-c（打包成.tar文件），-z（打包的同时压缩），-v（打包的同时显示进度），-f（放在最后，后面跟.tar.gz），-x(解压)，常用：tar -zcvf&nbsp; <em><strong>.tar.gz&nbsp; &nbsp; ;&nbsp; &nbsp; tar -zxvf</strong> tar.gz</em> -C&nbsp; 指定解压目录&nbsp;&nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;还有more，head，tail等命令，不过这些不常用。</p>\n<p><strong>四，用户权限命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，whoami：</strong>查看当前账户的用户名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，who：</strong>查看当前登录用户</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，exit：</strong>退出登录</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，adduser/useradd：</strong>添加用户，-d（指定用户主目录），-g（指定用户用户组），-m（自动建立目录），默认情况下用户主目录和用户组名都和用户名一样</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，passwd：</strong>只有root用户才能使用，用于修改用户密码</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，userdel：</strong>删除用户，默认不删除用户的主目录，-r（删除用户主目录）</p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;7，su：</strong>切换账户</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>8，groupadd/groupdel：</strong>添加用户组和删除用户组</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>9，groups：</strong>查看用户所在用户组，例如：groups&nbsp; 用户名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>10，usermod：</strong>修改用户所在用户组，例如：usermod&nbsp; 用户组名 用户名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>11，chmod：</strong>修改文件权限，例如：chmod&nbsp; 777&nbsp; test</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>12，chown：</strong>修改文件所有者，例如：chown&nbsp; &nbsp;用户&nbsp; 文件名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>13，chgrp：</strong>修改文件所在组，例如：chgrp&nbsp; 组名&nbsp; 文件名</p>\n<p><strong>五，系统命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，cal：</strong>查看日历</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，date：</strong>查看时间，可以设置格式，例如：date '+<span class=\"ql-token hljs-built_in\">%Y</span>-<span class=\"ql-token hljs-built_in\">%m</span>-<span class=\"ql-token hljs-built_in\">%d</span> <span class=\"ql-token hljs-built_in\">%H</span>:<span class=\"ql-token hljs-built_in\">%M</span>:<span class=\"ql-token hljs-built_in\">%S</span>'</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，ps：</strong>查看线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，kill：</strong>杀死线程，-9（强制杀死）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，查看网卡信息：</strong>centos6：ifconfig ；centos7：ip addr</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，ping：</strong>查看网址或者链接的连通性</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>7，防火墙：</strong>centos6：service&nbsp; iptables&nbsp; status（查看防火墙状态），service&nbsp; &nbsp;iptables&nbsp; &nbsp;start(开启),service&nbsp; iptables&nbsp; stop(关闭);centos7:firewall-cmd&nbsp; --state（查看防火墙状态），systemctl&nbsp; start&nbsp; firewalld.service(启动)，systemctl&nbsp; &nbsp;stop&nbsp; firewalld.service（关闭）</p>\n<p><strong>六，网络命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，wget：</strong>下载，例如：wget&nbsp; &nbsp;链接地址</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，yum：</strong>下载安装</p>\n<p><strong>七，vim（这里只说几个常用的命令）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;</strong>vim有三种模式：命令模式，插入模式，编辑模式&nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;vim&nbsp; 文件名：进入文件，且处于命令模式；iao任意一键进入插入模式（i表示在贯标之前插入，a光标之后插入，o在下一行插入），：进入编辑模式</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;命令：set:nu显示行号，set:nonu不显示行号；/strinng，向后搜索字符串，？string向后搜索字符串；：w保存，：wq保存并退出，：q不保存退出</p>","blogGoods":0,"blogId":"1248500061625745408","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dDA6AfCOJAAAyfL52jxY706.jpg","blogRead":2,"blogRemark":"Linux基本命令总结","blogTitle":"Linux基本命令","createdTime":"2020-04-10 06:36:25","typeName":"Linux","updateTime":"2020-04-20 10:42:25"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，集合</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，List：</strong>list是java中一种有序的集合，下有三个实现类，分别为ArrayList，Vector，LinkedList</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ArrayList：基于数组实现，增删慢，查询快，线程不安全。因为其基于数组实现，所以查询的时候可以直接根据数组的索引下标进行快速查询，但是进行增删操作的时候，需要将待增删元素后的元素全部移动，因而效率较低。且ArrayList创建时不需要分配初始大小，其空间不够的时候，会自动创建一个更大的list，然后复制数据。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Vector：基于数组实现，和ArrayList一样增删慢，查询快。但是线程安全，因为同一时间只支持一个线程对Vector进行写操作，然而因为要进行频繁的加锁和释放锁的操作，所以效率要低于ArrayList。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; LinkedList：基于双向链表实现，增删快，查询慢。因为基于链表实现，增删元素的时候，只需要改变元素的指针即可，改动较小，效率较高。然而进行查询操作的时候，需要从链表头部进行遍历，因而效率较低。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，Queue：</strong>队列，满足先进先出，种类较多。（不作详细解释）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，set：</strong>具有独一无二的特性，常用来存储无序且不重复的元素，对象相等的本质是hashcode的值相同，而如果想要比较两个对象是否相等，需要重写对象的hashcode方法和equals方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;hashset：基于hashTable实现，无序。存放的是对象的散列值，即通过hashcode计算得到的值</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;treeset：基于二叉树实现，即其中的对象按照一定的排序方式进行排列（升序，降序），每次添加对象的时候，都会进行排序，将其插入指定位置。基本的数据类型例如Integer，String等可以使用treeset默认的排序方法，而自定义数据类型需要实现compareable接口，实现compareTo方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;LinkHashSet：继承自hashset，只不过使用双向链表记录数据的顺序。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，map：</strong>一种键值对形式的集合</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;hashmap：基于数组+链表实现，增删改查操作快，但是每次遍历hashmap元素的顺序无法保证且线程不安全。如果想要其线程安全，可以使用synchronizedMap和ConcurrentHashmap，hashmap的内部是数组，数组中的每一个元素又是一个单向链表，链表中的每个元素嵌套一个Entry实例，其中包括Key，Value，Hash值，指向下一个节点的next。每次查询的时候，可以根据元素的hash值很快定位所在数组，但是定位之后需要遍历链表查找元素，因而时间复杂度为O（n），但是Java8之后对其进行了优化，将其改为了数组+链表或红黑树的结构，即当链表中的元素大于8个的时候，链表会转换为红黑树（红黑树是一种特化的二叉平衡树，因为其左右子树的深度差可以大于1），这样查询的时间复杂度就缩短到了O（logN）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ConcurrentHashmap：采用分段锁的思想进行并发操作，因而使线程安全的。由多个Segment组成，只要保证每个Segment线程安全就可以保证全局线程安全。ConcurrentHashmap的默认Segment即并发度为16，可以在初始化的时候修改，但是初始化之后不能再修改。每个Segment内部的实现和hashmap一样&middot;。Java8之后也和hashmap进行了一样的优化。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;HashTable：线程安全，即同一时刻只能有一个线程对其进行操作，并发度不如ConcurrentHashmap。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;TreeMap：基于二叉树数据结构实现，实现了SortedMap，默认按照键值的升序进行排列。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;LinkedHashMap：Hashmap的子类，只不过使用链表保存元素的插入顺序。使用迭代器遍历的时候按照插入顺序遍历。</p>\n<h2><strong>二，异常分类及处理</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;1，异常分类：</strong>Throwable是所有异常类的父类，其下有error和Exception，Error下有AwtError，ThreadDeath；Exception下有RuntimeException和CheckedException。</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</strong>对于Error类异常通常是由内部错误和资源耗尽造成的，无法在程序运行期间对其进行捕获和处理，对于这类错误我们只能记录错误的原因和终止程序。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; Exception中的RuntimeException异常（运行时异常）：这类异常是我们程序中异常处理的核心，可以在程序中进行捕获并处理。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Exception中的CheckedException异常（检查异常）：这类异常时程序中需要强制捕获的异常，通常有IO异常，SQL异常等等。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，异常处理：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>异常处理有两种方式：抛出异常和捕获异常</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;抛出异常有三种方法：throws，throw，系统自动抛出。其中throws是作用在方法上，后面跟的是可能产生的异常类。throw是作用在方法内部，后面跟的是具体的异常对象。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 捕获异常：即使用try{}catch语句进行捕获</p>\n<h2><strong>三，反射机制</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，什么叫做反射机制？</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>即在程序运行的过程中，可以获取类的属性和方法，并且可以调用任意一个类的方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，反射机制的使用</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 首先，获取类的class对象，有三种方式，className.getClass()，类对象.class，Class.forName(\"类路径\")，其中最后一种最为安全，性能最好。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 然后利用反射的API可以实现对类中信息的操作，例如getDeclareFields（），getDeclareMethods（），getConstroctors（）等等。反射创建类的对像有两种方法，一，class.newInstance()初始化一个类实例；二，先获取其构造器，然后利用构造器初始化一个实例。利用反射调用类的方法：先获取方法，然后调用method.invoke()执行方法。</p>\n<h2><strong>四，注解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，四种元注解：</strong>@Target（指定注解的使用范围），@Retention（定义注解的保留级别，有三级，SOURCE源程序中保存，CLASS文件中保存，RUNTIME运行时保存），@Documented（可以工具文档化），@Inherited（<span style=\"background-color: #ffff00;\">这个没怎么看懂</span>）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，注解使用示例：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>第一步，定义注解接口</p>\n<pre class=\"language-java\"><code>@Target(ElementType.FIELD)  \n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface FruitProvider {\n\n    //id\n    public int id() default  -1;\n\n    //供应商名称\n    public String name() default \"\";\n\n    //供应商地址\n    public String address() default \"\";\n\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 第二步，使用注解</p>\n<pre class=\"language-java\"><code>public class Apple {\n\n    @FruitProvider(id = 1,name = \"红富士苹果\",address = \"陕西\")\n    private String appleProvider;\n\n    public String getAppleProvider() {\n        return appleProvider;\n    }\n\n    public void setAppleProvider(String appleProvider) {\n        this.appleProvider = appleProvider;\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第三步，定义注解处理器</p>\n<pre class=\"language-java\"><code>public class FruitInfoUtil {\n    public static void getFruitInfo(Class&lt;?&gt; clazz) {\n        String strFruitProvider = \"供应商信息:\";\n        Field[] declaredFields = clazz.getDeclaredFields();\n        for (int i = 0; i &lt; declaredFields.length; i++) {\n            if (declaredFields[i].isAnnotationPresent(FruitProvider.class)) {\n                FruitProvider annotation = declaredFields[i].getAnnotation(FruitProvider.class);\n                strFruitProvider += annotation.id() + \",\" + annotation.name() + \",\" + annotation.address();\n                System.out.println(strFruitProvider);\n            }\n        }\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第四步，主方法入口</p>\n<pre class=\"language-java\"><code>public class FruitRun {\n    public static void main(String[] args) {\n        FruitInfoUtil.getFruitInfo(Apple.class);\n    }\n}</code></pre>\n<h2><strong>五，内部类</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 1，静态内部类：</strong>即在类的内部定义的静态类，静态内部类可以访问外部了的静态变量和方法，外部也可以通过outClassName.innerClassName调用内部类</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2，成员内部类：</strong>在类的内部定义的没有用static修饰的内部类，使用方式和静态内部类一样。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>3，局部内部类：</strong>即一个类只在一个方法中使用，则完全可以将这个类定义为这个方法的内部类，即局部内部类，局部内部类可以实现真正的对外隐藏</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>4，匿名内部类：</strong>通常用于继承一个类或者实现一个接口的时候，使用new关键字定义，例如:Person person = new Student(){new Pupil(){}}</p>\n<h2><strong>六，泛型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 1，为什么要使用泛型：</strong>其根本目的是为了实现代码的复用，举个开发中常见的例子，我们需要定义返回类Result，返回类中包含状态码code，信息msg，以及数据data（任意类型），这个时候我们就需要使用泛型，因为我们返回的数据类型有各种vo，pojo类对象，list等。这时候泛型类result就可以被各种对象使用，实现代码的复用，简化开发。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>2，泛型标记和泛型限定：</strong>E表示集合中的元素，K表示键值，V表示value，N表示数值类型，T表示任意类型（包含基础类型，所有的对象类型），？（不确定的java类型）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>泛型限定：</strong>向上限定，&lt;?&nbsp; extends T&gt;，向下限定，&lt;? super&nbsp; T&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; <strong>3，泛型方法：</strong>即参数类型定义为泛型类型，以便于接收不同类型的参数，做出不同的处理。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>4，泛型类：</strong>例如public class Pair&lt;T&gt;{private T data;}</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>5，泛型接口：</strong>与放泛型类类似</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>6，类型擦除：</strong>即在泛型编译的过程中，会将泛型类型替换为限定类型的操作</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>7，明确的一点：</strong>虚拟机在运行程序的过程中，内部是没有泛型的，只有普通的类和方法。</p>\n<h2><strong>7，序列化</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 序列化是为了确保对象及其状态的持久化</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>序列化的使用：</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </strong>首先，实现序列化接口java.io.Serializble</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 然后，声明序列化ID，通常private static final&nbsp; long&nbsp; serialVersionUid&nbsp; = ***</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 因为序列化是保证对象及其状态的持久化，而静态变量是不属于对象，属于类本身的，所以序列化无法保存静态变量。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果需要序列化父类变量，则父类也要实现Serializable接口</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t'ransient修饰的属性不会序列化</p>\n<h3><strong>最后，提供一张思维导图供大家学习：<a href=\"https://images-cdn.shimo.im/es83SQH0CggucT7f__thumbnail\" target=\"_blank\" rel=\"noopener\">JAVA基础</a></strong></h3>\n<p>&nbsp;</p>\n<h2>水平有限，如有错误，还望指出！</h2>","blogGoods":0,"blogId":"1248605157059497984","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHMKAcvZ8AABJTVJPTfk020.jpg","blogRead":27,"blogRemark":"面试（二）------之JAVA基础篇","blogTitle":"面试（二）------之JAVA基础篇","createdTime":"2020-04-10 13:34:02","typeName":"java面试篇","updateTime":"2020-04-20 11:53:39"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，JAVA线程的创建方式</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>JAVA线程的创建有四种方式，分别为，继承Thread类，实现Runable接口，实现Callable&lt;Class&gt;接口，基于线程池。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>1，继承Thread方式：创建一个类继承Thread类，创建类的实例对象，调用start方法，继而执行线程的run（）方法，代码如下：</strong></p>\n<pre class=\"language-java\"><code>public class NewThread extends Thread{\n    public static void main(String[] args) {\n        NewThread thread = new NewThread();\n        thread.start();\n    }\n    @Override\n    public void run(){\n        System.out.println(\"create  a  new thread by Thread!\");\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>2，当子类已经继承了一个类，这时候就没法再继承Thread类了，这时候就可以实现Runable接口，实例化类的线程实例，创建Thread实例传入类的实例，执行start方法，继而执行run（）方法代码如下：</strong></p>\n<p>&nbsp;</p>\n<pre class=\"language-java\"><code>public class ThreadExample2 implements Runnable {\n    public static void main(String[] args) {\n        ThreadExample2 threadExample2 = new ThreadExample2();\n        Thread thread = new Thread(threadExample2);\n        thread.start();\n    }\n    @Override\n    public void run() {\n        System.out.println(\"create a new thread by Runnable!\");\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，有些情况下，我们需要再一个主线程中并发多个子线程执行同一个任务，然后回收子线程的返回值整理汇总，这时候就需要实现Callable&lt;Class&gt;接口，重写其call（）方法，用于计算结果。然床创建一个线程池用于提交线程，继而执行call方法，并且创建一个Future的list用于接收子线程逻辑代码即call方法的返回，最终遍历list，得到想要的返回值，如下：</strong></p>\n<pre class=\"language-java\"><code>public class ThreadExample3 implements Callable&lt;String&gt; {\n\n    private String name;\n\n    public ThreadExample3(String name){\n        this.name = name;\n    }\n\n    @Override\n    public String call() throws Exception {\n        return name;\n    }\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        ExecutorService pool = Executors.newFixedThreadPool(3);\n        List&lt;Future&gt; list = new ArrayList&lt;&gt;();\n        for(int i=0;i&lt;3;i++){\n            ThreadExample3 threadExample3 = new ThreadExample3(i+\"\");\n            Future future =pool.submit(threadExample3);\n            System.out.println(future.get().toString()+\" is running\");\n            list.add(future);\n        }\n        pool.shutdown();\n        for (Future future : list) {\n            System.out.println(\"currentThread's result is \"+future.get().toString());\n        }\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，基于线程池创建线程</strong></p>\n<pre class=\"language-java\"><code>public class ThreadExample4 {\n    public static void main(String[] args){\n        ExecutorService pool = Executors.newFixedThreadPool(3);\n        for(int i=0;i&lt;3;i++){\n            pool.execute(new Runnable() {\n                @Override\n                public void run() {\n                    System.out.println(\"thread  is running by FixedThreadPool\");\n                }\n            });\n        }\n        pool.shutdown();\n    }\n}</code></pre>\n<h2>二，线程池的工作原理</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong> &nbsp;1，概述：</strong>JVM根据用户提供的参数创建一定数量的线程任务，将其放入队列中，线程创建之后启动这些任务，如果线程的数量大于核心线程数量（用户设置的线程数量），则超出数量的线程排在队列中等待，当有线程任务执行完毕后，线程池调度器就会发现有可用可用线程，继而从队列中取出任务继续执行<strong>。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; </strong><strong>2，线程复用：</strong>（参见JDK源码解读，这里只做简单描述），由前可知，JVM会根据用户提供的参数创建一定数量的线程任务，且将其添加到任务队列中。JVM通过start（）方法创建一个线程之后， 会相应的为其创建一个任务队列，线程会不停的查看任务队列，如果任务队列中有任务，则调用run方法，执行，这样就达到了一次start（）创建线程，多次使用，完成线程复用的任务。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>3，线程池的核心组件和核心类（见JDK源码分类中关于线程的总结）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; </strong><strong>4，JAVA线程的工作流程：</strong>线程池刚被创建的时候，只是向系统申请一个执行线程队列和管理线程池的线程资源，当调用execute方法之后，执行下列流程：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果正在运行的线程数量小于corePoolSize（核心线程数量，即用户定义的的线程数量），则立即创建线程执行线程任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果正在运行的线程数量大于或等于corePoolSize，则将超过数量的线程加入到阻塞队列中</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在阻塞队列已满且线程数量小于MaximumPoolSize（即线程池能够容纳的最大线程数），线程池会创建非核心线程立即执行任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在阻塞队列已满且线程数量大于或等于MaximumPoolSize的时候，线程池会拒绝该线程任务且抛出异常</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在线程任务执行完毕之后，会将其从任务队列中移除，从队列中取出下一个线程任务执行</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在线程处于空闲状态且空闲时间超过KeepAliveTime，且线程数量大于corePoolSize的时候，会停止该线程，这样在没有任务的时候，线程池中的线程数始终维持在corePoolSize。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，线程池的拒绝策略：</strong>分为四种，分别为AbortPolicy，CallerRunsPolicy，DiscardOldestPolicy，DiscardPolicy</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; AbortPolicy：直接抛出异常，阻止线程运行，源码如下：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</p>\n<pre class=\"language-java\"><code>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n            throw new RejectedExecutionException(\"Task \" + r.toString() +\n                                                 \" rejected from \" +\n                                                 e.toString());\n        }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CallerRunsPolicy：如果线程任务没有关闭，则尝试执行该线程任务，源码如下：</p>\n<pre class=\"language-java\"><code>* @param r the runnable task requested to be executed\n* @param e the executor attempting to execute this task\n*/\npublic void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n     if (!e.isShutdown()) {\n         r.run()\n     }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DiscardOldestPolicy：移除任务队列中最早进入的线程任务，执行当前任务线程，源码如下：</p>\n<pre class=\"language-java\"><code>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n       if (!e.isShutdown()) {\n           e.getQueue().poll();\n           e.execute(r);\n       }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DiscardPolicy：直接丢弃线程任务，不做任何处理</p>\n<h2><strong>三，五种常用的线程池</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;newCachedThreadPool（可缓存线程池）：</strong>当线程池创建线程的时候如果发现有可复用的线程（执行完任务，且未关闭的线程），则直接复用，如果没有则创建新线程。可缓存线程池可以高效的利用执行任务时间短的线程，提高系统的性能，且线程池中的线程如果空闲时间超过60s，则会被终止且从缓存中移除，这样可缓存线程池不会占用系统资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>newFixedThreadPool（固定大小的线程池）：</strong>即线程池中的线程是初始化固定的，当任务线程大于线程池中线程数量时，任务线程就会进入阻塞队列等待。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newScheduledThreadPool（可做任务调度的线程池）：</strong>即可以设置线程执行的停顿时间和执行周期，进行定期定时的执行某个任务。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newSingleThreadPool（单个线程的线程池）:&nbsp;</strong>即线程池中永远只有一个线程进行工作，如果下称停止或者异常，则线程池创建新的线程替代当前线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newWorkStealingPool（足够大小的线程池）：</strong>即创建足够数量的线程的线程池，保证更快的进行运算，提高效率。</p>\n<h2><strong>四，线程的生命周期</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;线程的生命周期大致分为五个阶段：新建（new），就绪（Runnable），运行（Running），阻塞（Blocked），死亡（Dead）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;新建：</strong>即使用new创建一个线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>就绪：</strong>调用start方法，</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>运行：</strong>即线程获取cpu资源，执行run（）方法，进入运行状态，运行状态的线程如果调用yield（线程让步方法）或者失去cpu资源，都会导致线程重新回到就绪态；如果调用sleep方法，I/O阻塞，等待同步锁，等待通知以及suspend挂起都会导致线程进入阻塞态。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞：</strong>即线程被放入Blocked池。阻塞状态的线程如果结束了sleep方法，I/O方法返回，获取同步锁，收到通知或者resume都会导致其重新进入就绪态，与其它线程竞争cpu时间片。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>死亡：</strong>线程正常执行完run（）或者call（）方法，或者执行stop方法，或者发生异常或者错误都会导致线程死亡。（stop方法会导致锁混乱和死锁，不建议使用）</p>\n<h2><strong>五，线程的基本方法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;wait（线程等待）：</strong>会让线程进入WAITING状态，并且会释放对象的锁。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>sleep（线程睡眠）：</strong>会让线程进入睡眠，进入TIMED_WAITING状态，但是不会释放对象锁，睡眠时间到了之后，再次恢复运行状态</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>yield（线程让步）:</strong>&nbsp; 当前线程会让出其占有的cpu资源，重新回到就绪态和其它线程竞争cpu时间片</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>interrupt（线程中断）:&nbsp; </strong>中断当前线程，但是并不会导致其停止，只是改变其内部的终端标识位，在使用了thread.sleep()之后使用该方法，会导致抛出异常，且我们可以利用中断标识位进行线程的安全退出</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>join（线程加入）：</strong>即将当前线程进入阻塞态，等待下一个线程执行完毕后进入就绪态，重新竞争锁资源。通常用于主线程下面执行子线程，需要主线程阻塞，等待子线程执行完毕后返回其结果给主线程，主线程再执行的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>notify（线程唤醒）/notifyAll：</strong>前者随机唤醒一个等待线程，后者全部唤醒</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>setDaemon（守护线程）:</strong>级别较低的线程，用于后台运行，服务用户用户线程，例如垃圾收集线程就是典型的守护线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>sleep方法和wait方法的区别：</strong>前者属于Thread，后者属于Object，前者不会释放锁资源，后者会释放锁资源</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>start方法和run方法：</strong>start方法只是创建一个线程，并没有运行，run方法时执行线程的真正代码逻辑。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>线程退出的方式：</strong>见四中最后一条</p>\n<h2><strong>六，JAVA中的锁（知识比较杂乱）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述:JAVA中的锁是为了保护数据的一致性。按照不同的标准可分为乐观锁和悲观锁，公平锁和非公平锁，共享锁和独占锁，偏向锁，轻量级锁，重量级锁，自旋锁，可重入锁。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;乐观锁：</strong>即认为每次读取数据都不会被修改，当修改操作的时候再判断当前数据是否被修改，未修改则修改，若已被修改，则返回失败状态。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>悲观锁：</strong>即认为每次读取数据都会被修改，因而每次读取数据都对其进行加锁，这样只有当前用户可以修改，其它用户阻塞等待直到当前用户修改完毕释放锁资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>自旋锁：</strong>即有些线程任务的执行很短，很快就可以释放锁资源，为了避免在这种情况下竞争线程仍然进行内核态和用户态之间的转换，因而让线程自旋（即等一会），如果有可用锁，则获取，减少了线程在用户态和内核态之间切换的时间损耗。提高了性能（优势）。当然线程自旋是占用cpu资源的，因而需要设置一个自旋的最大等待时间，如果超过此时间，则线程退出自旋模式。对于线程竞争锁资源激烈的情况，自旋有可能会导致cpu资源的损耗（劣势）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>公平锁和非公平锁：</strong>即根据线程竞争锁资源的机制判定，一般如果依据先到先得的原则，则位公平锁；如果依据就近原则，则位非公平锁。公平锁相比于非公平锁会更加耗费性能，因为要维护一个线程任务丢列，根据线程任务在队列中的顺序分配锁资源，因而不常用。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>可重入锁：</strong>又被称为递归锁，即该锁可以然后线程对其进行多次的加锁操作。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>偏向锁：</strong>当线程获取到锁的时候，用来消除线程的锁重入的开销（看起来是偏袒这个线程）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>共享锁和独占锁：</strong>共享锁即多线程共享锁资源（典型例子，读锁）；独占锁即当前锁只能有一个线程获取，其它线程阻塞</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>轻量级锁：</strong>没有多线程竞争的前提下，减少重量级锁的使用提高性能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>重量级锁：</strong>基于操作系统的互斥量而实现的锁，会导致进程在用户态和内核态之间切换，耗费性能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>synchronized：独占式悲观锁，可重入锁，非公平锁，重量级锁。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 作用范围：</strong>作用于成员变量和非静态方法，相当于锁住的是对象的实例，即this对象</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;作用于静态方法，相当于锁住的是class实例</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;作用域代码块，相当于锁住的代码块中的对象</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>实现原理：</strong>内部包括ContentionList（锁竞争队列），EntryList（竞争候选列表），WaitSet（等待集合），OnDeck（竞争候选者），Owner，!Owner，其中ContentionList是用来存放竞争锁资源的线程。EntryList是用来存放有资格竞争锁资源的线程。调用wait方法后放入WaitSet中，onDeck指的是同一时刻，只有一个线程竞争锁资源，Owner指的是得到锁资源的线程，!Owner指的是线程执行完毕，释放锁资源的线程。需要注意的是线程首先采用的都是自旋模式获取锁资源，如果自旋获取不到再加入ContentionList，而且Owner状态的线程并不是直接把锁资源交给onDeck状态线程，而是给它竞争锁资源的权利，因而onDeck状态的线程还需要跟自旋线程竞争锁资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>ReentrantLock：独占式，可重入锁，并且可以实现公平锁和非公平锁，重量级锁。</strong></p>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;用法：</strong>lock()加锁，后跟try代码块，finally中进行释放锁unlock()</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;避免死锁的方法：</strong>响应中断（即可以根据情况中断对锁资源的请求），可轮询锁（tryLock（）即尝试获取锁，如果有可用锁则获取返回true，没有则返回。和lock（）的区别在于lock获取锁资源如果没有则一直等待直到获取到锁资源），定时所（tryLock（time,unit）即再一定时间内如果有可用锁，且线程未中断则获取锁，否则禁用当前线程。）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>Semaphore（信号量）:</strong>机制和ReentrantLock类似</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ReadWriteLock（读写锁）：</strong>如果系统要求支持多线程共享读，但不能多线程写，使用读锁；如果要求同一时刻只能有一个线程写，写的过程中不能读取该共享数据，则使用写锁。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; <strong>分段锁：</strong>一种思想，将数据分段加锁，例如ConcurrentHashMap</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;死锁：</strong>即线程之间互相共享资源会导致死锁</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; <strong>锁优化：</strong>第一，减少锁的持有时间；第二：减小锁粒度，例如分段锁；第三：锁分离，例如读写锁；第四：锁粗化，放置锁粒度太小，造成频繁加锁释放锁；第五：锁消除，消除程序代码不规范而造成的乱用了锁</p>\n<p>&nbsp;</p>\n<h3><strong>并发编程（上）的思维导图送上：<a href=\"https://images-cdn.shimo.im/1UcHkyrlJyGRPYnn.png__thumbnail\" target=\"_blank\" rel=\"noopener\">并发编程（上）</a></strong></h3>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>\n<h1>水平有限，如果错误，还望指出！</h1>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;</p>","blogGoods":0,"blogId":"1249313090567143424","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHM2AQOeZAABJTVJPTfk967.jpg","blogRead":8,"blogRemark":"面试（三）------之并发编程篇（上）","blogTitle":"面试（三）------之并发编程篇（上）","createdTime":"2020-04-12 12:27:07","typeName":"java面试篇","updateTime":"2020-04-20 11:53:51"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，redis简介</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>redis是NoSQL型系统之一，与之相似的还有Memcache，用来存储key-value这种键值型数据。相比于Memcache而言，redis不仅可以做临时缓存，还可以做数据持久化，将数据定时的存入硬盘或者将命令追加到日志文件当中。而Memcache只能做临时缓存，因而现在基本上已经被redis完全取代。redis的读写速度非常快，官方给出的数据是读110000次/s，写81000次/s；而且redis支持多种数据类型，例如String，list，hash，set，zset；redis支持主从复制（集群），进行数据持久化；还支持过期时间，事务等。</p>\n<h2><strong>二，redis的安装与启动（docker环境下）</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;docker安装完毕后，安装redis：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第一步：拉取redis镜像，docker&nbsp; pull&nbsp; redis</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第二步：启动redis，docker&nbsp; &nbsp;run&nbsp; &nbsp;redis&nbsp; &nbsp;</p>\n<p><strong>三，基本知识串讲</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>单进程单线程：redis只有一个进程，且内部为单线程，这样做的优势是不存在线程安全问题，且不需要进行线程间的切换，提高了性能，而且多线程可能会涉及到锁。劣势是无法发挥多核cpu的优势，不过可以通过开启搭建多个redis实例实现</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>redis中默认有16个数据库（0-15），可以通过select n来进行数据库之间的切换</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;常用的基本命令：flushDB（清空当前数据库），flushAll（清空所有数据库），dbSize（查看有多少数据库）</p>\n<h2><strong>四，redis基本数据类型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;string：</strong>字符串类型，数据库中存储Map&lt;String,String&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>list：</strong>列表数组类型，数据库中存储Map&lt;String,List&lt;Object&gt;&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>hash：</strong>哈希类型，数据库中存储Map&lt;String,Map&lt;Object,Object&gt;&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>set：</strong>集合类型，其中元素无序，数据库中存储Map&lt;String,Set&lt;Object,Object&gt;&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>Zset：</strong>有序集合类型，每个元素都有一个可用于排序的权重</p>\n<h2><strong>五，redis相关命令（这里详解一些常用的命令，不常用的一笔带过）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;string：</strong>(1)set&nbsp; key&nbsp; value,插入一条数据&nbsp; （2）mset&nbsp; key value...批量插入 （3）setnx&nbsp; key value&nbsp; 若无则插入（4）get&nbsp; key&nbsp; 获取某条数据&nbsp; （5）mget keys 批量获取&nbsp; （6）getrange key&nbsp; 0 -1获取数据库全部数据&nbsp; （7）incr age 递增&nbsp; (8) incrby&nbsp; age&nbsp; 10&nbsp; 递增 age 步长为10（9）decr&nbsp; age&nbsp; 递减&nbsp; （10）decrby&nbsp; age&nbsp; 10 步长递减&nbsp; &nbsp;（11）del&nbsp; key&nbsp; 删除某条数据&nbsp; <span style=\"background-color: #ffff00;\">（12）exists&nbsp; key&nbsp; 判断是否存在某个key&nbsp; &nbsp;(13)expire&nbsp; key&nbsp; 10&nbsp; 设置过期时间（单位为秒）&nbsp; （14）pexpire&nbsp; key&nbsp; 1000 设置过期时间，单位为毫秒&nbsp; （15）persist key删除过期时间 （</span><span style=\"background-color: #ffff00;\">16）ttl&nbsp; key&nbsp; 查看过期时间</span></p>\n<p><span style=\"background-color: #ffff00;\">&nbsp;<span style=\"background-color: #ffffff;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>list：&nbsp;&nbsp;</strong>（1）lpush&nbsp; key&nbsp; value 左插入一条数据&nbsp; &nbsp;（2）lpush mylist&nbsp; key&nbsp; value....批量左插入&nbsp; （3）rpush&nbsp; key value 右插入一条数据&nbsp; (4)rpush&nbsp; mylist&nbsp; key value...右批量插入&nbsp; （5）lrange&nbsp; mylist&nbsp; 0&nbsp; -1&nbsp; 取出数据集合&nbsp; （6）lpop mylist 左弹出集合中第一条数据&nbsp; （7）rpop&nbsp; </span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">mylist&nbsp; 右弹出集合中第一条数据&nbsp; （8）llen&nbsp; mylist&nbsp; 获取数据集合长度lrem&nbsp; mylist&nbsp; count&nbsp; value&nbsp; （count&gt;0,从表头开始搜索，移除count个与值与value相等的元素；count&lt;0,表尾开始；count=0，移除所有值与value相等的元素） （9）linsert mylist&nbsp; before/after&nbsp; a&nbsp; 在a元素前或后插入。</span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">(10) lpoplpush&nbsp; list&nbsp; list1 转移列表的元素到另一个列表</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>hash：</strong>（1）hset&nbsp; key&nbsp; &nbsp;val-key&nbsp; val-val&nbsp; 插入一条数据&nbsp; （2）hset&nbsp; myhash&nbsp; name&nbsp; xxx&nbsp; 用于给哈希表中的字段赋值，不存在则创建哈希表赋值，存在则覆盖旧值&nbsp; (3) hget&nbsp; &nbsp;myhash&nbsp; name&nbsp; 取哈希表中某个值&nbsp; （4）hmset&nbsp; myhash name&nbsp; xxx age xxx&nbsp; 批量插入字段&nbsp; （5）hmget</span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">批量获取 （6）hgetall&nbsp; myhash&nbsp; 获取哈希表中所有值&nbsp; (7)&nbsp; hexisets myhash&nbsp; name&nbsp; 判断哈希表中是否存在name字段&nbsp; （8）hsetnx&nbsp; myhash score 100 若存在则不插入，若不存在则插入数据&nbsp; （9）hincrby&nbsp; myhash id 1/hdecrby&nbsp; myhash id&nbsp; 10 递增递减 （10）hdel&nbsp; myhash name&nbsp; </span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">删除&nbsp; （11）hkeys&nbsp; myhash&nbsp; 只取key值&nbsp; （12）hvals&nbsp; myhash&nbsp; 只取value值&nbsp; （13）hlen&nbsp; myhash 获取哈希表长度</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>set：</strong>（1）sadd myset&nbsp; redis&nbsp; 添加一条数据&nbsp; （2）smembers myset&nbsp; 获取数据集合&nbsp; （3）srem&nbsp; myset&nbsp; set1&nbsp; 删除set1&nbsp; （4）sismember myset&nbsp; set1 判断set中是否存在set1&nbsp; (5)srandmember&nbsp; key count&nbsp; 随机获取count个元素（6）spop&nbsp; 从集合中弹出一个元素</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>zset：</strong>之后补充</span></span></p>\n<h2><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">六，redis配置文件（常见配置）</span></span></strong></h2>\n<p><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;daemonize no：</span></span></strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">redis默认不是以守护进程的方式运行的，可以更改为yes启用守护进程（即后台运行）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>pidfile&nbsp; /var/run/redis.pid&nbsp; :</strong>启用守护进程后，默认将pid写入/var/run/redis.pid文件，可以更改</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>port&nbsp; 6379 ：</strong>redis默认端口</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp; &nbsp; &nbsp; &nbsp; <strong>bind&nbsp; 127.0.0.1：</strong>绑定的主机地址</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\"> &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>timeout&nbsp; 300</strong><strong>：</strong>redis客户端闲置多长时间后关闭连接，改为0的话，表示关闭该功能</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>loglevel&nbsp; verbose：</strong>默认日志级别（还有debug，notice，warning）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>database 16：</strong>redis默认有16个数据库可以修改</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>save&nbsp; 900&nbsp; 1/save&nbsp; 300&nbsp; 10/save&nbsp; 60&nbsp; 10000：&nbsp;</strong>表示一定时间内有多少条数据发生修改，就将其同步到数据文件一次，例如第一个表示15分钟内有一条数据发生改变就同步</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>rdbcompression yes&nbsp; ：</strong>表示数据存储到本地数据库时是否进行压缩</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>dbfilename&nbsp; dump.rdb：</strong>指定本地数据库文件名</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>dir&nbsp; /...../redis安装目录/bin ：</strong>本地数据库存放目录，默认在redis安装目录的bin目录下</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>slaveof&nbsp; &nbsp;masterip&nbsp; masterport ：</strong>设置当本机为从机时，它的主机的ip和端口</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>masterauth&nbsp; &lt;master-password&gt;：</strong>当master服务设置了密码时，slav服务连接master的密码</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>requirepass&nbsp; foobared：</strong>默认关闭redis连接需要密码，当给redis设置了密码，就需要打开</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>maxclients&nbsp; &nbsp;128：</strong>redis同一时间最大连接客户端的数量</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>appendonly&nbsp; &nbsp;no：</strong>是否开启aof持久化，默认不开启，采用rdb</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>appendfilename&nbsp; appendonlu.aof：</strong>指定aof持久化的文件名</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>appendfsync&nbsp; everysec :</strong>指定更新日志条件，默认每秒更新一次（还有no，指等操作系统进行数据缓存到磁盘，快；always指每次更新操作后都手动写入磁盘，慢但安全）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;虚拟机方面的配置暂不说明</span></span></p>\n<h2><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">七，redis持久化</span></span></strong></h2>\n<p><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;概述：</span></span></strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">redis持久化主要有两种方式，即rdb和aof</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>rdb：</strong>适用于大数据集的恢复，数据的备份，但是因为设置周期时间进行数据的快照，所以如果redis宕机，可能会丢失最后一个写操作的数据，因为数据完整性较差。数据保存在dump.db文件中，只需要移动到redis安装目录，重启即可恢复数据</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>aof：</strong>适用于对数据的完整性要求较高的情况，因为可以设置不同的持久化策略，例如每秒保存一次，这样即时redis宕机，也只会丢失最后一秒的数据。但是因为其日志文件存储的是写入命令，因而其文件大小要大于rdb的数据文件，且每次重启，都要从头执行数据文件中的命令，因而恢复速度也</span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">要慢于rdb。</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>注意：</strong>当rdb和aof同时开启的时候，redis重启，默认会采用aof的形式进行数据的重新构建</span></span></p>\n<h2><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">八，redis事务</span></span></strong></h2>\n<p><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;概述：</span></span></strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">什么是事务？事务即是一系列的命令要买全部执行，要么全部回滚</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <strong>常用命令：</strong>multi(启动事务)，discard（取消事务）,exec（执行事务块内命令）,watch key(监控某个key的变化)，unwatch（取消对所有key的监控）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>注意：</strong>redis的事务中在命令本身出错的情况下会造成命令的全部回滚，但是在命令无错，执行某个命令的时候发生异常的时候，则谁的错，谁停止（这一点和mysql是不同的）</span></span></p>\n<h2><strong>九，redis的主从复制</strong></h2>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>redis的主从复制，即主机数据更新后根据我们设置的策略将数据同步到从机上，主机以写为主，从机以读为主<strong>。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 使用：</strong>配主不配从，在从机中使用slaveof&nbsp; 主机ip&nbsp; &nbsp;主机端口配置从机，但是这种配置方式当redis重启之后就会失效，如果想要redis重启仍然可用，则需要配置redis.conf配置文件中的slaveof&nbsp; masterip&nbsp; masterport。这种配置方式的问题所在，中心化只有一台极其支持写操作，如果主机宕机，则从机等待，且从机宕机重启后不会跟上大部队（即重启后变为主机）。当然我们可以采用命令slave&nbsp; no&nbsp; one 使从机反客为主，成为主机。但是这种手动操作太过麻烦。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>哨兵模式：</strong>即配置之后，如果主机宕机，则哨兵会自动根据投票规则在从机中进行选举，从而产生新的主机顶替。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>主从复制的缺点：</strong>因为所有的写操作都是子主机上进行，从而在同步到从机上，所以存在着一定的延迟，当系统繁忙或者从机数量较多的时候，这种问题就更加明显。</p>\n<h2><strong>十，redis集群</strong></h2>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;概述：</strong>集群是一种去中心化的模式，与中心化模式不同的是，中心化模式中如果主服务挂掉了，那么服务就挂掉了。但是集群模式下，没有主路由，每个节点自身都可以成为路由</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;redis集群：即配置多台主机，多台从机，不同的主机中有不同的槽点，当执行数据写入时，会根据crc16算法计算出数据的槽点，从而将数据存入到对应的主机中，并同步到与其对应的从机中</p>\n<p>&nbsp;</p>\n<h1>水平有限，如有错误，还望指出！</h1>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1249588251598041088","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6caUuADBI7AAAb07iHSRw500.jpg","blogRead":4,"blogRemark":"redis基础（一）","blogTitle":"redis基础（一）","createdTime":"2020-04-13 06:40:30","typeName":"redis","updateTime":"2020-04-20 16:47:37"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，线程上下文切换</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>cpu利用时间片轮询的方式来为每个任务都分配一定的时间片，任务的执行过程中保存任务的状态。任务状态的保存和在加载就叫做上下文切换。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>进程：</strong>指的是一个运行中的程序实例，一个进程中可以有多个线程，并且与进程共享同样的内存和系统资源</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong> 上下文：</strong>指的是寄存器和程序计数器保存的线程的信息</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>寄存器：</strong>指的是内存中很小但是运行速度很快的一块区域（相对于RAM外部内存）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>程序计数器：</strong>一种寄存器，用来保存当前执行指令的位置或者下一个待执行指令的位置</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>上下文切换：</strong>上下文切换指的是操作系统的内核在cpu上对进程或者线程的切换。上下文信息保存在进程控制块中（PCB）。流程如下：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;挂起当前进程，将进程的上下文信息保存在进程控制块中；</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;在进程控制块中寻找下一个任务的上下文信息。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;恢复进程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>上下文切换的原因：</strong>第一，任务正常执行完毕，调度下一个任务；第二，线程出现I/O阻塞，被挂起，cpu调度下一个任务；第三，线程等待同步锁，获取socket通知等，被挂起，cpu调度下一个任务；第四，用户调用sleep方法，让出cpu；第五，硬件中断</p>\n<h2><strong>二，JAVA阻塞队列</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>阻塞队列的是调度当前队列的线程处于阻塞状态</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 消费者阻塞：如果队列为空，则消费者线程被挂起，处于阻塞状态，当有新数据进入队列，则消费者线程被唤醒，消费数据</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 生产者阻塞：如果队列数据已满，则生产者线程挂起，处于阻塞状态，当队列有空闲位置，生产者线程被唤醒，生产数据。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞队列的主要操作：</strong>插入操作和移除（获取）操作</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>插入操作：</strong>add(e)，有空间则插入，无空间报异常；offer(e),有空间则插入，无空间返回false；offer(e,time,unit),有空间插入，无空间等待time时间，若超时返回false；put(e),有空间插入，无空间则线程挂起处于阻塞直到有空间</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>移除操作：</strong>poll(e),有值返回值，无值返回null;poll(e,time,unit),有值返回值，无值等待time时间，超时返回null;take(e),有值返回值，无值等待新数据进入再立即返回；drainTo(collection&lt;Object&gt;)批量移除，提高获取效率</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞队列的实现：</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong> ArrayBlockingQueue：</strong>基于数组的有界阻塞队列，按照先进先出顺序对元素进行排序</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>LinkedBlockingQueue：</strong>基于链表的有界阻塞队列，队头队尾采用不两个不同的锁控制数据同步，并发性高</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>PriorityBlockingQueue：</strong>基于优先级的无界队列，默认升序排列，可以自定义排序规则，根据优先级访问数据。但是有数据优先级一样的情况</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>DelayQueue：</strong>支持延时的队列，即从队列中取数据时等待一定的时间才能获取元素。可以用于缓存系统的设计，设计过期时间，也可以用来设置定时调度任务，即如果能够从队列中获取，说明到了任务的调度时间。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>SynchronousQueue</strong>：该队列是一个不存储元素的阻塞队列，每一个put操作都必须等待一个take操作的完成。吞吐量高于ArrayBlockingQueue和LinkedBlockingQueue。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>LinkedTransferQueue：</strong>基于链表的无界阻塞队列，多了transfer方法(如果消费者等待，直接将任务从生产者传递给消费者，无消费者等待，则将任务加到队尾直到被消费才返回)和tryTransfer（与transfer一致，只不过不管有没有消费者等待获取都会立即返回tryTransfer（e,time,unit）（与tryTransfer一致，只不过设置了超时时间）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>LinkedBlockingDeque：</strong>基于链表的双向阻塞队列，可以在两端同时进行读写操作，提高了队列的操作效率。</p>\n<h2><strong>三，并发关键字</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;CountDownLatch：</strong>适用于一个主线程等待子线程完成任务之后执行（原理：设置一个程序计数器，计数器的值为子线程的个数，子线程并发执行，每个子线程执行完毕后，调用CountDown方法，将其计数器的值减去1，值为0时，唤醒主线程执行）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>CyclicBarrier：</strong>即当所有线程到达一个状态共同执行。await（）方法：确保所有线程到达Barrier状态才执行；await（time,unit）：设置一个超时时间，超过这个时间，执行达到Barrier状态的线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>Semaphore：</strong>因为其限制了多线程访问资源的线程个数，所以适用于多线程并发访问有限资源的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>volatile：</strong>直接用来修饰变量，是一种比Synchronized更加轻量级的机制，用于多线程共享同一变量，可以同时对其进行读写操作。当多个线程共享变量的时候，读取变量将其从内存复制到cpu缓存中，然后线程对其操作进行修改，这样再多cpu的情况下，有可能出现线程修改原数据造成数据不一致的情况，使用volatile关键字直接将线程修改的变量存入内存，解决这个问题。</p>\n<h2><strong>四，多线程共享数据</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>多线程共享数据主要通过共享内存实现，而共享内存的可见性，有序性，原子性已经由JVM和锁解决。理想情况下我们需要解决同步和互斥的问题（<span style=\"background-color: #ffff00;\">怎么解决的有待考证！</span>）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>解决方法一：</strong>将数据抽象成一个类，将对数据的操作封装成类中的方法</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解决方法二：</strong>将Runnable对象作为一个内部类，将共享数据作为这个类的成员变量</p>\n<h2><strong>五，ConcurrentHashmap并发</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ConcurrentHashmap使用了减小锁粒度，这里具体为分段锁的思想优化了锁，因为如果直接对hashmap进行加锁，锁太大，而且同一时刻只能有一个线程操作hashmap，并发性能较差</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;实现原理：</strong>即内部采用分段锁思想，将hashmap分为多个segment，每次读取数据的时候，对数据所在的segment进行加锁，这样只要保证每个segment线程安全，就可以保证整个hashmap线程安全</p>\n<h2><strong>六，JAVA中的线程调度</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;抢占式调度：</strong>即线程对cpu资源进行抢占，这种策略下每个线程抢占到cpu资源的概率是相等的，这样就不会一个线程阻塞造成整个系统阻塞的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>协同式调度：</strong>即一个线程使用完cpu资源之后通知cpu调度下一个任务，适用于多线程交替执行任务。因为如果一个线程阻塞可能会造成整个系统阻塞甚至崩溃</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>JAVA采用的是抢占式调度，但同时又尽可能的保证公平性（即为每个线程分配优先级不同的cpu时间片）</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>&nbsp;线程让出cpu的情况</strong>：第一，线程调用yield方法；第二，I/O阻塞，socket等待等；第三，等待同步锁；第四，正常执行完毕</p>\n<h2>七，进程调度算法</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>优先调度算法：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;先来先服务调度算法：</strong>即遵循先来先被分配cpu资源运行的原则</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>短作业调度算法：</strong>即预估作业的时间长短，优先调度时间短的任务，可能会导致长时间大任务很长时间无法被调度 &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>高优先权调度算法：即每个任务会预先被分配优先级</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;非抢占式优先调度算法：</strong>按照优先级的高低一次分配cpu资源运行</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>抢占式优先调度算法：</strong>按照优先级的高低分配cpu资源运行，但是如果任务再运行过程中有优先级更高的任务加入，则将其cpu资源临时回收分配给紧急任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>高响应比调度算法：</strong>动态调度，即作业时间短，则优先级高；等待时间长，则优先级高。前者遵循短作业调度算法，后者遵循先来先服务原则。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>时间片轮转调度算法：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;时间片轮转法：</strong>按照任务再队列中的顺序进行调度</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>多级反馈队列调度算法：</strong>即再时间片轮转法的基础上维护了就绪队列，默认第一队列优先级高，先调度第一队列的任务，如果再分配的cpu时间片内未完成则将其加入第二队列队尾，以此类推直到其执行完毕。只有第1 -（n-1）队列为空，才会调度第n队列的任务，而且当前任务执行时，如果有优先级高的任务进来，会抢占其cpu资源。</p>\n<h2><strong>八，CAS</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>即比较和交换，CAS（V,E,N）三个参数，只有当V=E的时候才会将V设置为N。如果V!=E，则说明数据已经被其它线程修改，不做任何操作</p>\n<h2><strong>九，ABA问题</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>概述：</strong>即当1线程从V中取出A时，2线程也从中取出1，修改为B，再修改为A。而1线程仍然修改成功，实际上修改过程中V的实际值已经发生改变，只不过1没有发觉。解决这种问题，常采用乐观锁的版本号机制。</p>\n<h2><strong>另外有AQS问题没怎么读懂，下次完善！</strong></h2>\n<p>&nbsp;</p>\n<h3><strong>思维导图：<a href=\"https://images-cdn.shimo.im/myFodjsaVAA3PVV7__thumbnail\" target=\"_blank\" rel=\"noopener\">并发编程（下）</a></strong></h3>\n<p>&nbsp;</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</p>","blogGoods":0,"blogId":"1249742755949817856","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHNmAPuxmAABJTVJPTfk117.jpg","blogRead":17,"blogRemark":"面试（三）------之并发编程篇（下）","blogTitle":"面试（三）------之并发编程篇（下）","createdTime":"2020-04-13 16:54:26","typeName":"java面试篇","updateTime":"2020-04-20 11:54:02"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，栈及其JAVA实现</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：栈是一种先进后出的数据结构，对栈顶元素的添加，删除等操作较快，但是对于栈内的元素操作很慢</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA实现：实现需要定义栈的数据结构，写栈的入栈，出栈，获取栈顶元素的方法，如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n * 基于数组实现栈\n * @author wcj\n * @Date 2020/4/14 20:59\n * @Version 1.0\n */\npublic class StackExample&lt;E&gt; {\n\n    /**\n     * 站的深度\n     */\n    private int maxSize;\n    /**\n     * 存储数据的数组\n     */\n    private Object[] data;\n    /**\n     * 栈顶指针\n     */\n    private int top = -1;\n\n    /**\n     * 默认栈的深度为10\n     */\n    public StackExample(){\n        this(10);\n    }\n\n    /**\n     * 用户自定义栈的深度\n     * @param initialSize\n     */\n    public StackExample(int initialSize){\n        if(initialSize&gt;=0){\n            this.maxSize = initialSize;\n            this.data = new  Object[initialSize];\n            this.top = -1;\n        }else{\n            throw new RuntimeException(\"初始化栈的深度不能小于0!\");\n        }\n    }\n\n    /**\n     * 入栈操作\n     * @param e\n     * @return\n     */\n    public Boolean push(E e){\n        if(top == maxSize-1){\n            throw new RuntimeException(\"栈已满,不能入栈\");\n        }else{\n            data[++top] = e;\n        }\n        return true;\n    }\n\n    /**\n     * 出栈操作\n     * @return\n     */\n    public E pop(){\n        if(top==-1){\n            throw new RuntimeException(\"栈空，不能出栈！\");\n        }else{\n            return (E) data[top--];\n        }\n    }\n\n    /**\n     * 获取栈顶元素\n     * @return\n     */\n    public E peak(){\n        if(top==-1){\n            throw new RuntimeException(\"栈空异常！\");\n        }else{\n            return (E) data[top];\n        }\n    }  </code></pre>\n<h2><strong>二，队列极其JAVA实现</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：队列是一种先进先出的数据结构，对队头和队尾的操作简单，但是队内元素的操作复杂。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA实现：定义队列的数据结构，队列的出队，入队，获取队头元素。代码如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n * 基于数组实现队列\n * @author wcj\n * @Date 2020/4/14 21:14\n * @Version 1.0\n */\npublic class QueueExample&lt;E&gt; {\n\n    /**\n     * 队列长度\n     */\n    private int maxSize;\n    /**\n     * 存储数据数组\n     */\n    private Object[] data;\n    /**\n     * 队头指针\n     */\n    private int front;\n    /**\n     * 队尾指针\n     */\n    private int rear;\n\n    /**\n     * 默认构造器\n     */\n    public QueueExample(){\n        this(10);\n    }\n    /**\n     * 用户自定义队列长度构造器\n     * @param initialSize\n     */\n    public QueueExample(int initialSize){\n        if(initialSize&gt;=0){\n            this.maxSize = initialSize;\n            data = new Object[initialSize];\n            front = rear = 0;\n        }else{\n            throw new RuntimeException(\"初始化队列长度不能小于0！\");\n        }\n    }\n\n    /**\n     * 入队操作\n     * @param e\n     * @return\n     */\n    public Boolean add(E e){\n        if(rear == maxSize){\n            throw new RuntimeException(\"队列已满，无法入队!\");\n        }else{\n            data[rear++] = e;\n        }\n        return true;\n    }\n\n    /**\n     * 出队操作\n     * @return\n     */\n    public E poll(){\n        if(front==rear){\n            throw new RuntimeException(\"队空，无元素可出队！\");\n        }else{\n            E e = (E) data[front];\n            data[front] = null;\n            return e;\n        }\n    }\n\n    /**\n     * 获取队头元素\n     * @return\n     */\n    public E peek(){\n        if(front==rear){\n            throw new RuntimeException(\"队空，无元素可出队!\");\n        }else{\n            return (E) data[front];\n        }\n    }\n}\n</code></pre>\n<h2><strong>三，链表及其JAVA实现</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：链表是由一系列数据节点组成的数据结构，节点可以动态生成。对于元素的增加，删除操作快，查询操作慢</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;这里主要讲述几种有代表性的链表：单向链表，双向链表，双向循环链表</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;单链表的JAVA实现：数据结构定义，添加节点，删除节点，查找节点，代码如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n * 单向链表\n * @author wcj\n * @Date 2020/4/14 21:32\n * @Version 1.0\n */\npublic class SingleLinkedList {\n\n    /**\n     * 链表长度\n     */\n    private int length;\n    /**\n     * 链表头节点\n     */\n    private Node head;\n\n    public SingleLinkedList(){\n        this.length = 0;\n        this.head = null;\n    }\n    /**\n     * 内部类声明每个链表节点\n     * 每个节点包括数据域和指向下一个节点的指针\n     */\n    private class Node{\n        private Object data;\n        private Node next;\n        public Node(Object data){\n            this.data = data;\n        }\n    }\n\n    /**\n     * 插入节点（这里使用头插法）\n     * @param obj\n     * @return\n     */\n    public Boolean add(Object obj){\n        Node node = new Node(obj);\n        if(length==0){\n            head = node;\n        }else{\n            node.next= head;\n            head = node;\n        }\n        length++;\n        return true;\n    }\n\n    /**\n     * 删除某个节点\n     * 先对链表进行判空处理\n     * 然后找到要删除的节点\n     * 最后进行删除\n     * @param obj\n     * @return\n     */\n    public Boolean delete(Object obj){\n        if(length==0){\n            throw new RuntimeException(\"链表为空，无节点可删除!\");\n        }else{\n            Node prev = head;\n            Node current = head;\n            //查找待删除元素\n            while(!current.data.equals(obj)){\n                if(current.next==null){\n                    return false;\n                }else{\n                    prev = current;\n                    current = current.next;\n                }\n            }\n            prev.next = current.next;\n            length--;\n        }\n        return true;\n    }\n\n    /**\n     * 获取某个元素\n     * @param obj\n     * @return\n     */\n    public Object find(Object obj){\n        if(length==0){\n            throw new RuntimeException(\"链表为空\");\n        }else{\n            Node current = head;\n            while(current.data.equals(obj)){\n                if(current.next==null){\n                    return null;\n                }else{\n                    current = current.next;\n                }\n            }\n            return current.data;\n        }\n    }\n}\n</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>双向链表的JAVA实现：定义数据结构，头插法，尾插法，删除头部节点，删除尾部节点（这里只写尾插节点和删除尾部节点），代码如下：</strong></p>\n<pre class=\"language-java\"><code>import com.sun.org.apache.xpath.internal.operations.Bool;\n\n/**\n * 单向循环链表\n * @author wcj\n * @Date 2020/4/14 22:05\n * @Version 1.0\n */\npublic class CircleLinkedList {\n\n    /**\n     * 链表长度\n     */\n    private int length;\n    /**\n     * 头节点\n     */\n    private Node head;\n    /**\n     * 尾节点\n     */\n    private Node tail;\n\n    /**\n     * 初始化构造方法\n     */\n    public CircleLinkedList(){\n        this.length = 0;\n        this.head=this.tail = null;\n    }\n\n    /**\n     * 内部类实现的链表节点\n     */\n    private class Node{\n        private Object data;\n        private Node prev;\n        private Node next;\n        public Node(Object data){\n            this.data = data;\n        }\n    }\n\n    /**\n     * 尾插节点\n     * @param obj\n     * @return\n     */\n    public Boolean addTail(Object obj){\n        Node node = new Node(obj);\n        if(length==0){\n            head = tail= node;\n            length++;\n        }else{\n            tail.next = node;\n            node.prev = tail;\n            tail = node;\n            length++;\n        }\n        return true;\n    }\n\n    /**\n     * 删除尾部节点\n     * @return\n     */\n    public Boolean delTail(){\n        Node temp = tail;\n        if(length==0){\n            throw new RuntimeException(\"链表为空!\");\n        }else{\n            tail = tail.prev;\n            tail.next = null;\n            length--;\n        }\n        return true;\n    }\n}\n</code></pre>\n<h2><strong>四，散列表</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：有一张表M，一个映射函数f(key)，如果对于任意一个key，都有一个函数指与表中的内存地址相对应，则M就为散列表，f(key)就为散列函数。散列函数存储key-value键值对形式的数据，直接生成key与表中地址值的映射，因此查询非常迅速。同时散列表也经常被用于信息安全，用于加密操作。</strong></p>\n<h2><strong>五，二叉排序树</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：二叉查找树又成为二叉搜索树，二叉查找树</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;特征：根节点左边的数据小于根节点，根节点右边的数据大于根节点，且其左右子树还是二叉排序树</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现：定义数据结构，插入操作，删除操作，查找操作，代码如下：</strong></p>\n<pre class=\"language-java\"><code>package interviewFour.example4;\n\n/**\n * 二叉排序树\n * @author wcj\n * @Date 2020/4/14 17:17\n * @Version 1.0\n */\npublic class Node {\n\n    private Node root = null;\n    private int value;\n    private Node left;\n    private Node right;\n\n    public Node(){}\n\n    public Node(int value, Node left, Node right){\n        this.value = value;\n        this.left = left;\n        this.right = right;\n    }\n\n    public Node(int value){\n        this.left = null;\n        this.right = null;\n        this.value = value;\n    }\n\n    public int getValue() {\n        return value;\n    }\n\n    public void setValue(int value) {\n        this.value = value;\n    }\n\n    public Node getLeft() {\n        return left;\n    }\n\n    public void setLeft(Node left) {\n        this.left = left;\n    }\n\n    public Node getRight() {\n        return right;\n    }\n\n    public void setRight(Node right) {\n        this.right = right;\n    }\n\n    /**\n     * 插入节点\n     * @param value\n     * @return\n     */\n    public Boolean insert(int value){\n        //root代表根节点\n        Node p = root;\n        Node prev = null;\n        //创建一个节点\n        Node node = new Node(value);\n        //寻找节点的插入位置\n        while(p!=null){\n            prev = p;\n            if(value==p.getValue()){\n                return false;\n            }else if(value&lt;p.getValue()){\n                p = p.getLeft();\n            }else{\n                p = p.getRight();\n            }\n        }\n        if(root==null){\n            root = node;\n        }else if(value&lt;prev.getValue()){\n            prev.setLeft(node);\n        }else{\n            prev.setRight(node);\n        }\n        return true;\n    }\n\n    /**\n     * 删除某个节点\n     * 分为三种情况，待删除节点为叶子节点，则直接删除\n     * 待删除节点只有左子树或者右子树，则用左子树或者右子树替代当前节点位置\n     * 待删除节点即有左子树又有右子树，则寻找左子树最大节点或者右子树最小节点顶替当前节点(这里使用左子树的最大节点)\n     * @param value\n     * @return\n     */\n    public void deleteBST(int value){\n        deleteBST(root,value);\n    }\n\n    /**\n     * 递归删除左子树，或者右子树，或者根节点\n     * @param root\n     * @param value\n     * @return\n     */\n    public Boolean deleteBST(Node root,int value){\n        if(root==null){\n            return false;\n        }else{\n            if(root.getValue()==value){\n                delete(root);\n            }else if(value&lt;root.getValue()){\n                deleteBST(root.getLeft(),value);\n            }else{\n                deleteBST(root.getRight(),value);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * 分情况执行具体的删除逻辑\n     * @param node\n     * @return\n     */\n    public Boolean delete(Node node){\n        if(node.getLeft()==null){\n            node = node.getRight();\n        }else if(node.getRight()==null){\n            node = node.getLeft();\n        }else{\n            Node temp = node;\n            Node s = node;\n            //转向左子树，向右走到底\n            s = s.getLeft();\n            //寻找替换待删除节点的节点\n            while(s!=null){\n                temp = s;\n                s = s.getRight();\n            }\n            node.setValue(temp.getValue());\n            if(temp!=node){\n                node.setLeft(temp.getLeft());\n            }else{\n                node.setRight(temp.getRight());\n            }\n        }\n        return true;\n    }\n\n    /**\n     * 在二叉查找树中找到对应节点\n     * @param value\n     * @return\n     */\n    public Boolean searchBTS(int value){\n        Node node = root;\n        if(node==null){\n            throw new RuntimeException(\"无此节点！\");\n        }else{\n            if(value==node.getValue()){\n                return true;\n            }else if(value&lt;node.getValue()){\n                node = node.getLeft();\n            }else{\n                node = node.getRight();\n            }\n        }\n        return false;\n    }\n}\n</code></pre>\n<h2><strong>六，红黑树</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 概述：红黑树是一种特化的自平衡二叉排序树，即其左右子树的深度差可以超过1。（详细的插入等操作过段时间会补充）</strong></p>\n<h2><strong>七，图，位图</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;图的知识：定义，有向图/无向图，邻接矩阵/邻接表，BFS/DFS，位图的话没怎么搞清楚。</strong></p>\n<h3><strong>思维导图：<a href=\"https://images-cdn.shimo.im/YClQaLxx9e8uEb9U__thumbnail\" target=\"_blank\" rel=\"noopener\">数据结构</a></strong></h3>\n<h2>&nbsp;</h2>","blogGoods":0,"blogId":"1250068950784536576","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHQGAYlUxAABJTVJPTfk990.jpg","blogRead":7,"blogRemark":"面试（四）------之数据结构篇","blogTitle":"面试（四）------之数据结构篇","createdTime":"2020-04-14 14:30:37","typeName":"java面试篇","updateTime":"2020-04-23 22:14:43"}],"pageSize":10,"params":{},"sortMethod":"ASC","totalCount":53,"totalPage":6},"msg":"操作成功!"}
2020-04-26 23:25:34.691 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listBack
2020-04-26 23:25:34.692 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:25:34.692 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:25:34.693 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeList
2020-04-26 23:25:34.693 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=ASC)]
2020-04-26 23:25:34.874 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 183
2020-04-26 23:25:34.874 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"enable":1,"typeBlogCount":1,"typeId":1,"typeName":"Linux"},{"enable":1,"typeBlogCount":0,"typeId":2,"typeName":"Docker"},{"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"SpringBoot"},{"enable":1,"typeBlogCount":0,"typeId":4,"typeName":"Mybatis"},{"enable":1,"typeBlogCount":0,"typeId":5,"typeName":"爬虫"},{"enable":1,"typeBlogCount":4,"typeId":6,"typeName":"博客开发和维护总结"},{"enable":1,"typeBlogCount":1,"typeId":7,"typeName":"CSS"},{"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"JavaScript"},{"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Vue"},{"enable":1,"typeBlogCount":1,"typeId":10,"typeName":"随笔"}],"pageSize":10,"params":{},"sortMethod":"ASC","totalCount":19,"totalPage":2},"msg":"操作成功!"}
2020-04-26 23:25:38.765 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listBack
2020-04-26 23:25:38.765 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:25:38.766 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:25:38.766 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeList
2020-04-26 23:25:38.766 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=2, pageSize=10, totalPage=2, totalCount=19, list=[Type(typeId=1, typeName=Linux, typeBlogCount=1, enable=1, deleted=null), Type(typeId=2, typeName=Docker, typeBlogCount=0, enable=1, deleted=null), Type(typeId=3, typeName=SpringBoot, typeBlogCount=0, enable=1, deleted=null), Type(typeId=4, typeName=Mybatis, typeBlogCount=0, enable=1, deleted=null), Type(typeId=5, typeName=爬虫, typeBlogCount=0, enable=1, deleted=null), Type(typeId=6, typeName=博客开发和维护总结, typeBlogCount=4, enable=1, deleted=null), Type(typeId=7, typeName=CSS, typeBlogCount=1, enable=1, deleted=null), Type(typeId=8, typeName=JavaScript, typeBlogCount=0, enable=1, deleted=null), Type(typeId=9, typeName=Vue, typeBlogCount=0, enable=1, deleted=null), Type(typeId=10, typeName=随笔, typeBlogCount=1, enable=1, deleted=null)], params={}, sortColumn=null, sortMethod=ASC)]
2020-04-26 23:25:38.950 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 185
2020-04-26 23:25:38.951 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":2,"index":10,"list":[{"enable":1,"typeBlogCount":16,"typeId":11,"typeName":"java面试篇"},{"enable":1,"typeBlogCount":0,"typeId":13,"typeName":"JDK源码阅读"},{"enable":1,"typeBlogCount":1,"typeId":14,"typeName":"redis"},{"enable":1,"typeBlogCount":0,"typeId":15,"typeName":"MongoDB"},{"enable":1,"typeBlogCount":28,"typeId":16,"typeName":"LeetCode"},{"enable":1,"typeBlogCount":1,"typeId":17,"typeName":"随心日记"},{"enable":1,"typeBlogCount":0,"typeId":18,"typeName":"计算机网络"},{"enable":1,"typeBlogCount":0,"typeId":19,"typeName":"操作系统"},{"enable":1,"typeBlogCount":0,"typeId":20,"typeName":"数据结构"}],"pageSize":10,"params":{},"sortMethod":"ASC","totalCount":19,"totalPage":2},"msg":"操作成功!"}
2020-04-26 23:25:43.557 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /about/list
2020-04-26 23:25:43.558 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:25:43.558 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:25:43.558 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.AboutController.getAboutList
2020-04-26 23:25:43.558 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=ASC)]
2020-04-26 23:25:43.835 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 278
2020-04-26 23:25:43.837 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"aboutContent":"<p>我是一名24岁的程序员</p>\n<p>目前在读研究生</p>\n<p>对于生活，对于工作，对于各种事务都充满着新鲜感和干劲</p>\n<p>我喜欢学习，喜欢这种不断充实自己的生活，喜欢这种逐渐强大的感觉</p>\n<p>我喜欢电脑，与接触之时的无感相比，现在对于电脑更多的是新奇和探究</p>\n<p>常常走在街道，乡间，看到万物，我都会尽我所能的想象其和程序之间的联系</p>\n<p>或许这是程序员的通病吧，在常人眼中看来很简单的一个红绿灯，我都会分析可能采用了什么算法</p>\n<p>设置怎样的定时器可以实现它的灯光切换，想象灯光切换之间的时间长度是根据什么标准进行限定的等等。</p>\n<p>说了这么多，可能你想：天呐，程序员都是什么样奇特的脑回路，看世界难道都是看代码吗？嗯，这一点你还真没猜错，哈哈</p>\n<p>但是实际上我也想拥有丰富的娱乐生活，但是奈何24岁的我还不够优秀，不够成熟</p>\n<p>或许有一天，我会达到我所期望的高度，但是绝对不是现在</p>\n<p>所以在这个过程中，唯有不断的学习和提高</p>\n<p>引用我很喜欢的汪国真的一句话：既然选择了远方，便只顾风雨兼程！</p>","aboutId":1,"aboutRead":40,"aboutTitle":"一名程序员的自白------24岁","createdTime":"2020-04-08 04:55:27","enable":1,"updateTime":"2020-04-24 00:12:33","version":42}],"pageSize":10,"params":{},"sortMethod":"ASC","totalCount":1,"totalPage":1},"msg":"操作成功!"}
2020-04-26 23:25:47.036 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /admin/getInfo
2020-04-26 23:25:47.036 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:25:47.037 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:25:47.037 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.AdminController.getInfo
2020-04-26 23:25:47.037 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:25:47.129 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 93
2020-04-26 23:25:47.129 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"header":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMSKACehsAACHOzTvceE295.jpg","id":1,"name":"小屋","signature":"时光好不经用，转眼已是半生","username":"admin"},"msg":"操作成功!"}
2020-04-26 23:25:48.296 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /user/list
2020-04-26 23:25:48.297 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:25:48.297 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:25:48.297 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.UserController.getUserList
2020-04-26 23:25:48.297 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=ASC)]
2020-04-26 23:25:48.819 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 523
2020-04-26 23:25:48.822 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"createdTime":"2020-04-08 04:59:22","header":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NWkaAJPVvAANwwcjPp-g88.jpeg","name":"","nickname":"小屋","password":"928bfd2577490322a6e19b793691467e","sex":1,"updateTime":"2020-04-12 14:21:56","userEmail":"570857634@qq.com","userId":1,"username":"admin","version":2}],"pageSize":10,"params":{},"sortMethod":"ASC","totalCount":1,"totalPage":1},"msg":"操作成功!"}
2020-04-26 23:25:52.028 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /comment/list
2020-04-26 23:25:52.029 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:25:52.029 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:25:52.029 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.CommentController.getCommentList
2020-04-26 23:25:52.029 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=null, params={}, sortColumn=null, sortMethod=ASC)]
2020-04-26 23:25:52.230 INFO  [http-nio-1000-exec-1]org.mongodb.driver.connection.info:71 -Opened connection [connectionId{localValue:2, serverValue:621}] to 121.199.34.159:27017
2020-04-26 23:25:52.291 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 263
2020-04-26 23:25:52.291 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[],"pageSize":10,"params":{},"sortMethod":"ASC","totalCount":0,"totalPage":0},"msg":"操作成功!"}
2020-04-26 23:25:54.347 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /rotation-picture/list
2020-04-26 23:25:54.348 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:25:54.348 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:25:54.349 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.RotationPictureController.getRotationPictureList
2020-04-26 23:25:54.349 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:25:54.444 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 97
2020-04-26 23:25:54.445 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"createdTime":"2020-04-08 02:07:31","enable":0,"rotationId":1,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMeGALlMgAB3vNI2iaCs718.gif"},{"createdTime":"2020-04-09 13:31:10","enable":0,"rotationId":3,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PI5KAYzGaAAGfH751PIw644.jpg"},{"createdTime":"2020-04-09 13:31:20","enable":1,"rotationId":4,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PI6aAZIz1AASCO4hlpJI295.jpg"},{"createdTime":"2020-04-09 13:37:02","enable":1,"rotationId":9,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJPyAbm8fAAG9gfO8lxE28.jpeg"},{"createdTime":"2020-04-09 13:41:30","enable":1,"rotationId":10,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJgeAeG8wAAS2pjJC5QU547.jpg"},{"createdTime":"2020-04-09 13:41:38","enable":1,"rotationId":11,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhGAQFZbAAP2OOBWb6k310.jpg"},{"createdTime":"2020-04-09 13:41:50","enable":1,"rotationId":12,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhyABMZCAAG7doyXiM8109.jpg"},{"createdTime":"2020-04-09 13:41:59","enable":1,"rotationId":13,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJiWAL7BoAARW3_O3ISw651.jpg"}],"msg":"操作成功!"}
2020-04-26 23:26:03.996 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listBack
2020-04-26 23:26:03.996 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:26:03.996 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:26:03.996 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeList
2020-04-26 23:26:03.996 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=ASC)]
2020-04-26 23:26:04.178 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 182
2020-04-26 23:26:04.178 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"enable":1,"typeBlogCount":1,"typeId":1,"typeName":"Linux"},{"enable":1,"typeBlogCount":0,"typeId":2,"typeName":"Docker"},{"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"SpringBoot"},{"enable":1,"typeBlogCount":0,"typeId":4,"typeName":"Mybatis"},{"enable":1,"typeBlogCount":0,"typeId":5,"typeName":"爬虫"},{"enable":1,"typeBlogCount":4,"typeId":6,"typeName":"博客开发和维护总结"},{"enable":1,"typeBlogCount":1,"typeId":7,"typeName":"CSS"},{"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"JavaScript"},{"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Vue"},{"enable":1,"typeBlogCount":1,"typeId":10,"typeName":"随笔"}],"pageSize":10,"params":{},"sortMethod":"ASC","totalCount":19,"totalPage":2},"msg":"操作成功!"}
2020-04-26 23:26:07.705 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /log/list
2020-04-26 23:26:07.705 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:26:07.705 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:26:07.706 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.LogController.getLogList
2020-04-26 23:26:07.706 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=null, params={}, sortColumn=null, sortMethod=ASC)]
2020-04-26 23:26:08.149 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 444
2020-04-26 23:26:08.153 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"createdTime":"2020-04-15 07:57:45","logId":3125,"logIp":"127.0.0.1","logMethod":"GET","logParams":"[]","logStatus":1,"logTime":97,"logUrl":"/blog/blog-statistic"},{"createdTime":"2020-04-15 07:57:48","logId":3126,"logIp":"127.0.0.1","logMethod":"POST","logParams":"[Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=ASC)]","logStatus":1,"logTime":398,"logUrl":"/blog/list"},{"createdTime":"2020-04-15 10:05:12","logId":3127,"logIp":"127.0.0.1","logMethod":"POST","logParams":"[Admin(id=null, name=null, header=null, signature=null, comment=null, username=admin, password=admin)]","logStatus":1,"logTime":1864,"logUrl":"/admin/login"},{"createdTime":"2020-04-15 10:05:12","logId":3128,"logIp":"127.0.0.1","logMethod":"GET","logParams":"[]","logStatus":1,"logTime":2,"logUrl":"/admin/info"},{"createdTime":"2020-04-15 10:05:13","logId":3129,"logIp":"127.0.0.1","logMethod":"GET","logParams":"[]","logStatus":1,"logTime":94,"logUrl":"/type/listFront"},{"createdTime":"2020-04-15 10:05:14","logId":3130,"logIp":"127.0.0.1","logMethod":"POST","logParams":"[Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=ASC)]","logStatus":1,"logTime":507,"logUrl":"/blog/list"},{"createdTime":"2020-04-15 10:05:57","logId":3131,"logIp":"127.0.0.1","logMethod":"POST","logParams":"[org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile@f04689a]","logStatus":1,"logTime":1074,"logUrl":"/upload/uploadImage"},{"createdTime":"2020-04-15 10:06:09","logId":3132,"logIp":"127.0.0.1","logMethod":"POST","logParams":"[Blog(blogId=null, blogTitle=面试（五）------之算法, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6W3IWAZhjCAACsl_OYPcQ410.jpg, blogContent=<h2><strong>一，二分查找算法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：二分查找算法又称为折半查找算法，待查找的序列必须已经是有序的，每次取序列的中间值与查找值进行比较，若相等则返回；若中间值小于查找值，则在中间值右侧序列中进行查找；若中间值大于查找值，则在中间值左侧序列中进行查找。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现如下：</strong></p>\n<pre class=\"language-java\"><code>public static int binarySearch(int[] arr,int low,int high,int key){\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(arr[mid]==key){\n                return mid;\n            }else if(arr[mid]&lt;key){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        return -1;\n    }</code></pre>\n<h2><strong>二，冒泡排序（这里以升序为例）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：冒泡排序即对于一个无序序列，从第一个元素开始，依次比较相邻的元素，如果前一个元素大于后一个元素，则交换位置，这样一趟比较下来，就确定出最大值。直到整个序列有序为止</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现如下：</strong></p>\n<pre class=\"language-java\"><code>public static void bubbleSort(int[] arr){\n        for (int i = arr.length-1; i &gt;=0 ; i--) {\n            for (int j = 0; j &lt; i; j++) {\n                if(arr[j]&gt;arr[j+1]){\n                    swap(arr,j,j+1);\n                }\n            }\n        }\n    }\n    /**\n     * 交换元素\n     * @param arr\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] arr,int i,int j){\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }</code></pre>\n<h2>三，插入排序（升序为例）</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>概述：即默认无序序列中的第一个元素有序，随后每次排列有序序列后的一个元素，将其排列进入前面的有序序列，同时保证有序序列的有序性即可。（类似于我们打扑克牌时，每拿一张从后往前比较大小，放入正确的位置）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现如下：</strong></p>\n<pre class=\"language-java\"><code>public static void insertSort(int[] arr){\n        for (int i = 1; i &lt; arr.length; i++) {\n            for (int j = i; j &gt;=0; j--) {\n                if(arr[j]&lt;arr[j-1]){\n                    swap(arr,i,j);\n                }\n            }\n        }\n    }\n\n    /**\n     * 交换元素\n     * @param arr\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] arr,int i,int j){\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }</code></pre>\n<h2>四，快速排序（升序为例）</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>概述：在一个无序序列中，取一个基准值，通常取第一个元素为基准值。然后从最右边依次查找，找到第一个比基准值小的元素，与其交换位置；再从最左边查找，查找到第一个比基准值大的元素，与其交换位置。直到从左往右查找的索引等于从右往左查找的索引，结束一次循环，重复以上过程分别比较左右两标的序列，直到整个</strong></p>\n<p><strong>有序为止。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;JAVA代码实现如下：</strong></p>\n<pre class=\"language-java\"><code>public static void quickSort(int[] arr,int low,int high){\n        int base = arr[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //先从右往左查找第一个比基准值小的元素\n            while(R&gt;L&amp;&amp;arr[R]&gt;=base){\n                R--;\n            }\n            if(arr[R]&lt;base){\n             swap(arr,L,R);\n            }\n            //再从左往右查找第一个比基准值大的元素\n            while(R&gt;L&amp;&amp;arr[L]&lt;=base){\n                L++;\n            }\n            if(arr[L]&gt;base){\n                swap(arr,L,R);\n            }\n        }\n        //递归左右序列\n        if(L&gt;low) {\n            quickSort(arr,low,L-1);\n        }\n        if(R&lt;high) {\n            quickSort(arr,R+1,high);\n        }\n    }\n\n    /**\n     * 交换元素\n     * @param arr\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] arr,int i,int j){\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }</code></pre>\n<h2>五，希尔排序（升序为例，以初始dk为length/3+1）</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>概述：希尔排序又称增量排序，是优化的插入排序，即有一个增量dk，根据增量dk将无序序列分为若干个子序列，分别对子序列进行插入排序，每进行完一趟排序，更改增量，直到增量dk为1时，则对整个序列再进行依次插入排序。希尔排序，当增量dk大的时候，因为序列数据较少，排序较快；而当增量dk小的时候，又因为序列</strong></p>\n<p><strong>中的数据已经基本有序了，因而排序也较快。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;JAVA代码实现：为例</strong></p>\n<pre class=\"language-java\"><code>public static void sort(int[] arr){\n\n        int dk = arr.length/3+1;\n        while(dk!=1){\n            shellSort(arr,dk);\n            dk = dk/3+1;\n        }\n        if(dk==1){\n            shellSort(arr,dk);\n        }\n    }\n\n    public static void shellSort(int[] arr,int dk){\n        for (int i = dk; i &lt;arr.length ; i++) {\n            if(arr[i]&lt;arr[i-dk]){\n                swap(arr,i,i-dk);\n            }\n        }\n    }\n\n    /**\n     * 交换元素\n     * @param arr\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] arr,int i,int j){\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }</code></pre>\n<h2><strong>六，归并排序</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：归并排序采用的是典型的分治思想，即先分解，然后再归并。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n     * 先分\n     * @param arr\n     */\n    public static void sortProcess(int[] arr,int L,int R){\n        if(L==R){\n            return;\n        }\n        int mid = (L+R)/2;\n        sortProcess(arr,L,mid);\n        sortProcess(arr,mid+1,R);\n        merge(arr,L,mid,R);\n    }\n\n    /**\n     * 分治中的治\n     * @param arr\n     * @param L\n     * @param mid\n     * @param R\n     */\n    public static void merge(int[] arr,int L,int mid,int R){\n        int[] help = new int[R-L+1];\n        int p1 = L;\n        int p2 = mid+1;\n        int i =0;\n        while(p1&lt;=mid&amp;&amp;p2&lt;=R){\n            help[i++] = arr[p1]&gt;arr[p2]?arr[p2++]:arr[p1++];\n        }\n        while(p1&lt;=mid){\n            help[i++] = arr[p1++];\n        }\n        while(p2&lt;=R){\n            help[i++] = arr[p2++];\n        }\n        //将数组help复制回原数组（注意一定要有这一步，不然无法保证元素比较后的大小顺序性）\n        for (int j = 0; j &lt; help.length; j++) {\n            arr[L+j] = help[j];\n        }\n        System.out.println(Arrays.toString(arr));\n    }</code></pre>\n<h2>七，桶排序算法</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>概述：先找出无序序列中的最大值和最小值，然后根据最大值和最小值计算桶的个数并且初始化桶，然后将每个元素加入到对应的桶中，对每个桶进行排序，再整合桶中的数据即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>JAVA代码如下：</strong></p>\n<pre class=\"language-java\"><code>public static void bucketSort(int[] arr){\n\n        int k = 0;\n        //找出无序序列中的最大值和最小值\n        int max = Integer.MIN_VALUE;\n        int min = Integer.MAX_VALUE;\n        for (int i : arr) {\n            max = Math.max(max,i);\n            min = Math.min(min,i);\n        }\n\n        //根据最大值和最小值确定桶\n        int bucketNum = (max-min)/arr.length+1;\n        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = new ArrayList&lt;&gt;(bucketNum);\n        for (int i = 0; i &lt; bucketNum; i++) {\n            bucketArr.add(new ArrayList&lt;&gt;());\n        }\n\n        //遍历序列中的数据，将其分配进入不同的桶\n        for (int i=0;i&lt;arr.length;i++) {\n            int num = (arr[i]-min)/arr.length;\n            bucketArr.get(num).add(arr[i]);\n        }\n\n        //对每个桶都进行排序\n        for (ArrayList&lt;Integer&gt; bucket : bucketArr) {\n            Collections.sort(bucket);\n        }\n\n        //将桶中的数据按照顺序复制回原数组\n        for (ArrayList&lt;Integer&gt; bucket : bucketArr) {\n            for (Integer integer : bucket) {\n                arr[k++] = integer;\n            }\n        }\n    }</code></pre>\n<h2>八，基数排序（这里以高位优先为例）</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>概述：基数排序是一种优化的桶排序，但是基数排序只能排序整型数据。先要统一数据的位数，位数不够的前面添0，然后按照从低位到高位的位数顺序依据位数上数字的大小进行排序，最终得到一个有序序列。 &nbsp;</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码如下：</strong></p>\n<pre class=\"language-java\"><code>public static void radixSort(int[] arr){\n        //指数\n        int exp = 1;\n\n        //查找数组中的最大值\n        int max= Integer.MIN_VALUE;\n        for (int i : arr) {\n            max = Math.max(max,i);\n        }\n\n        //按照低位到高位的顺序依次排序\n        for (exp=1;(max/exp)&gt;0;exp*=10){\n            int[] temp = new int[arr.length];\n            //初始化桶\n            int[] buckets = new int[10];\n            //统计每个桶中数据的次数\n            for (int i = 0; i &lt; arr.length; i++) {\n                buckets[(arr[i]/exp)%10]++;\n            }\n\n            //更改buckets[i]\n            for (int i = 1; i &lt; buckets.length; i++) {\n                buckets[i]+=buckets[i-1];\n            }\n\n            //将数据存储到临时数组temp中\n            for (int i = 0; i &lt; arr.length; i++) {\n                temp[buckets[(arr[i]/exp)%10]-1] = arr[i];\n                buckets[(arr[i]/exp)%10]--;\n            }\n\n            //将临时数组的数据复制到原数组\n            System.arraycopy(temp,0,arr,0,arr.length);\n        }\n    }</code></pre>\n<h2><strong>九，其它算法（对于最短路径算法和回溯算法后面会单列出来）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;剪枝算法，最短路径算法，回溯算法</strong></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>, blogGoods=null, blogRead=null, blogCollection=null, blogType=11, blogRemark=面试（五）------之算法, blogComment=null, blogSource=null, createdTime=null, updateTime=null, version=null, deleted=null)]","logStatus":1,"logTime":373,"logUrl":"/blog/add"},{"createdTime":"2020-04-15 10:06:10","logId":3133,"logIp":"127.0.0.1","logMethod":"POST","logParams":"[Page(currentPage=1, pageSize=10, totalPage=1, totalCount=10, list=[BlogVo(blogId=1247745014683947008, blogTitle=博客开发总结（一）-----之数据库设计篇, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6NVHmAfuv6AADVlotocVo322.jpg, blogContent=<p><strong>一，数据库设计--表的命名规范等</strong></p>\n<p>（1），统一采用bl_开头对表进行命名</p>\n<p>（2），对于数据比较重要的表统一添加四个字段，分别为：created_time(创建时间),update_time(修改时间),version(版本号),deleted(删除字段)</p>\n<p>（3），数据库表的字段尽量都设置为NOT_NULL</p>\n<p>（4），数据库中表varchar类型字段需要设置长度的尽量设置为2<sup>n</sup>-1</p>\n<p>（5），因为博客系统分为前台展示界面和后台管理，所以对于有些表，例如bl_type（博客类型表），bl_music（音乐表）等设置了enable（启用字段）</p>\n<p><strong>二，上述第二条--四个字段的解释</strong></p>\n<p>（1），为什么要设置created_time和update_time字段：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;其一，从数据库的通用性上来说，设计这两个字段是必要的，但也需要根据业务的需要来合理添加这两个字段，因为无用的字段会浪费空间，性能，影响系统的运行。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 其二，大部分的应用都有需要根据时间进行排序的功能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 其三，当系统发生异常的时候，我们可以通过这两个字段对异常进行排查和定位。</p>\n<p>（2），为什么要设置version字段：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 1，version字段含义：字段的含义与其字面意思一样，代表版本，在这里作为乐观锁进行使用，从而保证不会出现脏数据的情况。下面解释一下什么叫乐观锁，以及乐观锁和悲观锁</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 2，乐观锁：总是假定最好的情况，即每次用户调用接口从数据库中取出数据到修改数据前的过程中，不会有其它用户对当前数据进行修改，这样在当前用户修改数据的时候，利用版本机制即判断取出的version字段和当前数据库该条数据的version字段是否相等来判断该条数据是否已经被修改，如果未修改，则予以修改（且version字段递增），如果已经修改，则提示用户更新失败。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 悲观锁：总是假定最坏的情况，即每次用户调用接口从数据库取出数据的时候，都认为该条数据会被修改，因此每次取出数据都对数据进行加锁处理，只允许当前用户进行修改，其它用户阻塞，直到当前用户修改完毕。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3，为什么使用乐观锁而不使用悲观锁：因为悲观锁比较浪费性能</p>\n<p>（3），为什么设置deleted字段：deleted字段在这里作为一个逻辑删除字段（0否1是），何为逻辑删除，即执行删除操作操作的时候，不会真正的删除数据库中的数据，而是将deleted字段设置为1即可。&nbsp;这样如果用户出现误删的操作，可以通过数据库修改该字段进行数据的恢复。</p>\n<p><strong>三，上述第三条--数据库表字段尽量设置为NOT_NULL</strong></p>\n<p>（1），数据库表字段尽量设置为NOT_NULL：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 1，有些人可能认为设置为NULL相比于NOT_NULL不是更节省空间吗？但是实际上不是这样的，设计为NULL相比于NOT_NULL要多占用一个字节的空间</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 2，设计为NOT_NULL，这样在做查询的时候能够更好的避免空指针异常，且发生该类错误的时候能够更好的进行排查</p>\n<p><strong>四，上述第四条--表varchar类型字段长度尽量设置为2<sup>n</sup>-1</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>因为计算机只识别二进制，且有一定的范围，例如2<sup>8</sup>，在计算机中的范围为-128~127,因此对于varchar字段长度来说，如果设置为255，则正好是一个字节，而如果设置为256，则占用两个字节，这样会浪费计算机的内存空间，因此数据库varchar类型字段的长度最好设置为2<sup>n</sup>-1</p>\n<p><strong>五，上述第五条--对于设置enable字段的解释</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>enable字段，字面意思启用，在这里表明是否启用（0否1是），因为系统分为前台博客页面和后台管理，对于这两个不同的前端项目，后台可以通过启用字段来控制内容在前台博客页面的展示与否，与deleted字段不同的是，如果执行删除操作，那么我们只能通过手动修改数据库中的字段进行数据的恢复，且如果执行删除操作，则该数据在前台博客页面和后台管理页面都无法看见。但是如果将数据弃用（即修改enable字段值为1），则表明该数据被弃用，在前台博客页面无法显示，但是在后台管理页面可以看见，且无需通过手动修改数据库来恢复数据，可以在后台管理页面操作启用数据。</p>\n<p>&nbsp;</p>, blogGoods=0, blogRead=21, blogCollection=0, typeName=博客开发和维护总结, blogRemark=博客开发总结（一）-----之数据库设计篇, blogComment=0, blogSource=null, createdTime=2020-04-08 04:36:07, blogMonth=null, updateTime=2020-04-12 12:57:33), BlogVo(blogId=1247867141693128704, blogTitle=闲谈前后端分离开发, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6NxmWAR3lsAAB7Q44XPGk369.jpg, blogContent=<p><strong>一，前后端分离开发优势</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，</strong>项目开发过程中，前后端完全解耦，前端只需要负责页面的实现，只需要通过接口拿数据。后端不需要管页面的跳转，只需要负责接口的编写</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，</strong>前后端人员有更多的精力去负责自己的工作，前端人员可以将更多的精力投放在页面的编写，页面的美化，页面特效的制作和用户体验上；而后端人员可以将更多的精力放在接口代码的优化，sql优化，jvm调优上面</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，</strong>前后端分离的项目部署的时候，前端项目往往都是部署在nginx服务器上，而前后端不分离的项目往往都是部署再一台服务器上。因此前后端分离项目大大降低了服务器的负担</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>4，</strong>前后端不分离的项目使用模板引擎例如freemaker，thymeleaf等，前后端人员交流起来较为困难。且前端项目使用原生的DOM操作，极大的增加了前端工作人员的工作量。而前后端分离项目前端通常都是用各种ui框架，框架采用MVVM模式，极大的减轻了前端工作人员的工作量</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，</strong>前后端分离开发，前端可以通过easy-mock来伪造接口数据进行测试，后端人员可以通过postman进行接口测试，开发效率大大提升。</p>, blogGoods=0, blogRead=7, blogCollection=0, typeName=随笔, blogRemark=前后端分离开发的优势所在, blogComment=0, blogSource=null, createdTime=2020-04-08 12:41:25, blogMonth=null, updateTime=2020-04-10 13:45:56), BlogVo(blogId=1248135765829918720, blogTitle=CSS----之flex弹性布局, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6OwJOAYOmCAACSMXNdKeQ941.jpg, blogContent=<p><strong>一，css之弹性布局</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，</strong>何为弹性布局？</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 弹性布局是css的一种新的布局方式，所谓&ldquo;弹性布局&rdquo;，即页面随着不同设备的屏幕大小拉伸会自适应页面的大小。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，</strong>弹性布局的两种主要元素，container（弹性容器），item（弹性子元素），一个弹性容器中可以放入多个弹性子元素，元素之间是可以进行嵌套的，弹性子元素也可以设置为弹性容器，里面再嵌套弹性子元素。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，</strong>弹性布局的基本属性</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （1）display：flex，声明容器为弹性布局</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （2）flex-direction：声明弹性容器内部元素的排列方式，默认为row。row（横向布局），row-reverse（横向布局，但是元素反方向码），column（纵向布局），column-reverse（纵向布局，但是元素反着码）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （3）flex-wrap：声明弹性盒子中的元素是否可以换行，默认为nowrap（不换行），wrap（换行），wrap-reverse（换行，但是反着码）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （4）align-items：设置容器中元素在纵轴方向上的对齐方式，默认为stretch（即如果不设置子元素高度，则默认拉伸至于容器同宽度），flex-start（子元素位于容器的开始位置），flex-end（子元素位于容器的结尾处），center（元素依纵轴方向居中），baseline（元素位于容器基线，不过没怎么用过，所以不是很清楚）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （5）justify-content（设置元素在主轴上的对齐方式），默认为flex-start（元素从容器主轴开始位置码），flex-end（元素从容器主轴结尾处码），center（元素位于主轴居中处），space-between（元素布局在容器的两端），space-around（元素布局在容器两端，但是元素前后都留有空白）因为项目中大多数只使用了对于容器的操作，对于容器中元素的操作很少，所以这里只介绍这点。谢谢阅读！</p>, blogGoods=0, blogRead=2, blogCollection=0, typeName=CSS, blogRemark=CSS----之flex弹性布局, blogComment=0, blogSource=null, createdTime=2020-04-09 06:28:51, blogMonth=null, updateTime=2020-04-10 13:46:01), BlogVo(blogId=1248224512563068928, blogTitle=面试（一）------之JVM篇, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6PEz6AUs0lAAB4ISeFCt8304.jpg, blogContent=<p style=\"text-align: left;\"><strong>一，JVM运行机制</strong></p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;jvm即java虚拟机，一共由四个部分组成，分别是类加载器子系统，运行时数据区（程序计数器，本地方法区，jvm栈，方法区，jvm堆），执行引擎（即时编译器，垃圾收集器），本地接口库。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;一个java源程序的运行先是经过编译器将其编译成字节码文件（class文件），然后通过类加载器子系统将其加载进入jvm&mdash;&mdash;&gt;程序运行过程中，运行时数据区存放程序运行过程产生的数据&mdash;&mdash;&gt;执行引擎中的垃圾收集器收集程序运行过程中创建的不再使用的对象，即时编译器将程序的字节码文件编译成机器码&mdash;&mdash;&gt;然后本地接口库利用机器码调用本地方法库中的方法，和操作系统实现交互。</p>\n<pre><strong>二，多线程</strong></pre>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;</strong>在多核操作系统中，jvm支持一个进程中同时并发执行多个线程，且这些线程和本地操作系统的线程相对应。当jvm中的对象初始化，内存空间分配等一系列准备工作完成之后，会调用操作系统中的接口创建一个原生线程，原生线程初始化完毕后，会调用java线程的run（）方法执行该线程，线程结束之后，jvm会释放原生线程和java线程资源。</p>\n<p><strong>三，JVM的内存区域</strong></p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM的内存区域主要分为线程私有区域（程序计数器，本地方法区，JVM栈），线程共享区（方法区，JVM堆）和直接内存。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;程序计数器：线程私有区域，无内存溢出，用来记录程序运行过程中的字节码指令地址，如果是Native方法，则程序计数器为空。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM栈：线程私有区域，用来描述java程序的运行过程，java程序运行每次运行的时候，都会创建一个栈帧，方法的执行和返回对应着栈帧的入栈和出栈操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;本地方法区：线程私有区域，和JVM栈的功能一样，只不过是用来记录Native方法的运行过程。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM堆：线程共享区，主要用来存放程序运行过程中产生的数据，同时也是垃圾收集器进行垃圾回收的主要区域。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;方法区：也被称为永久代，用来存放常量，静态变量，类信息等等。</p>\n<p><strong>四，JVM的运行时内存</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>JVM的运行时内存又被称为JVM堆，因为JVM的GC算法使用的是分代收集算法，所以JVM堆按照GC标准可以分为三个区域分别为：新生代，老年代，永久代。其中新生代占1/3，老年代占2/3，永久代很少，</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;新生代：存放短生命周期，小对象的区域。新生代又分为Eden区，ServivorTo区，ServivorFrom区，区域的GC算法采用复制算法。Eden区是用来存放新创建的对象（大对象除外），ServivorTo区是用来保存MinorGC幸存下来的对象，ServivorFrom区是用来将上一次MinorGC幸存下来的对象作为下一次MinorGC的扫描对象。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;老年代：存放长生命周期的大对象，区域的GC算法采用标记整理算法</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;永久代：主要用来存放class和meta数据信息的。程序运行过程中不会进行永久代的垃圾回收，这也就导致永久代区域的数据会越来越多，最终造成内存溢出。java8之后永久代已经被元数据区取代，元数据区和永久代的功能都是一样的，但是最大的不同在于永久代区域依赖于虚拟机的内存大小，因而可以存储的class，meta信息非常有限。但是元数据区依赖的是本地操作系统，因而不会受到虚拟机内存的限制。</p>\n<p><strong>五，垃圾回收与算法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;(1)垃圾回收：</strong>Jvm的垃圾回收判定依赖于两种方法，引用计数法和可达性分析法。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;引用计数法：即如果想要在程序中使用对象，就必须赋予一个引用，这样在对象赋予引用的时候将其引用计数加1，删除一个引用时，将对象引用计数减1，如果引用计数为0，就说明该对象已经不使用，作为垃圾。但是引用计数法存在一个缺陷，即循环引用的问题，如果两个对象相互引用，则这两个对象的引用计数永远都不会为0，造成对象无法被回收。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;可达性分析法：即先创建一些根节点对象ROOTS，然后通过这些根节点对象向下搜索，如果一个对象到任意一个ROOTS之间都没有可达路径，在经过两次标记（下文解释为什么进行两次标记），还是没有可达路径，则说明该对象可回收。</p>\n<p>&nbsp;&nbsp; &nbsp;<strong>（2）GC算法：</strong>常见的GC算法有四种，分别为标记清除算法，复制算法，标记整理算法，分代收集算法</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;标记清除算法：即在进行垃圾回收前，对所有对象进行一次标记，标记可回收的对象，然后进行清理即可。但是标记清除算法在清除回收对象之后，并不会对堆内存进行整理，这样的话如果内存中的对象大部分为小对象，清理之后就会导致没有大片连续的内存空间，即造成了内存碎片化，这样大对象存储的时候就无法找到相应的完整连续内存。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;复制算法：即将内存分为两块同等大小的区域，区域1和区域2，创建的新对象都存储在区域1中，当区域1中的内存占满之后，会对内存中的所有对象进行一次标记，标记存活的对象，将存活的对象复制到区域2，这时区域1中的对象都是可回收对象，回收区域1中的所有对象即可。但是复制算法也存在着一定的缺陷，即每次都只能使用一半的内存空间，造成了大量的内存浪费。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;标记整理算法：即结合标记清除算法和复制算法的优点，先对所有的对象进行标记，标记存活的对象，将存活的对象复制到内存的另一端，然后清除当前端的对象即可。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;分代收集算法：前面的三种算法，都无法按照对象的类型进行收集，分代收集算法正是解决这个问题，按照对象的不同类型采用不同的GC算法。以JVM的分代收集算法为例，JVM的堆内存分为新生代，老年代，永久代。新生代又分为Eden区，ServivorTo区和ServivorFrom区。新生代因为其存储生</p>\n<p>命周期短的小对象，GC比较频繁，所以采用复制算法。程序运行过程中创建的对象都存储在Eden区（大对象除外，大对象直接复制到老年代区域）。当Eden区的内存不够的时候进行MinorGC，然后将Eden区和ServivorFrom区的存活对象都复制到ServivorTo区，然后将ServivorTo区和ServivorFrom</p>\n<p>区进行交换，再次进行MinorGC。老年代因为存放的都是生命周期长的大对象，因而进行GC的不会太频繁，且清除的对象并不会太多，因而采用标记整理算法。老年代每次进行MajorGC之前都会先进行一次MinorGC，当MinorGC之后新生代的内存仍然不够的时候，将对象复制到老年代进行MajorGC。</p>\n<p>永久代区域主要回收常量，无用class等。</p>\n<p><strong>六，JAVA中的四种引用类型</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;强引用类型<strong>：</strong>即把对象赋给一个引用变量，强引用的对象一定为可达状态，所以不会进行垃圾回收。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;软引用类型：通过SoftReference类实现，当内存不够的时候对其进行GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;弱引用类型：只有弱引用类型的对象，一定会被GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;虚引用类型：虚引用对象主要是用来跟踪对象的GC状态</p>\n<p><strong>七，分代收集算法和分区收集算法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>分代收集算法：新生代因其存放大量短生命周期小对象，且GC频繁，所以采用复制算法。老年代因其存放长生命周期大对象，且GC不平凡，所以采用标记整理算法。永久代，回收常量，类信息等。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;分区收集算法：即将堆内存区域分为大小不同的区，可以按照不同的区进行快速垃圾回收，减少系统的停顿时间。然后再以并行的方式逐步完成整个GC。</p>\n<p><strong>八，垃圾收集器</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>新生代区域：Serial垃圾收集器，单线程复制算法，因为单线程无需进行线程之间的交互和切换，所以效率非常高，是JVM默认的client模式下的默认垃圾回收策略，工作期间需要暂停其它所有的线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ParNew垃圾收集器，多线程复制算法，跟单线程Serial一样，是JVM默认的server模式下的垃圾回收策略，工作期间需要暂停所有其它线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Parallel Scavenge垃圾收集器：多线程复制算法，不同的是优先考虑系统吞吐量，可以利用更高效的利用CPU完成GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;老年代区域：Serial Old垃圾收集器，单线程标记整理算法，同新生代的Serial功能一样，只是采取的算法不同而已。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Parallel Old垃圾收集器：多线程标记整理算法，优先考虑了系统的吞吐量，其次考虑停顿时间。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CMS,多线程标记清除算法，优先考虑系统GC时的停顿时间，且过程分为四步（<span style=\"background-color: #ffff00;\">解释上文的可达性分析中的两次标记</span>，第一步：标记GC ROOTS可达对象，暂停其它工作线程；第二步：和用户线程一起工作，跟踪GC ROOTS；第三步，因为第二步用户进程没有暂停，所以有些对象状态</p>\n<p>可能发生了改变，重新进行标记；第四步，清除不可达对象）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; G1垃圾收集器，多线程标记整理算法，将内存分区，与CMS相比，一方面不会产生内存碎片，一方面，可以精确的控制系统停顿时间。</p>\n<p><strong>九，JAVA的网络编程模型</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;</strong>阻塞I/O模型：即用户线程发出I/O请求之后，内核会检查数据是否准备就绪，这时候用户线程始终处于阻塞状态等待数据准备就绪。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;非阻塞I/O模型：即用户线程不断的给内核发出I/O请求，内核接受到I/O请求之后会返回一个状态，如果数据准备就绪，就将数据复制进入用户线程，如果数据没有准备好，返回一个false，用户线程无需阻塞，可以去处理其它事情，而当数据准备好了且刚好用户线程发起I/O请求进行操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;多路复用I/O模型：多路复用I/O模型通过一个Selector线程轮询Socket的状态，如果Socket有读写事件，则进行I/O操作。此模型的优势在于可以更好的处理连接数众多但消息体不大的情况下。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;信号驱动I/O模型：即用户线程发出一个I/O请求，系统会为该请求创建一个信号函数，用户请求可继续执行其它业务逻辑，当内核数据准备就绪之后会返回给用户线程一个信号，用户线程接收到之后进行I/O操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;异步I/O模型：用户线程给内核发起一个asynchronous read操作，内核接收到之后，返回其请求是否成功，然后等待数据准备成功之后复制到用户线程。整个过程中请求的发起和数据读取都在内核中进行，最终发送一个信号告知用户线程I/O操作已经完成，用户直接使用数据就行。（说实话个人感</p>\n<p>觉和信号驱动很像）</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;java NIO：没怎么读懂（<span style=\"background-color: #993300;\">记得补充！</span>）</p>\n<p><strong>十，JVM的类加载机制</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>JVM类加载分为五个阶段：加载，验证，准备，解析，初始化</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;加载：即将class文件加载到JVM中，且创建class对象，封装其数据结构。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;验证：对class文件进行验证，确保符合JVM的标准，保证JVM的安全。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;准备：即方法区中给类变量分配空间和赋初值。static修改的会在初始化阶段赋值，final修饰的会在准备阶段赋值。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;解析：即将常量池中的引用替换为直接引用</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;初始化：执行类构造器进行初始化。（因为内部流程不是很清楚，所以对于其几种不进行初始化的情况不做说明）</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;类加载器：JVM提供了三种类加载器，启动类加载器（/lib），扩展类加载器(/lib/ext)，应用程序类加载器(classpath)。还可以再应用程序类加载器自定义类加载器。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;双亲委派机制：即当一个类接收到类加载请求的时候，不会自己进行加载，而是将其加载请求委派给其父类加载器，这样一路委派，最终加载请求都会委派到启动类加载器.启动类加载器接收到加载请求之后会去lib目录下寻找相关的class文件，若找不到，则将其加载请求再委培给子类加载器，一路委</p>\n<p>派，直到能够加载。</p>\n<p>&nbsp;</p>\n<h2>水平有限，若发现有误，还望指出！</h2>, blogGoods=0, blogRead=7, blogCollection=0, typeName=java面试篇, blogRemark=面试（一）------之JVM篇, blogComment=0, blogSource=null, createdTime=2020-04-09 12:21:30, blogMonth=null, updateTime=2020-04-12 12:45:18), BlogVo(blogId=1248500061625745408, blogTitle=Linux基本命令, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6QE92AaLPoAADG_98SpI0054.jpg, blogContent=<p><strong>一，Linux的发展历史</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; </strong>1965年之前，电脑并不像现在这么普遍，除了军事机构和研究即构，一般人基本接触不到电脑，而且那时候的一台大型主机最多也就只能支持30台终端。为了解决数量问题，1965年之后，由贝尔实验室，麻省理工学院以及通用电气一起放弃了Multics项目，准备让大型主机能够支持300台终端，但是在开发过程中，进度缓慢，最终由于资金的短缺，贝尔实验室推出了研究。1969年，从这个项目中退出的Ken Thompson在家无聊，为了让电脑能够运行&ldquo;星际旅行&rdquo;游戏，因而趁着妻子回家探亲的一个月，独自写出了Unix操作系统的原型（！！！！牛批）。1970年，这个人以BCPL语言为基础，又写出了很接近硬件的B语言，并且用B语言写出了第一个Unix操作系统。但是由于B语言的跨平台性比较差，为了解决这个问题。Dennis Ritchie和Ken Thompson决定以B语言为基础开发一种新的语言，1972年，Dennis Ritchie最终设计出了一种新语言，他以BCPL的第二个字母命名，也就是我们后来熟知的C语言。随后两人便迫不及待的用C语言重现Unix操作系统。Unix系统起初开源，但是在Unix7之后，由于政策的变化，代码闭源化，因而大学中不能使用Unix的源代码进行教学。Andrew S. Tanenbaum教授为了能够让学生更好的理解代码细节，在完全不使用任何源代码的情况下开发除了Minix---小型Unix。但是因为其只用于教学，功能并不强大，因而Torvalds以此为基础，开发除了Linux，但是起初Linux并不支持Unix，最终经过全世界网友的帮助，最终让其能够兼容各种硬件。</p>\n<p><strong>二，文件和目录</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; 1，windows和linux的区别：</strong>我们熟知的windows系统，它的文件系统是分盘符的，盘符下的文件构成一个树形结构，但是Linux文件系统没有盘符，所有文件目录都在根目录/之下</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;<strong>2，Linux需要记住的目录：</strong>/bin（存放系统命令的目录），/sbin（只有超级管理员能访问的命令文件目录），/root（存放和root用户相关文件的目录），/etc（存放系统配置文件的目录），/usr（存放系统共享资源的目录），/opt（存放安装的第三方软件的目录，通常在/usr/local下）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;<strong>3，文件权限：</strong>Linux中的文件权限有读（r，可用于数字4表示），写操作（w，可用数字2表示），执行权限（x，可用数字1表示）</p>\n<p><strong>三，常用命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，ls：</strong>列出目录中的所有目录和文件名&nbsp; -a（列出所有，包括隐藏文件和目录），-l（以列表形式列出所有），-h（人性化列出，需要配合-l使用，即文件大小转换为我们熟知的kb，mb等），-d（显示当前目录属性），命令可以联合使用，例如-al，-lh等等。&nbsp;&nbsp;&nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，cd：</strong>用于切换目录，需知（.和..是相对路径，.表示当前目录，..表示上级目录；/表示绝对路径），cd ~（切换到root目录），cd - （切换到前一次切换的目录）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，clear：</strong>清屏</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，pwd：</strong>显示当前所在目录</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，mkdir：</strong>创建目录，-p（如果目录存在则不创建，如果不存在则创建目录再创建自目录），可以一次性创建多级目录，例如：mkdir&nbsp; -p test/test1</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，touch：</strong>创建空文件</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>7，cp：</strong>复制，-r（递归复制目录下的文件目录信息），-i(提示是否覆盖)，-v（显示复制进度）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>8，mv：</strong>移动文件，不过经常用来给文件进行重命名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>9，rm：</strong>删除目录或者文件，-r（递归删除），-f（强制删除），-v（显示删除进度）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>10，cat：</strong>查看文件内部信息</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>11，ln：</strong>文件创建链接，ln 源文件 目标链接文件（创建硬链接，硬链接和源文件大小相同，修改同步，但是删除不同步，使用较少），ln -s（创建软连接，相当于我们平时创建快捷方式，使用较多）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>12，which：</strong>搜索命令所在位置，例如：which&nbsp; &nbsp;ls</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>13，find：</strong>搜索文件所在位置&nbsp; 例如：find&nbsp; &nbsp;test.conf</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>14，grep：</strong>文件内容搜索，例如：grep &ldquo;想要搜索的内容&rdquo;&nbsp; 源文件</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>15，tar：</strong>归档命令，-c（打包成.tar文件），-z（打包的同时压缩），-v（打包的同时显示进度），-f（放在最后，后面跟.tar.gz），-x(解压)，常用：tar -zcvf&nbsp; <em><strong>.tar.gz&nbsp; &nbsp; ;&nbsp; &nbsp; tar -zxvf</strong> tar.gz</em> -C&nbsp; 指定解压目录&nbsp;&nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;还有more，head，tail等命令，不过这些不常用。</p>\n<p><strong>四，用户权限命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，whoami：</strong>查看当前账户的用户名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，who：</strong>查看当前登录用户</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，exit：</strong>退出登录</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，adduser/useradd：</strong>添加用户，-d（指定用户主目录），-g（指定用户用户组），-m（自动建立目录），默认情况下用户主目录和用户组名都和用户名一样</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，passwd：</strong>只有root用户才能使用，用于修改用户密码</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，userdel：</strong>删除用户，默认不删除用户的主目录，-r（删除用户主目录）</p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;7，su：</strong>切换账户</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>8，groupadd/groupdel：</strong>添加用户组和删除用户组</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>9，groups：</strong>查看用户所在用户组，例如：groups&nbsp; 用户名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>10，usermod：</strong>修改用户所在用户组，例如：usermod&nbsp; 用户组名 用户名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>11，chmod：</strong>修改文件权限，例如：chmod&nbsp; 777&nbsp; test</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>12，chown：</strong>修改文件所有者，例如：chown&nbsp; &nbsp;用户&nbsp; 文件名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>13，chgrp：</strong>修改文件所在组，例如：chgrp&nbsp; 组名&nbsp; 文件名</p>\n<p><strong>五，系统命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，cal：</strong>查看日历</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，date：</strong>查看时间，可以设置格式，例如：date '+<span class=\"ql-token hljs-built_in\">%Y</span>-<span class=\"ql-token hljs-built_in\">%m</span>-<span class=\"ql-token hljs-built_in\">%d</span> <span class=\"ql-token hljs-built_in\">%H</span>:<span class=\"ql-token hljs-built_in\">%M</span>:<span class=\"ql-token hljs-built_in\">%S</span>'</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，ps：</strong>查看线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，kill：</strong>杀死线程，-9（强制杀死）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，查看网卡信息：</strong>centos6：ifconfig ；centos7：ip addr</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，ping：</strong>查看网址或者链接的连通性</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>7，防火墙：</strong>centos6：service&nbsp; iptables&nbsp; status（查看防火墙状态），service&nbsp; &nbsp;iptables&nbsp; &nbsp;start(开启),service&nbsp; iptables&nbsp; stop(关闭);centos7:firewall-cmd&nbsp; --state（查看防火墙状态），systemctl&nbsp; start&nbsp; firewalld.service(启动)，systemctl&nbsp; &nbsp;stop&nbsp; firewalld.service（关闭）</p>\n<p><strong>六，网络命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，wget：</strong>下载，例如：wget&nbsp; &nbsp;链接地址</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，yum：</strong>下载安装</p>\n<p><strong>七，vim（这里只说几个常用的命令）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;</strong>vim有三种模式：命令模式，插入模式，编辑模式&nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;vim&nbsp; 文件名：进入文件，且处于命令模式；iao任意一键进入插入模式（i表示在贯标之前插入，a光标之后插入，o在下一行插入），：进入编辑模式</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;命令：set:nu显示行号，set:nonu不显示行号；/strinng，向后搜索字符串，？string向后搜索字符串；：w保存，：wq保存并退出，：q不保存退出</p>, blogGoods=0, blogRead=1, blogCollection=0, typeName=Linux, blogRemark=Linux基本命令总结, blogComment=0, blogSource=null, createdTime=2020-04-10 06:36:25, blogMonth=null, updateTime=2020-04-10 06:36:52), BlogVo(blogId=1248605157059497984, blogTitle=面试（二）------之JAVA基础篇, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6QdaWAWQpnAAD6cIgEnVw521.png, blogContent=<p><strong>一，集合</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，List：</strong>list是java中一种有序的集合，下有三个实现类，分别为ArrayList，Vector，LinkedList</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ArrayList：基于数组实现，增删慢，查询快，线程不安全。因为其基于数组实现，所以查询的时候可以直接根据数组的索引下标进行快速查询，但是进行增删操作的时候，需要将待增删元素后的元素全部移动，因而效率较低。且ArrayList创建时不需要分配初始大小，其空间不够的时候，会自动创建一个更大的list，然后复制数据。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Vector：基于数组实现，和ArrayList一样增删慢，查询快。但是线程安全，因为同一时间只支持一个线程对Vector进行写操作，然而因为要进行频繁的加锁和释放锁的操作，所以效率要低于ArrayList。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; LinkedList：基于双向链表实现，增删快，查询慢。因为基于链表实现，增删元素的时候，只需要改变元素的指针即可，改动较小，效率较高。然而进行查询操作的时候，需要从链表头部进行遍历，因而效率较低。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，Queue：</strong>队列，满足先进先出，种类较多。（不作详细解释）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，set：</strong>具有独一无二的特性，常用来存储无序且不重复的元素，对象相等的本质是hashcode的值相同，而如果想要比较两个对象是否相等，需要重写对象的hashcode方法和equals方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;hashset：基于hashTable实现，无序。存放的是对象的散列值，即通过hashcode计算得到的值</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;treeset：基于二叉树实现，即其中的对象按照一定的排序方式进行排列（升序，降序），每次添加对象的时候，都会进行排序，将其插入指定位置。基本的数据类型例如Integer，String等可以使用treeset默认的排序方法，而自定义数据类型需要实现compareable接口，实现compareTo方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;LinkHashSet：继承自hashset，只不过使用双向链表记录数据的顺序。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，map：</strong>一种键值对形式的集合</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;hashmap：基于数组+链表实现，增删改查操作快，但是每次遍历hashmap元素的顺序无法保证且线程不安全。如果想要其线程安全，可以使用synchronizedMap和ConcurrentHashmap，hashmap的内部是数组，数组中的每一个元素又是一个单向链表，链表中的每个元素嵌套一个Entry实例，其中包括Key，Value，Hash值，指向下一个节点的next。每次查询的时候，可以根据元素的hash值很快定位所在数组，但是定位之后需要遍历链表查找元素，因而时间复杂度为O（n），但是Java8之后对其进行了优化，将其改为了数组+链表或红黑树的结构，即当链表中的元素大于8个的时候，链表会转换为红黑树（红黑树是一种特化的二叉平衡树，因为其左右子树的深度差可以大于1），这样查询的时间复杂度就缩短到了O（logN）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ConcurrentHashmap：采用分段锁的思想进行并发操作，因而使线程安全的。由多个Segment组成，只要保证每个Segment线程安全就可以保证全局线程安全。ConcurrentHashmap的默认Segment即并发度为16，可以在初始化的时候修改，但是初始化之后不能再修改。每个Segment内部的实现和hashmap一样&middot;。Java8之后也和hashmap进行了一样的优化。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;HashTable：线程安全，即同一时刻只能有一个线程对其进行操作，并发度不如ConcurrentHashmap。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;TreeMap：基于二叉树数据结构实现，实现了SortedMap，默认按照键值的升序进行排列。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;LinkedHashMap：Hashmap的子类，只不过使用链表保存元素的插入顺序。使用迭代器遍历的时候按照插入顺序遍历。</p>\n<p><strong>二，异常分类及处理</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;1，异常分类：</strong>Throwable是所有异常类的父类，其下有error和Exception，Error下有AwtError，ThreadDeath；Exception下有RuntimeException和CheckedException。</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</strong>对于Error类异常通常是由内部错误和资源耗尽造成的，无法在程序运行期间对其进行捕获和处理，对于这类错误我们只能记录错误的原因和终止程序。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; Exception中的RuntimeException异常（运行时异常）：这类异常是我们程序中异常处理的核心，可以在程序中进行捕获并处理。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Exception中的CheckedException异常（检查异常）：这类异常时程序中需要强制捕获的异常，通常有IO异常，SQL异常等等。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，异常处理：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>异常处理有两种方式：抛出异常和捕获异常</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;抛出异常有三种方法：throws，throw，系统自动抛出。其中throws是作用在方法上，后面跟的是可能产生的异常类。throw是作用在方法内部，后面跟的是具体的异常对象。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 捕获异常：即使用try{}catch语句进行捕获</p>\n<p><strong>三，反射机制</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，什么叫做反射机制？</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>即在程序运行的过程中，可以获取类的属性和方法，并且可以调用任意一个类的方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，反射机制的使用</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 首先，获取类的class对象，有三种方式，className.getClass()，类对象.class，Class.forName(\"类路径\")，其中最后一种最为安全，性能最好。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 然后利用反射的API可以实现对类中信息的操作，例如getDeclareFields（），getDeclareMethods（），getConstroctors（）等等。反射创建类的对像有两种方法，一，class.newInstance()初始化一个类实例；二，先获取其构造器，然后利用构造器初始化一个实例。利用反射调用类的方法：先获取方法，然后调用method.invoke()执行方法。</p>\n<p><strong>四，注解</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，四种元注解：</strong>@Target（指定注解的使用范围），@Retention（定义注解的保留级别，有三级，SOURCE源程序中保存，CLASS文件中保存，RUNTIME运行时保存），@Documented（可以工具文档化），@Inherited（<span style=\"background-color: #ffff00;\">这个没怎么看懂</span>）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，注解使用示例：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>第一步，定义注解接口</p>\n<pre class=\"language-java\"><code>@Target(ElementType.FIELD)  \n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface FruitProvider {\n\n    //id\n    public int id() default  -1;\n\n    //供应商名称\n    public String name() default \"\";\n\n    //供应商地址\n    public String address() default \"\";\n\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 第二步，使用注解</p>\n<pre class=\"language-java\"><code>public class Apple {\n\n    @FruitProvider(id = 1,name = \"红富士苹果\",address = \"陕西\")\n    private String appleProvider;\n\n    public String getAppleProvider() {\n        return appleProvider;\n    }\n\n    public void setAppleProvider(String appleProvider) {\n        this.appleProvider = appleProvider;\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第三步，定义注解处理器</p>\n<pre class=\"language-java\"><code>public class FruitInfoUtil {\n    public static void getFruitInfo(Class&lt;?&gt; clazz) {\n        String strFruitProvider = \"供应商信息:\";\n        Field[] declaredFields = clazz.getDeclaredFields();\n        for (int i = 0; i &lt; declaredFields.length; i++) {\n            if (declaredFields[i].isAnnotationPresent(FruitProvider.class)) {\n                FruitProvider annotation = declaredFields[i].getAnnotation(FruitProvider.class);\n                strFruitProvider += annotation.id() + \",\" + annotation.name() + \",\" + annotation.address();\n                System.out.println(strFruitProvider);\n            }\n        }\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第四步，主方法入口</p>\n<pre class=\"language-java\"><code>public class FruitRun {\n    public static void main(String[] args) {\n        FruitInfoUtil.getFruitInfo(Apple.class);\n    }\n}</code></pre>\n<p><strong>五，内部类</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 1，静态内部类：</strong>即在类的内部定义的静态类，静态内部类可以访问外部了的静态变量和方法，外部也可以通过outClassName.innerClassName调用内部类</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2，成员内部类：</strong>在类的内部定义的没有用static修饰的内部类，使用方式和静态内部类一样。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>3，成员内部类：</strong>即一个类只在一个方法中使用，则完全可以将这个类定义为这个方法的内部类，即局部内部类，局部内部类可以实现真正的对外隐藏</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>4，匿名内部类：</strong>通常用于继承一个类或者实现一个接口的时候，使用new关键字定义，例如:Person person = new Student(){new Pupil(){}}</p>\n<p><strong>六，泛型</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 1，为什么要使用泛型：</strong>其根本目的是为了实现代码的复用，举个开发中常见的例子，我们需要定义返回类Result，返回类中包含状态码code，信息msg，以及数据data（任意类型），这个时候我们就需要使用泛型，因为我们返回的数据类型有各种vo，pojo类对象，list等。这时候泛型类result就可以被各种对象使用，实现代码的复用，简化开发。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>2，泛型标记和泛型限定：</strong>E表示集合中的元素，K表示键值，V表示value，N表示数值类型，T表示任意类型（包含基础类型，所有的对象类型），？（不确定的java类型）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>泛型限定：</strong>向上限定，&lt;?&nbsp; extends T&gt;，向下限定，&lt;? super&nbsp; T&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; <strong>3，泛型方法：</strong>即参数类型定义为泛型类型，以便于接收不同类型的参数，做出不同的处理。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>4，泛型类：</strong>例如public class Pair&lt;T&gt;{private T data;}</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>5，泛型接口：</strong>与放泛型类类似</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>6，类型擦除：</strong>即在泛型编译的过程中，会将泛型类型替换为限定类型的操作</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>7，明确的一点：</strong>虚拟机在运行程序的过程中，内部是没有泛型的，只有普通的类和方法。</p>\n<p><strong>7，序列化：</strong>序列化是为了确保对象及其状态的持久化</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>序列化的使用：</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </strong>首先，实现序列化接口java.io.Serializble</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 然后，声明序列化ID，通常private static final&nbsp; long&nbsp; serialVersionUid&nbsp; = ***</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 因为序列化是保证对象及其状态的持久化，而静态变量是不属于对象，属于类本身的，所以序列化无法保存静态变量。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果需要序列化父类变量，则父类也要实现Serializable接口</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t'ransient修饰的属性不会序列化</p>\n<p>&nbsp;</p>\n<h2>水平有限，如有错误，还望指出！</h2>, blogGoods=0, blogRead=17, blogCollection=0, typeName=java面试篇, blogRemark=面试（二）------之JAVA基础篇, blogComment=0, blogSource=null, createdTime=2020-04-10 13:34:02, blogMonth=null, updateTime=2020-04-12 09:07:59), BlogVo(blogId=1249313090567143424, blogTitle=面试（三）------之并发编程篇（上）, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6TCO-AEYrKAACh3H-d2Gc645.jpg, blogContent=<h2><strong>一，JAVA线程的创建方式</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>JAVA线程的创建有四种方式，分别为，继承Thread类，实现Runable接口，实现Callable&lt;Class&gt;接口，基于线程池。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>1，继承Thread方式：创建一个类继承Thread类，创建类的实例对象，调用start方法，继而执行线程的run（）方法，代码如下：</strong></p>\n<pre class=\"language-java\"><code>public class NewThread extends Thread{\n    public static void main(String[] args) {\n        NewThread thread = new NewThread();\n        thread.start();\n    }\n    @Override\n    public void run(){\n        System.out.println(\"create  a  new thread by Thread!\");\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>2，当子类已经继承了一个类，这时候就没法再继承Thread类了，这时候就可以实现Runable接口，实例化类的线程实例，创建Thread实例传入类的实例，执行start方法，继而执行run（）方法代码如下：</strong></p>\n<p>&nbsp;</p>\n<pre class=\"language-java\"><code>public class ThreadExample2 implements Runnable {\n    public static void main(String[] args) {\n        ThreadExample2 threadExample2 = new ThreadExample2();\n        Thread thread = new Thread(threadExample2);\n        thread.start();\n    }\n    @Override\n    public void run() {\n        System.out.println(\"create a new thread by Runnable!\");\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，有些情况下，我们需要再一个主线程中并发多个子线程执行同一个任务，然后回收子线程的返回值整理汇总，这时候就需要实现Callable&lt;Class&gt;接口，重写其call（）方法，用于计算结果。然床创建一个线程池用于提交线程，继而执行call方法，并且创建一个Future的list用于接收子线程逻辑代码即call方法的返回，最终遍历list，得到想要的返回值，如下：</strong></p>\n<pre class=\"language-java\"><code>public class ThreadExample3 implements Callable&lt;String&gt; {\n\n    private String name;\n\n    public ThreadExample3(String name){\n        this.name = name;\n    }\n\n    @Override\n    public String call() throws Exception {\n        return name;\n    }\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        ExecutorService pool = Executors.newFixedThreadPool(3);\n        List&lt;Future&gt; list = new ArrayList&lt;&gt;();\n        for(int i=0;i&lt;3;i++){\n            ThreadExample3 threadExample3 = new ThreadExample3(i+\"\");\n            Future future =pool.submit(threadExample3);\n            System.out.println(future.get().toString()+\" is running\");\n            list.add(future);\n        }\n        pool.shutdown();\n        for (Future future : list) {\n            System.out.println(\"currentThread's result is \"+future.get().toString());\n        }\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，基于线程池创建线程</strong></p>\n<pre class=\"language-java\"><code>public class ThreadExample4 {\n    public static void main(String[] args){\n        ExecutorService pool = Executors.newFixedThreadPool(3);\n        for(int i=0;i&lt;3;i++){\n            pool.execute(new Runnable() {\n                @Override\n                public void run() {\n                    System.out.println(\"thread  is running by FixedThreadPool\");\n                }\n            });\n        }\n        pool.shutdown();\n    }\n}</code></pre>\n<h2>二，线程池的工作原理</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong> &nbsp;1，概述：</strong>JVM根据用户提供的参数创建一定数量的线程任务，将其放入队列中，线程创建之后启动这些任务，如果线程的数量大于核心线程数量（用户设置的线程数量），则超出数量的线程排在队列中等待，当有线程任务执行完毕后，线程池调度器就会发现有可用可用线程，继而从队列中取出任务继续执行<strong>。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; </strong><strong>2，线程复用：</strong>（参见JDK源码解读，这里只做简单描述），由前可知，JVM会根据用户提供的参数创建一定数量的线程任务，且将其添加到任务队列中。JVM通过start（）方法创建一个线程之后， 会相应的为其创建一个任务队列，线程会不停的查看任务队列，如果任务队列中有任务，则调用run方法，执行，这样就达到了一次start（）创建线程，多次使用，完成线程复用的任务。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>3，线程池的核心组件和核心类（见JDK源码分类中关于线程的总结）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; </strong><strong>4，JAVA线程的工作流程：</strong>线程池刚被创建的时候，只是向系统申请一个执行线程队列和管理线程池的线程资源，当调用execute方法之后，执行下列流程：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果正在运行的线程数量小于corePoolSize（核心线程数量，即用户定义的的线程数量），则立即创建线程执行线程任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果正在运行的线程数量大于或等于corePoolSize，则将超过数量的线程加入到阻塞队列中</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在阻塞队列已满且线程数量小于MaximumPoolSize（即线程池能够容纳的最大线程数），线程池会创建非核心线程立即执行任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在阻塞队列已满且线程数量大于或等于MaximumPoolSize的时候，线程池会拒绝该线程任务且抛出异常</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在线程任务执行完毕之后，会将其从任务队列中移除，从队列中取出下一个线程任务执行</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在线程处于空闲状态且空闲时间超过KeepAliveTime，且线程数量大于corePoolSize的时候，会停止该线程，这样在没有任务的时候，线程池中的线程数始终维持在corePoolSize。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，线程池的拒绝策略：</strong>分为四种，分别为AbortPolicy，CallerRunsPolicy，DiscardOldestPolicy，DiscardPolicy</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; AbortPolicy：直接抛出异常，阻止线程运行，源码如下：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</p>\n<pre class=\"language-java\"><code>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n            throw new RejectedExecutionException(\"Task \" + r.toString() +\n                                                 \" rejected from \" +\n                                                 e.toString());\n        }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CallerRunsPolicy：如果线程任务没有关闭，则尝试执行该线程任务，源码如下：</p>\n<pre class=\"language-java\"><code>* @param r the runnable task requested to be executed\n* @param e the executor attempting to execute this task\n*/\npublic void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n     if (!e.isShutdown()) {\n         r.run()\n     }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DiscardOldestPolicy：移除任务队列中最早进入的线程任务，执行当前任务线程，源码如下：</p>\n<pre class=\"language-java\"><code>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n       if (!e.isShutdown()) {\n           e.getQueue().poll();\n           e.execute(r);\n       }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DiscardPolicy：直接丢弃线程任务，不做任何处理</p>\n<h2><strong>三，五种常用的线程池</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;newCachedThreadPool（可缓存线程池）：</strong>当线程池创建线程的时候如果发现有可复用的线程（执行完任务，且未关闭的线程），则直接复用，如果没有则创建新线程。可缓存线程池可以高效的利用执行任务时间短的线程，提高系统的性能，且线程池中的线程如果空闲时间超过60s，则会被终止且从缓存中移除，这样可缓存线程池不会占用系统资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>newFixedThreadPool（固定大小的线程池）：</strong>即线程池中的线程是初始化固定的，当任务线程大于线程池中线程数量时，任务线程就会进入阻塞队列等待。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newScheduledThreadPool（可做任务调度的线程池）：</strong>即可以设置线程执行的停顿时间和执行周期，进行定期定时的执行某个任务。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newSingleThreadPool（单个线程的线程池）:&nbsp;</strong>即线程池中永远只有一个线程进行工作，如果下称停止或者异常，则线程池创建新的线程替代当前线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newWorkStealingPool（足够大小的线程池）：</strong>即创建足够数量的线程的线程池，保证更快的进行运算，提高效率。</p>\n<h2><strong>四，线程的生命周期</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;线程的生命周期大致分为五个阶段：新建（new），就绪（Runnable），运行（Running），阻塞（Blocked），死亡（Dead）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;新建：</strong>即使用new创建一个线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>就绪：</strong>调用start方法，</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>运行：</strong>即线程获取cpu资源，执行run（）方法，进入运行状态，运行状态的线程如果调用yield（线程让步方法）或者失去cpu资源，都会导致线程重新回到就绪态；如果调用sleep方法，I/O阻塞，等待同步锁，等待通知以及suspend挂起都会导致线程进入阻塞态。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞：</strong>即线程被放入Blocked池。阻塞状态的线程如果结束了sleep方法，I/O方法返回，获取同步锁，收到通知或者resume都会导致其重新进入就绪态，与其它线程竞争cpu时间片。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>死亡：</strong>线程正常执行完run（）或者call（）方法，或者执行stop方法，或者发生异常或者错误都会导致线程死亡。（stop方法会导致锁混乱和死锁，不建议使用）</p>\n<h2><strong>五，线程的基本方法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;wait（线程等待）：</strong>会让线程进入WAITING状态，并且会释放对象的锁。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>sleep（线程睡眠）：</strong>会让线程进入睡眠，进入TIMED_WAITING状态，但是不会释放对象锁，睡眠时间到了之后，再次恢复运行状态</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>yield（线程让步）:</strong>&nbsp; 当前线程会让出其占有的cpu资源，重新回到就绪态和其它线程竞争cpu时间片</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>interrupt（线程终端）:&nbsp;&nbsp;</strong>中断当前线程，但是并不会导致其停止，只是改变其内部的终端标识位，在使用了thread.sleep()之后使用该方法，会导致抛出异常，且我们可以利用中断标识位进行线程的安全退出</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>join（线程加入）：</strong>即将当前线程进入阻塞态，等待下一个线程执行完毕后进入就绪态，重新竞争锁资源。通常用于主线程下面执行子线程，需要主线程阻塞，等待子线程执行完毕后返回其结果给主线程，主线程再执行的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>notify（线程唤醒）/notifyAll：</strong>前者随机唤醒一个等待线程，后者全部唤醒</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>setDaemon（守护线程）:</strong>级别较低的线程，用于后台运行，服务用户用户线程，例如垃圾收集线程就是典型的守护线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>sleep方法和wait方法的区别：</strong>前者属于Thread，后者属于Object，前者不会释放锁资源，后者会释放锁资源</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>start方法和run方法：</strong>start方法只是创建一个线程，并没有运行，run方法时执行线程的真正代码逻辑。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>线程退出的方式：</strong>见四中最后一条</p>\n<h2><strong>六，JAVA中的锁（知识比较杂乱）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述:JAVA中的锁是为了保护数据的一致性。按照不同的标准可分为乐观锁和悲观锁，公平锁和非公平锁，共享锁和独占锁，偏向锁，轻量级锁，重量级锁，自旋锁，可重入锁。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;乐观锁：</strong>即认为每次读取数据都不会被修改，当修改操作的时候再判断当前数据是否被修改，未修改则修改，若已被修改，则返回失败状态。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>悲观锁：</strong>即认为每次读取数据都会被修改，因而每次读取数据都对其进行加锁，这样只有当前用户可以修改，其它用户阻塞等待直到当前用户修改完毕释放锁资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>自旋锁：</strong>即有些线程任务的执行很短，很快就可以释放锁资源，为了避免在这种情况下竞争线程仍然进行内核态和用户态之间的转换，因而让线程自旋（即等一会），如果有可用锁，则获取，减少了线程在用户态和内核态之间切换的时间损耗。提高了性能（优势）。当然线程自旋是占用cpu资源的，因而需要设置一个自旋的最大等待时间，如果超过此时间，则线程退出自旋模式。对于线程竞争锁资源激烈的情况，自旋有可能会导致cpu资源的损耗（劣势）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>公平锁和非公平锁：</strong>即根据线程竞争锁资源的机制判定，一般如果依据先到先得的原则，则位公平锁；如果依据就近原则，则位非公平锁。公平锁相比于非公平锁会更加耗费性能，因为要维护一个线程任务丢列，根据线程任务在队列中的顺序分配锁资源，因而不常用。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>可重入锁：</strong>又被称为递归锁，即该锁可以然后线程对其进行多次的加锁操作。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>偏向锁：</strong>当线程获取到锁的时候，用来消除线程的锁重入的开销（看起来是偏袒这个线程）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>共享锁和独占锁：</strong>共享锁即多线程共享锁资源（典型例子，读锁）；独占锁即当前锁只能有一个线程获取，其它线程阻塞</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>轻量级锁：</strong>没有多线程竞争的前提下，减少重量级锁的使用提高性能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>重量级锁：</strong>基于操作系统的互斥量而实现的锁，会导致进程在用户态和内核态之间切换，耗费性能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>synchronized：独占式悲观锁，可重入锁，非公平锁，重量级锁。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 作用范围：</strong>作用于成员变量和非静态方法，相当于锁住的是对象的实例，即this对象</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;作用于静态方法，相当于锁住的是class实例</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;作用域代码块，相当于锁住的代码块中的对象</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>实现原理：</strong>内部包括ContentionList（锁竞争队列），EntryList（竞争候选列表），WaitSet（等待集合），OnDeck（竞争候选者），Owner，!Owner，其中ContentionList是用来存放竞争锁资源的线程。EntryList是用来存放有资格竞争锁资源的线程。调用wait方法后放入WaitSet中，onDeck指的是同一时刻，只有一个线程竞争锁资源，Owner指的是得到锁资源的线程，!Owner指的是线程执行完毕，释放锁资源的线程。需要注意的是线程首先采用的都是自旋模式获取锁资源，如果自旋获取不到再加入ContentionList，而且Owner状态的线程并不是直接把锁资源交给onDeck状态线程，而是给它竞争锁资源的权利，因而onDeck状态的线程还需要跟自旋线程竞争锁资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>ReentrantLock：独占式，可重入锁，并且可以实现公平锁和非公平锁，重量级锁。</strong></p>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;用法：</strong>lock()加锁，后跟try代码块，finally中进行释放锁unlock()</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;避免死锁的方法：</strong>响应中断（即可以根据情况中断对锁资源的请求），可轮询锁（tryLock（）即尝试获取锁，如果有可用锁则获取返回true，没有则返回。和lock（）的区别在于lock获取锁资源如果没有则一直等待直到获取到锁资源），定时所（tryLock（time,unit）即再一定时间内如果有可用锁，且线程未中断则获取锁，否则禁用当前线程。）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>Semaphore（信号量）:</strong>机制和ReentrantLock类似</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ReadWriteLock（读写锁）：</strong>如果系统要求支持多线程共享读，但不能多线程写，使用读锁；如果要求同一时刻只能有一个线程写，写的过程中不能读取该共享数据，则使用写锁。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; <strong>分段锁：</strong>一种思想，将数据分段加锁，例如ConcurrentHashMap</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;死锁：</strong>即线程之间互相共享资源会导致死锁</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; <strong>锁优化：</strong>第一，减少锁的持有时间；第二：减小锁粒度，例如分段锁；第三：锁分离，例如读写锁；第四：锁粗化，放置锁粒度太小，造成频繁加锁释放锁；第五：锁消除，消除程序代码不规范而造成的乱用了锁</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>\n<h1>水平有限，如果错误，还望指出！</h1>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;</p>, blogGoods=0, blogRead=4, blogCollection=0, typeName=java面试篇, blogRemark=面试（三）------之并发编程篇（上）, blogComment=0, blogSource=null, createdTime=2020-04-12 12:27:07, blogMonth=null, updateTime=2020-04-12 12:57:17), BlogVo(blogId=1249588251598041088, blogTitle=redis基础（一）, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6UCU-ALIMAAACFuGw0Y70739.jpg, blogContent=<h2><strong>一，redis简介</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>redis是NoSQL型系统之一，与之相似的还有Memcache，用来存储key-value这种键值型数据。相比于Memcache而言，redis不仅可以做临时缓存，还可以做数据持久化，将数据定时的存入硬盘或者将命令追加到日志文件当中。而Memcache只能做临时缓存，因而现在基本上已经被redis完全取代。redis的读写速度非常快，官方给出的数据是读110000次/s，写81000次/s；而且redis支持多种数据类型，例如String，list，hash，set，zset；redis支持主从复制（集群），进行数据持久化；还支持过期时间，事务等。</p>\n<h2><strong>二，redis的安装与启动（docker环境下）</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;docker安装完毕后，安装redis：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第一步：拉取redis镜像，docker&nbsp; pull&nbsp; redis</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第二步：启动redis，docker&nbsp; &nbsp;run&nbsp; &nbsp;redis&nbsp; &nbsp;</p>\n<p><strong>三，基本知识串讲</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>单进程单线程：redis只有一个进程，且内部为单线程，这样做的优势是不存在线程安全问题，且不需要进行线程间的切换，提高了性能，而且多线程可能会涉及到锁。劣势是无法发挥多核cpu的优势，不过可以通过开启搭建多个redis实例实现</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>redis中默认有16个数据库（0-15），可以通过select n来进行数据库之间的切换</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;常用的基本命令：flushDB（清空当前数据库），flushAll（清空所有数据库），dbSize（查看有多少数据库）</p>\n<h2><strong>四，redis基本数据类型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;string：</strong>字符串类型，数据库中存储Map&lt;String,String&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>list：</strong>列表数组类型，数据库中存储Map&lt;String,List&lt;Object&gt;&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>hash：</strong>哈希类型，数据库中存储Map&lt;String,Map&lt;Object,Object&gt;&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>set：</strong>集合类型，其中元素无序，数据库中存储Map&lt;String,Set&lt;Object,Object&gt;&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>Zset：</strong>有序集合类型，每个元素都有一个可用于排序的权重</p>\n<h2><strong>五，redis相关命令（这里详解一些常用的命令，不常用的一笔带过）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;string：</strong>(1)set&nbsp; key&nbsp; value,插入一条数据&nbsp; （2）mset&nbsp; key value...批量插入 （3）setnx&nbsp; key value&nbsp; 若无则插入（4）get&nbsp; key&nbsp; 获取某条数据&nbsp; （5）mget keys 批量获取&nbsp; （6）getrange key&nbsp; 0 -1获取数据库全部数据&nbsp; （7）incr age 递增&nbsp; (8) incrby&nbsp; age&nbsp; 10&nbsp; 递增 age 步长为10（9）decr&nbsp; age&nbsp; 递减&nbsp; （10）decrby&nbsp; age&nbsp; 10 步长递减&nbsp; &nbsp;（11）del&nbsp; key&nbsp; 删除某条数据&nbsp; <span style=\"background-color: #ffff00;\">（12）exists&nbsp; key&nbsp; 判断是否存在某个key&nbsp; &nbsp;(13)expire&nbsp; key&nbsp; 10&nbsp; 设置过期时间（单位为秒）&nbsp; （14）pexpire&nbsp; key&nbsp; 1000 设置过期时间，单位为毫秒&nbsp; （15）persist key删除过期时间 （</span><span style=\"background-color: #ffff00;\">16）ttl&nbsp; key&nbsp; 查看过期时间</span></p>\n<p><span style=\"background-color: #ffff00;\">&nbsp;<span style=\"background-color: #ffffff;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>list：&nbsp;&nbsp;</strong>（1）lpush&nbsp; key&nbsp; value 左插入一条数据&nbsp; &nbsp;（2）lpush mylist&nbsp; key&nbsp; value....批量左插入&nbsp; （3）rpush&nbsp; key value 右插入一条数据&nbsp; (4)rpush&nbsp; mylist&nbsp; key value...右批量插入&nbsp; （5）lrange&nbsp; mylist&nbsp; 0&nbsp; -1&nbsp; 取出数据集合&nbsp; （6）lpop mylist 左弹出集合中第一条数据&nbsp; （7）rpop&nbsp; </span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">mylist&nbsp; 右弹出集合中第一条数据&nbsp; （8）llen&nbsp; mylist&nbsp; 获取数据集合长度lrem&nbsp; mylist&nbsp; count&nbsp; value&nbsp; （count&gt;0,从表头开始搜索，移除count个与值与value相等的元素；count&lt;0,表尾开始；count=0，移除所有值与value相等的元素） （9）linsert mylist&nbsp; before/after&nbsp; a&nbsp; 在a元素前或后插入。</span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">(10) lpoplpush&nbsp; list&nbsp; list1 转移列表的元素到另一个列表</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>hash：</strong>（1）hset&nbsp; key&nbsp; &nbsp;val-key&nbsp; val-val&nbsp; 插入一条数据&nbsp; （2）hset&nbsp; myhash&nbsp; name&nbsp; xxx&nbsp; 用于给哈希表中的字段赋值，不存在则创建哈希表赋值，存在则覆盖旧值&nbsp; (3) hget&nbsp; &nbsp;myhash&nbsp; name&nbsp; 取哈希表中某个值&nbsp; （4）hmset&nbsp; myhash name&nbsp; xxx age xxx&nbsp; 批量插入字段&nbsp; （5）hmget</span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">批量获取 （6）hgetall&nbsp; myhash&nbsp; 获取哈希表中所有值&nbsp; (7)&nbsp; hexisets myhash&nbsp; name&nbsp; 判断哈希表中是否存在name字段&nbsp; （8）hsetnx&nbsp; myhash score 100 若存在则不插入，若不存在则插入数据&nbsp; （9）hincrby&nbsp; myhash id 1/hdecrby&nbsp; myhash id&nbsp; 10 递增递减 （10）hdel&nbsp; myhash name&nbsp; </span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">删除&nbsp; （11）hkeys&nbsp; myhash&nbsp; 只取key值&nbsp; （12）hvals&nbsp; myhash&nbsp; 只取value值&nbsp; （13）hlen&nbsp; myhash 获取哈希表长度</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>set：</strong>（1）sadd myset&nbsp; redis&nbsp; 添加一条数据&nbsp; （2）smembers myset&nbsp; 获取数据集合&nbsp; （3）srem&nbsp; myset&nbsp; set1&nbsp; 删除set1&nbsp; （4）sismember myset&nbsp; set1 判断set中是否存在set1&nbsp; (5)srandmember&nbsp; key count&nbsp; 随机获取count个元素（6）spop&nbsp; 从集合中弹出一个元素</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>zset：</strong>之后补充</span></span></p>\n<h2><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">六，redis配置文件（常见配置）</span></span></strong></h2>\n<p><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;daemonize no：</span></span></strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">redis默认不是以守护进程的方式运行的，可以更改为yes启用守护进程（即后台运行）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>pidfile&nbsp; /var/run/redis.pid&nbsp; :</strong>启用守护进程后，默认将pid写入/var/run/redis.pid文件，可以更改</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>port&nbsp; 6379 ：</strong>redis默认端口</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp; &nbsp; &nbsp; &nbsp; <strong>bind&nbsp; 127.0.0.1：</strong>绑定的主机地址</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\"> &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>timeout&nbsp; 300</strong><strong>：</strong>redis客户端闲置多长时间后关闭连接，改为0的话，表示关闭该功能</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>loglevel&nbsp; verbose：</strong>默认日志级别（还有debug，notice，warning）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>database 16：</strong>redis默认有16个数据库可以修改</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>save&nbsp; 900&nbsp; 1/save&nbsp; 300&nbsp; 10/save&nbsp; 60&nbsp; 10000：&nbsp;</strong>表示一定时间内有多少条数据发生修改，就将其同步到数据文件一次，例如第一个表示15分钟内有一条数据发生改变就同步</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>rdbcompression yes&nbsp; ：</strong>表示数据存储到本地数据库时是否进行压缩</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>dbfilename&nbsp; dump.rdb：</strong>指定本地数据库文件名</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>dir&nbsp; /...../redis安装目录/bin ：</strong>本地数据库存放目录，默认在redis安装目录的bin目录下</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>slaveof&nbsp; &nbsp;masterip&nbsp; masterport ：</strong>设置当本机为从机时，它的主机的ip和端口</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>masterauth&nbsp; &lt;master-password&gt;：</strong>当master服务设置了密码时，slav服务连接master的密码</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>requirepass&nbsp; foobared：</strong>默认关闭redis连接需要密码，当给redis设置了密码，就需要打开</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>maxclients&nbsp; &nbsp;128：</strong>redis同一时间最大连接客户端的数量</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>appendonly&nbsp; &nbsp;no：</strong>是否开启aof持久化，默认不开启，采用rdb</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>appendfilename&nbsp; appendonlu.aof：</strong>指定aof持久化的文件名</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>appendfsync&nbsp; everysec :</strong>指定更新日志条件，默认每秒更新一次（还有no，指等操作系统进行数据缓存到磁盘，快；always指每次更新操作后都手动写入磁盘，慢但安全）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;虚拟机方面的配置暂不说明</span></span></p>\n<h2><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">七，redis持久化</span></span></strong></h2>\n<p><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;概述：</span></span></strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">redis持久化主要有两种方式，即rdb和aof</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>rdb：</strong>适用于大数据集的恢复，数据的备份，但是因为设置周期时间进行数据的快照，所以如果redis宕机，可能会丢失最后一个写操作的数据，因为数据完整性较差。数据保存在dump.db文件中，只需要移动到redis安装目录，重启即可恢复数据</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>aof：</strong>适用于对数据的完整性要求较高的情况，因为可以设置不同的持久化策略，例如每秒保存一次，这样即时redis宕机，也只会丢失最后一秒的数据。但是因为其日志文件存储的是写入命令，因而其文件大小要大于rdb的数据文件，且每次重启，都要从头执行数据文件中的命令，因而恢复速度也</span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">要慢于rdb。</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>注意：</strong>当rdb和aof同时开启的时候，redis重启，默认会采用aof的形式进行数据的重新构建</span></span></p>\n<h2><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">八，redis事务</span></span></strong></h2>\n<p><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;概述：</span></span></strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">什么是事务？事务即是一系列的命令要买全部执行，要么全部回滚</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <strong>常用命令：</strong>multi(启动事务)，discard（取消事务）,exec（执行事务块内命令）,watch key(监控某个key的变化)，unwatch（取消对所有key的监控）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>注意：</strong>redis的事务中在命令本身出错的情况下会造成命令的全部回滚，但是在命令无错，执行某个命令的时候发生异常的时候，则谁的错，谁停止（这一点和mysql是不同的）</span></span></p>\n<h2><strong>九，redis的主从复制</strong></h2>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>redis的主从复制，即主机数据更新后根据我们设置的策略将数据同步到从机上，主机以写为主，从机以读为主<strong>。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 使用：</strong>配主不配从，在从机中使用slaveof&nbsp; 主机ip&nbsp; &nbsp;主机端口配置从机，但是这种配置方式当redis重启之后就会失效，如果想要redis重启仍然可用，则需要配置redis.conf配置文件中的slaveof&nbsp; masterip&nbsp; masterport。这种配置方式的问题所在，中心化只有一台极其支持写操作，如果主机宕机，则从机等待，且从机宕机重启后不会跟上大部队（即重启后变为主机）。当然我们可以采用命令slave&nbsp; no&nbsp; one 使从机反客为主，成为主机。但是这种手动操作太过麻烦。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>哨兵模式：</strong>即配置之后，如果主机宕机，则哨兵会自动根据投票规则在从机中进行选举，从而产生新的主机顶替。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>主从复制的缺点：</strong>因为所有的写操作都是子主机上进行，从而在同步到从机上，所以存在着一定的延迟，当系统繁忙或者从机数量较多的时候，这种问题就更加明显。</p>\n<h2><strong>十，redis集群</strong></h2>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;概述：</strong>集群是一种去中心化的模式，与中心化模式不同的是，中心化模式中如果主服务挂掉了，那么服务就挂掉了。但是集群模式下，没有主路由，每个节点自身都可以成为路由</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;redis集群：即配置多台主机，多台从机，不同的主机中有不同的槽点，当执行数据写入时，会根据crc16算法计算出数据的槽点，从而将数据存入到对应的主机中，并同步到与其对应的从机中</p>\n<p>&nbsp;</p>\n<h1>水平有限，如有错误，还望指出！</h1>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong></p>, blogGoods=0, blogRead=1, blogCollection=0, typeName=redis, blogRemark=redis基础（一）, blogComment=0, blogSource=null, createdTime=2020-04-13 06:40:30, blogMonth=null, updateTime=2020-04-13 06:42:09), BlogVo(blogId=1249742755949817856, blogTitle=面试（三）------之并发编程篇（下）, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6UmSuAdB35AABzd_wnH78043.jpg, blogContent=<h2><strong>一，线程上下文切换</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>cpu利用时间片轮询的方式来为每个任务都分配一定的时间片，任务的执行过程中保存任务的状态。任务状态的保存和在加载就叫做上下文切换。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>进程：</strong>指的是一个运行中的程序实例，一个进程中可以有多个线程，并且与进程共享同样的内存和系统资源</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong> 上下文：</strong>指的是寄存器和程序计数器保存的线程的信息</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>寄存器：</strong>指的是内存中很小但是运行速度很快的一块区域（相对于RAM外部内存）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>程序计数器：</strong>一种寄存器，用来保存当前执行指令的位置或者下一个待执行指令的位置</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>上下文切换：</strong>上下文切换指的是操作系统的内核在cpu上对进程或者线程的切换。上下文信息保存在进程控制块中（PCB）。流程如下：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;挂起当前进程，将进程的上下文信息保存在进程控制块中；</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;在进程控制块中寻找下一个任务的上下文信息。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;恢复进程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>上下文切换的原因：</strong>第一，任务正常执行完毕，调度下一个任务；第二，线程出现I/O阻塞，被挂起，cpu调度下一个任务；第三，线程等待同步锁，获取socket通知等，被挂起，cpu调度下一个任务；第四，用户调用sleep方法，让出cpu；第五，硬件中断</p>\n<h2><strong>二，JAVA阻塞队列</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>阻塞队列的是调度当前队列的线程处于阻塞状态</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 消费者阻塞：如果队列为空，则消费者线程被挂起，处于阻塞状态，当有新数据进入队列，则消费者线程被唤醒，消费数据</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 生产者阻塞：如果队列数据已满，则生产者线程挂起，处于阻塞状态，当队列有空闲位置，生产者线程被唤醒，生产数据。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞队列的主要操作：</strong>插入操作和移除（获取）操作</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>插入操作：</strong>add(e)，有空间则插入，无空间报异常；offer(e),有空间则插入，无空间返回false；offer(e,time,unit),有空间插入，无空间等待time时间，若超时返回false；put(e),有空间插入，无空间则线程挂起处于阻塞直到有空间</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>移除操作：</strong>poll(e),有值返回值，无值返回null;poll(e,time,unit),有值返回值，无值等待time时间，超时返回null;take(e),有值返回值，无值等待新数据进入再立即返回；drainTo(collection&lt;Object&gt;)批量移除，提高获取效率</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞队列的实现：</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong> ArrayBlockingQueue：</strong>基于数组的有界阻塞队列，按照先进先出顺序对元素进行排序</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>LinkedBlockingQueue：</strong>基于链表的有界阻塞队列，队头队尾采用不两个不同的锁控制数据同步，并发性高</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>PriorityBlockingQueue：</strong>基于优先级的无界队列，默认升序排列，可以自定义排序规则，根据优先级访问数据。但是有数据优先级一样的情况</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>DelayQueue：</strong>支持延时的队列，即从队列中取数据时等待一定的时间才能获取元素。可以用于缓存系统的设计，设计过期时间，也可以用来设置定时调度任务，即如果能够从队列中获取，说明到了任务的调度时间。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>SynchronousQueue</strong>：没怎么读懂（<span style=\"background-color: #ffff00;\">记得补充</span>！）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>LinkedTransferQueue：</strong>基于链表的无界阻塞队列，多了transfer方法(如果消费者等待，直接将任务从生产者传递给消费者，无消费者等待，则将任务加到队尾直到被消费才返回)和tryTransfer（与transfer一致，只不过不管有没有消费者等待获取都会立即返回tryTransfer（e,time,unit）（与tryTransfer一致，只不过设置了超时时间）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>LinkedBlockingDeque：</strong>基于链表的双向阻塞队列，可以在两端同时进行读写操作，提高了队列的操作效率。</p>\n<h2><strong>三，并发关键字</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;CountDownLatch：</strong>适用于一个主线程等待子线程完成任务之后执行（原理：设置一个程序计数器，计数器的值为子线程的个数，子线程并发执行，每个子线程执行完毕后，调用CountDown方法，将其计数器的值减去1，值为0时，唤醒主线程执行）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>CyclicBarrier：</strong>即当所有线程到达一个状态共同执行。await（）方法：确保所有线程到达Barrier状态才执行；await（time,unit）：设置一个超时时间，超过这个时间，执行达到Barrier状态的线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>Semaphore：</strong>因为其限制了多线程访问资源的线程个数，所以适用于多线程并发访问有限资源的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>volatile：</strong>直接用来修饰变量，是一种比Synchronized更加轻量级的机制，用于多线程共享同一变量，可以同时对其进行读写操作。当多个线程共享变量的时候，读取变量将其从内存复制到cpu缓存中，然后线程对其操作进行修改，这样再多cpu的情况下，有可能出现线程修改原数据造成数据不一致的情况，使用volatile关键字直接将线程修改的变量存入内存，解决这个问题。</p>\n<h2><strong>四，多线程共享数据</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>多线程共享数据主要通过共享内存实现，而共享内存的可见性，有序性，原子性已经由JVM和锁解决。理想情况下我们需要解决同步和互斥的问题（<span style=\"background-color: #ffff00;\">怎么解决的有待考证！</span>）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>解决方法一：</strong>将数据抽象成一个类，将对数据的操作封装成类中的方法</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解决方法二：</strong>将Runnable对象作为一个内部类，将共享数据作为这个类的成员变量</p>\n<h2><strong>五，ConcurrentHashmap并发</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ConcurrentHashmap使用了减小锁粒度，这里具体为分段锁的思想优化了锁，因为如果直接对hashmap进行加锁，锁太大，而且同一时刻只能有一个线程操作hashmap，并发性能较差</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;实现原理：</strong>即内部采用分段锁思想，将hashmap分为多个segment，每次读取数据的时候，对数据所在的segment进行加锁，这样只要保证每个segment线程安全，就可以保证整个hashmap线程安全</p>\n<h2><strong>六，JAVA中的线程调度</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;抢占式调度：</strong>即线程对cpu资源进行抢占，这种策略下每个线程抢占到cpu资源的概率是相等的，这样就不会一个线程阻塞造成整个系统阻塞的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>协同式调度：</strong>即一个线程使用完cpu资源之后通知cpu调度下一个任务，适用于多线程交替执行任务。因为如果一个线程阻塞可能会造成整个系统阻塞甚至崩溃</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>JAVA采用的是抢占式调度，但同时又尽可能的保证公平性（即为每个线程分配优先级不同的cpu时间片）</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>&nbsp;线程让出cpu的情况</strong>：第一，线程调用yield方法；第二，I/O阻塞，socket等待等；第三，等待同步锁；第四，正常执行完毕</p>\n<h2>七，进程调度算法</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>优先调度算法：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;先来先服务调度算法：</strong>即遵循先来先被分配cpu资源运行的原则</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>短作业调度算法：</strong>即预估作业的时间长短，优先调度时间短的任务，可能会导致长时间大任务很长时间无法被调度 &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>高优先权调度算法：即每个任务会预先被分配优先级</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;非抢占式优先调度算法：</strong>按照优先级的高低一次分配cpu资源运行</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>抢占式优先调度算法：</strong>按照优先级的高低分配cpu资源运行，但是如果任务再运行过程中有优先级更高的任务加入，则将其cpu资源临时回收分配给紧急任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>高响应比调度算法：</strong>动态调度，即作业时间短，则优先级高；等待时间长，则优先级高。前者遵循短作业调度算法，后者遵循先来先服务原则。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>时间片轮转调度算法：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;时间片轮转法：</strong>按照任务再队列中的顺序进行调度</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>多级反馈队列调度算法：</strong>即再时间片轮转法的基础上维护了就绪队列，默认第一队列优先级高，先调度第一队列的任务，如果再分配的cpu时间片内未完成则将其加入第二队列队尾，以此类推直到其执行完毕。只有第1 -（n-1）队列为空，才会调度第n队列的任务，而且当前任务执行时，如</p>\n<p>果有优先级高的任务进来，会抢占其cpu资源。</p>\n<h2><strong>八，CAS</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>即比较和交换，CAS（V,E,N）三个参数，只有当V=E的时候才会将V设置为N。如果V!=E，则说明数据已经被其它线程修改，不做任何操作</p>\n<h2><strong>九，ABA问题</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>概述：</strong>即当1线程从V中取出A时，2线程也从中取出1，修改为B，再修改为A。而1线程仍然修改成功，实际上修改过程中V的实际值已经发生改变，只不过1没有发觉。解决这种问题，常采用乐观锁的版本号机制。</p>\n<h2><strong>另外有AQS问题没怎么读懂，下次完善！</strong></h2>\n<p>&nbsp;</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</p>, blogGoods=0, blogRead=1, blogCollection=0, typeName=java面试篇, blogRemark=面试（三）------之并发编程篇（下）, blogComment=0, blogSource=null, createdTime=2020-04-13 16:54:26, blogMonth=null, updateTime=2020-04-13 16:54:43), BlogVo(blogId=1250068950784536576, blogTitle=面试（四）------之数据结构篇, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6VyQCAX-J_AACqF70d5gI039.jpg, blogContent=<h2><strong>一，栈及其JAVA实现</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：栈是一种先进后出的数据结构，对栈顶元素的添加，删除等操作较快，但是对于栈内的元素操作很慢</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA实现：实现需要定义栈的数据结构，写栈的入栈，出栈，获取栈顶元素的方法，如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n * 基于数组实现栈\n * @author wcj\n * @Date 2020/4/14 20:59\n * @Version 1.0\n */\npublic class StackExample&lt;E&gt; {\n\n    /**\n     * 站的深度\n     */\n    private int maxSize;\n    /**\n     * 存储数据的数组\n     */\n    private Object[] data;\n    /**\n     * 栈顶指针\n     */\n    private int top = -1;\n\n    /**\n     * 默认栈的深度为10\n     */\n    public StackExample(){\n        this(10);\n    }\n\n    /**\n     * 用户自定义栈的深度\n     * @param initialSize\n     */\n    public StackExample(int initialSize){\n        if(initialSize&gt;=0){\n            this.maxSize = initialSize;\n            this.data = new  Object[initialSize];\n            this.top = -1;\n        }else{\n            throw new RuntimeException(\"初始化栈的深度不能小于0!\");\n        }\n    }\n\n    /**\n     * 入栈操作\n     * @param e\n     * @return\n     */\n    public Boolean push(E e){\n        if(top == maxSize-1){\n            throw new RuntimeException(\"栈已满,不能入栈\");\n        }else{\n            data[++top] = e;\n        }\n        return true;\n    }\n\n    /**\n     * 出栈操作\n     * @return\n     */\n    public E pop(){\n        if(top==-1){\n            throw new RuntimeException(\"栈空，不能出栈！\");\n        }else{\n            return (E) data[top--];\n        }\n    }\n\n    /**\n     * 获取栈顶元素\n     * @return\n     */\n    public E peak(){\n        if(top==-1){\n            throw new RuntimeException(\"栈空异常！\");\n        }else{\n            return (E) data[top];\n        }\n    }  </code></pre>\n<h2><strong>二，队列极其JAVA实现</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：队列是一种先进先出的数据结构，对队头和队尾的操作简单，但是队内元素的操作复杂。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA实现：定义队列的数据结构，队列的出队，入队，获取队头元素。代码如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n * 基于数组实现队列\n * @author wcj\n * @Date 2020/4/14 21:14\n * @Version 1.0\n */\npublic class QueueExample&lt;E&gt; {\n\n    /**\n     * 队列长度\n     */\n    private int maxSize;\n    /**\n     * 存储数据数组\n     */\n    private Object[] data;\n    /**\n     * 队头指针\n     */\n    private int front;\n    /**\n     * 队尾指针\n     */\n    private int rear;\n\n    /**\n     * 默认构造器\n     */\n    public QueueExample(){\n        this(10);\n    }\n    /**\n     * 用户自定义队列长度构造器\n     * @param initialSize\n     */\n    public QueueExample(int initialSize){\n        if(initialSize&gt;=0){\n            this.maxSize = initialSize;\n            data = new Object[initialSize];\n            front = rear = 0;\n        }else{\n            throw new RuntimeException(\"初始化队列长度不能小于0！\");\n        }\n    }\n\n    /**\n     * 入队操作\n     * @param e\n     * @return\n     */\n    public Boolean add(E e){\n        if(rear == maxSize){\n            throw new RuntimeException(\"队列已满，无法入队!\");\n        }else{\n            data[rear++] = e;\n        }\n        return true;\n    }\n\n    /**\n     * 出队操作\n     * @return\n     */\n    public E poll(){\n        if(front==rear){\n            throw new RuntimeException(\"队空，无元素可出队！\");\n        }else{\n            E e = (E) data[front];\n            data[front] = null;\n            return e;\n        }\n    }\n\n    /**\n     * 获取队头元素\n     * @return\n     */\n    public E peek(){\n        if(front==rear){\n            throw new RuntimeException(\"队空，无元素可出队!\");\n        }else{\n            return (E) data[front];\n        }\n    }\n}\n</code></pre>\n<h2><strong>三，链表及其JAVA实现</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：链表是由一系列数据节点组成的数据结构，节点可以动态生成。对于元素的增加，删除操作快，查询操作慢</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;这里主要讲述几种有代表性的链表：单向链表，双向链表，双向循环链表</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;单链表的JAVA实现：数据结构定义，添加节点，删除节点，查找节点，代码如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n * 单向链表\n * @author wcj\n * @Date 2020/4/14 21:32\n * @Version 1.0\n */\npublic class SingleLinkedList {\n\n    /**\n     * 链表长度\n     */\n    private int length;\n    /**\n     * 链表头节点\n     */\n    private Node head;\n\n    public SingleLinkedList(){\n        this.length = 0;\n        this.head = null;\n    }\n    /**\n     * 内部类声明每个链表节点\n     * 每个节点包括数据域和指向下一个节点的指针\n     */\n    private class Node{\n        private Object data;\n        private Node next;\n        public Node(Object data){\n            this.data = data;\n        }\n    }\n\n    /**\n     * 插入节点（这里使用头插法）\n     * @param obj\n     * @return\n     */\n    public Boolean add(Object obj){\n        Node node = new Node(obj);\n        if(length==0){\n            head = node;\n        }else{\n            node.next= head;\n            head = node;\n        }\n        length++;\n        return true;\n    }\n\n    /**\n     * 删除某个节点\n     * 先对链表进行判空处理\n     * 然后找到要删除的节点\n     * 最后进行删除\n     * @param obj\n     * @return\n     */\n    public Boolean delete(Object obj){\n        if(length==0){\n            throw new RuntimeException(\"链表为空，无节点可删除!\");\n        }else{\n            Node prev = head;\n            Node current = head;\n            //查找待删除元素\n            while(!current.data.equals(obj)){\n                if(current.next==null){\n                    return false;\n                }else{\n                    prev = current;\n                    current = current.next;\n                }\n            }\n            prev.next = current.next;\n            length--;\n        }\n        return true;\n    }\n\n    /**\n     * 获取某个元素\n     * @param obj\n     * @return\n     */\n    public Object find(Object obj){\n        if(length==0){\n            throw new RuntimeException(\"链表为空\");\n        }else{\n            Node current = head;\n            while(current.data.equals(obj)){\n                if(current.next==null){\n                    return null;\n                }else{\n                    current = current.next;\n                }\n            }\n            return current.data;\n        }\n    }\n}\n</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>双向链表的JAVA实现：定义数据结构，头插法，尾插法，删除头部节点，删除尾部节点（这里只写尾插节点和删除尾部节点），代码如下：</strong></p>\n<pre class=\"language-java\"><code>import com.sun.org.apache.xpath.internal.operations.Bool;\n\n/**\n * 单向循环链表\n * @author wcj\n * @Date 2020/4/14 22:05\n * @Version 1.0\n */\npublic class CircleLinkedList {\n\n    /**\n     * 链表长度\n     */\n    private int length;\n    /**\n     * 头节点\n     */\n    private Node head;\n    /**\n     * 尾节点\n     */\n    private Node tail;\n\n    /**\n     * 初始化构造方法\n     */\n    public CircleLinkedList(){\n        this.length = 0;\n        this.head=this.tail = null;\n    }\n\n    /**\n     * 内部类实现的链表节点\n     */\n    private class Node{\n        private Object data;\n        private Node prev;\n        private Node next;\n        public Node(Object data){\n            this.data = data;\n        }\n    }\n\n    /**\n     * 尾插节点\n     * @param obj\n     * @return\n     */\n    public Boolean addTail(Object obj){\n        Node node = new Node(obj);\n        if(length==0){\n            head = tail= node;\n            length++;\n        }else{\n            tail.next = node;\n            node.prev = tail;\n            tail = node;\n            length++;\n        }\n        return true;\n    }\n\n    /**\n     * 删除尾部节点\n     * @return\n     */\n    public Boolean delTail(){\n        Node temp = tail;\n        if(length==0){\n            throw new RuntimeException(\"链表为空!\");\n        }else{\n            tail = tail.prev;\n            tail.next = null;\n            length--;\n        }\n        return true;\n    }\n}\n</code></pre>\n<h2><strong>四，散列表</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：有一张表M，一个映射函数f(key)，如果对于任意一个key，都有一个函数指与表中的内存地址相对应，则M就为散列表，f(key)就为散列函数。散列函数存储key-value键值对形式的数据，直接生成key与表中地址值的映射，因此查询非常迅速。同时散列表也经常被用于信息安全，用于加密操作。</strong></p>\n<h2><strong>五，二叉排序树</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：二叉查找树又成为二叉搜索树，二叉查找树</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;特征：根节点左边的数据小于根节点，根节点右边的数据大于根节点，且其左右子树还是二叉排序树</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现：定义数据结构，插入操作，删除操作，查找操作，代码如下：</strong></p>\n<pre class=\"language-java\"><code>package interviewFour.example4;\n\n/**\n * 二叉排序树\n * @author wcj\n * @Date 2020/4/14 17:17\n * @Version 1.0\n */\npublic class Node {\n\n    private Node root = null;\n    private int value;\n    private Node left;\n    private Node right;\n\n    public Node(){}\n\n    public Node(int value, Node left, Node right){\n        this.value = value;\n        this.left = left;\n        this.right = right;\n    }\n\n    public Node(int value){\n        this.left = null;\n        this.right = null;\n        this.value = value;\n    }\n\n    public int getValue() {\n        return value;\n    }\n\n    public void setValue(int value) {\n        this.value = value;\n    }\n\n    public Node getLeft() {\n        return left;\n    }\n\n    public void setLeft(Node left) {\n        this.left = left;\n    }\n\n    public Node getRight() {\n        return right;\n    }\n\n    public void setRight(Node right) {\n        this.right = right;\n    }\n\n    /**\n     * 插入节点\n     * @param value\n     * @return\n     */\n    public Boolean insert(int value){\n        //root代表根节点\n        Node p = root;\n        Node prev = null;\n        //创建一个节点\n        Node node = new Node(value);\n        //寻找节点的插入位置\n        while(p!=null){\n            prev = p;\n            if(value==p.getValue()){\n                return false;\n            }else if(value&lt;p.getValue()){\n                p = p.getLeft();\n            }else{\n                p = p.getRight();\n            }\n        }\n        if(root==null){\n            root = node;\n        }else if(value&lt;prev.getValue()){\n            prev.setLeft(node);\n        }else{\n            prev.setRight(node);\n        }\n        return true;\n    }\n\n    /**\n     * 删除某个节点\n     * 分为三种情况，待删除节点为叶子节点，则直接删除\n     * 待删除节点只有左子树或者右子树，则用左子树或者右子树替代当前节点位置\n     * 待删除节点即有左子树又有右子树，则寻找左子树最大节点或者右子树最小节点顶替当前节点(这里使用左子树的最大节点)\n     * @param value\n     * @return\n     */\n    public void deleteBST(int value){\n        deleteBST(root,value);\n    }\n\n    /**\n     * 递归删除左子树，或者右子树，或者根节点\n     * @param root\n     * @param value\n     * @return\n     */\n    public Boolean deleteBST(Node root,int value){\n        if(root==null){\n            return false;\n        }else{\n            if(root.getValue()==value){\n                delete(root);\n            }else if(value&lt;root.getValue()){\n                deleteBST(root.getLeft(),value);\n            }else{\n                deleteBST(root.getRight(),value);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * 分情况执行具体的删除逻辑\n     * @param node\n     * @return\n     */\n    public Boolean delete(Node node){\n        if(node.getLeft()==null){\n            node = node.getRight();\n        }else if(node.getRight()==null){\n            node = node.getLeft();\n        }else{\n            Node temp = node;\n            Node s = node;\n            //转向左子树，向右走到底\n            s = s.getLeft();\n            //寻找替换待删除节点的节点\n            while(s!=null){\n                temp = s;\n                s = s.getRight();\n            }\n            node.setValue(temp.getValue());\n            if(temp!=node){\n                node.setLeft(temp.getLeft());\n            }else{\n                node.setRight(temp.getRight());\n            }\n        }\n        return true;\n    }\n\n    /**\n     * 在二叉查找树中找到对应节点\n     * @param value\n     * @return\n     */\n    public Boolean searchBTS(int value){\n        Node node = root;\n        if(node==null){\n            throw new RuntimeException(\"无此节点！\");\n        }else{\n            if(value==node.getValue()){\n                return true;\n            }else if(value&lt;node.getValue()){\n                node = node.getLeft();\n            }else{\n                node = node.getRight();\n            }\n        }\n        return false;\n    }\n}\n</code></pre>\n<h2>&nbsp;</h2>\n<h2><strong>六，红黑树</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 概述：红黑树是一种特化的自平衡二叉排序树，即其左右子树的深度差可以超过1。（详细的插入等操作过段时间会补充）</strong></p>\n<h2><strong>七，图，位图</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;图的知识：定义，有向图/无向图，邻接矩阵/邻接表，BFS/DFS，位图的话没怎么搞清楚。</strong></p>\n<h2>&nbsp;</h2>, blogGoods=0, blogRead=1, blogCollection=0, typeName=java面试篇, blogRemark=面试（四）------之数据结构篇, blogComment=0, blogSource=null, createdTime=2020-04-14 14:30:37, blogMonth=null, updateTime=2020-04-14 14:30:58)], params={}, sortColumn=null, sortMethod=ASC)]","logStatus":1,"logTime":410,"logUrl":"/blog/list"},{"createdTime":"2020-04-15 10:06:16","logId":3134,"logIp":"127.0.0.1","logMethod":"GET","logParams":"[]","logStatus":1,"logTime":94,"logUrl":"/rotation-picture/listFront"}],"pageSize":10,"params":{},"sortMethod":"ASC","totalCount":4113,"totalPage":412},"msg":"操作成功!"}
2020-04-26 23:26:15.346 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /music/list
2020-04-26 23:26:15.347 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:26:15.347 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:26:15.347 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.MusicController.getMusicList
2020-04-26 23:26:15.347 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=5, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=ASC)]
2020-04-26 23:26:15.614 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 268
2020-04-26 23:26:15.616 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"artist":"周深","cover":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMh2AFeEFAAAZaWcYmAM180.jpg","createdTime":"2020-04-08 02:09:38","enabled":1,"id":1,"lrc":"[00:00.37]周深 - 直破穹苍 (《斗破苍穹》动画第三季主题曲)\n[00:02.79]作词：冥凰\n[00:03.86]作曲：李建衡\n[00:05.19]编曲：崔博源、李建衡\n[00:07.13]人声录制：徐威@上海V-Studio\n[00:09.23]监唱：徐威@上海V-Studio\n[00:11.38]混音：周天澈@Studio21A\n[00:24.13]有没有想过 穿越这片沙漠\n[00:32.21]前方是什么\n[00:35.16]是就此陨落\n[00:37.97]还是抓牢命运脉搏\n[00:45.38]他曾经 爱过 恨过 痛过\n[00:51.07]直到望见远处那抹焰火\n[00:56.73]也许这 是祸 是过 是错\n[01:02.41]仍不害怕 去烧灼\n[01:08.50]管那六合八荒 斗一场\n[01:14.06]焰分噬浪谁能抗\n[01:19.28]漫却这漫漫险关 莫登攀\n[01:24.88]他欲乘风 直破穹苍\n[01:43.04]太多的纠葛 太多悲欢离合\n[01:51.39]要人太执着\n[01:54.21]该如何选择\n[01:57.02]才能看清是非漩涡\n[02:04.58]他曾经 哭过 泪过 笑过\n[02:10.16]直到紧握手心那抹焰火\n[02:15.77]走遍这 荒山 大漠 湖泊\n[02:21.49]仍不退缩 去冲破\n[02:27.44]管那龙潭虎穴 斗一场\n[02:32.72]生死福祸也跌宕\n[02:38.28]漫却他太多如果 都过往\n[02:43.86]还来惊诧 满堂\n[02:50.00]管那六合八荒 斗一场\n[02:55.22]焰分噬浪谁能抗\n[03:00.85]漫却这漫漫险关 莫登攀\n[03:06.51]他欲乘风 直破穹苍","name":"直破苍穹","url":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMlWAC1FrAr8ypaThmW479.flac"},{"artist":"冷鸢","cover":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMnWAa32EAABwmk6a5Cs834.jpg","createdTime":"2020-04-08 02:11:07","enabled":1,"id":2,"lrc":"你是信的开头诗的内容\n童话的结尾\n你是理所当然的奇迹\n你是月色真美\n你是圣诞老人送给我\n好孩子的礼物\n你是三千美丽世界里\n我的一瓢水\n所以让我再靠近一点点\n因为你太温暖\n我会再变得坚强一点点\n因为你太柔软\n交换无名指金色的契约\n给彼此岁月\n说好从今以后都牵着手\n因为要走很远\n你是我万水千山的冒险\n要找的标记点\n你是分割我人生的线\n又将它们相连\n你是前世千次的回眸\n虔诚牵的手\n你是其余所有的一切\n是我的世界\n所以请你再闪亮一点点\n尽管我太平凡\n我会再变得柔软一点点\n因为你太敏感\n交换无名指金色的契约\n给彼此岁月\n说好从今以后都牵着手\n不管要走多远\n让我再靠近一点点\n因为你太温暖\n我会再变得坚强一点点\n因为你太柔软\n交换无名指金色的契约\n给彼此岁月\n说好从今以后都牵着手\n因为要走很远","name":"勾指起誓","url":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMomAGXdvAHZQ_9pwL9c866.mp3"}],"pageSize":5,"params":{},"sortMethod":"ASC","totalCount":2,"totalPage":1},"msg":"操作成功!"}
2020-04-26 23:26:17.453 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /link/list
2020-04-26 23:26:17.454 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:26:17.454 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:26:17.454 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.LinkController.getLinkList
2020-04-26 23:26:17.454 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:26:17.548 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 95
2020-04-26 23:26:17.550 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"createdTime":"2020-04-08 02:11:26","linkId":1,"linkName":"百度","linkUrl":"www.baidu.com","updateTime":"2020-04-08 02:11:26","version":1},{"createdTime":"2020-04-18 21:39:52","linkId":2,"linkName":"CSDN","linkUrl":"https://www.csdn.net/","updateTime":"2020-04-18 21:39:52","version":1}],"msg":"操作成功!"}
2020-04-26 23:26:23.094 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/popular-statistic
2020-04-26 23:26:23.094 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/blog-statistic
2020-04-26 23:26:23.094 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:26:23.094 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:26:23.094 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:26:23.095 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:26:23.095 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogPopularStatistic
2020-04-26 23:26:23.095 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogStatistic
2020-04-26 23:26:23.095 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:26:23.095 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:26:23.189 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 95
2020-04-26 23:26:23.192 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"blogTitle":"面试（二）-----","count":27},{"blogTitle":"博客开发总结（一）-","count":21},{"blogTitle":"面试（三）-----","count":17},{"blogTitle":"面试（一）-----","count":17},{"blogTitle":"面试（三）-----","count":8}],"msg":"操作成功!"}
2020-04-26 23:26:24.191 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 1097
2020-04-26 23:26:24.192 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"blogNumber":53,"month":"04"}],"msg":"操作成功!"}
2020-04-26 23:27:24.302 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/list
2020-04-26 23:27:24.302 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:27:24.302 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:27:24.302 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogList
2020-04-26 23:27:24.302 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=ASC)]
2020-04-26 23:27:24.648 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 346
2020-04-26 23:27:24.650 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，数据库设计--表的命名规范等</strong></p>\n<p>（1），统一采用bl_开头对表进行命名</p>\n<p>（2），对于数据比较重要的表统一添加四个字段，分别为：created_time(创建时间),update_time(修改时间),version(版本号),deleted(删除字段)</p>\n<p>（3），数据库表的字段尽量都设置为NOT_NULL</p>\n<p>（4），数据库中表varchar类型字段需要设置长度的尽量设置为2<sup>n</sup>-1</p>\n<p>（5），因为博客系统分为前台展示界面和后台管理，所以对于有些表，例如bl_type（博客类型表），bl_music（音乐表）等设置了enable（启用字段）</p>\n<p><strong>二，上述第二条--四个字段的解释</strong></p>\n<p>（1），为什么要设置created_time和update_time字段：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;其一，从数据库的通用性上来说，设计这两个字段是必要的，但也需要根据业务的需要来合理添加这两个字段，因为无用的字段会浪费空间，性能，影响系统的运行。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 其二，大部分的应用都有需要根据时间进行排序的功能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 其三，当系统发生异常的时候，我们可以通过这两个字段对异常进行排查和定位。</p>\n<p>（2），为什么要设置version字段：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 1，version字段含义：字段的含义与其字面意思一样，代表版本，在这里作为乐观锁进行使用，从而保证不会出现脏数据的情况。下面解释一下什么叫乐观锁，以及乐观锁和悲观锁</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 2，乐观锁：总是假定最好的情况，即每次用户调用接口从数据库中取出数据到修改数据前的过程中，不会有其它用户对当前数据进行修改，这样在当前用户修改数据的时候，利用版本机制即判断取出的version字段和当前数据库该条数据的version字段是否相等来判断该条数据是否已经被修改，如果未修改，则予以修改（且version字段递增），如果已经修改，则提示用户更新失败。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 悲观锁：总是假定最坏的情况，即每次用户调用接口从数据库取出数据的时候，都认为该条数据会被修改，因此每次取出数据都对数据进行加锁处理，只允许当前用户进行修改，其它用户阻塞，直到当前用户修改完毕。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3，为什么使用乐观锁而不使用悲观锁：因为悲观锁比较浪费性能</p>\n<p>（3），为什么设置deleted字段：deleted字段在这里作为一个逻辑删除字段（0否1是），何为逻辑删除，即执行删除操作操作的时候，不会真正的删除数据库中的数据，而是将deleted字段设置为1即可。&nbsp;这样如果用户出现误删的操作，可以通过数据库修改该字段进行数据的恢复。</p>\n<p><strong>三，上述第三条--数据库表字段尽量设置为NOT_NULL</strong></p>\n<p>（1），数据库表字段尽量设置为NOT_NULL：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 1，有些人可能认为设置为NULL相比于NOT_NULL不是更节省空间吗？但是实际上不是这样的，设计为NULL相比于NOT_NULL要多占用一个字节的空间</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 2，设计为NOT_NULL，这样在做查询的时候能够更好的避免空指针异常，且发生该类错误的时候能够更好的进行排查</p>\n<p><strong>四，上述第四条--表varchar类型字段长度尽量设置为2<sup>n</sup>-1</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>因为计算机只识别二进制，且有一定的范围，例如2<sup>8</sup>，在计算机中的范围为-128~127,因此对于varchar字段长度来说，如果设置为255，则正好是一个字节，而如果设置为256，则占用两个字节，这样会浪费计算机的内存空间，因此数据库varchar类型字段的长度最好设置为2<sup>n</sup>-1</p>\n<p><strong>五，上述第五条--对于设置enable字段的解释</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>enable字段，字面意思启用，在这里表明是否启用（0否1是），因为系统分为前台博客页面和后台管理，对于这两个不同的前端项目，后台可以通过启用字段来控制内容在前台博客页面的展示与否，与deleted字段不同的是，如果执行删除操作，那么我们只能通过手动修改数据库中的字段进行数据的恢复，且如果执行删除操作，则该数据在前台博客页面和后台管理页面都无法看见。但是如果将数据弃用（即修改enable字段值为1），则表明该数据被弃用，在前台博客页面无法显示，但是在后台管理页面可以看见，且无需通过手动修改数据库来恢复数据，可以在后台管理页面操作启用数据。</p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1247745014683947008","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dDViAcnjvAACb6PL1tzA485.jpg","blogRead":21,"blogRemark":"博客开发总结（一）-----之数据库设计篇","blogTitle":"博客开发总结（一）-----之数据库设计篇","createdTime":"2020-04-08 04:36:07","typeName":"博客开发和维护总结","updateTime":"2020-04-20 10:47:54"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，前后端分离开发优势</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，</strong>项目开发过程中，前后端完全解耦，前端只需要负责页面的实现，只需要通过接口拿数据。后端不需要管页面的跳转，只需要负责接口的编写</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，</strong>前后端人员有更多的精力去负责自己的工作，前端人员可以将更多的精力投放在页面的编写，页面的美化，页面特效的制作和用户体验上；而后端人员可以将更多的精力放在接口代码的优化，sql优化，jvm调优上面</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，</strong>前后端分离的项目部署的时候，前端项目往往都是部署在nginx服务器上，而前后端不分离的项目往往都是部署再一台服务器上。因此前后端分离项目大大降低了服务器的负担</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>4，</strong>前后端不分离的项目使用模板引擎例如freemaker，thymeleaf等，前后端人员交流起来较为困难。且前端项目使用原生的DOM操作，极大的增加了前端工作人员的工作量。而前后端分离项目前端通常都是用各种ui框架，框架采用MVVM模式，极大的减轻了前端工作人员的工作量</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，</strong>前后端分离开发，前端可以通过easy-mock来伪造接口数据进行测试，后端人员可以通过postman进行接口测试，开发效率大大提升。</p>","blogGoods":0,"blogId":"1247867141693128704","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dG6CAI6ipAACiM2P5LtI65.jpeg","blogRead":7,"blogRemark":"前后端分离开发的优势所在","blogTitle":"闲谈前后端分离开发","createdTime":"2020-04-08 12:41:25","typeName":"随笔","updateTime":"2020-04-20 11:48:53"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，css之弹性布局</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，</strong>何为弹性布局？</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 弹性布局是css的一种新的布局方式，所谓&ldquo;弹性布局&rdquo;，即页面随着不同设备的屏幕大小拉伸会自适应页面的大小。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，</strong>弹性布局的两种主要元素，container（弹性容器），item（弹性子元素），一个弹性容器中可以放入多个弹性子元素，元素之间是可以进行嵌套的，弹性子元素也可以设置为弹性容器，里面再嵌套弹性子元素。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，</strong>弹性布局的基本属性</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （1）display：flex，声明容器为弹性布局</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （2）flex-direction：声明弹性容器内部元素的排列方式，默认为row。row（横向布局），row-reverse（横向布局，但是元素反方向码），column（纵向布局），column-reverse（纵向布局，但是元素反着码）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （3）flex-wrap：声明弹性盒子中的元素是否可以换行，默认为nowrap（不换行），wrap（换行），wrap-reverse（换行，但是反着码）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （4）align-items：设置容器中元素在纵轴方向上的对齐方式，默认为stretch（即如果不设置子元素高度，则默认拉伸至于容器同宽度），flex-start（子元素位于容器的开始位置），flex-end（子元素位于容器的结尾处），center（元素依纵轴方向居中），baseline（元素位于容器基线，不过没怎么用过，所以不是很清楚）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （5）justify-content（设置元素在主轴上的对齐方式），默认为flex-start（元素从容器主轴开始位置码），flex-end（元素从容器主轴结尾处码），center（元素位于主轴居中处），space-between（元素布局在容器的两端），space-around（元素布局在容器两端，但是元素前后都留有空白）因为项目中大多数只使用了对于容器的操作，对于容器中元素的操作很少，所以这里只介绍这点。谢谢阅读！</p>","blogGoods":0,"blogId":"1248135765829918720","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dGnuAWkLLAAAaRXQXNms575.jpg","blogRead":3,"blogRemark":"CSS----之flex弹性布局","blogTitle":"CSS----之flex弹性布局","createdTime":"2020-04-09 06:28:51","typeName":"CSS","updateTime":"2020-04-20 11:43:57"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2 style=\"text-align: left;\"><strong>一，JVM运行机制</strong></h2>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;jvm即java虚拟机，一共由四个部分组成，分别是类加载器子系统，运行时数据区（程序计数器，本地方法区，jvm栈，方法区，jvm堆），执行引擎（即时编译器，垃圾收集器），本地接口库。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;一个java源程序的运行先是经过编译器将其编译成字节码文件（class文件），然后通过类加载器子系统将其加载进入jvm&mdash;&mdash;&gt;程序运行过程中，运行时数据区存放程序运行过程产生的数据&mdash;&mdash;&gt;执行引擎中的垃圾收集器收集程序运行过程中创建的不再使用的对象，即时编译器将程序的字节码文件编译成机器码&mdash;&mdash;&gt;然后本地接口库利用机器码调用本地方法库中的方法，和操作系统实现交互。</p>\n<h2><strong>二，多线程</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;</strong>在多核操作系统中，jvm支持一个进程中同时并发执行多个线程，且这些线程和本地操作系统的线程相对应。当jvm中的对象初始化，内存空间分配等一系列准备工作完成之后，会调用操作系统中的接口创建一个原生线程，原生线程初始化完毕后，会调用java线程的run（）方法执行该线程，线程结束之后，jvm会释放原生线程和java线程资源。</p>\n<h2><strong>三，JVM的内存区域</strong></h2>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM的内存区域主要分为线程私有区域（程序计数器，本地方法区，JVM栈），线程共享区（方法区，JVM堆）和直接内存。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;程序计数器：线程私有区域，无内存溢出，用来记录程序运行过程中的字节码指令地址，如果是Native方法，则程序计数器为空。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM栈：线程私有区域，用来描述java程序的运行过程，java程序运行每次运行的时候，都会创建一个栈帧，方法的执行和返回对应着栈帧的入栈和出栈操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;本地方法区：线程私有区域，和JVM栈的功能一样，只不过是用来记录Native方法的运行过程。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM堆：线程共享区，主要用来存放程序运行过程中产生的数据，同时也是垃圾收集器进行垃圾回收的主要区域。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;方法区：也被称为永久代，用来存放常量，静态变量，类信息等等。</p>\n<h2><strong>四，JVM的运行时内存</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>JVM的运行时内存又被称为JVM堆，因为JVM的GC算法使用的是分代收集算法，所以JVM堆按照GC标准可以分为三个区域分别为：新生代，老年代，永久代。其中新生代占1/3，老年代占2/3，永久代很少，</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;新生代：存放短生命周期，小对象的区域。新生代又分为Eden区，ServivorTo区，ServivorFrom区，区域的GC算法采用复制算法。Eden区是用来存放新创建的对象（大对象除外），ServivorTo区是用来保存MinorGC幸存下来的对象，ServivorFrom区是用来将上一次MinorGC幸存下来的对象作为下一次MinorGC的扫描对象。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;老年代：存放长生命周期的大对象，区域的GC算法采用标记整理算法</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;永久代：主要用来存放class和meta数据信息的。程序运行过程中不会进行永久代的垃圾回收，这也就导致永久代区域的数据会越来越多，最终造成内存溢出。java8之后永久代已经被元数据区取代，元数据区和永久代的功能都是一样的，但是最大的不同在于永久代区域依赖于虚拟机的内存大小，因而可以存储的class，meta信息非常有限。但是元数据区依赖的是本地操作系统，因而不会受到虚拟机内存的限制。</p>\n<h2><strong>五，垃圾回收与算法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;(1)垃圾回收：</strong>Jvm的垃圾回收判定依赖于两种方法，引用计数法和可达性分析法。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;引用计数法：即如果想要在程序中使用对象，就必须赋予一个引用，这样在对象赋予引用的时候将其引用计数加1，删除一个引用时，将对象引用计数减1，如果引用计数为0，就说明该对象已经不使用，作为垃圾。但是引用计数法存在一个缺陷，即循环引用的问题，如果两个对象相互引用，则这两个对象的引用计数永远都不会为0，造成对象无法被回收。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;可达性分析法：即先创建一些根节点对象ROOTS，然后通过这些根节点对象向下搜索，如果一个对象到任意一个ROOTS之间都没有可达路径，在经过两次标记（下文解释为什么进行两次标记），还是没有可达路径，则说明该对象可回收。</p>\n<p>&nbsp;&nbsp; &nbsp;<strong>（2）GC算法：</strong>常见的GC算法有四种，分别为标记清除算法，复制算法，标记整理算法，分代收集算法</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;标记清除算法：即在进行垃圾回收前，对所有对象进行一次标记，标记可回收的对象，然后进行清理即可。但是标记清除算法在清除回收对象之后，并不会对堆内存进行整理，这样的话如果内存中的对象大部分为小对象，清理之后就会导致没有大片连续的内存空间，即造成了内存碎片化，这样大对象存储的时候就无法找到相应的完整连续内存。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;复制算法：即将内存分为两块同等大小的区域，区域1和区域2，创建的新对象都存储在区域1中，当区域1中的内存占满之后，会对内存中的所有对象进行一次标记，标记存活的对象，将存活的对象复制到区域2，这时区域1中的对象都是可回收对象，回收区域1中的所有对象即可。但是复制算法也存在着一定的缺陷，即每次都只能使用一半的内存空间，造成了大量的内存浪费。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;标记整理算法：即结合标记清除算法和复制算法的优点，先对所有的对象进行标记，标记存活的对象，将存活的对象复制到内存的另一端，然后清除当前端的对象即可。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;分代收集算法：前面的三种算法，都无法按照对象的类型进行收集，分代收集算法正是解决这个问题，按照对象的不同类型采用不同的GC算法。以JVM的分代收集算法为例，JVM的堆内存分为新生代，老年代，永久代。新生代又分为Eden区，ServivorTo区和ServivorFrom区。新生代因为其存储生命周期短的小对象，GC比较频繁，所以采用复制算法。程序运行过程中创建的对象都存储在Eden区（大对象除外，大对象直接复制到老年代区域）。当Eden区的内存不够的时候进行MinorGC，然后将Eden区和ServivorFrom区的存活对象都复制到ServivorTo区，然后将ServivorTo区和ServivorFrom区进行交换，再次进行MinorGC。老年代因为存放的都是生命周期长的大对象，因而进行GC的不会太频繁，且清除的对象并不会太多，因而采用标记整理算法。老年代每次进行MajorGC之前都会先进行一次MinorGC，当MinorGC之后新生代的内存仍然不够的时候，将对象复制到老年代进行MajorGC。永久代区域主要回收常量，无用class等。</p>\n<h2><strong>六，JAVA中的四种引用类型</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;强引用类型<strong>：</strong>即把对象赋给一个引用变量，强引用的对象一定为可达状态，所以不会进行垃圾回收。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;软引用类型：通过SoftReference类实现，当内存不够的时候对其进行GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;弱引用类型：只有弱引用类型的对象，一定会被GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;虚引用类型：虚引用对象主要是用来跟踪对象的GC状态</p>\n<h2><strong>七，分代收集算法和分区收集算法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>分代收集算法：新生代因其存放大量短生命周期小对象，且GC频繁，所以采用复制算法。老年代因其存放长生命周期大对象，且GC不平凡，所以采用标记整理算法。永久代，回收常量，类信息等。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;分区收集算法：即将堆内存区域分为大小不同的区，可以按照不同的区进行快速垃圾回收，减少系统的停顿时间。然后再以并行的方式逐步完成整个GC。</p>\n<h2><strong>八，垃圾收集器</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>新生代区域：Serial垃圾收集器，单线程复制算法，因为单线程无需进行线程之间的交互和切换，所以效率非常高，是JVM默认的client模式下的默认垃圾回收策略，工作期间需要暂停其它所有的线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ParNew垃圾收集器，多线程复制算法，跟单线程Serial一样，是JVM默认的server模式下的垃圾回收策略，工作期间需要暂停所有其它线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Parallel Scavenge垃圾收集器：多线程复制算法，不同的是优先考虑系统吞吐量，可以利用更高效的利用CPU完成GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;老年代区域：Serial Old垃圾收集器，单线程标记整理算法，同新生代的Serial功能一样，只是采取的算法不同而已。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Parallel Old垃圾收集器：多线程标记整理算法，优先考虑了系统的吞吐量，其次考虑停顿时间。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CMS,多线程标记清除算法，优先考虑系统GC时的停顿时间，且过程分为四步（<span style=\"background-color: #ffff00;\">解释上文的可达性分析中的两次标记</span>，第一步：标记GC ROOTS可达对象，暂停其它工作线程；第二步：和用户线程一起工作，跟踪GC ROOTS；第三步，因为第二步用户进程没有暂停，所以有些对象状态</p>\n<p>可能发生了改变，重新进行标记；第四步，清除不可达对象）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; G1垃圾收集器，多线程标记整理算法，将内存分区，与CMS相比，一方面不会产生内存碎片，一方面，可以精确的控制系统停顿时间。</p>\n<h2><strong>九，JAVA的网络编程模型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;</strong>阻塞I/O模型：即用户线程发出I/O请求之后，内核会检查数据是否准备就绪，这时候用户线程始终处于阻塞状态等待数据准备就绪。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;非阻塞I/O模型：即用户线程不断的给内核发出I/O请求，内核接受到I/O请求之后会返回一个状态，如果数据准备就绪，就将数据复制进入用户线程，如果数据没有准备好，返回一个false，用户线程无需阻塞，可以去处理其它事情，而当数据准备好了且刚好用户线程发起I/O请求进行操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;多路复用I/O模型：多路复用I/O模型通过一个Selector线程轮询Socket的状态，如果Socket有读写事件，则进行I/O操作。此模型的优势在于可以更好的处理连接数众多但消息体不大的情况下。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;信号驱动I/O模型：即用户线程发出一个I/O请求，系统会为该请求创建一个信号函数，用户请求可继续执行其它业务逻辑，当内核数据准备就绪之后会返回给用户线程一个信号，用户线程接收到之后进行I/O操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;异步I/O模型：用户线程给内核发起一个asynchronous read操作，内核接收到之后，返回其请求是否成功，然后等待数据准备成功之后复制到用户线程。整个过程中请求的发起和数据读取都在内核中进行，最终发送一个信号告知用户线程I/O操作已经完成，用户直接使用数据就行。（说实话个人感</p>\n<p>觉和信号驱动很像）</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;java NIO：没怎么读懂（<span style=\"background-color: #993300;\">记得补充！</span>）</p>\n<h2><strong>十，JVM的类加载机制</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>JVM类加载分为五个阶段：加载，验证，准备，解析，初始化</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;加载：即将class文件加载到JVM中，且创建class对象，封装其数据结构。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;验证：对class文件进行验证，确保符合JVM的标准，保证JVM的安全。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;准备：即方法区中给类变量分配空间和赋初值。static修改的会在初始化阶段赋值，final修饰的会在准备阶段赋值。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;解析：即将常量池中的引用替换为直接引用</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;初始化：执行类构造器进行初始化。（因为内部流程不是很清楚，所以对于其几种不进行初始化的情况不做说明）</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;类加载器：JVM提供了三种类加载器，启动类加载器（/lib），扩展类加载器(/lib/ext)，应用程序类加载器(classpath)。还可以再应用程序类加载器自定义类加载器。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;双亲委派机制：即当一个类接收到类加载请求的时候，不会自己进行加载，而是将其加载请求委派给其父类加载器，这样一路委派，最终加载请求都会委派到启动类加载器.启动类加载器接收到加载请求之后会去lib目录下寻找相关的class文件，若找不到，则将其加载请求再委培给子类加载器，一路委派，直到能够加载。</p>\n<h3><strong>最后，送给大家一张博主画的JVM的思维导图，以后读《深入JVM虚拟机》的时候可能会出一个JVM专题：<a href=\"https://uploader.shimo.im/f/X0MX3hLaHrevltxW.png!thumbnail\" target=\"_blank\" rel=\"noopener\">JVM思维导图</a></strong></h3>\n<p>&nbsp;</p>\n<h2>水平有限，若发现有误，还望指出！</h2>","blogGoods":0,"blogId":"1248224512563068928","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHLeALxSjAABJTVJPTfk677.jpg","blogRead":17,"blogRemark":"面试（一）------之JVM篇","blogTitle":"面试（一）------之JVM篇","createdTime":"2020-04-09 12:21:30","typeName":"java面试篇","updateTime":"2020-04-20 11:53:29"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，Linux的发展历史</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; </strong>1965年之前，电脑并不像现在这么普遍，除了军事机构和研究即构，一般人基本接触不到电脑，而且那时候的一台大型主机最多也就只能支持30台终端。为了解决数量问题，1965年之后，由贝尔实验室，麻省理工学院以及通用电气一起放弃了Multics项目，准备让大型主机能够支持300台终端，但是在开发过程中，进度缓慢，最终由于资金的短缺，贝尔实验室推出了研究。1969年，从这个项目中退出的Ken Thompson在家无聊，为了让电脑能够运行&ldquo;星际旅行&rdquo;游戏，因而趁着妻子回家探亲的一个月，独自写出了Unix操作系统的原型（！！！！牛批）。1970年，这个人以BCPL语言为基础，又写出了很接近硬件的B语言，并且用B语言写出了第一个Unix操作系统。但是由于B语言的跨平台性比较差，为了解决这个问题。Dennis Ritchie和Ken Thompson决定以B语言为基础开发一种新的语言，1972年，Dennis Ritchie最终设计出了一种新语言，他以BCPL的第二个字母命名，也就是我们后来熟知的C语言。随后两人便迫不及待的用C语言重现Unix操作系统。Unix系统起初开源，但是在Unix7之后，由于政策的变化，代码闭源化，因而大学中不能使用Unix的源代码进行教学。Andrew S. Tanenbaum教授为了能够让学生更好的理解代码细节，在完全不使用任何源代码的情况下开发除了Minix---小型Unix。但是因为其只用于教学，功能并不强大，因而Torvalds以此为基础，开发除了Linux，但是起初Linux并不支持Unix，最终经过全世界网友的帮助，最终让其能够兼容各种硬件。</p>\n<p><strong>二，文件和目录</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; 1，windows和linux的区别：</strong>我们熟知的windows系统，它的文件系统是分盘符的，盘符下的文件构成一个树形结构，但是Linux文件系统没有盘符，所有文件目录都在根目录/之下</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;<strong>2，Linux需要记住的目录：</strong>/bin（存放系统命令的目录），/sbin（只有超级管理员能访问的命令文件目录），/root（存放和root用户相关文件的目录），/etc（存放系统配置文件的目录），/usr（存放系统共享资源的目录），/opt（存放安装的第三方软件的目录，通常在/usr/local下）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;<strong>3，文件权限：</strong>Linux中的文件权限有读（r，可用于数字4表示），写操作（w，可用数字2表示），执行权限（x，可用数字1表示）</p>\n<p><strong>三，常用命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，ls：</strong>列出目录中的所有目录和文件名&nbsp; -a（列出所有，包括隐藏文件和目录），-l（以列表形式列出所有），-h（人性化列出，需要配合-l使用，即文件大小转换为我们熟知的kb，mb等），-d（显示当前目录属性），命令可以联合使用，例如-al，-lh等等。&nbsp;&nbsp;&nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，cd：</strong>用于切换目录，需知（.和..是相对路径，.表示当前目录，..表示上级目录；/表示绝对路径），cd ~（切换到root目录），cd - （切换到前一次切换的目录）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，clear：</strong>清屏</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，pwd：</strong>显示当前所在目录</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，mkdir：</strong>创建目录，-p（如果目录存在则不创建，如果不存在则创建目录再创建自目录），可以一次性创建多级目录，例如：mkdir&nbsp; -p test/test1</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，touch：</strong>创建空文件</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>7，cp：</strong>复制，-r（递归复制目录下的文件目录信息），-i(提示是否覆盖)，-v（显示复制进度）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>8，mv：</strong>移动文件，不过经常用来给文件进行重命名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>9，rm：</strong>删除目录或者文件，-r（递归删除），-f（强制删除），-v（显示删除进度）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>10，cat：</strong>查看文件内部信息</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>11，ln：</strong>文件创建链接，ln 源文件 目标链接文件（创建硬链接，硬链接和源文件大小相同，修改同步，但是删除不同步，使用较少），ln -s（创建软连接，相当于我们平时创建快捷方式，使用较多）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>12，which：</strong>搜索命令所在位置，例如：which&nbsp; &nbsp;ls</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>13，find：</strong>搜索文件所在位置&nbsp; 例如：find&nbsp; &nbsp;test.conf</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>14，grep：</strong>文件内容搜索，例如：grep &ldquo;想要搜索的内容&rdquo;&nbsp; 源文件</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>15，tar：</strong>归档命令，-c（打包成.tar文件），-z（打包的同时压缩），-v（打包的同时显示进度），-f（放在最后，后面跟.tar.gz），-x(解压)，常用：tar -zcvf&nbsp; <em><strong>.tar.gz&nbsp; &nbsp; ;&nbsp; &nbsp; tar -zxvf</strong> tar.gz</em> -C&nbsp; 指定解压目录&nbsp;&nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;还有more，head，tail等命令，不过这些不常用。</p>\n<p><strong>四，用户权限命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，whoami：</strong>查看当前账户的用户名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，who：</strong>查看当前登录用户</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，exit：</strong>退出登录</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，adduser/useradd：</strong>添加用户，-d（指定用户主目录），-g（指定用户用户组），-m（自动建立目录），默认情况下用户主目录和用户组名都和用户名一样</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，passwd：</strong>只有root用户才能使用，用于修改用户密码</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，userdel：</strong>删除用户，默认不删除用户的主目录，-r（删除用户主目录）</p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;7，su：</strong>切换账户</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>8，groupadd/groupdel：</strong>添加用户组和删除用户组</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>9，groups：</strong>查看用户所在用户组，例如：groups&nbsp; 用户名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>10，usermod：</strong>修改用户所在用户组，例如：usermod&nbsp; 用户组名 用户名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>11，chmod：</strong>修改文件权限，例如：chmod&nbsp; 777&nbsp; test</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>12，chown：</strong>修改文件所有者，例如：chown&nbsp; &nbsp;用户&nbsp; 文件名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>13，chgrp：</strong>修改文件所在组，例如：chgrp&nbsp; 组名&nbsp; 文件名</p>\n<p><strong>五，系统命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，cal：</strong>查看日历</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，date：</strong>查看时间，可以设置格式，例如：date '+<span class=\"ql-token hljs-built_in\">%Y</span>-<span class=\"ql-token hljs-built_in\">%m</span>-<span class=\"ql-token hljs-built_in\">%d</span> <span class=\"ql-token hljs-built_in\">%H</span>:<span class=\"ql-token hljs-built_in\">%M</span>:<span class=\"ql-token hljs-built_in\">%S</span>'</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，ps：</strong>查看线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，kill：</strong>杀死线程，-9（强制杀死）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，查看网卡信息：</strong>centos6：ifconfig ；centos7：ip addr</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，ping：</strong>查看网址或者链接的连通性</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>7，防火墙：</strong>centos6：service&nbsp; iptables&nbsp; status（查看防火墙状态），service&nbsp; &nbsp;iptables&nbsp; &nbsp;start(开启),service&nbsp; iptables&nbsp; stop(关闭);centos7:firewall-cmd&nbsp; --state（查看防火墙状态），systemctl&nbsp; start&nbsp; firewalld.service(启动)，systemctl&nbsp; &nbsp;stop&nbsp; firewalld.service（关闭）</p>\n<p><strong>六，网络命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，wget：</strong>下载，例如：wget&nbsp; &nbsp;链接地址</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，yum：</strong>下载安装</p>\n<p><strong>七，vim（这里只说几个常用的命令）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;</strong>vim有三种模式：命令模式，插入模式，编辑模式&nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;vim&nbsp; 文件名：进入文件，且处于命令模式；iao任意一键进入插入模式（i表示在贯标之前插入，a光标之后插入，o在下一行插入），：进入编辑模式</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;命令：set:nu显示行号，set:nonu不显示行号；/strinng，向后搜索字符串，？string向后搜索字符串；：w保存，：wq保存并退出，：q不保存退出</p>","blogGoods":0,"blogId":"1248500061625745408","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dDA6AfCOJAAAyfL52jxY706.jpg","blogRead":2,"blogRemark":"Linux基本命令总结","blogTitle":"Linux基本命令","createdTime":"2020-04-10 06:36:25","typeName":"Linux","updateTime":"2020-04-20 10:42:25"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，集合</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，List：</strong>list是java中一种有序的集合，下有三个实现类，分别为ArrayList，Vector，LinkedList</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ArrayList：基于数组实现，增删慢，查询快，线程不安全。因为其基于数组实现，所以查询的时候可以直接根据数组的索引下标进行快速查询，但是进行增删操作的时候，需要将待增删元素后的元素全部移动，因而效率较低。且ArrayList创建时不需要分配初始大小，其空间不够的时候，会自动创建一个更大的list，然后复制数据。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Vector：基于数组实现，和ArrayList一样增删慢，查询快。但是线程安全，因为同一时间只支持一个线程对Vector进行写操作，然而因为要进行频繁的加锁和释放锁的操作，所以效率要低于ArrayList。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; LinkedList：基于双向链表实现，增删快，查询慢。因为基于链表实现，增删元素的时候，只需要改变元素的指针即可，改动较小，效率较高。然而进行查询操作的时候，需要从链表头部进行遍历，因而效率较低。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，Queue：</strong>队列，满足先进先出，种类较多。（不作详细解释）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，set：</strong>具有独一无二的特性，常用来存储无序且不重复的元素，对象相等的本质是hashcode的值相同，而如果想要比较两个对象是否相等，需要重写对象的hashcode方法和equals方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;hashset：基于hashTable实现，无序。存放的是对象的散列值，即通过hashcode计算得到的值</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;treeset：基于二叉树实现，即其中的对象按照一定的排序方式进行排列（升序，降序），每次添加对象的时候，都会进行排序，将其插入指定位置。基本的数据类型例如Integer，String等可以使用treeset默认的排序方法，而自定义数据类型需要实现compareable接口，实现compareTo方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;LinkHashSet：继承自hashset，只不过使用双向链表记录数据的顺序。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，map：</strong>一种键值对形式的集合</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;hashmap：基于数组+链表实现，增删改查操作快，但是每次遍历hashmap元素的顺序无法保证且线程不安全。如果想要其线程安全，可以使用synchronizedMap和ConcurrentHashmap，hashmap的内部是数组，数组中的每一个元素又是一个单向链表，链表中的每个元素嵌套一个Entry实例，其中包括Key，Value，Hash值，指向下一个节点的next。每次查询的时候，可以根据元素的hash值很快定位所在数组，但是定位之后需要遍历链表查找元素，因而时间复杂度为O（n），但是Java8之后对其进行了优化，将其改为了数组+链表或红黑树的结构，即当链表中的元素大于8个的时候，链表会转换为红黑树（红黑树是一种特化的二叉平衡树，因为其左右子树的深度差可以大于1），这样查询的时间复杂度就缩短到了O（logN）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ConcurrentHashmap：采用分段锁的思想进行并发操作，因而使线程安全的。由多个Segment组成，只要保证每个Segment线程安全就可以保证全局线程安全。ConcurrentHashmap的默认Segment即并发度为16，可以在初始化的时候修改，但是初始化之后不能再修改。每个Segment内部的实现和hashmap一样&middot;。Java8之后也和hashmap进行了一样的优化。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;HashTable：线程安全，即同一时刻只能有一个线程对其进行操作，并发度不如ConcurrentHashmap。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;TreeMap：基于二叉树数据结构实现，实现了SortedMap，默认按照键值的升序进行排列。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;LinkedHashMap：Hashmap的子类，只不过使用链表保存元素的插入顺序。使用迭代器遍历的时候按照插入顺序遍历。</p>\n<h2><strong>二，异常分类及处理</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;1，异常分类：</strong>Throwable是所有异常类的父类，其下有error和Exception，Error下有AwtError，ThreadDeath；Exception下有RuntimeException和CheckedException。</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</strong>对于Error类异常通常是由内部错误和资源耗尽造成的，无法在程序运行期间对其进行捕获和处理，对于这类错误我们只能记录错误的原因和终止程序。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; Exception中的RuntimeException异常（运行时异常）：这类异常是我们程序中异常处理的核心，可以在程序中进行捕获并处理。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Exception中的CheckedException异常（检查异常）：这类异常时程序中需要强制捕获的异常，通常有IO异常，SQL异常等等。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，异常处理：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>异常处理有两种方式：抛出异常和捕获异常</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;抛出异常有三种方法：throws，throw，系统自动抛出。其中throws是作用在方法上，后面跟的是可能产生的异常类。throw是作用在方法内部，后面跟的是具体的异常对象。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 捕获异常：即使用try{}catch语句进行捕获</p>\n<h2><strong>三，反射机制</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，什么叫做反射机制？</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>即在程序运行的过程中，可以获取类的属性和方法，并且可以调用任意一个类的方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，反射机制的使用</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 首先，获取类的class对象，有三种方式，className.getClass()，类对象.class，Class.forName(\"类路径\")，其中最后一种最为安全，性能最好。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 然后利用反射的API可以实现对类中信息的操作，例如getDeclareFields（），getDeclareMethods（），getConstroctors（）等等。反射创建类的对像有两种方法，一，class.newInstance()初始化一个类实例；二，先获取其构造器，然后利用构造器初始化一个实例。利用反射调用类的方法：先获取方法，然后调用method.invoke()执行方法。</p>\n<h2><strong>四，注解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，四种元注解：</strong>@Target（指定注解的使用范围），@Retention（定义注解的保留级别，有三级，SOURCE源程序中保存，CLASS文件中保存，RUNTIME运行时保存），@Documented（可以工具文档化），@Inherited（<span style=\"background-color: #ffff00;\">这个没怎么看懂</span>）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，注解使用示例：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>第一步，定义注解接口</p>\n<pre class=\"language-java\"><code>@Target(ElementType.FIELD)  \n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface FruitProvider {\n\n    //id\n    public int id() default  -1;\n\n    //供应商名称\n    public String name() default \"\";\n\n    //供应商地址\n    public String address() default \"\";\n\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 第二步，使用注解</p>\n<pre class=\"language-java\"><code>public class Apple {\n\n    @FruitProvider(id = 1,name = \"红富士苹果\",address = \"陕西\")\n    private String appleProvider;\n\n    public String getAppleProvider() {\n        return appleProvider;\n    }\n\n    public void setAppleProvider(String appleProvider) {\n        this.appleProvider = appleProvider;\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第三步，定义注解处理器</p>\n<pre class=\"language-java\"><code>public class FruitInfoUtil {\n    public static void getFruitInfo(Class&lt;?&gt; clazz) {\n        String strFruitProvider = \"供应商信息:\";\n        Field[] declaredFields = clazz.getDeclaredFields();\n        for (int i = 0; i &lt; declaredFields.length; i++) {\n            if (declaredFields[i].isAnnotationPresent(FruitProvider.class)) {\n                FruitProvider annotation = declaredFields[i].getAnnotation(FruitProvider.class);\n                strFruitProvider += annotation.id() + \",\" + annotation.name() + \",\" + annotation.address();\n                System.out.println(strFruitProvider);\n            }\n        }\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第四步，主方法入口</p>\n<pre class=\"language-java\"><code>public class FruitRun {\n    public static void main(String[] args) {\n        FruitInfoUtil.getFruitInfo(Apple.class);\n    }\n}</code></pre>\n<h2><strong>五，内部类</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 1，静态内部类：</strong>即在类的内部定义的静态类，静态内部类可以访问外部了的静态变量和方法，外部也可以通过outClassName.innerClassName调用内部类</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2，成员内部类：</strong>在类的内部定义的没有用static修饰的内部类，使用方式和静态内部类一样。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>3，局部内部类：</strong>即一个类只在一个方法中使用，则完全可以将这个类定义为这个方法的内部类，即局部内部类，局部内部类可以实现真正的对外隐藏</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>4，匿名内部类：</strong>通常用于继承一个类或者实现一个接口的时候，使用new关键字定义，例如:Person person = new Student(){new Pupil(){}}</p>\n<h2><strong>六，泛型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 1，为什么要使用泛型：</strong>其根本目的是为了实现代码的复用，举个开发中常见的例子，我们需要定义返回类Result，返回类中包含状态码code，信息msg，以及数据data（任意类型），这个时候我们就需要使用泛型，因为我们返回的数据类型有各种vo，pojo类对象，list等。这时候泛型类result就可以被各种对象使用，实现代码的复用，简化开发。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>2，泛型标记和泛型限定：</strong>E表示集合中的元素，K表示键值，V表示value，N表示数值类型，T表示任意类型（包含基础类型，所有的对象类型），？（不确定的java类型）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>泛型限定：</strong>向上限定，&lt;?&nbsp; extends T&gt;，向下限定，&lt;? super&nbsp; T&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; <strong>3，泛型方法：</strong>即参数类型定义为泛型类型，以便于接收不同类型的参数，做出不同的处理。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>4，泛型类：</strong>例如public class Pair&lt;T&gt;{private T data;}</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>5，泛型接口：</strong>与放泛型类类似</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>6，类型擦除：</strong>即在泛型编译的过程中，会将泛型类型替换为限定类型的操作</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>7，明确的一点：</strong>虚拟机在运行程序的过程中，内部是没有泛型的，只有普通的类和方法。</p>\n<h2><strong>7，序列化</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 序列化是为了确保对象及其状态的持久化</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>序列化的使用：</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </strong>首先，实现序列化接口java.io.Serializble</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 然后，声明序列化ID，通常private static final&nbsp; long&nbsp; serialVersionUid&nbsp; = ***</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 因为序列化是保证对象及其状态的持久化，而静态变量是不属于对象，属于类本身的，所以序列化无法保存静态变量。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果需要序列化父类变量，则父类也要实现Serializable接口</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t'ransient修饰的属性不会序列化</p>\n<h3><strong>最后，提供一张思维导图供大家学习：<a href=\"https://images-cdn.shimo.im/es83SQH0CggucT7f__thumbnail\" target=\"_blank\" rel=\"noopener\">JAVA基础</a></strong></h3>\n<p>&nbsp;</p>\n<h2>水平有限，如有错误，还望指出！</h2>","blogGoods":0,"blogId":"1248605157059497984","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHMKAcvZ8AABJTVJPTfk020.jpg","blogRead":27,"blogRemark":"面试（二）------之JAVA基础篇","blogTitle":"面试（二）------之JAVA基础篇","createdTime":"2020-04-10 13:34:02","typeName":"java面试篇","updateTime":"2020-04-20 11:53:39"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，JAVA线程的创建方式</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>JAVA线程的创建有四种方式，分别为，继承Thread类，实现Runable接口，实现Callable&lt;Class&gt;接口，基于线程池。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>1，继承Thread方式：创建一个类继承Thread类，创建类的实例对象，调用start方法，继而执行线程的run（）方法，代码如下：</strong></p>\n<pre class=\"language-java\"><code>public class NewThread extends Thread{\n    public static void main(String[] args) {\n        NewThread thread = new NewThread();\n        thread.start();\n    }\n    @Override\n    public void run(){\n        System.out.println(\"create  a  new thread by Thread!\");\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>2，当子类已经继承了一个类，这时候就没法再继承Thread类了，这时候就可以实现Runable接口，实例化类的线程实例，创建Thread实例传入类的实例，执行start方法，继而执行run（）方法代码如下：</strong></p>\n<p>&nbsp;</p>\n<pre class=\"language-java\"><code>public class ThreadExample2 implements Runnable {\n    public static void main(String[] args) {\n        ThreadExample2 threadExample2 = new ThreadExample2();\n        Thread thread = new Thread(threadExample2);\n        thread.start();\n    }\n    @Override\n    public void run() {\n        System.out.println(\"create a new thread by Runnable!\");\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，有些情况下，我们需要再一个主线程中并发多个子线程执行同一个任务，然后回收子线程的返回值整理汇总，这时候就需要实现Callable&lt;Class&gt;接口，重写其call（）方法，用于计算结果。然床创建一个线程池用于提交线程，继而执行call方法，并且创建一个Future的list用于接收子线程逻辑代码即call方法的返回，最终遍历list，得到想要的返回值，如下：</strong></p>\n<pre class=\"language-java\"><code>public class ThreadExample3 implements Callable&lt;String&gt; {\n\n    private String name;\n\n    public ThreadExample3(String name){\n        this.name = name;\n    }\n\n    @Override\n    public String call() throws Exception {\n        return name;\n    }\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        ExecutorService pool = Executors.newFixedThreadPool(3);\n        List&lt;Future&gt; list = new ArrayList&lt;&gt;();\n        for(int i=0;i&lt;3;i++){\n            ThreadExample3 threadExample3 = new ThreadExample3(i+\"\");\n            Future future =pool.submit(threadExample3);\n            System.out.println(future.get().toString()+\" is running\");\n            list.add(future);\n        }\n        pool.shutdown();\n        for (Future future : list) {\n            System.out.println(\"currentThread's result is \"+future.get().toString());\n        }\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，基于线程池创建线程</strong></p>\n<pre class=\"language-java\"><code>public class ThreadExample4 {\n    public static void main(String[] args){\n        ExecutorService pool = Executors.newFixedThreadPool(3);\n        for(int i=0;i&lt;3;i++){\n            pool.execute(new Runnable() {\n                @Override\n                public void run() {\n                    System.out.println(\"thread  is running by FixedThreadPool\");\n                }\n            });\n        }\n        pool.shutdown();\n    }\n}</code></pre>\n<h2>二，线程池的工作原理</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong> &nbsp;1，概述：</strong>JVM根据用户提供的参数创建一定数量的线程任务，将其放入队列中，线程创建之后启动这些任务，如果线程的数量大于核心线程数量（用户设置的线程数量），则超出数量的线程排在队列中等待，当有线程任务执行完毕后，线程池调度器就会发现有可用可用线程，继而从队列中取出任务继续执行<strong>。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; </strong><strong>2，线程复用：</strong>（参见JDK源码解读，这里只做简单描述），由前可知，JVM会根据用户提供的参数创建一定数量的线程任务，且将其添加到任务队列中。JVM通过start（）方法创建一个线程之后， 会相应的为其创建一个任务队列，线程会不停的查看任务队列，如果任务队列中有任务，则调用run方法，执行，这样就达到了一次start（）创建线程，多次使用，完成线程复用的任务。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>3，线程池的核心组件和核心类（见JDK源码分类中关于线程的总结）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; </strong><strong>4，JAVA线程的工作流程：</strong>线程池刚被创建的时候，只是向系统申请一个执行线程队列和管理线程池的线程资源，当调用execute方法之后，执行下列流程：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果正在运行的线程数量小于corePoolSize（核心线程数量，即用户定义的的线程数量），则立即创建线程执行线程任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果正在运行的线程数量大于或等于corePoolSize，则将超过数量的线程加入到阻塞队列中</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在阻塞队列已满且线程数量小于MaximumPoolSize（即线程池能够容纳的最大线程数），线程池会创建非核心线程立即执行任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在阻塞队列已满且线程数量大于或等于MaximumPoolSize的时候，线程池会拒绝该线程任务且抛出异常</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在线程任务执行完毕之后，会将其从任务队列中移除，从队列中取出下一个线程任务执行</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在线程处于空闲状态且空闲时间超过KeepAliveTime，且线程数量大于corePoolSize的时候，会停止该线程，这样在没有任务的时候，线程池中的线程数始终维持在corePoolSize。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，线程池的拒绝策略：</strong>分为四种，分别为AbortPolicy，CallerRunsPolicy，DiscardOldestPolicy，DiscardPolicy</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; AbortPolicy：直接抛出异常，阻止线程运行，源码如下：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</p>\n<pre class=\"language-java\"><code>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n            throw new RejectedExecutionException(\"Task \" + r.toString() +\n                                                 \" rejected from \" +\n                                                 e.toString());\n        }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CallerRunsPolicy：如果线程任务没有关闭，则尝试执行该线程任务，源码如下：</p>\n<pre class=\"language-java\"><code>* @param r the runnable task requested to be executed\n* @param e the executor attempting to execute this task\n*/\npublic void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n     if (!e.isShutdown()) {\n         r.run()\n     }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DiscardOldestPolicy：移除任务队列中最早进入的线程任务，执行当前任务线程，源码如下：</p>\n<pre class=\"language-java\"><code>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n       if (!e.isShutdown()) {\n           e.getQueue().poll();\n           e.execute(r);\n       }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DiscardPolicy：直接丢弃线程任务，不做任何处理</p>\n<h2><strong>三，五种常用的线程池</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;newCachedThreadPool（可缓存线程池）：</strong>当线程池创建线程的时候如果发现有可复用的线程（执行完任务，且未关闭的线程），则直接复用，如果没有则创建新线程。可缓存线程池可以高效的利用执行任务时间短的线程，提高系统的性能，且线程池中的线程如果空闲时间超过60s，则会被终止且从缓存中移除，这样可缓存线程池不会占用系统资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>newFixedThreadPool（固定大小的线程池）：</strong>即线程池中的线程是初始化固定的，当任务线程大于线程池中线程数量时，任务线程就会进入阻塞队列等待。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newScheduledThreadPool（可做任务调度的线程池）：</strong>即可以设置线程执行的停顿时间和执行周期，进行定期定时的执行某个任务。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newSingleThreadPool（单个线程的线程池）:&nbsp;</strong>即线程池中永远只有一个线程进行工作，如果下称停止或者异常，则线程池创建新的线程替代当前线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newWorkStealingPool（足够大小的线程池）：</strong>即创建足够数量的线程的线程池，保证更快的进行运算，提高效率。</p>\n<h2><strong>四，线程的生命周期</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;线程的生命周期大致分为五个阶段：新建（new），就绪（Runnable），运行（Running），阻塞（Blocked），死亡（Dead）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;新建：</strong>即使用new创建一个线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>就绪：</strong>调用start方法，</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>运行：</strong>即线程获取cpu资源，执行run（）方法，进入运行状态，运行状态的线程如果调用yield（线程让步方法）或者失去cpu资源，都会导致线程重新回到就绪态；如果调用sleep方法，I/O阻塞，等待同步锁，等待通知以及suspend挂起都会导致线程进入阻塞态。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞：</strong>即线程被放入Blocked池。阻塞状态的线程如果结束了sleep方法，I/O方法返回，获取同步锁，收到通知或者resume都会导致其重新进入就绪态，与其它线程竞争cpu时间片。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>死亡：</strong>线程正常执行完run（）或者call（）方法，或者执行stop方法，或者发生异常或者错误都会导致线程死亡。（stop方法会导致锁混乱和死锁，不建议使用）</p>\n<h2><strong>五，线程的基本方法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;wait（线程等待）：</strong>会让线程进入WAITING状态，并且会释放对象的锁。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>sleep（线程睡眠）：</strong>会让线程进入睡眠，进入TIMED_WAITING状态，但是不会释放对象锁，睡眠时间到了之后，再次恢复运行状态</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>yield（线程让步）:</strong>&nbsp; 当前线程会让出其占有的cpu资源，重新回到就绪态和其它线程竞争cpu时间片</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>interrupt（线程中断）:&nbsp; </strong>中断当前线程，但是并不会导致其停止，只是改变其内部的终端标识位，在使用了thread.sleep()之后使用该方法，会导致抛出异常，且我们可以利用中断标识位进行线程的安全退出</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>join（线程加入）：</strong>即将当前线程进入阻塞态，等待下一个线程执行完毕后进入就绪态，重新竞争锁资源。通常用于主线程下面执行子线程，需要主线程阻塞，等待子线程执行完毕后返回其结果给主线程，主线程再执行的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>notify（线程唤醒）/notifyAll：</strong>前者随机唤醒一个等待线程，后者全部唤醒</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>setDaemon（守护线程）:</strong>级别较低的线程，用于后台运行，服务用户用户线程，例如垃圾收集线程就是典型的守护线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>sleep方法和wait方法的区别：</strong>前者属于Thread，后者属于Object，前者不会释放锁资源，后者会释放锁资源</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>start方法和run方法：</strong>start方法只是创建一个线程，并没有运行，run方法时执行线程的真正代码逻辑。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>线程退出的方式：</strong>见四中最后一条</p>\n<h2><strong>六，JAVA中的锁（知识比较杂乱）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述:JAVA中的锁是为了保护数据的一致性。按照不同的标准可分为乐观锁和悲观锁，公平锁和非公平锁，共享锁和独占锁，偏向锁，轻量级锁，重量级锁，自旋锁，可重入锁。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;乐观锁：</strong>即认为每次读取数据都不会被修改，当修改操作的时候再判断当前数据是否被修改，未修改则修改，若已被修改，则返回失败状态。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>悲观锁：</strong>即认为每次读取数据都会被修改，因而每次读取数据都对其进行加锁，这样只有当前用户可以修改，其它用户阻塞等待直到当前用户修改完毕释放锁资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>自旋锁：</strong>即有些线程任务的执行很短，很快就可以释放锁资源，为了避免在这种情况下竞争线程仍然进行内核态和用户态之间的转换，因而让线程自旋（即等一会），如果有可用锁，则获取，减少了线程在用户态和内核态之间切换的时间损耗。提高了性能（优势）。当然线程自旋是占用cpu资源的，因而需要设置一个自旋的最大等待时间，如果超过此时间，则线程退出自旋模式。对于线程竞争锁资源激烈的情况，自旋有可能会导致cpu资源的损耗（劣势）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>公平锁和非公平锁：</strong>即根据线程竞争锁资源的机制判定，一般如果依据先到先得的原则，则位公平锁；如果依据就近原则，则位非公平锁。公平锁相比于非公平锁会更加耗费性能，因为要维护一个线程任务丢列，根据线程任务在队列中的顺序分配锁资源，因而不常用。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>可重入锁：</strong>又被称为递归锁，即该锁可以然后线程对其进行多次的加锁操作。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>偏向锁：</strong>当线程获取到锁的时候，用来消除线程的锁重入的开销（看起来是偏袒这个线程）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>共享锁和独占锁：</strong>共享锁即多线程共享锁资源（典型例子，读锁）；独占锁即当前锁只能有一个线程获取，其它线程阻塞</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>轻量级锁：</strong>没有多线程竞争的前提下，减少重量级锁的使用提高性能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>重量级锁：</strong>基于操作系统的互斥量而实现的锁，会导致进程在用户态和内核态之间切换，耗费性能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>synchronized：独占式悲观锁，可重入锁，非公平锁，重量级锁。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 作用范围：</strong>作用于成员变量和非静态方法，相当于锁住的是对象的实例，即this对象</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;作用于静态方法，相当于锁住的是class实例</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;作用域代码块，相当于锁住的代码块中的对象</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>实现原理：</strong>内部包括ContentionList（锁竞争队列），EntryList（竞争候选列表），WaitSet（等待集合），OnDeck（竞争候选者），Owner，!Owner，其中ContentionList是用来存放竞争锁资源的线程。EntryList是用来存放有资格竞争锁资源的线程。调用wait方法后放入WaitSet中，onDeck指的是同一时刻，只有一个线程竞争锁资源，Owner指的是得到锁资源的线程，!Owner指的是线程执行完毕，释放锁资源的线程。需要注意的是线程首先采用的都是自旋模式获取锁资源，如果自旋获取不到再加入ContentionList，而且Owner状态的线程并不是直接把锁资源交给onDeck状态线程，而是给它竞争锁资源的权利，因而onDeck状态的线程还需要跟自旋线程竞争锁资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>ReentrantLock：独占式，可重入锁，并且可以实现公平锁和非公平锁，重量级锁。</strong></p>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;用法：</strong>lock()加锁，后跟try代码块，finally中进行释放锁unlock()</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;避免死锁的方法：</strong>响应中断（即可以根据情况中断对锁资源的请求），可轮询锁（tryLock（）即尝试获取锁，如果有可用锁则获取返回true，没有则返回。和lock（）的区别在于lock获取锁资源如果没有则一直等待直到获取到锁资源），定时所（tryLock（time,unit）即再一定时间内如果有可用锁，且线程未中断则获取锁，否则禁用当前线程。）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>Semaphore（信号量）:</strong>机制和ReentrantLock类似</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ReadWriteLock（读写锁）：</strong>如果系统要求支持多线程共享读，但不能多线程写，使用读锁；如果要求同一时刻只能有一个线程写，写的过程中不能读取该共享数据，则使用写锁。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; <strong>分段锁：</strong>一种思想，将数据分段加锁，例如ConcurrentHashMap</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;死锁：</strong>即线程之间互相共享资源会导致死锁</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; <strong>锁优化：</strong>第一，减少锁的持有时间；第二：减小锁粒度，例如分段锁；第三：锁分离，例如读写锁；第四：锁粗化，放置锁粒度太小，造成频繁加锁释放锁；第五：锁消除，消除程序代码不规范而造成的乱用了锁</p>\n<p>&nbsp;</p>\n<h3><strong>并发编程（上）的思维导图送上：<a href=\"https://images-cdn.shimo.im/1UcHkyrlJyGRPYnn.png__thumbnail\" target=\"_blank\" rel=\"noopener\">并发编程（上）</a></strong></h3>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>\n<h1>水平有限，如果错误，还望指出！</h1>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;</p>","blogGoods":0,"blogId":"1249313090567143424","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHM2AQOeZAABJTVJPTfk967.jpg","blogRead":8,"blogRemark":"面试（三）------之并发编程篇（上）","blogTitle":"面试（三）------之并发编程篇（上）","createdTime":"2020-04-12 12:27:07","typeName":"java面试篇","updateTime":"2020-04-20 11:53:51"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，redis简介</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>redis是NoSQL型系统之一，与之相似的还有Memcache，用来存储key-value这种键值型数据。相比于Memcache而言，redis不仅可以做临时缓存，还可以做数据持久化，将数据定时的存入硬盘或者将命令追加到日志文件当中。而Memcache只能做临时缓存，因而现在基本上已经被redis完全取代。redis的读写速度非常快，官方给出的数据是读110000次/s，写81000次/s；而且redis支持多种数据类型，例如String，list，hash，set，zset；redis支持主从复制（集群），进行数据持久化；还支持过期时间，事务等。</p>\n<h2><strong>二，redis的安装与启动（docker环境下）</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;docker安装完毕后，安装redis：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第一步：拉取redis镜像，docker&nbsp; pull&nbsp; redis</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第二步：启动redis，docker&nbsp; &nbsp;run&nbsp; &nbsp;redis&nbsp; &nbsp;</p>\n<p><strong>三，基本知识串讲</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>单进程单线程：redis只有一个进程，且内部为单线程，这样做的优势是不存在线程安全问题，且不需要进行线程间的切换，提高了性能，而且多线程可能会涉及到锁。劣势是无法发挥多核cpu的优势，不过可以通过开启搭建多个redis实例实现</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>redis中默认有16个数据库（0-15），可以通过select n来进行数据库之间的切换</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;常用的基本命令：flushDB（清空当前数据库），flushAll（清空所有数据库），dbSize（查看有多少数据库）</p>\n<h2><strong>四，redis基本数据类型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;string：</strong>字符串类型，数据库中存储Map&lt;String,String&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>list：</strong>列表数组类型，数据库中存储Map&lt;String,List&lt;Object&gt;&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>hash：</strong>哈希类型，数据库中存储Map&lt;String,Map&lt;Object,Object&gt;&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>set：</strong>集合类型，其中元素无序，数据库中存储Map&lt;String,Set&lt;Object,Object&gt;&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>Zset：</strong>有序集合类型，每个元素都有一个可用于排序的权重</p>\n<h2><strong>五，redis相关命令（这里详解一些常用的命令，不常用的一笔带过）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;string：</strong>(1)set&nbsp; key&nbsp; value,插入一条数据&nbsp; （2）mset&nbsp; key value...批量插入 （3）setnx&nbsp; key value&nbsp; 若无则插入（4）get&nbsp; key&nbsp; 获取某条数据&nbsp; （5）mget keys 批量获取&nbsp; （6）getrange key&nbsp; 0 -1获取数据库全部数据&nbsp; （7）incr age 递增&nbsp; (8) incrby&nbsp; age&nbsp; 10&nbsp; 递增 age 步长为10（9）decr&nbsp; age&nbsp; 递减&nbsp; （10）decrby&nbsp; age&nbsp; 10 步长递减&nbsp; &nbsp;（11）del&nbsp; key&nbsp; 删除某条数据&nbsp; <span style=\"background-color: #ffff00;\">（12）exists&nbsp; key&nbsp; 判断是否存在某个key&nbsp; &nbsp;(13)expire&nbsp; key&nbsp; 10&nbsp; 设置过期时间（单位为秒）&nbsp; （14）pexpire&nbsp; key&nbsp; 1000 设置过期时间，单位为毫秒&nbsp; （15）persist key删除过期时间 （</span><span style=\"background-color: #ffff00;\">16）ttl&nbsp; key&nbsp; 查看过期时间</span></p>\n<p><span style=\"background-color: #ffff00;\">&nbsp;<span style=\"background-color: #ffffff;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>list：&nbsp;&nbsp;</strong>（1）lpush&nbsp; key&nbsp; value 左插入一条数据&nbsp; &nbsp;（2）lpush mylist&nbsp; key&nbsp; value....批量左插入&nbsp; （3）rpush&nbsp; key value 右插入一条数据&nbsp; (4)rpush&nbsp; mylist&nbsp; key value...右批量插入&nbsp; （5）lrange&nbsp; mylist&nbsp; 0&nbsp; -1&nbsp; 取出数据集合&nbsp; （6）lpop mylist 左弹出集合中第一条数据&nbsp; （7）rpop&nbsp; </span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">mylist&nbsp; 右弹出集合中第一条数据&nbsp; （8）llen&nbsp; mylist&nbsp; 获取数据集合长度lrem&nbsp; mylist&nbsp; count&nbsp; value&nbsp; （count&gt;0,从表头开始搜索，移除count个与值与value相等的元素；count&lt;0,表尾开始；count=0，移除所有值与value相等的元素） （9）linsert mylist&nbsp; before/after&nbsp; a&nbsp; 在a元素前或后插入。</span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">(10) lpoplpush&nbsp; list&nbsp; list1 转移列表的元素到另一个列表</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>hash：</strong>（1）hset&nbsp; key&nbsp; &nbsp;val-key&nbsp; val-val&nbsp; 插入一条数据&nbsp; （2）hset&nbsp; myhash&nbsp; name&nbsp; xxx&nbsp; 用于给哈希表中的字段赋值，不存在则创建哈希表赋值，存在则覆盖旧值&nbsp; (3) hget&nbsp; &nbsp;myhash&nbsp; name&nbsp; 取哈希表中某个值&nbsp; （4）hmset&nbsp; myhash name&nbsp; xxx age xxx&nbsp; 批量插入字段&nbsp; （5）hmget</span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">批量获取 （6）hgetall&nbsp; myhash&nbsp; 获取哈希表中所有值&nbsp; (7)&nbsp; hexisets myhash&nbsp; name&nbsp; 判断哈希表中是否存在name字段&nbsp; （8）hsetnx&nbsp; myhash score 100 若存在则不插入，若不存在则插入数据&nbsp; （9）hincrby&nbsp; myhash id 1/hdecrby&nbsp; myhash id&nbsp; 10 递增递减 （10）hdel&nbsp; myhash name&nbsp; </span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">删除&nbsp; （11）hkeys&nbsp; myhash&nbsp; 只取key值&nbsp; （12）hvals&nbsp; myhash&nbsp; 只取value值&nbsp; （13）hlen&nbsp; myhash 获取哈希表长度</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>set：</strong>（1）sadd myset&nbsp; redis&nbsp; 添加一条数据&nbsp; （2）smembers myset&nbsp; 获取数据集合&nbsp; （3）srem&nbsp; myset&nbsp; set1&nbsp; 删除set1&nbsp; （4）sismember myset&nbsp; set1 判断set中是否存在set1&nbsp; (5)srandmember&nbsp; key count&nbsp; 随机获取count个元素（6）spop&nbsp; 从集合中弹出一个元素</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>zset：</strong>之后补充</span></span></p>\n<h2><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">六，redis配置文件（常见配置）</span></span></strong></h2>\n<p><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;daemonize no：</span></span></strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">redis默认不是以守护进程的方式运行的，可以更改为yes启用守护进程（即后台运行）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>pidfile&nbsp; /var/run/redis.pid&nbsp; :</strong>启用守护进程后，默认将pid写入/var/run/redis.pid文件，可以更改</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>port&nbsp; 6379 ：</strong>redis默认端口</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp; &nbsp; &nbsp; &nbsp; <strong>bind&nbsp; 127.0.0.1：</strong>绑定的主机地址</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\"> &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>timeout&nbsp; 300</strong><strong>：</strong>redis客户端闲置多长时间后关闭连接，改为0的话，表示关闭该功能</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>loglevel&nbsp; verbose：</strong>默认日志级别（还有debug，notice，warning）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>database 16：</strong>redis默认有16个数据库可以修改</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>save&nbsp; 900&nbsp; 1/save&nbsp; 300&nbsp; 10/save&nbsp; 60&nbsp; 10000：&nbsp;</strong>表示一定时间内有多少条数据发生修改，就将其同步到数据文件一次，例如第一个表示15分钟内有一条数据发生改变就同步</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>rdbcompression yes&nbsp; ：</strong>表示数据存储到本地数据库时是否进行压缩</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>dbfilename&nbsp; dump.rdb：</strong>指定本地数据库文件名</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>dir&nbsp; /...../redis安装目录/bin ：</strong>本地数据库存放目录，默认在redis安装目录的bin目录下</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>slaveof&nbsp; &nbsp;masterip&nbsp; masterport ：</strong>设置当本机为从机时，它的主机的ip和端口</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>masterauth&nbsp; &lt;master-password&gt;：</strong>当master服务设置了密码时，slav服务连接master的密码</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>requirepass&nbsp; foobared：</strong>默认关闭redis连接需要密码，当给redis设置了密码，就需要打开</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>maxclients&nbsp; &nbsp;128：</strong>redis同一时间最大连接客户端的数量</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>appendonly&nbsp; &nbsp;no：</strong>是否开启aof持久化，默认不开启，采用rdb</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>appendfilename&nbsp; appendonlu.aof：</strong>指定aof持久化的文件名</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>appendfsync&nbsp; everysec :</strong>指定更新日志条件，默认每秒更新一次（还有no，指等操作系统进行数据缓存到磁盘，快；always指每次更新操作后都手动写入磁盘，慢但安全）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;虚拟机方面的配置暂不说明</span></span></p>\n<h2><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">七，redis持久化</span></span></strong></h2>\n<p><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;概述：</span></span></strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">redis持久化主要有两种方式，即rdb和aof</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>rdb：</strong>适用于大数据集的恢复，数据的备份，但是因为设置周期时间进行数据的快照，所以如果redis宕机，可能会丢失最后一个写操作的数据，因为数据完整性较差。数据保存在dump.db文件中，只需要移动到redis安装目录，重启即可恢复数据</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>aof：</strong>适用于对数据的完整性要求较高的情况，因为可以设置不同的持久化策略，例如每秒保存一次，这样即时redis宕机，也只会丢失最后一秒的数据。但是因为其日志文件存储的是写入命令，因而其文件大小要大于rdb的数据文件，且每次重启，都要从头执行数据文件中的命令，因而恢复速度也</span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">要慢于rdb。</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>注意：</strong>当rdb和aof同时开启的时候，redis重启，默认会采用aof的形式进行数据的重新构建</span></span></p>\n<h2><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">八，redis事务</span></span></strong></h2>\n<p><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;概述：</span></span></strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">什么是事务？事务即是一系列的命令要买全部执行，要么全部回滚</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <strong>常用命令：</strong>multi(启动事务)，discard（取消事务）,exec（执行事务块内命令）,watch key(监控某个key的变化)，unwatch（取消对所有key的监控）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>注意：</strong>redis的事务中在命令本身出错的情况下会造成命令的全部回滚，但是在命令无错，执行某个命令的时候发生异常的时候，则谁的错，谁停止（这一点和mysql是不同的）</span></span></p>\n<h2><strong>九，redis的主从复制</strong></h2>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>redis的主从复制，即主机数据更新后根据我们设置的策略将数据同步到从机上，主机以写为主，从机以读为主<strong>。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 使用：</strong>配主不配从，在从机中使用slaveof&nbsp; 主机ip&nbsp; &nbsp;主机端口配置从机，但是这种配置方式当redis重启之后就会失效，如果想要redis重启仍然可用，则需要配置redis.conf配置文件中的slaveof&nbsp; masterip&nbsp; masterport。这种配置方式的问题所在，中心化只有一台极其支持写操作，如果主机宕机，则从机等待，且从机宕机重启后不会跟上大部队（即重启后变为主机）。当然我们可以采用命令slave&nbsp; no&nbsp; one 使从机反客为主，成为主机。但是这种手动操作太过麻烦。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>哨兵模式：</strong>即配置之后，如果主机宕机，则哨兵会自动根据投票规则在从机中进行选举，从而产生新的主机顶替。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>主从复制的缺点：</strong>因为所有的写操作都是子主机上进行，从而在同步到从机上，所以存在着一定的延迟，当系统繁忙或者从机数量较多的时候，这种问题就更加明显。</p>\n<h2><strong>十，redis集群</strong></h2>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;概述：</strong>集群是一种去中心化的模式，与中心化模式不同的是，中心化模式中如果主服务挂掉了，那么服务就挂掉了。但是集群模式下，没有主路由，每个节点自身都可以成为路由</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;redis集群：即配置多台主机，多台从机，不同的主机中有不同的槽点，当执行数据写入时，会根据crc16算法计算出数据的槽点，从而将数据存入到对应的主机中，并同步到与其对应的从机中</p>\n<p>&nbsp;</p>\n<h1>水平有限，如有错误，还望指出！</h1>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1249588251598041088","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6caUuADBI7AAAb07iHSRw500.jpg","blogRead":4,"blogRemark":"redis基础（一）","blogTitle":"redis基础（一）","createdTime":"2020-04-13 06:40:30","typeName":"redis","updateTime":"2020-04-20 16:47:37"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，线程上下文切换</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>cpu利用时间片轮询的方式来为每个任务都分配一定的时间片，任务的执行过程中保存任务的状态。任务状态的保存和在加载就叫做上下文切换。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>进程：</strong>指的是一个运行中的程序实例，一个进程中可以有多个线程，并且与进程共享同样的内存和系统资源</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong> 上下文：</strong>指的是寄存器和程序计数器保存的线程的信息</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>寄存器：</strong>指的是内存中很小但是运行速度很快的一块区域（相对于RAM外部内存）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>程序计数器：</strong>一种寄存器，用来保存当前执行指令的位置或者下一个待执行指令的位置</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>上下文切换：</strong>上下文切换指的是操作系统的内核在cpu上对进程或者线程的切换。上下文信息保存在进程控制块中（PCB）。流程如下：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;挂起当前进程，将进程的上下文信息保存在进程控制块中；</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;在进程控制块中寻找下一个任务的上下文信息。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;恢复进程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>上下文切换的原因：</strong>第一，任务正常执行完毕，调度下一个任务；第二，线程出现I/O阻塞，被挂起，cpu调度下一个任务；第三，线程等待同步锁，获取socket通知等，被挂起，cpu调度下一个任务；第四，用户调用sleep方法，让出cpu；第五，硬件中断</p>\n<h2><strong>二，JAVA阻塞队列</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>阻塞队列的是调度当前队列的线程处于阻塞状态</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 消费者阻塞：如果队列为空，则消费者线程被挂起，处于阻塞状态，当有新数据进入队列，则消费者线程被唤醒，消费数据</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 生产者阻塞：如果队列数据已满，则生产者线程挂起，处于阻塞状态，当队列有空闲位置，生产者线程被唤醒，生产数据。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞队列的主要操作：</strong>插入操作和移除（获取）操作</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>插入操作：</strong>add(e)，有空间则插入，无空间报异常；offer(e),有空间则插入，无空间返回false；offer(e,time,unit),有空间插入，无空间等待time时间，若超时返回false；put(e),有空间插入，无空间则线程挂起处于阻塞直到有空间</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>移除操作：</strong>poll(e),有值返回值，无值返回null;poll(e,time,unit),有值返回值，无值等待time时间，超时返回null;take(e),有值返回值，无值等待新数据进入再立即返回；drainTo(collection&lt;Object&gt;)批量移除，提高获取效率</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞队列的实现：</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong> ArrayBlockingQueue：</strong>基于数组的有界阻塞队列，按照先进先出顺序对元素进行排序</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>LinkedBlockingQueue：</strong>基于链表的有界阻塞队列，队头队尾采用不两个不同的锁控制数据同步，并发性高</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>PriorityBlockingQueue：</strong>基于优先级的无界队列，默认升序排列，可以自定义排序规则，根据优先级访问数据。但是有数据优先级一样的情况</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>DelayQueue：</strong>支持延时的队列，即从队列中取数据时等待一定的时间才能获取元素。可以用于缓存系统的设计，设计过期时间，也可以用来设置定时调度任务，即如果能够从队列中获取，说明到了任务的调度时间。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>SynchronousQueue</strong>：该队列是一个不存储元素的阻塞队列，每一个put操作都必须等待一个take操作的完成。吞吐量高于ArrayBlockingQueue和LinkedBlockingQueue。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>LinkedTransferQueue：</strong>基于链表的无界阻塞队列，多了transfer方法(如果消费者等待，直接将任务从生产者传递给消费者，无消费者等待，则将任务加到队尾直到被消费才返回)和tryTransfer（与transfer一致，只不过不管有没有消费者等待获取都会立即返回tryTransfer（e,time,unit）（与tryTransfer一致，只不过设置了超时时间）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>LinkedBlockingDeque：</strong>基于链表的双向阻塞队列，可以在两端同时进行读写操作，提高了队列的操作效率。</p>\n<h2><strong>三，并发关键字</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;CountDownLatch：</strong>适用于一个主线程等待子线程完成任务之后执行（原理：设置一个程序计数器，计数器的值为子线程的个数，子线程并发执行，每个子线程执行完毕后，调用CountDown方法，将其计数器的值减去1，值为0时，唤醒主线程执行）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>CyclicBarrier：</strong>即当所有线程到达一个状态共同执行。await（）方法：确保所有线程到达Barrier状态才执行；await（time,unit）：设置一个超时时间，超过这个时间，执行达到Barrier状态的线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>Semaphore：</strong>因为其限制了多线程访问资源的线程个数，所以适用于多线程并发访问有限资源的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>volatile：</strong>直接用来修饰变量，是一种比Synchronized更加轻量级的机制，用于多线程共享同一变量，可以同时对其进行读写操作。当多个线程共享变量的时候，读取变量将其从内存复制到cpu缓存中，然后线程对其操作进行修改，这样再多cpu的情况下，有可能出现线程修改原数据造成数据不一致的情况，使用volatile关键字直接将线程修改的变量存入内存，解决这个问题。</p>\n<h2><strong>四，多线程共享数据</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>多线程共享数据主要通过共享内存实现，而共享内存的可见性，有序性，原子性已经由JVM和锁解决。理想情况下我们需要解决同步和互斥的问题（<span style=\"background-color: #ffff00;\">怎么解决的有待考证！</span>）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>解决方法一：</strong>将数据抽象成一个类，将对数据的操作封装成类中的方法</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解决方法二：</strong>将Runnable对象作为一个内部类，将共享数据作为这个类的成员变量</p>\n<h2><strong>五，ConcurrentHashmap并发</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ConcurrentHashmap使用了减小锁粒度，这里具体为分段锁的思想优化了锁，因为如果直接对hashmap进行加锁，锁太大，而且同一时刻只能有一个线程操作hashmap，并发性能较差</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;实现原理：</strong>即内部采用分段锁思想，将hashmap分为多个segment，每次读取数据的时候，对数据所在的segment进行加锁，这样只要保证每个segment线程安全，就可以保证整个hashmap线程安全</p>\n<h2><strong>六，JAVA中的线程调度</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;抢占式调度：</strong>即线程对cpu资源进行抢占，这种策略下每个线程抢占到cpu资源的概率是相等的，这样就不会一个线程阻塞造成整个系统阻塞的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>协同式调度：</strong>即一个线程使用完cpu资源之后通知cpu调度下一个任务，适用于多线程交替执行任务。因为如果一个线程阻塞可能会造成整个系统阻塞甚至崩溃</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>JAVA采用的是抢占式调度，但同时又尽可能的保证公平性（即为每个线程分配优先级不同的cpu时间片）</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>&nbsp;线程让出cpu的情况</strong>：第一，线程调用yield方法；第二，I/O阻塞，socket等待等；第三，等待同步锁；第四，正常执行完毕</p>\n<h2>七，进程调度算法</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>优先调度算法：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;先来先服务调度算法：</strong>即遵循先来先被分配cpu资源运行的原则</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>短作业调度算法：</strong>即预估作业的时间长短，优先调度时间短的任务，可能会导致长时间大任务很长时间无法被调度 &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>高优先权调度算法：即每个任务会预先被分配优先级</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;非抢占式优先调度算法：</strong>按照优先级的高低一次分配cpu资源运行</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>抢占式优先调度算法：</strong>按照优先级的高低分配cpu资源运行，但是如果任务再运行过程中有优先级更高的任务加入，则将其cpu资源临时回收分配给紧急任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>高响应比调度算法：</strong>动态调度，即作业时间短，则优先级高；等待时间长，则优先级高。前者遵循短作业调度算法，后者遵循先来先服务原则。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>时间片轮转调度算法：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;时间片轮转法：</strong>按照任务再队列中的顺序进行调度</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>多级反馈队列调度算法：</strong>即再时间片轮转法的基础上维护了就绪队列，默认第一队列优先级高，先调度第一队列的任务，如果再分配的cpu时间片内未完成则将其加入第二队列队尾，以此类推直到其执行完毕。只有第1 -（n-1）队列为空，才会调度第n队列的任务，而且当前任务执行时，如果有优先级高的任务进来，会抢占其cpu资源。</p>\n<h2><strong>八，CAS</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>即比较和交换，CAS（V,E,N）三个参数，只有当V=E的时候才会将V设置为N。如果V!=E，则说明数据已经被其它线程修改，不做任何操作</p>\n<h2><strong>九，ABA问题</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>概述：</strong>即当1线程从V中取出A时，2线程也从中取出1，修改为B，再修改为A。而1线程仍然修改成功，实际上修改过程中V的实际值已经发生改变，只不过1没有发觉。解决这种问题，常采用乐观锁的版本号机制。</p>\n<h2><strong>另外有AQS问题没怎么读懂，下次完善！</strong></h2>\n<p>&nbsp;</p>\n<h3><strong>思维导图：<a href=\"https://images-cdn.shimo.im/myFodjsaVAA3PVV7__thumbnail\" target=\"_blank\" rel=\"noopener\">并发编程（下）</a></strong></h3>\n<p>&nbsp;</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</p>","blogGoods":0,"blogId":"1249742755949817856","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHNmAPuxmAABJTVJPTfk117.jpg","blogRead":17,"blogRemark":"面试（三）------之并发编程篇（下）","blogTitle":"面试（三）------之并发编程篇（下）","createdTime":"2020-04-13 16:54:26","typeName":"java面试篇","updateTime":"2020-04-20 11:54:02"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，栈及其JAVA实现</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：栈是一种先进后出的数据结构，对栈顶元素的添加，删除等操作较快，但是对于栈内的元素操作很慢</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA实现：实现需要定义栈的数据结构，写栈的入栈，出栈，获取栈顶元素的方法，如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n * 基于数组实现栈\n * @author wcj\n * @Date 2020/4/14 20:59\n * @Version 1.0\n */\npublic class StackExample&lt;E&gt; {\n\n    /**\n     * 站的深度\n     */\n    private int maxSize;\n    /**\n     * 存储数据的数组\n     */\n    private Object[] data;\n    /**\n     * 栈顶指针\n     */\n    private int top = -1;\n\n    /**\n     * 默认栈的深度为10\n     */\n    public StackExample(){\n        this(10);\n    }\n\n    /**\n     * 用户自定义栈的深度\n     * @param initialSize\n     */\n    public StackExample(int initialSize){\n        if(initialSize&gt;=0){\n            this.maxSize = initialSize;\n            this.data = new  Object[initialSize];\n            this.top = -1;\n        }else{\n            throw new RuntimeException(\"初始化栈的深度不能小于0!\");\n        }\n    }\n\n    /**\n     * 入栈操作\n     * @param e\n     * @return\n     */\n    public Boolean push(E e){\n        if(top == maxSize-1){\n            throw new RuntimeException(\"栈已满,不能入栈\");\n        }else{\n            data[++top] = e;\n        }\n        return true;\n    }\n\n    /**\n     * 出栈操作\n     * @return\n     */\n    public E pop(){\n        if(top==-1){\n            throw new RuntimeException(\"栈空，不能出栈！\");\n        }else{\n            return (E) data[top--];\n        }\n    }\n\n    /**\n     * 获取栈顶元素\n     * @return\n     */\n    public E peak(){\n        if(top==-1){\n            throw new RuntimeException(\"栈空异常！\");\n        }else{\n            return (E) data[top];\n        }\n    }  </code></pre>\n<h2><strong>二，队列极其JAVA实现</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：队列是一种先进先出的数据结构，对队头和队尾的操作简单，但是队内元素的操作复杂。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA实现：定义队列的数据结构，队列的出队，入队，获取队头元素。代码如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n * 基于数组实现队列\n * @author wcj\n * @Date 2020/4/14 21:14\n * @Version 1.0\n */\npublic class QueueExample&lt;E&gt; {\n\n    /**\n     * 队列长度\n     */\n    private int maxSize;\n    /**\n     * 存储数据数组\n     */\n    private Object[] data;\n    /**\n     * 队头指针\n     */\n    private int front;\n    /**\n     * 队尾指针\n     */\n    private int rear;\n\n    /**\n     * 默认构造器\n     */\n    public QueueExample(){\n        this(10);\n    }\n    /**\n     * 用户自定义队列长度构造器\n     * @param initialSize\n     */\n    public QueueExample(int initialSize){\n        if(initialSize&gt;=0){\n            this.maxSize = initialSize;\n            data = new Object[initialSize];\n            front = rear = 0;\n        }else{\n            throw new RuntimeException(\"初始化队列长度不能小于0！\");\n        }\n    }\n\n    /**\n     * 入队操作\n     * @param e\n     * @return\n     */\n    public Boolean add(E e){\n        if(rear == maxSize){\n            throw new RuntimeException(\"队列已满，无法入队!\");\n        }else{\n            data[rear++] = e;\n        }\n        return true;\n    }\n\n    /**\n     * 出队操作\n     * @return\n     */\n    public E poll(){\n        if(front==rear){\n            throw new RuntimeException(\"队空，无元素可出队！\");\n        }else{\n            E e = (E) data[front];\n            data[front] = null;\n            return e;\n        }\n    }\n\n    /**\n     * 获取队头元素\n     * @return\n     */\n    public E peek(){\n        if(front==rear){\n            throw new RuntimeException(\"队空，无元素可出队!\");\n        }else{\n            return (E) data[front];\n        }\n    }\n}\n</code></pre>\n<h2><strong>三，链表及其JAVA实现</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：链表是由一系列数据节点组成的数据结构，节点可以动态生成。对于元素的增加，删除操作快，查询操作慢</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;这里主要讲述几种有代表性的链表：单向链表，双向链表，双向循环链表</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;单链表的JAVA实现：数据结构定义，添加节点，删除节点，查找节点，代码如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n * 单向链表\n * @author wcj\n * @Date 2020/4/14 21:32\n * @Version 1.0\n */\npublic class SingleLinkedList {\n\n    /**\n     * 链表长度\n     */\n    private int length;\n    /**\n     * 链表头节点\n     */\n    private Node head;\n\n    public SingleLinkedList(){\n        this.length = 0;\n        this.head = null;\n    }\n    /**\n     * 内部类声明每个链表节点\n     * 每个节点包括数据域和指向下一个节点的指针\n     */\n    private class Node{\n        private Object data;\n        private Node next;\n        public Node(Object data){\n            this.data = data;\n        }\n    }\n\n    /**\n     * 插入节点（这里使用头插法）\n     * @param obj\n     * @return\n     */\n    public Boolean add(Object obj){\n        Node node = new Node(obj);\n        if(length==0){\n            head = node;\n        }else{\n            node.next= head;\n            head = node;\n        }\n        length++;\n        return true;\n    }\n\n    /**\n     * 删除某个节点\n     * 先对链表进行判空处理\n     * 然后找到要删除的节点\n     * 最后进行删除\n     * @param obj\n     * @return\n     */\n    public Boolean delete(Object obj){\n        if(length==0){\n            throw new RuntimeException(\"链表为空，无节点可删除!\");\n        }else{\n            Node prev = head;\n            Node current = head;\n            //查找待删除元素\n            while(!current.data.equals(obj)){\n                if(current.next==null){\n                    return false;\n                }else{\n                    prev = current;\n                    current = current.next;\n                }\n            }\n            prev.next = current.next;\n            length--;\n        }\n        return true;\n    }\n\n    /**\n     * 获取某个元素\n     * @param obj\n     * @return\n     */\n    public Object find(Object obj){\n        if(length==0){\n            throw new RuntimeException(\"链表为空\");\n        }else{\n            Node current = head;\n            while(current.data.equals(obj)){\n                if(current.next==null){\n                    return null;\n                }else{\n                    current = current.next;\n                }\n            }\n            return current.data;\n        }\n    }\n}\n</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>双向链表的JAVA实现：定义数据结构，头插法，尾插法，删除头部节点，删除尾部节点（这里只写尾插节点和删除尾部节点），代码如下：</strong></p>\n<pre class=\"language-java\"><code>import com.sun.org.apache.xpath.internal.operations.Bool;\n\n/**\n * 单向循环链表\n * @author wcj\n * @Date 2020/4/14 22:05\n * @Version 1.0\n */\npublic class CircleLinkedList {\n\n    /**\n     * 链表长度\n     */\n    private int length;\n    /**\n     * 头节点\n     */\n    private Node head;\n    /**\n     * 尾节点\n     */\n    private Node tail;\n\n    /**\n     * 初始化构造方法\n     */\n    public CircleLinkedList(){\n        this.length = 0;\n        this.head=this.tail = null;\n    }\n\n    /**\n     * 内部类实现的链表节点\n     */\n    private class Node{\n        private Object data;\n        private Node prev;\n        private Node next;\n        public Node(Object data){\n            this.data = data;\n        }\n    }\n\n    /**\n     * 尾插节点\n     * @param obj\n     * @return\n     */\n    public Boolean addTail(Object obj){\n        Node node = new Node(obj);\n        if(length==0){\n            head = tail= node;\n            length++;\n        }else{\n            tail.next = node;\n            node.prev = tail;\n            tail = node;\n            length++;\n        }\n        return true;\n    }\n\n    /**\n     * 删除尾部节点\n     * @return\n     */\n    public Boolean delTail(){\n        Node temp = tail;\n        if(length==0){\n            throw new RuntimeException(\"链表为空!\");\n        }else{\n            tail = tail.prev;\n            tail.next = null;\n            length--;\n        }\n        return true;\n    }\n}\n</code></pre>\n<h2><strong>四，散列表</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：有一张表M，一个映射函数f(key)，如果对于任意一个key，都有一个函数指与表中的内存地址相对应，则M就为散列表，f(key)就为散列函数。散列函数存储key-value键值对形式的数据，直接生成key与表中地址值的映射，因此查询非常迅速。同时散列表也经常被用于信息安全，用于加密操作。</strong></p>\n<h2><strong>五，二叉排序树</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：二叉查找树又成为二叉搜索树，二叉查找树</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;特征：根节点左边的数据小于根节点，根节点右边的数据大于根节点，且其左右子树还是二叉排序树</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现：定义数据结构，插入操作，删除操作，查找操作，代码如下：</strong></p>\n<pre class=\"language-java\"><code>package interviewFour.example4;\n\n/**\n * 二叉排序树\n * @author wcj\n * @Date 2020/4/14 17:17\n * @Version 1.0\n */\npublic class Node {\n\n    private Node root = null;\n    private int value;\n    private Node left;\n    private Node right;\n\n    public Node(){}\n\n    public Node(int value, Node left, Node right){\n        this.value = value;\n        this.left = left;\n        this.right = right;\n    }\n\n    public Node(int value){\n        this.left = null;\n        this.right = null;\n        this.value = value;\n    }\n\n    public int getValue() {\n        return value;\n    }\n\n    public void setValue(int value) {\n        this.value = value;\n    }\n\n    public Node getLeft() {\n        return left;\n    }\n\n    public void setLeft(Node left) {\n        this.left = left;\n    }\n\n    public Node getRight() {\n        return right;\n    }\n\n    public void setRight(Node right) {\n        this.right = right;\n    }\n\n    /**\n     * 插入节点\n     * @param value\n     * @return\n     */\n    public Boolean insert(int value){\n        //root代表根节点\n        Node p = root;\n        Node prev = null;\n        //创建一个节点\n        Node node = new Node(value);\n        //寻找节点的插入位置\n        while(p!=null){\n            prev = p;\n            if(value==p.getValue()){\n                return false;\n            }else if(value&lt;p.getValue()){\n                p = p.getLeft();\n            }else{\n                p = p.getRight();\n            }\n        }\n        if(root==null){\n            root = node;\n        }else if(value&lt;prev.getValue()){\n            prev.setLeft(node);\n        }else{\n            prev.setRight(node);\n        }\n        return true;\n    }\n\n    /**\n     * 删除某个节点\n     * 分为三种情况，待删除节点为叶子节点，则直接删除\n     * 待删除节点只有左子树或者右子树，则用左子树或者右子树替代当前节点位置\n     * 待删除节点即有左子树又有右子树，则寻找左子树最大节点或者右子树最小节点顶替当前节点(这里使用左子树的最大节点)\n     * @param value\n     * @return\n     */\n    public void deleteBST(int value){\n        deleteBST(root,value);\n    }\n\n    /**\n     * 递归删除左子树，或者右子树，或者根节点\n     * @param root\n     * @param value\n     * @return\n     */\n    public Boolean deleteBST(Node root,int value){\n        if(root==null){\n            return false;\n        }else{\n            if(root.getValue()==value){\n                delete(root);\n            }else if(value&lt;root.getValue()){\n                deleteBST(root.getLeft(),value);\n            }else{\n                deleteBST(root.getRight(),value);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * 分情况执行具体的删除逻辑\n     * @param node\n     * @return\n     */\n    public Boolean delete(Node node){\n        if(node.getLeft()==null){\n            node = node.getRight();\n        }else if(node.getRight()==null){\n            node = node.getLeft();\n        }else{\n            Node temp = node;\n            Node s = node;\n            //转向左子树，向右走到底\n            s = s.getLeft();\n            //寻找替换待删除节点的节点\n            while(s!=null){\n                temp = s;\n                s = s.getRight();\n            }\n            node.setValue(temp.getValue());\n            if(temp!=node){\n                node.setLeft(temp.getLeft());\n            }else{\n                node.setRight(temp.getRight());\n            }\n        }\n        return true;\n    }\n\n    /**\n     * 在二叉查找树中找到对应节点\n     * @param value\n     * @return\n     */\n    public Boolean searchBTS(int value){\n        Node node = root;\n        if(node==null){\n            throw new RuntimeException(\"无此节点！\");\n        }else{\n            if(value==node.getValue()){\n                return true;\n            }else if(value&lt;node.getValue()){\n                node = node.getLeft();\n            }else{\n                node = node.getRight();\n            }\n        }\n        return false;\n    }\n}\n</code></pre>\n<h2><strong>六，红黑树</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 概述：红黑树是一种特化的自平衡二叉排序树，即其左右子树的深度差可以超过1。（详细的插入等操作过段时间会补充）</strong></p>\n<h2><strong>七，图，位图</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;图的知识：定义，有向图/无向图，邻接矩阵/邻接表，BFS/DFS，位图的话没怎么搞清楚。</strong></p>\n<h3><strong>思维导图：<a href=\"https://images-cdn.shimo.im/YClQaLxx9e8uEb9U__thumbnail\" target=\"_blank\" rel=\"noopener\">数据结构</a></strong></h3>\n<h2>&nbsp;</h2>","blogGoods":0,"blogId":"1250068950784536576","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHQGAYlUxAABJTVJPTfk990.jpg","blogRead":7,"blogRemark":"面试（四）------之数据结构篇","blogTitle":"面试（四）------之数据结构篇","createdTime":"2020-04-14 14:30:37","typeName":"java面试篇","updateTime":"2020-04-23 22:14:43"}],"pageSize":10,"params":{},"sortMethod":"ASC","totalCount":53,"totalPage":6},"msg":"操作成功!"}
2020-04-26 23:27:28.676 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/list
2020-04-26 23:27:28.677 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:27:28.677 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:27:28.678 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogList
2020-04-26 23:27:28.678 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=10, totalPage=6, totalCount=53, list=[BlogVo(blogId=1247745014683947008, blogTitle=博客开发总结（一）-----之数据库设计篇, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dDViAcnjvAACb6PL1tzA485.jpg, blogContent=<p><strong>一，数据库设计--表的命名规范等</strong></p>
<p>（1），统一采用bl_开头对表进行命名</p>
<p>（2），对于数据比较重要的表统一添加四个字段，分别为：created_time(创建时间),update_time(修改时间),version(版本号),deleted(删除字段)</p>
<p>（3），数据库表的字段尽量都设置为NOT_NULL</p>
<p>（4），数据库中表varchar类型字段需要设置长度的尽量设置为2<sup>n</sup>-1</p>
<p>（5），因为博客系统分为前台展示界面和后台管理，所以对于有些表，例如bl_type（博客类型表），bl_music（音乐表）等设置了enable（启用字段）</p>
<p><strong>二，上述第二条--四个字段的解释</strong></p>
<p>（1），为什么要设置created_time和update_time字段：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;其一，从数据库的通用性上来说，设计这两个字段是必要的，但也需要根据业务的需要来合理添加这两个字段，因为无用的字段会浪费空间，性能，影响系统的运行。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 其二，大部分的应用都有需要根据时间进行排序的功能。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 其三，当系统发生异常的时候，我们可以通过这两个字段对异常进行排查和定位。</p>
<p>（2），为什么要设置version字段：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 1，version字段含义：字段的含义与其字面意思一样，代表版本，在这里作为乐观锁进行使用，从而保证不会出现脏数据的情况。下面解释一下什么叫乐观锁，以及乐观锁和悲观锁</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 2，乐观锁：总是假定最好的情况，即每次用户调用接口从数据库中取出数据到修改数据前的过程中，不会有其它用户对当前数据进行修改，这样在当前用户修改数据的时候，利用版本机制即判断取出的version字段和当前数据库该条数据的version字段是否相等来判断该条数据是否已经被修改，如果未修改，则予以修改（且version字段递增），如果已经修改，则提示用户更新失败。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 悲观锁：总是假定最坏的情况，即每次用户调用接口从数据库取出数据的时候，都认为该条数据会被修改，因此每次取出数据都对数据进行加锁处理，只允许当前用户进行修改，其它用户阻塞，直到当前用户修改完毕。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3，为什么使用乐观锁而不使用悲观锁：因为悲观锁比较浪费性能</p>
<p>（3），为什么设置deleted字段：deleted字段在这里作为一个逻辑删除字段（0否1是），何为逻辑删除，即执行删除操作操作的时候，不会真正的删除数据库中的数据，而是将deleted字段设置为1即可。&nbsp;这样如果用户出现误删的操作，可以通过数据库修改该字段进行数据的恢复。</p>
<p><strong>三，上述第三条--数据库表字段尽量设置为NOT_NULL</strong></p>
<p>（1），数据库表字段尽量设置为NOT_NULL：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 1，有些人可能认为设置为NULL相比于NOT_NULL不是更节省空间吗？但是实际上不是这样的，设计为NULL相比于NOT_NULL要多占用一个字节的空间</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 2，设计为NOT_NULL，这样在做查询的时候能够更好的避免空指针异常，且发生该类错误的时候能够更好的进行排查</p>
<p><strong>四，上述第四条--表varchar类型字段长度尽量设置为2<sup>n</sup>-1</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>因为计算机只识别二进制，且有一定的范围，例如2<sup>8</sup>，在计算机中的范围为-128~127,因此对于varchar字段长度来说，如果设置为255，则正好是一个字节，而如果设置为256，则占用两个字节，这样会浪费计算机的内存空间，因此数据库varchar类型字段的长度最好设置为2<sup>n</sup>-1</p>
<p><strong>五，上述第五条--对于设置enable字段的解释</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>enable字段，字面意思启用，在这里表明是否启用（0否1是），因为系统分为前台博客页面和后台管理，对于这两个不同的前端项目，后台可以通过启用字段来控制内容在前台博客页面的展示与否，与deleted字段不同的是，如果执行删除操作，那么我们只能通过手动修改数据库中的字段进行数据的恢复，且如果执行删除操作，则该数据在前台博客页面和后台管理页面都无法看见。但是如果将数据弃用（即修改enable字段值为1），则表明该数据被弃用，在前台博客页面无法显示，但是在后台管理页面可以看见，且无需通过手动修改数据库来恢复数据，可以在后台管理页面操作启用数据。</p>
<p>&nbsp;</p>, blogGoods=0, blogRead=21, blogCollection=0, typeName=博客开发和维护总结, blogRemark=博客开发总结（一）-----之数据库设计篇, blogComment=0, blogSource=null, createdTime=2020-04-08 04:36:07, blogMonth=null, updateTime=2020-04-20 10:47:54), BlogVo(blogId=1247867141693128704, blogTitle=闲谈前后端分离开发, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dG6CAI6ipAACiM2P5LtI65.jpeg, blogContent=<p><strong>一，前后端分离开发优势</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，</strong>项目开发过程中，前后端完全解耦，前端只需要负责页面的实现，只需要通过接口拿数据。后端不需要管页面的跳转，只需要负责接口的编写</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，</strong>前后端人员有更多的精力去负责自己的工作，前端人员可以将更多的精力投放在页面的编写，页面的美化，页面特效的制作和用户体验上；而后端人员可以将更多的精力放在接口代码的优化，sql优化，jvm调优上面</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，</strong>前后端分离的项目部署的时候，前端项目往往都是部署在nginx服务器上，而前后端不分离的项目往往都是部署再一台服务器上。因此前后端分离项目大大降低了服务器的负担</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>4，</strong>前后端不分离的项目使用模板引擎例如freemaker，thymeleaf等，前后端人员交流起来较为困难。且前端项目使用原生的DOM操作，极大的增加了前端工作人员的工作量。而前后端分离项目前端通常都是用各种ui框架，框架采用MVVM模式，极大的减轻了前端工作人员的工作量</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，</strong>前后端分离开发，前端可以通过easy-mock来伪造接口数据进行测试，后端人员可以通过postman进行接口测试，开发效率大大提升。</p>, blogGoods=0, blogRead=7, blogCollection=0, typeName=随笔, blogRemark=前后端分离开发的优势所在, blogComment=0, blogSource=null, createdTime=2020-04-08 12:41:25, blogMonth=null, updateTime=2020-04-20 11:48:53), BlogVo(blogId=1248135765829918720, blogTitle=CSS----之flex弹性布局, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dGnuAWkLLAAAaRXQXNms575.jpg, blogContent=<p><strong>一，css之弹性布局</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，</strong>何为弹性布局？</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 弹性布局是css的一种新的布局方式，所谓&ldquo;弹性布局&rdquo;，即页面随着不同设备的屏幕大小拉伸会自适应页面的大小。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，</strong>弹性布局的两种主要元素，container（弹性容器），item（弹性子元素），一个弹性容器中可以放入多个弹性子元素，元素之间是可以进行嵌套的，弹性子元素也可以设置为弹性容器，里面再嵌套弹性子元素。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，</strong>弹性布局的基本属性</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （1）display：flex，声明容器为弹性布局</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （2）flex-direction：声明弹性容器内部元素的排列方式，默认为row。row（横向布局），row-reverse（横向布局，但是元素反方向码），column（纵向布局），column-reverse（纵向布局，但是元素反着码）。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （3）flex-wrap：声明弹性盒子中的元素是否可以换行，默认为nowrap（不换行），wrap（换行），wrap-reverse（换行，但是反着码）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （4）align-items：设置容器中元素在纵轴方向上的对齐方式，默认为stretch（即如果不设置子元素高度，则默认拉伸至于容器同宽度），flex-start（子元素位于容器的开始位置），flex-end（子元素位于容器的结尾处），center（元素依纵轴方向居中），baseline（元素位于容器基线，不过没怎么用过，所以不是很清楚）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （5）justify-content（设置元素在主轴上的对齐方式），默认为flex-start（元素从容器主轴开始位置码），flex-end（元素从容器主轴结尾处码），center（元素位于主轴居中处），space-between（元素布局在容器的两端），space-around（元素布局在容器两端，但是元素前后都留有空白）因为项目中大多数只使用了对于容器的操作，对于容器中元素的操作很少，所以这里只介绍这点。谢谢阅读！</p>, blogGoods=0, blogRead=3, blogCollection=0, typeName=CSS, blogRemark=CSS----之flex弹性布局, blogComment=0, blogSource=null, createdTime=2020-04-09 06:28:51, blogMonth=null, updateTime=2020-04-20 11:43:57), BlogVo(blogId=1248224512563068928, blogTitle=面试（一）------之JVM篇, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dHLeALxSjAABJTVJPTfk677.jpg, blogContent=<h2 style="text-align: left;"><strong>一，JVM运行机制</strong></h2>
<p>&nbsp;&nbsp; &nbsp; &nbsp;jvm即java虚拟机，一共由四个部分组成，分别是类加载器子系统，运行时数据区（程序计数器，本地方法区，jvm栈，方法区，jvm堆），执行引擎（即时编译器，垃圾收集器），本地接口库。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;一个java源程序的运行先是经过编译器将其编译成字节码文件（class文件），然后通过类加载器子系统将其加载进入jvm&mdash;&mdash;&gt;程序运行过程中，运行时数据区存放程序运行过程产生的数据&mdash;&mdash;&gt;执行引擎中的垃圾收集器收集程序运行过程中创建的不再使用的对象，即时编译器将程序的字节码文件编译成机器码&mdash;&mdash;&gt;然后本地接口库利用机器码调用本地方法库中的方法，和操作系统实现交互。</p>
<h2><strong>二，多线程</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;</strong>在多核操作系统中，jvm支持一个进程中同时并发执行多个线程，且这些线程和本地操作系统的线程相对应。当jvm中的对象初始化，内存空间分配等一系列准备工作完成之后，会调用操作系统中的接口创建一个原生线程，原生线程初始化完毕后，会调用java线程的run（）方法执行该线程，线程结束之后，jvm会释放原生线程和java线程资源。</p>
<h2><strong>三，JVM的内存区域</strong></h2>
<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM的内存区域主要分为线程私有区域（程序计数器，本地方法区，JVM栈），线程共享区（方法区，JVM堆）和直接内存。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;程序计数器：线程私有区域，无内存溢出，用来记录程序运行过程中的字节码指令地址，如果是Native方法，则程序计数器为空。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM栈：线程私有区域，用来描述java程序的运行过程，java程序运行每次运行的时候，都会创建一个栈帧，方法的执行和返回对应着栈帧的入栈和出栈操作。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;本地方法区：线程私有区域，和JVM栈的功能一样，只不过是用来记录Native方法的运行过程。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM堆：线程共享区，主要用来存放程序运行过程中产生的数据，同时也是垃圾收集器进行垃圾回收的主要区域。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;方法区：也被称为永久代，用来存放常量，静态变量，类信息等等。</p>
<h2><strong>四，JVM的运行时内存</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>JVM的运行时内存又被称为JVM堆，因为JVM的GC算法使用的是分代收集算法，所以JVM堆按照GC标准可以分为三个区域分别为：新生代，老年代，永久代。其中新生代占1/3，老年代占2/3，永久代很少，</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;新生代：存放短生命周期，小对象的区域。新生代又分为Eden区，ServivorTo区，ServivorFrom区，区域的GC算法采用复制算法。Eden区是用来存放新创建的对象（大对象除外），ServivorTo区是用来保存MinorGC幸存下来的对象，ServivorFrom区是用来将上一次MinorGC幸存下来的对象作为下一次MinorGC的扫描对象。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;老年代：存放长生命周期的大对象，区域的GC算法采用标记整理算法</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;永久代：主要用来存放class和meta数据信息的。程序运行过程中不会进行永久代的垃圾回收，这也就导致永久代区域的数据会越来越多，最终造成内存溢出。java8之后永久代已经被元数据区取代，元数据区和永久代的功能都是一样的，但是最大的不同在于永久代区域依赖于虚拟机的内存大小，因而可以存储的class，meta信息非常有限。但是元数据区依赖的是本地操作系统，因而不会受到虚拟机内存的限制。</p>
<h2><strong>五，垃圾回收与算法</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;(1)垃圾回收：</strong>Jvm的垃圾回收判定依赖于两种方法，引用计数法和可达性分析法。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;引用计数法：即如果想要在程序中使用对象，就必须赋予一个引用，这样在对象赋予引用的时候将其引用计数加1，删除一个引用时，将对象引用计数减1，如果引用计数为0，就说明该对象已经不使用，作为垃圾。但是引用计数法存在一个缺陷，即循环引用的问题，如果两个对象相互引用，则这两个对象的引用计数永远都不会为0，造成对象无法被回收。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;可达性分析法：即先创建一些根节点对象ROOTS，然后通过这些根节点对象向下搜索，如果一个对象到任意一个ROOTS之间都没有可达路径，在经过两次标记（下文解释为什么进行两次标记），还是没有可达路径，则说明该对象可回收。</p>
<p>&nbsp;&nbsp; &nbsp;<strong>（2）GC算法：</strong>常见的GC算法有四种，分别为标记清除算法，复制算法，标记整理算法，分代收集算法</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;标记清除算法：即在进行垃圾回收前，对所有对象进行一次标记，标记可回收的对象，然后进行清理即可。但是标记清除算法在清除回收对象之后，并不会对堆内存进行整理，这样的话如果内存中的对象大部分为小对象，清理之后就会导致没有大片连续的内存空间，即造成了内存碎片化，这样大对象存储的时候就无法找到相应的完整连续内存。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;复制算法：即将内存分为两块同等大小的区域，区域1和区域2，创建的新对象都存储在区域1中，当区域1中的内存占满之后，会对内存中的所有对象进行一次标记，标记存活的对象，将存活的对象复制到区域2，这时区域1中的对象都是可回收对象，回收区域1中的所有对象即可。但是复制算法也存在着一定的缺陷，即每次都只能使用一半的内存空间，造成了大量的内存浪费。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;标记整理算法：即结合标记清除算法和复制算法的优点，先对所有的对象进行标记，标记存活的对象，将存活的对象复制到内存的另一端，然后清除当前端的对象即可。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;分代收集算法：前面的三种算法，都无法按照对象的类型进行收集，分代收集算法正是解决这个问题，按照对象的不同类型采用不同的GC算法。以JVM的分代收集算法为例，JVM的堆内存分为新生代，老年代，永久代。新生代又分为Eden区，ServivorTo区和ServivorFrom区。新生代因为其存储生命周期短的小对象，GC比较频繁，所以采用复制算法。程序运行过程中创建的对象都存储在Eden区（大对象除外，大对象直接复制到老年代区域）。当Eden区的内存不够的时候进行MinorGC，然后将Eden区和ServivorFrom区的存活对象都复制到ServivorTo区，然后将ServivorTo区和ServivorFrom区进行交换，再次进行MinorGC。老年代因为存放的都是生命周期长的大对象，因而进行GC的不会太频繁，且清除的对象并不会太多，因而采用标记整理算法。老年代每次进行MajorGC之前都会先进行一次MinorGC，当MinorGC之后新生代的内存仍然不够的时候，将对象复制到老年代进行MajorGC。永久代区域主要回收常量，无用class等。</p>
<h2><strong>六，JAVA中的四种引用类型</strong></h2>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;强引用类型<strong>：</strong>即把对象赋给一个引用变量，强引用的对象一定为可达状态，所以不会进行垃圾回收。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;软引用类型：通过SoftReference类实现，当内存不够的时候对其进行GC</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;弱引用类型：只有弱引用类型的对象，一定会被GC</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;虚引用类型：虚引用对象主要是用来跟踪对象的GC状态</p>
<h2><strong>七，分代收集算法和分区收集算法</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>分代收集算法：新生代因其存放大量短生命周期小对象，且GC频繁，所以采用复制算法。老年代因其存放长生命周期大对象，且GC不平凡，所以采用标记整理算法。永久代，回收常量，类信息等。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;分区收集算法：即将堆内存区域分为大小不同的区，可以按照不同的区进行快速垃圾回收，减少系统的停顿时间。然后再以并行的方式逐步完成整个GC。</p>
<h2><strong>八，垃圾收集器</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>新生代区域：Serial垃圾收集器，单线程复制算法，因为单线程无需进行线程之间的交互和切换，所以效率非常高，是JVM默认的client模式下的默认垃圾回收策略，工作期间需要暂停其它所有的线程。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ParNew垃圾收集器，多线程复制算法，跟单线程Serial一样，是JVM默认的server模式下的垃圾回收策略，工作期间需要暂停所有其它线程</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Parallel Scavenge垃圾收集器：多线程复制算法，不同的是优先考虑系统吞吐量，可以利用更高效的利用CPU完成GC</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;老年代区域：Serial Old垃圾收集器，单线程标记整理算法，同新生代的Serial功能一样，只是采取的算法不同而已。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Parallel Old垃圾收集器：多线程标记整理算法，优先考虑了系统的吞吐量，其次考虑停顿时间。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CMS,多线程标记清除算法，优先考虑系统GC时的停顿时间，且过程分为四步（<span style="background-color: #ffff00;">解释上文的可达性分析中的两次标记</span>，第一步：标记GC ROOTS可达对象，暂停其它工作线程；第二步：和用户线程一起工作，跟踪GC ROOTS；第三步，因为第二步用户进程没有暂停，所以有些对象状态</p>
<p>可能发生了改变，重新进行标记；第四步，清除不可达对象）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; G1垃圾收集器，多线程标记整理算法，将内存分区，与CMS相比，一方面不会产生内存碎片，一方面，可以精确的控制系统停顿时间。</p>
<h2><strong>九，JAVA的网络编程模型</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;</strong>阻塞I/O模型：即用户线程发出I/O请求之后，内核会检查数据是否准备就绪，这时候用户线程始终处于阻塞状态等待数据准备就绪。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;非阻塞I/O模型：即用户线程不断的给内核发出I/O请求，内核接受到I/O请求之后会返回一个状态，如果数据准备就绪，就将数据复制进入用户线程，如果数据没有准备好，返回一个false，用户线程无需阻塞，可以去处理其它事情，而当数据准备好了且刚好用户线程发起I/O请求进行操作。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;多路复用I/O模型：多路复用I/O模型通过一个Selector线程轮询Socket的状态，如果Socket有读写事件，则进行I/O操作。此模型的优势在于可以更好的处理连接数众多但消息体不大的情况下。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;信号驱动I/O模型：即用户线程发出一个I/O请求，系统会为该请求创建一个信号函数，用户请求可继续执行其它业务逻辑，当内核数据准备就绪之后会返回给用户线程一个信号，用户线程接收到之后进行I/O操作。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;异步I/O模型：用户线程给内核发起一个asynchronous read操作，内核接收到之后，返回其请求是否成功，然后等待数据准备成功之后复制到用户线程。整个过程中请求的发起和数据读取都在内核中进行，最终发送一个信号告知用户线程I/O操作已经完成，用户直接使用数据就行。（说实话个人感</p>
<p>觉和信号驱动很像）</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;java NIO：没怎么读懂（<span style="background-color: #993300;">记得补充！</span>）</p>
<h2><strong>十，JVM的类加载机制</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>JVM类加载分为五个阶段：加载，验证，准备，解析，初始化</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;加载：即将class文件加载到JVM中，且创建class对象，封装其数据结构。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;验证：对class文件进行验证，确保符合JVM的标准，保证JVM的安全。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;准备：即方法区中给类变量分配空间和赋初值。static修改的会在初始化阶段赋值，final修饰的会在准备阶段赋值。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;解析：即将常量池中的引用替换为直接引用</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;初始化：执行类构造器进行初始化。（因为内部流程不是很清楚，所以对于其几种不进行初始化的情况不做说明）</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;类加载器：JVM提供了三种类加载器，启动类加载器（/lib），扩展类加载器(/lib/ext)，应用程序类加载器(classpath)。还可以再应用程序类加载器自定义类加载器。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;双亲委派机制：即当一个类接收到类加载请求的时候，不会自己进行加载，而是将其加载请求委派给其父类加载器，这样一路委派，最终加载请求都会委派到启动类加载器.启动类加载器接收到加载请求之后会去lib目录下寻找相关的class文件，若找不到，则将其加载请求再委培给子类加载器，一路委派，直到能够加载。</p>
<h3><strong>最后，送给大家一张博主画的JVM的思维导图，以后读《深入JVM虚拟机》的时候可能会出一个JVM专题：<a href="https://uploader.shimo.im/f/X0MX3hLaHrevltxW.png!thumbnail" target="_blank" rel="noopener">JVM思维导图</a></strong></h3>
<p>&nbsp;</p>
<h2>水平有限，若发现有误，还望指出！</h2>, blogGoods=0, blogRead=17, blogCollection=0, typeName=java面试篇, blogRemark=面试（一）------之JVM篇, blogComment=0, blogSource=null, createdTime=2020-04-09 12:21:30, blogMonth=null, updateTime=2020-04-20 11:53:29), BlogVo(blogId=1248500061625745408, blogTitle=Linux基本命令, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dDA6AfCOJAAAyfL52jxY706.jpg, blogContent=<p><strong>一，Linux的发展历史</strong></p>
<p><strong>&nbsp; &nbsp; &nbsp; </strong>1965年之前，电脑并不像现在这么普遍，除了军事机构和研究即构，一般人基本接触不到电脑，而且那时候的一台大型主机最多也就只能支持30台终端。为了解决数量问题，1965年之后，由贝尔实验室，麻省理工学院以及通用电气一起放弃了Multics项目，准备让大型主机能够支持300台终端，但是在开发过程中，进度缓慢，最终由于资金的短缺，贝尔实验室推出了研究。1969年，从这个项目中退出的Ken Thompson在家无聊，为了让电脑能够运行&ldquo;星际旅行&rdquo;游戏，因而趁着妻子回家探亲的一个月，独自写出了Unix操作系统的原型（！！！！牛批）。1970年，这个人以BCPL语言为基础，又写出了很接近硬件的B语言，并且用B语言写出了第一个Unix操作系统。但是由于B语言的跨平台性比较差，为了解决这个问题。Dennis Ritchie和Ken Thompson决定以B语言为基础开发一种新的语言，1972年，Dennis Ritchie最终设计出了一种新语言，他以BCPL的第二个字母命名，也就是我们后来熟知的C语言。随后两人便迫不及待的用C语言重现Unix操作系统。Unix系统起初开源，但是在Unix7之后，由于政策的变化，代码闭源化，因而大学中不能使用Unix的源代码进行教学。Andrew S. Tanenbaum教授为了能够让学生更好的理解代码细节，在完全不使用任何源代码的情况下开发除了Minix---小型Unix。但是因为其只用于教学，功能并不强大，因而Torvalds以此为基础，开发除了Linux，但是起初Linux并不支持Unix，最终经过全世界网友的帮助，最终让其能够兼容各种硬件。</p>
<p><strong>二，文件和目录</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp; 1，windows和linux的区别：</strong>我们熟知的windows系统，它的文件系统是分盘符的，盘符下的文件构成一个树形结构，但是Linux文件系统没有盘符，所有文件目录都在根目录/之下</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;<strong>2，Linux需要记住的目录：</strong>/bin（存放系统命令的目录），/sbin（只有超级管理员能访问的命令文件目录），/root（存放和root用户相关文件的目录），/etc（存放系统配置文件的目录），/usr（存放系统共享资源的目录），/opt（存放安装的第三方软件的目录，通常在/usr/local下）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;<strong>3，文件权限：</strong>Linux中的文件权限有读（r，可用于数字4表示），写操作（w，可用数字2表示），执行权限（x，可用数字1表示）</p>
<p><strong>三，常用命令</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，ls：</strong>列出目录中的所有目录和文件名&nbsp; -a（列出所有，包括隐藏文件和目录），-l（以列表形式列出所有），-h（人性化列出，需要配合-l使用，即文件大小转换为我们熟知的kb，mb等），-d（显示当前目录属性），命令可以联合使用，例如-al，-lh等等。&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，cd：</strong>用于切换目录，需知（.和..是相对路径，.表示当前目录，..表示上级目录；/表示绝对路径），cd ~（切换到root目录），cd - （切换到前一次切换的目录）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，clear：</strong>清屏</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，pwd：</strong>显示当前所在目录</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，mkdir：</strong>创建目录，-p（如果目录存在则不创建，如果不存在则创建目录再创建自目录），可以一次性创建多级目录，例如：mkdir&nbsp; -p test/test1</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，touch：</strong>创建空文件</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>7，cp：</strong>复制，-r（递归复制目录下的文件目录信息），-i(提示是否覆盖)，-v（显示复制进度）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>8，mv：</strong>移动文件，不过经常用来给文件进行重命名</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>9，rm：</strong>删除目录或者文件，-r（递归删除），-f（强制删除），-v（显示删除进度）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>10，cat：</strong>查看文件内部信息</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>11，ln：</strong>文件创建链接，ln 源文件 目标链接文件（创建硬链接，硬链接和源文件大小相同，修改同步，但是删除不同步，使用较少），ln -s（创建软连接，相当于我们平时创建快捷方式，使用较多）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>12，which：</strong>搜索命令所在位置，例如：which&nbsp; &nbsp;ls</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>13，find：</strong>搜索文件所在位置&nbsp; 例如：find&nbsp; &nbsp;test.conf</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>14，grep：</strong>文件内容搜索，例如：grep &ldquo;想要搜索的内容&rdquo;&nbsp; 源文件</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>15，tar：</strong>归档命令，-c（打包成.tar文件），-z（打包的同时压缩），-v（打包的同时显示进度），-f（放在最后，后面跟.tar.gz），-x(解压)，常用：tar -zcvf&nbsp; <em><strong>.tar.gz&nbsp; &nbsp; ;&nbsp; &nbsp; tar -zxvf</strong> tar.gz</em> -C&nbsp; 指定解压目录&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;还有more，head，tail等命令，不过这些不常用。</p>
<p><strong>四，用户权限命令</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，whoami：</strong>查看当前账户的用户名</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，who：</strong>查看当前登录用户</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，exit：</strong>退出登录</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，adduser/useradd：</strong>添加用户，-d（指定用户主目录），-g（指定用户用户组），-m（自动建立目录），默认情况下用户主目录和用户组名都和用户名一样</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，passwd：</strong>只有root用户才能使用，用于修改用户密码</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，userdel：</strong>删除用户，默认不删除用户的主目录，-r（删除用户主目录）</p>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;7，su：</strong>切换账户</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>8，groupadd/groupdel：</strong>添加用户组和删除用户组</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>9，groups：</strong>查看用户所在用户组，例如：groups&nbsp; 用户名</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>10，usermod：</strong>修改用户所在用户组，例如：usermod&nbsp; 用户组名 用户名</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>11，chmod：</strong>修改文件权限，例如：chmod&nbsp; 777&nbsp; test</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>12，chown：</strong>修改文件所有者，例如：chown&nbsp; &nbsp;用户&nbsp; 文件名</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>13，chgrp：</strong>修改文件所在组，例如：chgrp&nbsp; 组名&nbsp; 文件名</p>
<p><strong>五，系统命令</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，cal：</strong>查看日历</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，date：</strong>查看时间，可以设置格式，例如：date '+<span class="ql-token hljs-built_in">%Y</span>-<span class="ql-token hljs-built_in">%m</span>-<span class="ql-token hljs-built_in">%d</span> <span class="ql-token hljs-built_in">%H</span>:<span class="ql-token hljs-built_in">%M</span>:<span class="ql-token hljs-built_in">%S</span>'</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，ps：</strong>查看线程</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，kill：</strong>杀死线程，-9（强制杀死）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，查看网卡信息：</strong>centos6：ifconfig ；centos7：ip addr</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，ping：</strong>查看网址或者链接的连通性</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>7，防火墙：</strong>centos6：service&nbsp; iptables&nbsp; status（查看防火墙状态），service&nbsp; &nbsp;iptables&nbsp; &nbsp;start(开启),service&nbsp; iptables&nbsp; stop(关闭);centos7:firewall-cmd&nbsp; --state（查看防火墙状态），systemctl&nbsp; start&nbsp; firewalld.service(启动)，systemctl&nbsp; &nbsp;stop&nbsp; firewalld.service（关闭）</p>
<p><strong>六，网络命令</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，wget：</strong>下载，例如：wget&nbsp; &nbsp;链接地址</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，yum：</strong>下载安装</p>
<p><strong>七，vim（这里只说几个常用的命令）</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;</strong>vim有三种模式：命令模式，插入模式，编辑模式&nbsp; &nbsp;</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;vim&nbsp; 文件名：进入文件，且处于命令模式；iao任意一键进入插入模式（i表示在贯标之前插入，a光标之后插入，o在下一行插入），：进入编辑模式</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;命令：set:nu显示行号，set:nonu不显示行号；/strinng，向后搜索字符串，？string向后搜索字符串；：w保存，：wq保存并退出，：q不保存退出</p>, blogGoods=0, blogRead=2, blogCollection=0, typeName=Linux, blogRemark=Linux基本命令总结, blogComment=0, blogSource=null, createdTime=2020-04-10 06:36:25, blogMonth=null, updateTime=2020-04-20 10:42:25), BlogVo(blogId=1248605157059497984, blogTitle=面试（二）------之JAVA基础篇, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dHMKAcvZ8AABJTVJPTfk020.jpg, blogContent=<h2><strong>一，集合</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，List：</strong>list是java中一种有序的集合，下有三个实现类，分别为ArrayList，Vector，LinkedList</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ArrayList：基于数组实现，增删慢，查询快，线程不安全。因为其基于数组实现，所以查询的时候可以直接根据数组的索引下标进行快速查询，但是进行增删操作的时候，需要将待增删元素后的元素全部移动，因而效率较低。且ArrayList创建时不需要分配初始大小，其空间不够的时候，会自动创建一个更大的list，然后复制数据。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Vector：基于数组实现，和ArrayList一样增删慢，查询快。但是线程安全，因为同一时间只支持一个线程对Vector进行写操作，然而因为要进行频繁的加锁和释放锁的操作，所以效率要低于ArrayList。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; LinkedList：基于双向链表实现，增删快，查询慢。因为基于链表实现，增删元素的时候，只需要改变元素的指针即可，改动较小，效率较高。然而进行查询操作的时候，需要从链表头部进行遍历，因而效率较低。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，Queue：</strong>队列，满足先进先出，种类较多。（不作详细解释）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，set：</strong>具有独一无二的特性，常用来存储无序且不重复的元素，对象相等的本质是hashcode的值相同，而如果想要比较两个对象是否相等，需要重写对象的hashcode方法和equals方法。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;hashset：基于hashTable实现，无序。存放的是对象的散列值，即通过hashcode计算得到的值</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;treeset：基于二叉树实现，即其中的对象按照一定的排序方式进行排列（升序，降序），每次添加对象的时候，都会进行排序，将其插入指定位置。基本的数据类型例如Integer，String等可以使用treeset默认的排序方法，而自定义数据类型需要实现compareable接口，实现compareTo方法。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;LinkHashSet：继承自hashset，只不过使用双向链表记录数据的顺序。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，map：</strong>一种键值对形式的集合</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;hashmap：基于数组+链表实现，增删改查操作快，但是每次遍历hashmap元素的顺序无法保证且线程不安全。如果想要其线程安全，可以使用synchronizedMap和ConcurrentHashmap，hashmap的内部是数组，数组中的每一个元素又是一个单向链表，链表中的每个元素嵌套一个Entry实例，其中包括Key，Value，Hash值，指向下一个节点的next。每次查询的时候，可以根据元素的hash值很快定位所在数组，但是定位之后需要遍历链表查找元素，因而时间复杂度为O（n），但是Java8之后对其进行了优化，将其改为了数组+链表或红黑树的结构，即当链表中的元素大于8个的时候，链表会转换为红黑树（红黑树是一种特化的二叉平衡树，因为其左右子树的深度差可以大于1），这样查询的时间复杂度就缩短到了O（logN）。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ConcurrentHashmap：采用分段锁的思想进行并发操作，因而使线程安全的。由多个Segment组成，只要保证每个Segment线程安全就可以保证全局线程安全。ConcurrentHashmap的默认Segment即并发度为16，可以在初始化的时候修改，但是初始化之后不能再修改。每个Segment内部的实现和hashmap一样&middot;。Java8之后也和hashmap进行了一样的优化。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;HashTable：线程安全，即同一时刻只能有一个线程对其进行操作，并发度不如ConcurrentHashmap。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;TreeMap：基于二叉树数据结构实现，实现了SortedMap，默认按照键值的升序进行排列。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;LinkedHashMap：Hashmap的子类，只不过使用链表保存元素的插入顺序。使用迭代器遍历的时候按照插入顺序遍历。</p>
<h2><strong>二，异常分类及处理</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;1，异常分类：</strong>Throwable是所有异常类的父类，其下有error和Exception，Error下有AwtError，ThreadDeath；Exception下有RuntimeException和CheckedException。</p>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</strong>对于Error类异常通常是由内部错误和资源耗尽造成的，无法在程序运行期间对其进行捕获和处理，对于这类错误我们只能记录错误的原因和终止程序。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; Exception中的RuntimeException异常（运行时异常）：这类异常是我们程序中异常处理的核心，可以在程序中进行捕获并处理。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Exception中的CheckedException异常（检查异常）：这类异常时程序中需要强制捕获的异常，通常有IO异常，SQL异常等等。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，异常处理：</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>异常处理有两种方式：抛出异常和捕获异常</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;抛出异常有三种方法：throws，throw，系统自动抛出。其中throws是作用在方法上，后面跟的是可能产生的异常类。throw是作用在方法内部，后面跟的是具体的异常对象。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 捕获异常：即使用try{}catch语句进行捕获</p>
<h2><strong>三，反射机制</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，什么叫做反射机制？</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>即在程序运行的过程中，可以获取类的属性和方法，并且可以调用任意一个类的方法。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，反射机制的使用</strong></p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 首先，获取类的class对象，有三种方式，className.getClass()，类对象.class，Class.forName("类路径")，其中最后一种最为安全，性能最好。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 然后利用反射的API可以实现对类中信息的操作，例如getDeclareFields（），getDeclareMethods（），getConstroctors（）等等。反射创建类的对像有两种方法，一，class.newInstance()初始化一个类实例；二，先获取其构造器，然后利用构造器初始化一个实例。利用反射调用类的方法：先获取方法，然后调用method.invoke()执行方法。</p>
<h2><strong>四，注解</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，四种元注解：</strong>@Target（指定注解的使用范围），@Retention（定义注解的保留级别，有三级，SOURCE源程序中保存，CLASS文件中保存，RUNTIME运行时保存），@Documented（可以工具文档化），@Inherited（<span style="background-color: #ffff00;">这个没怎么看懂</span>）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，注解使用示例：</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>第一步，定义注解接口</p>
<pre class="language-java"><code>@Target(ElementType.FIELD)  
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FruitProvider {

    //id
    public int id() default  -1;

    //供应商名称
    public String name() default "";

    //供应商地址
    public String address() default "";

}</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 第二步，使用注解</p>
<pre class="language-java"><code>public class Apple {

    @FruitProvider(id = 1,name = "红富士苹果",address = "陕西")
    private String appleProvider;

    public String getAppleProvider() {
        return appleProvider;
    }

    public void setAppleProvider(String appleProvider) {
        this.appleProvider = appleProvider;
    }
}</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第三步，定义注解处理器</p>
<pre class="language-java"><code>public class FruitInfoUtil {
    public static void getFruitInfo(Class&lt;?&gt; clazz) {
        String strFruitProvider = "供应商信息:";
        Field[] declaredFields = clazz.getDeclaredFields();
        for (int i = 0; i &lt; declaredFields.length; i++) {
            if (declaredFields[i].isAnnotationPresent(FruitProvider.class)) {
                FruitProvider annotation = declaredFields[i].getAnnotation(FruitProvider.class);
                strFruitProvider += annotation.id() + "," + annotation.name() + "," + annotation.address();
                System.out.println(strFruitProvider);
            }
        }
    }
}</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第四步，主方法入口</p>
<pre class="language-java"><code>public class FruitRun {
    public static void main(String[] args) {
        FruitInfoUtil.getFruitInfo(Apple.class);
    }
}</code></pre>
<h2><strong>五，内部类</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 1，静态内部类：</strong>即在类的内部定义的静态类，静态内部类可以访问外部了的静态变量和方法，外部也可以通过outClassName.innerClassName调用内部类</p>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2，成员内部类：</strong>在类的内部定义的没有用static修饰的内部类，使用方式和静态内部类一样。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>3，局部内部类：</strong>即一个类只在一个方法中使用，则完全可以将这个类定义为这个方法的内部类，即局部内部类，局部内部类可以实现真正的对外隐藏</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>4，匿名内部类：</strong>通常用于继承一个类或者实现一个接口的时候，使用new关键字定义，例如:Person person = new Student(){new Pupil(){}}</p>
<h2><strong>六，泛型</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 1，为什么要使用泛型：</strong>其根本目的是为了实现代码的复用，举个开发中常见的例子，我们需要定义返回类Result，返回类中包含状态码code，信息msg，以及数据data（任意类型），这个时候我们就需要使用泛型，因为我们返回的数据类型有各种vo，pojo类对象，list等。这时候泛型类result就可以被各种对象使用，实现代码的复用，简化开发。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>2，泛型标记和泛型限定：</strong>E表示集合中的元素，K表示键值，V表示value，N表示数值类型，T表示任意类型（包含基础类型，所有的对象类型），？（不确定的java类型）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>泛型限定：</strong>向上限定，&lt;?&nbsp; extends T&gt;，向下限定，&lt;? super&nbsp; T&gt;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; <strong>3，泛型方法：</strong>即参数类型定义为泛型类型，以便于接收不同类型的参数，做出不同的处理。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>4，泛型类：</strong>例如public class Pair&lt;T&gt;{private T data;}</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>5，泛型接口：</strong>与放泛型类类似</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>6，类型擦除：</strong>即在泛型编译的过程中，会将泛型类型替换为限定类型的操作</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>7，明确的一点：</strong>虚拟机在运行程序的过程中，内部是没有泛型的，只有普通的类和方法。</p>
<h2><strong>7，序列化</strong></h2>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 序列化是为了确保对象及其状态的持久化</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>序列化的使用：</strong></p>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </strong>首先，实现序列化接口java.io.Serializble</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 然后，声明序列化ID，通常private static final&nbsp; long&nbsp; serialVersionUid&nbsp; = ***</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 因为序列化是保证对象及其状态的持久化，而静态变量是不属于对象，属于类本身的，所以序列化无法保存静态变量。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果需要序列化父类变量，则父类也要实现Serializable接口</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t'ransient修饰的属性不会序列化</p>
<h3><strong>最后，提供一张思维导图供大家学习：<a href="https://images-cdn.shimo.im/es83SQH0CggucT7f__thumbnail" target="_blank" rel="noopener">JAVA基础</a></strong></h3>
<p>&nbsp;</p>
<h2>水平有限，如有错误，还望指出！</h2>, blogGoods=0, blogRead=27, blogCollection=0, typeName=java面试篇, blogRemark=面试（二）------之JAVA基础篇, blogComment=0, blogSource=null, createdTime=2020-04-10 13:34:02, blogMonth=null, updateTime=2020-04-20 11:53:39), BlogVo(blogId=1249313090567143424, blogTitle=面试（三）------之并发编程篇（上）, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dHM2AQOeZAABJTVJPTfk967.jpg, blogContent=<h2><strong>一，JAVA线程的创建方式</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>JAVA线程的创建有四种方式，分别为，继承Thread类，实现Runable接口，实现Callable&lt;Class&gt;接口，基于线程池。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>1，继承Thread方式：创建一个类继承Thread类，创建类的实例对象，调用start方法，继而执行线程的run（）方法，代码如下：</strong></p>
<pre class="language-java"><code>public class NewThread extends Thread{
    public static void main(String[] args) {
        NewThread thread = new NewThread();
        thread.start();
    }
    @Override
    public void run(){
        System.out.println("create  a  new thread by Thread!");
    }
}</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>2，当子类已经继承了一个类，这时候就没法再继承Thread类了，这时候就可以实现Runable接口，实例化类的线程实例，创建Thread实例传入类的实例，执行start方法，继而执行run（）方法代码如下：</strong></p>
<p>&nbsp;</p>
<pre class="language-java"><code>public class ThreadExample2 implements Runnable {
    public static void main(String[] args) {
        ThreadExample2 threadExample2 = new ThreadExample2();
        Thread thread = new Thread(threadExample2);
        thread.start();
    }
    @Override
    public void run() {
        System.out.println("create a new thread by Runnable!");
    }
}</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，有些情况下，我们需要再一个主线程中并发多个子线程执行同一个任务，然后回收子线程的返回值整理汇总，这时候就需要实现Callable&lt;Class&gt;接口，重写其call（）方法，用于计算结果。然床创建一个线程池用于提交线程，继而执行call方法，并且创建一个Future的list用于接收子线程逻辑代码即call方法的返回，最终遍历list，得到想要的返回值，如下：</strong></p>
<pre class="language-java"><code>public class ThreadExample3 implements Callable&lt;String&gt; {

    private String name;

    public ThreadExample3(String name){
        this.name = name;
    }

    @Override
    public String call() throws Exception {
        return name;
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService pool = Executors.newFixedThreadPool(3);
        List&lt;Future&gt; list = new ArrayList&lt;&gt;();
        for(int i=0;i&lt;3;i++){
            ThreadExample3 threadExample3 = new ThreadExample3(i+"");
            Future future =pool.submit(threadExample3);
            System.out.println(future.get().toString()+" is running");
            list.add(future);
        }
        pool.shutdown();
        for (Future future : list) {
            System.out.println("currentThread's result is "+future.get().toString());
        }
    }
}</code></pre>
<p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，基于线程池创建线程</strong></p>
<pre class="language-java"><code>public class ThreadExample4 {
    public static void main(String[] args){
        ExecutorService pool = Executors.newFixedThreadPool(3);
        for(int i=0;i&lt;3;i++){
            pool.execute(new Runnable() {
                @Override
                public void run() {
                    System.out.println("thread  is running by FixedThreadPool");
                }
            });
        }
        pool.shutdown();
    }
}</code></pre>
<h2>二，线程池的工作原理</h2>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong> &nbsp;1，概述：</strong>JVM根据用户提供的参数创建一定数量的线程任务，将其放入队列中，线程创建之后启动这些任务，如果线程的数量大于核心线程数量（用户设置的线程数量），则超出数量的线程排在队列中等待，当有线程任务执行完毕后，线程池调度器就会发现有可用可用线程，继而从队列中取出任务继续执行<strong>。</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; </strong><strong>2，线程复用：</strong>（参见JDK源码解读，这里只做简单描述），由前可知，JVM会根据用户提供的参数创建一定数量的线程任务，且将其添加到任务队列中。JVM通过start（）方法创建一个线程之后， 会相应的为其创建一个任务队列，线程会不停的查看任务队列，如果任务队列中有任务，则调用run方法，执行，这样就达到了一次start（）创建线程，多次使用，完成线程复用的任务。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>3，线程池的核心组件和核心类（见JDK源码分类中关于线程的总结）</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; </strong><strong>4，JAVA线程的工作流程：</strong>线程池刚被创建的时候，只是向系统申请一个执行线程队列和管理线程池的线程资源，当调用execute方法之后，执行下列流程：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果正在运行的线程数量小于corePoolSize（核心线程数量，即用户定义的的线程数量），则立即创建线程执行线程任务</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果正在运行的线程数量大于或等于corePoolSize，则将超过数量的线程加入到阻塞队列中</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在阻塞队列已满且线程数量小于MaximumPoolSize（即线程池能够容纳的最大线程数），线程池会创建非核心线程立即执行任务</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在阻塞队列已满且线程数量大于或等于MaximumPoolSize的时候，线程池会拒绝该线程任务且抛出异常</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在线程任务执行完毕之后，会将其从任务队列中移除，从队列中取出下一个线程任务执行</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在线程处于空闲状态且空闲时间超过KeepAliveTime，且线程数量大于corePoolSize的时候，会停止该线程，这样在没有任务的时候，线程池中的线程数始终维持在corePoolSize。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，线程池的拒绝策略：</strong>分为四种，分别为AbortPolicy，CallerRunsPolicy，DiscardOldestPolicy，DiscardPolicy</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; AbortPolicy：直接抛出异常，阻止线程运行，源码如下：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</p>
<pre class="language-java"><code>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
            throw new RejectedExecutionException("Task " + r.toString() +
                                                 " rejected from " +
                                                 e.toString());
        }</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CallerRunsPolicy：如果线程任务没有关闭，则尝试执行该线程任务，源码如下：</p>
<pre class="language-java"><code>* @param r the runnable task requested to be executed
* @param e the executor attempting to execute this task
*/
public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
     if (!e.isShutdown()) {
         r.run()
     }
}</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DiscardOldestPolicy：移除任务队列中最早进入的线程任务，执行当前任务线程，源码如下：</p>
<pre class="language-java"><code>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
       if (!e.isShutdown()) {
           e.getQueue().poll();
           e.execute(r);
       }
}</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DiscardPolicy：直接丢弃线程任务，不做任何处理</p>
<h2><strong>三，五种常用的线程池</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;newCachedThreadPool（可缓存线程池）：</strong>当线程池创建线程的时候如果发现有可复用的线程（执行完任务，且未关闭的线程），则直接复用，如果没有则创建新线程。可缓存线程池可以高效的利用执行任务时间短的线程，提高系统的性能，且线程池中的线程如果空闲时间超过60s，则会被终止且从缓存中移除，这样可缓存线程池不会占用系统资源。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>newFixedThreadPool（固定大小的线程池）：</strong>即线程池中的线程是初始化固定的，当任务线程大于线程池中线程数量时，任务线程就会进入阻塞队列等待。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newScheduledThreadPool（可做任务调度的线程池）：</strong>即可以设置线程执行的停顿时间和执行周期，进行定期定时的执行某个任务。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newSingleThreadPool（单个线程的线程池）:&nbsp;</strong>即线程池中永远只有一个线程进行工作，如果下称停止或者异常，则线程池创建新的线程替代当前线程</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newWorkStealingPool（足够大小的线程池）：</strong>即创建足够数量的线程的线程池，保证更快的进行运算，提高效率。</p>
<h2><strong>四，线程的生命周期</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;线程的生命周期大致分为五个阶段：新建（new），就绪（Runnable），运行（Running），阻塞（Blocked），死亡（Dead）</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;新建：</strong>即使用new创建一个线程</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>就绪：</strong>调用start方法，</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>运行：</strong>即线程获取cpu资源，执行run（）方法，进入运行状态，运行状态的线程如果调用yield（线程让步方法）或者失去cpu资源，都会导致线程重新回到就绪态；如果调用sleep方法，I/O阻塞，等待同步锁，等待通知以及suspend挂起都会导致线程进入阻塞态。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞：</strong>即线程被放入Blocked池。阻塞状态的线程如果结束了sleep方法，I/O方法返回，获取同步锁，收到通知或者resume都会导致其重新进入就绪态，与其它线程竞争cpu时间片。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>死亡：</strong>线程正常执行完run（）或者call（）方法，或者执行stop方法，或者发生异常或者错误都会导致线程死亡。（stop方法会导致锁混乱和死锁，不建议使用）</p>
<h2><strong>五，线程的基本方法</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;wait（线程等待）：</strong>会让线程进入WAITING状态，并且会释放对象的锁。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>sleep（线程睡眠）：</strong>会让线程进入睡眠，进入TIMED_WAITING状态，但是不会释放对象锁，睡眠时间到了之后，再次恢复运行状态</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>yield（线程让步）:</strong>&nbsp; 当前线程会让出其占有的cpu资源，重新回到就绪态和其它线程竞争cpu时间片</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>interrupt（线程中断）:&nbsp; </strong>中断当前线程，但是并不会导致其停止，只是改变其内部的终端标识位，在使用了thread.sleep()之后使用该方法，会导致抛出异常，且我们可以利用中断标识位进行线程的安全退出</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>join（线程加入）：</strong>即将当前线程进入阻塞态，等待下一个线程执行完毕后进入就绪态，重新竞争锁资源。通常用于主线程下面执行子线程，需要主线程阻塞，等待子线程执行完毕后返回其结果给主线程，主线程再执行的情况。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>notify（线程唤醒）/notifyAll：</strong>前者随机唤醒一个等待线程，后者全部唤醒</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>setDaemon（守护线程）:</strong>级别较低的线程，用于后台运行，服务用户用户线程，例如垃圾收集线程就是典型的守护线程。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>sleep方法和wait方法的区别：</strong>前者属于Thread，后者属于Object，前者不会释放锁资源，后者会释放锁资源</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>start方法和run方法：</strong>start方法只是创建一个线程，并没有运行，run方法时执行线程的真正代码逻辑。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>线程退出的方式：</strong>见四中最后一条</p>
<h2><strong>六，JAVA中的锁（知识比较杂乱）</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述:JAVA中的锁是为了保护数据的一致性。按照不同的标准可分为乐观锁和悲观锁，公平锁和非公平锁，共享锁和独占锁，偏向锁，轻量级锁，重量级锁，自旋锁，可重入锁。</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;乐观锁：</strong>即认为每次读取数据都不会被修改，当修改操作的时候再判断当前数据是否被修改，未修改则修改，若已被修改，则返回失败状态。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>悲观锁：</strong>即认为每次读取数据都会被修改，因而每次读取数据都对其进行加锁，这样只有当前用户可以修改，其它用户阻塞等待直到当前用户修改完毕释放锁资源。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>自旋锁：</strong>即有些线程任务的执行很短，很快就可以释放锁资源，为了避免在这种情况下竞争线程仍然进行内核态和用户态之间的转换，因而让线程自旋（即等一会），如果有可用锁，则获取，减少了线程在用户态和内核态之间切换的时间损耗。提高了性能（优势）。当然线程自旋是占用cpu资源的，因而需要设置一个自旋的最大等待时间，如果超过此时间，则线程退出自旋模式。对于线程竞争锁资源激烈的情况，自旋有可能会导致cpu资源的损耗（劣势）。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>公平锁和非公平锁：</strong>即根据线程竞争锁资源的机制判定，一般如果依据先到先得的原则，则位公平锁；如果依据就近原则，则位非公平锁。公平锁相比于非公平锁会更加耗费性能，因为要维护一个线程任务丢列，根据线程任务在队列中的顺序分配锁资源，因而不常用。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>可重入锁：</strong>又被称为递归锁，即该锁可以然后线程对其进行多次的加锁操作。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>偏向锁：</strong>当线程获取到锁的时候，用来消除线程的锁重入的开销（看起来是偏袒这个线程）。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>共享锁和独占锁：</strong>共享锁即多线程共享锁资源（典型例子，读锁）；独占锁即当前锁只能有一个线程获取，其它线程阻塞</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>轻量级锁：</strong>没有多线程竞争的前提下，减少重量级锁的使用提高性能。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>重量级锁：</strong>基于操作系统的互斥量而实现的锁，会导致进程在用户态和内核态之间切换，耗费性能。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>synchronized：独占式悲观锁，可重入锁，非公平锁，重量级锁。</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 作用范围：</strong>作用于成员变量和非静态方法，相当于锁住的是对象的实例，即this对象</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;作用于静态方法，相当于锁住的是class实例</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;作用域代码块，相当于锁住的代码块中的对象</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>实现原理：</strong>内部包括ContentionList（锁竞争队列），EntryList（竞争候选列表），WaitSet（等待集合），OnDeck（竞争候选者），Owner，!Owner，其中ContentionList是用来存放竞争锁资源的线程。EntryList是用来存放有资格竞争锁资源的线程。调用wait方法后放入WaitSet中，onDeck指的是同一时刻，只有一个线程竞争锁资源，Owner指的是得到锁资源的线程，!Owner指的是线程执行完毕，释放锁资源的线程。需要注意的是线程首先采用的都是自旋模式获取锁资源，如果自旋获取不到再加入ContentionList，而且Owner状态的线程并不是直接把锁资源交给onDeck状态线程，而是给它竞争锁资源的权利，因而onDeck状态的线程还需要跟自旋线程竞争锁资源。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>ReentrantLock：独占式，可重入锁，并且可以实现公平锁和非公平锁，重量级锁。</strong></p>
<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;用法：</strong>lock()加锁，后跟try代码块，finally中进行释放锁unlock()</p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;避免死锁的方法：</strong>响应中断（即可以根据情况中断对锁资源的请求），可轮询锁（tryLock（）即尝试获取锁，如果有可用锁则获取返回true，没有则返回。和lock（）的区别在于lock获取锁资源如果没有则一直等待直到获取到锁资源），定时所（tryLock（time,unit）即再一定时间内如果有可用锁，且线程未中断则获取锁，否则禁用当前线程。）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>Semaphore（信号量）:</strong>机制和ReentrantLock类似</p>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ReadWriteLock（读写锁）：</strong>如果系统要求支持多线程共享读，但不能多线程写，使用读锁；如果要求同一时刻只能有一个线程写，写的过程中不能读取该共享数据，则使用写锁。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; <strong>分段锁：</strong>一种思想，将数据分段加锁，例如ConcurrentHashMap</p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;死锁：</strong>即线程之间互相共享资源会导致死锁</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; <strong>锁优化：</strong>第一，减少锁的持有时间；第二：减小锁粒度，例如分段锁；第三：锁分离，例如读写锁；第四：锁粗化，放置锁粒度太小，造成频繁加锁释放锁；第五：锁消除，消除程序代码不规范而造成的乱用了锁</p>
<p>&nbsp;</p>
<h3><strong>并发编程（上）的思维导图送上：<a href="https://images-cdn.shimo.im/1UcHkyrlJyGRPYnn.png__thumbnail" target="_blank" rel="noopener">并发编程（上）</a></strong></h3>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>
<h1>水平有限，如果错误，还望指出！</h1>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;</p>, blogGoods=0, blogRead=8, blogCollection=0, typeName=java面试篇, blogRemark=面试（三）------之并发编程篇（上）, blogComment=0, blogSource=null, createdTime=2020-04-12 12:27:07, blogMonth=null, updateTime=2020-04-20 11:53:51), BlogVo(blogId=1249588251598041088, blogTitle=redis基础（一）, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6caUuADBI7AAAb07iHSRw500.jpg, blogContent=<h2><strong>一，redis简介</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>redis是NoSQL型系统之一，与之相似的还有Memcache，用来存储key-value这种键值型数据。相比于Memcache而言，redis不仅可以做临时缓存，还可以做数据持久化，将数据定时的存入硬盘或者将命令追加到日志文件当中。而Memcache只能做临时缓存，因而现在基本上已经被redis完全取代。redis的读写速度非常快，官方给出的数据是读110000次/s，写81000次/s；而且redis支持多种数据类型，例如String，list，hash，set，zset；redis支持主从复制（集群），进行数据持久化；还支持过期时间，事务等。</p>
<h2><strong>二，redis的安装与启动（docker环境下）</strong></h2>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;docker安装完毕后，安装redis：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第一步：拉取redis镜像，docker&nbsp; pull&nbsp; redis</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第二步：启动redis，docker&nbsp; &nbsp;run&nbsp; &nbsp;redis&nbsp; &nbsp;</p>
<p><strong>三，基本知识串讲</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>单进程单线程：redis只有一个进程，且内部为单线程，这样做的优势是不存在线程安全问题，且不需要进行线程间的切换，提高了性能，而且多线程可能会涉及到锁。劣势是无法发挥多核cpu的优势，不过可以通过开启搭建多个redis实例实现</p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>redis中默认有16个数据库（0-15），可以通过select n来进行数据库之间的切换</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;常用的基本命令：flushDB（清空当前数据库），flushAll（清空所有数据库），dbSize（查看有多少数据库）</p>
<h2><strong>四，redis基本数据类型</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;string：</strong>字符串类型，数据库中存储Map&lt;String,String&gt;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>list：</strong>列表数组类型，数据库中存储Map&lt;String,List&lt;Object&gt;&gt;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>hash：</strong>哈希类型，数据库中存储Map&lt;String,Map&lt;Object,Object&gt;&gt;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>set：</strong>集合类型，其中元素无序，数据库中存储Map&lt;String,Set&lt;Object,Object&gt;&gt;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>Zset：</strong>有序集合类型，每个元素都有一个可用于排序的权重</p>
<h2><strong>五，redis相关命令（这里详解一些常用的命令，不常用的一笔带过）</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;string：</strong>(1)set&nbsp; key&nbsp; value,插入一条数据&nbsp; （2）mset&nbsp; key value...批量插入 （3）setnx&nbsp; key value&nbsp; 若无则插入（4）get&nbsp; key&nbsp; 获取某条数据&nbsp; （5）mget keys 批量获取&nbsp; （6）getrange key&nbsp; 0 -1获取数据库全部数据&nbsp; （7）incr age 递增&nbsp; (8) incrby&nbsp; age&nbsp; 10&nbsp; 递增 age 步长为10（9）decr&nbsp; age&nbsp; 递减&nbsp; （10）decrby&nbsp; age&nbsp; 10 步长递减&nbsp; &nbsp;（11）del&nbsp; key&nbsp; 删除某条数据&nbsp; <span style="background-color: #ffff00;">（12）exists&nbsp; key&nbsp; 判断是否存在某个key&nbsp; &nbsp;(13)expire&nbsp; key&nbsp; 10&nbsp; 设置过期时间（单位为秒）&nbsp; （14）pexpire&nbsp; key&nbsp; 1000 设置过期时间，单位为毫秒&nbsp; （15）persist key删除过期时间 （</span><span style="background-color: #ffff00;">16）ttl&nbsp; key&nbsp; 查看过期时间</span></p>
<p><span style="background-color: #ffff00;">&nbsp;<span style="background-color: #ffffff;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>list：&nbsp;&nbsp;</strong>（1）lpush&nbsp; key&nbsp; value 左插入一条数据&nbsp; &nbsp;（2）lpush mylist&nbsp; key&nbsp; value....批量左插入&nbsp; （3）rpush&nbsp; key value 右插入一条数据&nbsp; (4)rpush&nbsp; mylist&nbsp; key value...右批量插入&nbsp; （5）lrange&nbsp; mylist&nbsp; 0&nbsp; -1&nbsp; 取出数据集合&nbsp; （6）lpop mylist 左弹出集合中第一条数据&nbsp; （7）rpop&nbsp; </span></span><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">mylist&nbsp; 右弹出集合中第一条数据&nbsp; （8）llen&nbsp; mylist&nbsp; 获取数据集合长度lrem&nbsp; mylist&nbsp; count&nbsp; value&nbsp; （count&gt;0,从表头开始搜索，移除count个与值与value相等的元素；count&lt;0,表尾开始；count=0，移除所有值与value相等的元素） （9）linsert mylist&nbsp; before/after&nbsp; a&nbsp; 在a元素前或后插入。</span></span><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">(10) lpoplpush&nbsp; list&nbsp; list1 转移列表的元素到另一个列表</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>hash：</strong>（1）hset&nbsp; key&nbsp; &nbsp;val-key&nbsp; val-val&nbsp; 插入一条数据&nbsp; （2）hset&nbsp; myhash&nbsp; name&nbsp; xxx&nbsp; 用于给哈希表中的字段赋值，不存在则创建哈希表赋值，存在则覆盖旧值&nbsp; (3) hget&nbsp; &nbsp;myhash&nbsp; name&nbsp; 取哈希表中某个值&nbsp; （4）hmset&nbsp; myhash name&nbsp; xxx age xxx&nbsp; 批量插入字段&nbsp; （5）hmget</span></span><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">批量获取 （6）hgetall&nbsp; myhash&nbsp; 获取哈希表中所有值&nbsp; (7)&nbsp; hexisets myhash&nbsp; name&nbsp; 判断哈希表中是否存在name字段&nbsp; （8）hsetnx&nbsp; myhash score 100 若存在则不插入，若不存在则插入数据&nbsp; （9）hincrby&nbsp; myhash id 1/hdecrby&nbsp; myhash id&nbsp; 10 递增递减 （10）hdel&nbsp; myhash name&nbsp; </span></span><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">删除&nbsp; （11）hkeys&nbsp; myhash&nbsp; 只取key值&nbsp; （12）hvals&nbsp; myhash&nbsp; 只取value值&nbsp; （13）hlen&nbsp; myhash 获取哈希表长度</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>set：</strong>（1）sadd myset&nbsp; redis&nbsp; 添加一条数据&nbsp; （2）smembers myset&nbsp; 获取数据集合&nbsp; （3）srem&nbsp; myset&nbsp; set1&nbsp; 删除set1&nbsp; （4）sismember myset&nbsp; set1 判断set中是否存在set1&nbsp; (5)srandmember&nbsp; key count&nbsp; 随机获取count个元素（6）spop&nbsp; 从集合中弹出一个元素</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>zset：</strong>之后补充</span></span></p>
<h2><strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">六，redis配置文件（常见配置）</span></span></strong></h2>
<p><strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;daemonize no：</span></span></strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">redis默认不是以守护进程的方式运行的，可以更改为yes启用守护进程（即后台运行）</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>pidfile&nbsp; /var/run/redis.pid&nbsp; :</strong>启用守护进程后，默认将pid写入/var/run/redis.pid文件，可以更改</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>port&nbsp; 6379 ：</strong>redis默认端口</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp; &nbsp; &nbsp; &nbsp; <strong>bind&nbsp; 127.0.0.1：</strong>绑定的主机地址</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;"> &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>timeout&nbsp; 300</strong><strong>：</strong>redis客户端闲置多长时间后关闭连接，改为0的话，表示关闭该功能</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>loglevel&nbsp; verbose：</strong>默认日志级别（还有debug，notice，warning）</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>database 16：</strong>redis默认有16个数据库可以修改</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>save&nbsp; 900&nbsp; 1/save&nbsp; 300&nbsp; 10/save&nbsp; 60&nbsp; 10000：&nbsp;</strong>表示一定时间内有多少条数据发生修改，就将其同步到数据文件一次，例如第一个表示15分钟内有一条数据发生改变就同步</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>rdbcompression yes&nbsp; ：</strong>表示数据存储到本地数据库时是否进行压缩</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>dbfilename&nbsp; dump.rdb：</strong>指定本地数据库文件名</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>dir&nbsp; /...../redis安装目录/bin ：</strong>本地数据库存放目录，默认在redis安装目录的bin目录下</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>slaveof&nbsp; &nbsp;masterip&nbsp; masterport ：</strong>设置当本机为从机时，它的主机的ip和端口</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>masterauth&nbsp; &lt;master-password&gt;：</strong>当master服务设置了密码时，slav服务连接master的密码</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>requirepass&nbsp; foobared：</strong>默认关闭redis连接需要密码，当给redis设置了密码，就需要打开</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>maxclients&nbsp; &nbsp;128：</strong>redis同一时间最大连接客户端的数量</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>appendonly&nbsp; &nbsp;no：</strong>是否开启aof持久化，默认不开启，采用rdb</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>appendfilename&nbsp; appendonlu.aof：</strong>指定aof持久化的文件名</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>appendfsync&nbsp; everysec :</strong>指定更新日志条件，默认每秒更新一次（还有no，指等操作系统进行数据缓存到磁盘，快；always指每次更新操作后都手动写入磁盘，慢但安全）</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;虚拟机方面的配置暂不说明</span></span></p>
<h2><strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">七，redis持久化</span></span></strong></h2>
<p><strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;概述：</span></span></strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">redis持久化主要有两种方式，即rdb和aof</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>rdb：</strong>适用于大数据集的恢复，数据的备份，但是因为设置周期时间进行数据的快照，所以如果redis宕机，可能会丢失最后一个写操作的数据，因为数据完整性较差。数据保存在dump.db文件中，只需要移动到redis安装目录，重启即可恢复数据</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>aof：</strong>适用于对数据的完整性要求较高的情况，因为可以设置不同的持久化策略，例如每秒保存一次，这样即时redis宕机，也只会丢失最后一秒的数据。但是因为其日志文件存储的是写入命令，因而其文件大小要大于rdb的数据文件，且每次重启，都要从头执行数据文件中的命令，因而恢复速度也</span></span><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">要慢于rdb。</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>注意：</strong>当rdb和aof同时开启的时候，redis重启，默认会采用aof的形式进行数据的重新构建</span></span></p>
<h2><strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">八，redis事务</span></span></strong></h2>
<p><strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;概述：</span></span></strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">什么是事务？事务即是一系列的命令要买全部执行，要么全部回滚</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <strong>常用命令：</strong>multi(启动事务)，discard（取消事务）,exec（执行事务块内命令）,watch key(监控某个key的变化)，unwatch（取消对所有key的监控）</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>注意：</strong>redis的事务中在命令本身出错的情况下会造成命令的全部回滚，但是在命令无错，执行某个命令的时候发生异常的时候，则谁的错，谁停止（这一点和mysql是不同的）</span></span></p>
<h2><strong>九，redis的主从复制</strong></h2>
<p><strong>&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>redis的主从复制，即主机数据更新后根据我们设置的策略将数据同步到从机上，主机以写为主，从机以读为主<strong>。</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 使用：</strong>配主不配从，在从机中使用slaveof&nbsp; 主机ip&nbsp; &nbsp;主机端口配置从机，但是这种配置方式当redis重启之后就会失效，如果想要redis重启仍然可用，则需要配置redis.conf配置文件中的slaveof&nbsp; masterip&nbsp; masterport。这种配置方式的问题所在，中心化只有一台极其支持写操作，如果主机宕机，则从机等待，且从机宕机重启后不会跟上大部队（即重启后变为主机）。当然我们可以采用命令slave&nbsp; no&nbsp; one 使从机反客为主，成为主机。但是这种手动操作太过麻烦。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>哨兵模式：</strong>即配置之后，如果主机宕机，则哨兵会自动根据投票规则在从机中进行选举，从而产生新的主机顶替。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>主从复制的缺点：</strong>因为所有的写操作都是子主机上进行，从而在同步到从机上，所以存在着一定的延迟，当系统繁忙或者从机数量较多的时候，这种问题就更加明显。</p>
<h2><strong>十，redis集群</strong></h2>
<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;概述：</strong>集群是一种去中心化的模式，与中心化模式不同的是，中心化模式中如果主服务挂掉了，那么服务就挂掉了。但是集群模式下，没有主路由，每个节点自身都可以成为路由</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;redis集群：即配置多台主机，多台从机，不同的主机中有不同的槽点，当执行数据写入时，会根据crc16算法计算出数据的槽点，从而将数据存入到对应的主机中，并同步到与其对应的从机中</p>
<p>&nbsp;</p>
<h1>水平有限，如有错误，还望指出！</h1>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong></p>, blogGoods=0, blogRead=4, blogCollection=0, typeName=redis, blogRemark=redis基础（一）, blogComment=0, blogSource=null, createdTime=2020-04-13 06:40:30, blogMonth=null, updateTime=2020-04-20 16:47:37), BlogVo(blogId=1249742755949817856, blogTitle=面试（三）------之并发编程篇（下）, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dHNmAPuxmAABJTVJPTfk117.jpg, blogContent=<h2><strong>一，线程上下文切换</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>cpu利用时间片轮询的方式来为每个任务都分配一定的时间片，任务的执行过程中保存任务的状态。任务状态的保存和在加载就叫做上下文切换。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>进程：</strong>指的是一个运行中的程序实例，一个进程中可以有多个线程，并且与进程共享同样的内存和系统资源</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong> 上下文：</strong>指的是寄存器和程序计数器保存的线程的信息</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>寄存器：</strong>指的是内存中很小但是运行速度很快的一块区域（相对于RAM外部内存）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>程序计数器：</strong>一种寄存器，用来保存当前执行指令的位置或者下一个待执行指令的位置</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>上下文切换：</strong>上下文切换指的是操作系统的内核在cpu上对进程或者线程的切换。上下文信息保存在进程控制块中（PCB）。流程如下：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;挂起当前进程，将进程的上下文信息保存在进程控制块中；</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;在进程控制块中寻找下一个任务的上下文信息。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;恢复进程</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>上下文切换的原因：</strong>第一，任务正常执行完毕，调度下一个任务；第二，线程出现I/O阻塞，被挂起，cpu调度下一个任务；第三，线程等待同步锁，获取socket通知等，被挂起，cpu调度下一个任务；第四，用户调用sleep方法，让出cpu；第五，硬件中断</p>
<h2><strong>二，JAVA阻塞队列</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>阻塞队列的是调度当前队列的线程处于阻塞状态</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 消费者阻塞：如果队列为空，则消费者线程被挂起，处于阻塞状态，当有新数据进入队列，则消费者线程被唤醒，消费数据</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 生产者阻塞：如果队列数据已满，则生产者线程挂起，处于阻塞状态，当队列有空闲位置，生产者线程被唤醒，生产数据。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞队列的主要操作：</strong>插入操作和移除（获取）操作</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>插入操作：</strong>add(e)，有空间则插入，无空间报异常；offer(e),有空间则插入，无空间返回false；offer(e,time,unit),有空间插入，无空间等待time时间，若超时返回false；put(e),有空间插入，无空间则线程挂起处于阻塞直到有空间</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>移除操作：</strong>poll(e),有值返回值，无值返回null;poll(e,time,unit),有值返回值，无值等待time时间，超时返回null;take(e),有值返回值，无值等待新数据进入再立即返回；drainTo(collection&lt;Object&gt;)批量移除，提高获取效率</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞队列的实现：</strong></p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong> ArrayBlockingQueue：</strong>基于数组的有界阻塞队列，按照先进先出顺序对元素进行排序</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>LinkedBlockingQueue：</strong>基于链表的有界阻塞队列，队头队尾采用不两个不同的锁控制数据同步，并发性高</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>PriorityBlockingQueue：</strong>基于优先级的无界队列，默认升序排列，可以自定义排序规则，根据优先级访问数据。但是有数据优先级一样的情况</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>DelayQueue：</strong>支持延时的队列，即从队列中取数据时等待一定的时间才能获取元素。可以用于缓存系统的设计，设计过期时间，也可以用来设置定时调度任务，即如果能够从队列中获取，说明到了任务的调度时间。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>SynchronousQueue</strong>：该队列是一个不存储元素的阻塞队列，每一个put操作都必须等待一个take操作的完成。吞吐量高于ArrayBlockingQueue和LinkedBlockingQueue。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>LinkedTransferQueue：</strong>基于链表的无界阻塞队列，多了transfer方法(如果消费者等待，直接将任务从生产者传递给消费者，无消费者等待，则将任务加到队尾直到被消费才返回)和tryTransfer（与transfer一致，只不过不管有没有消费者等待获取都会立即返回tryTransfer（e,time,unit）（与tryTransfer一致，只不过设置了超时时间）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>LinkedBlockingDeque：</strong>基于链表的双向阻塞队列，可以在两端同时进行读写操作，提高了队列的操作效率。</p>
<h2><strong>三，并发关键字</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;CountDownLatch：</strong>适用于一个主线程等待子线程完成任务之后执行（原理：设置一个程序计数器，计数器的值为子线程的个数，子线程并发执行，每个子线程执行完毕后，调用CountDown方法，将其计数器的值减去1，值为0时，唤醒主线程执行）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>CyclicBarrier：</strong>即当所有线程到达一个状态共同执行。await（）方法：确保所有线程到达Barrier状态才执行；await（time,unit）：设置一个超时时间，超过这个时间，执行达到Barrier状态的线程。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>Semaphore：</strong>因为其限制了多线程访问资源的线程个数，所以适用于多线程并发访问有限资源的情况。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>volatile：</strong>直接用来修饰变量，是一种比Synchronized更加轻量级的机制，用于多线程共享同一变量，可以同时对其进行读写操作。当多个线程共享变量的时候，读取变量将其从内存复制到cpu缓存中，然后线程对其操作进行修改，这样再多cpu的情况下，有可能出现线程修改原数据造成数据不一致的情况，使用volatile关键字直接将线程修改的变量存入内存，解决这个问题。</p>
<h2><strong>四，多线程共享数据</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>多线程共享数据主要通过共享内存实现，而共享内存的可见性，有序性，原子性已经由JVM和锁解决。理想情况下我们需要解决同步和互斥的问题（<span style="background-color: #ffff00;">怎么解决的有待考证！</span>）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>解决方法一：</strong>将数据抽象成一个类，将对数据的操作封装成类中的方法</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解决方法二：</strong>将Runnable对象作为一个内部类，将共享数据作为这个类的成员变量</p>
<h2><strong>五，ConcurrentHashmap并发</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ConcurrentHashmap使用了减小锁粒度，这里具体为分段锁的思想优化了锁，因为如果直接对hashmap进行加锁，锁太大，而且同一时刻只能有一个线程操作hashmap，并发性能较差</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;实现原理：</strong>即内部采用分段锁思想，将hashmap分为多个segment，每次读取数据的时候，对数据所在的segment进行加锁，这样只要保证每个segment线程安全，就可以保证整个hashmap线程安全</p>
<h2><strong>六，JAVA中的线程调度</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;抢占式调度：</strong>即线程对cpu资源进行抢占，这种策略下每个线程抢占到cpu资源的概率是相等的，这样就不会一个线程阻塞造成整个系统阻塞的情况。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>协同式调度：</strong>即一个线程使用完cpu资源之后通知cpu调度下一个任务，适用于多线程交替执行任务。因为如果一个线程阻塞可能会造成整个系统阻塞甚至崩溃</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>JAVA采用的是抢占式调度，但同时又尽可能的保证公平性（即为每个线程分配优先级不同的cpu时间片）</strong></p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>&nbsp;线程让出cpu的情况</strong>：第一，线程调用yield方法；第二，I/O阻塞，socket等待等；第三，等待同步锁；第四，正常执行完毕</p>
<h2>七，进程调度算法</h2>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>优先调度算法：</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;先来先服务调度算法：</strong>即遵循先来先被分配cpu资源运行的原则</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>短作业调度算法：</strong>即预估作业的时间长短，优先调度时间短的任务，可能会导致长时间大任务很长时间无法被调度 &nbsp;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>高优先权调度算法：即每个任务会预先被分配优先级</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;非抢占式优先调度算法：</strong>按照优先级的高低一次分配cpu资源运行</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>抢占式优先调度算法：</strong>按照优先级的高低分配cpu资源运行，但是如果任务再运行过程中有优先级更高的任务加入，则将其cpu资源临时回收分配给紧急任务</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>高响应比调度算法：</strong>动态调度，即作业时间短，则优先级高；等待时间长，则优先级高。前者遵循短作业调度算法，后者遵循先来先服务原则。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>时间片轮转调度算法：</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;时间片轮转法：</strong>按照任务再队列中的顺序进行调度</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>多级反馈队列调度算法：</strong>即再时间片轮转法的基础上维护了就绪队列，默认第一队列优先级高，先调度第一队列的任务，如果再分配的cpu时间片内未完成则将其加入第二队列队尾，以此类推直到其执行完毕。只有第1 -（n-1）队列为空，才会调度第n队列的任务，而且当前任务执行时，如果有优先级高的任务进来，会抢占其cpu资源。</p>
<h2><strong>八，CAS</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>即比较和交换，CAS（V,E,N）三个参数，只有当V=E的时候才会将V设置为N。如果V!=E，则说明数据已经被其它线程修改，不做任何操作</p>
<h2><strong>九，ABA问题</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>概述：</strong>即当1线程从V中取出A时，2线程也从中取出1，修改为B，再修改为A。而1线程仍然修改成功，实际上修改过程中V的实际值已经发生改变，只不过1没有发觉。解决这种问题，常采用乐观锁的版本号机制。</p>
<h2><strong>另外有AQS问题没怎么读懂，下次完善！</strong></h2>
<p>&nbsp;</p>
<h3><strong>思维导图：<a href="https://images-cdn.shimo.im/myFodjsaVAA3PVV7__thumbnail" target="_blank" rel="noopener">并发编程（下）</a></strong></h3>
<p>&nbsp;</p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</p>, blogGoods=0, blogRead=17, blogCollection=0, typeName=java面试篇, blogRemark=面试（三）------之并发编程篇（下）, blogComment=0, blogSource=null, createdTime=2020-04-13 16:54:26, blogMonth=null, updateTime=2020-04-20 11:54:02), BlogVo(blogId=1250068950784536576, blogTitle=面试（四）------之数据结构篇, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dHQGAYlUxAABJTVJPTfk990.jpg, blogContent=<h2><strong>一，栈及其JAVA实现</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：栈是一种先进后出的数据结构，对栈顶元素的添加，删除等操作较快，但是对于栈内的元素操作很慢</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA实现：实现需要定义栈的数据结构，写栈的入栈，出栈，获取栈顶元素的方法，如下：</strong></p>
<pre class="language-java"><code>/**
 * 基于数组实现栈
 * @author wcj
 * @Date 2020/4/14 20:59
 * @Version 1.0
 */
public class StackExample&lt;E&gt; {

    /**
     * 站的深度
     */
    private int maxSize;
    /**
     * 存储数据的数组
     */
    private Object[] data;
    /**
     * 栈顶指针
     */
    private int top = -1;

    /**
     * 默认栈的深度为10
     */
    public StackExample(){
        this(10);
    }

    /**
     * 用户自定义栈的深度
     * @param initialSize
     */
    public StackExample(int initialSize){
        if(initialSize&gt;=0){
            this.maxSize = initialSize;
            this.data = new  Object[initialSize];
            this.top = -1;
        }else{
            throw new RuntimeException("初始化栈的深度不能小于0!");
        }
    }

    /**
     * 入栈操作
     * @param e
     * @return
     */
    public Boolean push(E e){
        if(top == maxSize-1){
            throw new RuntimeException("栈已满,不能入栈");
        }else{
            data[++top] = e;
        }
        return true;
    }

    /**
     * 出栈操作
     * @return
     */
    public E pop(){
        if(top==-1){
            throw new RuntimeException("栈空，不能出栈！");
        }else{
            return (E) data[top--];
        }
    }

    /**
     * 获取栈顶元素
     * @return
     */
    public E peak(){
        if(top==-1){
            throw new RuntimeException("栈空异常！");
        }else{
            return (E) data[top];
        }
    }  </code></pre>
<h2><strong>二，队列极其JAVA实现</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：队列是一种先进先出的数据结构，对队头和队尾的操作简单，但是队内元素的操作复杂。</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA实现：定义队列的数据结构，队列的出队，入队，获取队头元素。代码如下：</strong></p>
<pre class="language-java"><code>/**
 * 基于数组实现队列
 * @author wcj
 * @Date 2020/4/14 21:14
 * @Version 1.0
 */
public class QueueExample&lt;E&gt; {

    /**
     * 队列长度
     */
    private int maxSize;
    /**
     * 存储数据数组
     */
    private Object[] data;
    /**
     * 队头指针
     */
    private int front;
    /**
     * 队尾指针
     */
    private int rear;

    /**
     * 默认构造器
     */
    public QueueExample(){
        this(10);
    }
    /**
     * 用户自定义队列长度构造器
     * @param initialSize
     */
    public QueueExample(int initialSize){
        if(initialSize&gt;=0){
            this.maxSize = initialSize;
            data = new Object[initialSize];
            front = rear = 0;
        }else{
            throw new RuntimeException("初始化队列长度不能小于0！");
        }
    }

    /**
     * 入队操作
     * @param e
     * @return
     */
    public Boolean add(E e){
        if(rear == maxSize){
            throw new RuntimeException("队列已满，无法入队!");
        }else{
            data[rear++] = e;
        }
        return true;
    }

    /**
     * 出队操作
     * @return
     */
    public E poll(){
        if(front==rear){
            throw new RuntimeException("队空，无元素可出队！");
        }else{
            E e = (E) data[front];
            data[front] = null;
            return e;
        }
    }

    /**
     * 获取队头元素
     * @return
     */
    public E peek(){
        if(front==rear){
            throw new RuntimeException("队空，无元素可出队!");
        }else{
            return (E) data[front];
        }
    }
}
</code></pre>
<h2><strong>三，链表及其JAVA实现</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：链表是由一系列数据节点组成的数据结构，节点可以动态生成。对于元素的增加，删除操作快，查询操作慢</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;这里主要讲述几种有代表性的链表：单向链表，双向链表，双向循环链表</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;单链表的JAVA实现：数据结构定义，添加节点，删除节点，查找节点，代码如下：</strong></p>
<pre class="language-java"><code>/**
 * 单向链表
 * @author wcj
 * @Date 2020/4/14 21:32
 * @Version 1.0
 */
public class SingleLinkedList {

    /**
     * 链表长度
     */
    private int length;
    /**
     * 链表头节点
     */
    private Node head;

    public SingleLinkedList(){
        this.length = 0;
        this.head = null;
    }
    /**
     * 内部类声明每个链表节点
     * 每个节点包括数据域和指向下一个节点的指针
     */
    private class Node{
        private Object data;
        private Node next;
        public Node(Object data){
            this.data = data;
        }
    }

    /**
     * 插入节点（这里使用头插法）
     * @param obj
     * @return
     */
    public Boolean add(Object obj){
        Node node = new Node(obj);
        if(length==0){
            head = node;
        }else{
            node.next= head;
            head = node;
        }
        length++;
        return true;
    }

    /**
     * 删除某个节点
     * 先对链表进行判空处理
     * 然后找到要删除的节点
     * 最后进行删除
     * @param obj
     * @return
     */
    public Boolean delete(Object obj){
        if(length==0){
            throw new RuntimeException("链表为空，无节点可删除!");
        }else{
            Node prev = head;
            Node current = head;
            //查找待删除元素
            while(!current.data.equals(obj)){
                if(current.next==null){
                    return false;
                }else{
                    prev = current;
                    current = current.next;
                }
            }
            prev.next = current.next;
            length--;
        }
        return true;
    }

    /**
     * 获取某个元素
     * @param obj
     * @return
     */
    public Object find(Object obj){
        if(length==0){
            throw new RuntimeException("链表为空");
        }else{
            Node current = head;
            while(current.data.equals(obj)){
                if(current.next==null){
                    return null;
                }else{
                    current = current.next;
                }
            }
            return current.data;
        }
    }
}
</code></pre>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>双向链表的JAVA实现：定义数据结构，头插法，尾插法，删除头部节点，删除尾部节点（这里只写尾插节点和删除尾部节点），代码如下：</strong></p>
<pre class="language-java"><code>import com.sun.org.apache.xpath.internal.operations.Bool;

/**
 * 单向循环链表
 * @author wcj
 * @Date 2020/4/14 22:05
 * @Version 1.0
 */
public class CircleLinkedList {

    /**
     * 链表长度
     */
    private int length;
    /**
     * 头节点
     */
    private Node head;
    /**
     * 尾节点
     */
    private Node tail;

    /**
     * 初始化构造方法
     */
    public CircleLinkedList(){
        this.length = 0;
        this.head=this.tail = null;
    }

    /**
     * 内部类实现的链表节点
     */
    private class Node{
        private Object data;
        private Node prev;
        private Node next;
        public Node(Object data){
            this.data = data;
        }
    }

    /**
     * 尾插节点
     * @param obj
     * @return
     */
    public Boolean addTail(Object obj){
        Node node = new Node(obj);
        if(length==0){
            head = tail= node;
            length++;
        }else{
            tail.next = node;
            node.prev = tail;
            tail = node;
            length++;
        }
        return true;
    }

    /**
     * 删除尾部节点
     * @return
     */
    public Boolean delTail(){
        Node temp = tail;
        if(length==0){
            throw new RuntimeException("链表为空!");
        }else{
            tail = tail.prev;
            tail.next = null;
            length--;
        }
        return true;
    }
}
</code></pre>
<h2><strong>四，散列表</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：有一张表M，一个映射函数f(key)，如果对于任意一个key，都有一个函数指与表中的内存地址相对应，则M就为散列表，f(key)就为散列函数。散列函数存储key-value键值对形式的数据，直接生成key与表中地址值的映射，因此查询非常迅速。同时散列表也经常被用于信息安全，用于加密操作。</strong></p>
<h2><strong>五，二叉排序树</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：二叉查找树又成为二叉搜索树，二叉查找树</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;特征：根节点左边的数据小于根节点，根节点右边的数据大于根节点，且其左右子树还是二叉排序树</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现：定义数据结构，插入操作，删除操作，查找操作，代码如下：</strong></p>
<pre class="language-java"><code>package interviewFour.example4;

/**
 * 二叉排序树
 * @author wcj
 * @Date 2020/4/14 17:17
 * @Version 1.0
 */
public class Node {

    private Node root = null;
    private int value;
    private Node left;
    private Node right;

    public Node(){}

    public Node(int value, Node left, Node right){
        this.value = value;
        this.left = left;
        this.right = right;
    }

    public Node(int value){
        this.left = null;
        this.right = null;
        this.value = value;
    }

    public int getValue() {
        return value;
    }

    public void setValue(int value) {
        this.value = value;
    }

    public Node getLeft() {
        return left;
    }

    public void setLeft(Node left) {
        this.left = left;
    }

    public Node getRight() {
        return right;
    }

    public void setRight(Node right) {
        this.right = right;
    }

    /**
     * 插入节点
     * @param value
     * @return
     */
    public Boolean insert(int value){
        //root代表根节点
        Node p = root;
        Node prev = null;
        //创建一个节点
        Node node = new Node(value);
        //寻找节点的插入位置
        while(p!=null){
            prev = p;
            if(value==p.getValue()){
                return false;
            }else if(value&lt;p.getValue()){
                p = p.getLeft();
            }else{
                p = p.getRight();
            }
        }
        if(root==null){
            root = node;
        }else if(value&lt;prev.getValue()){
            prev.setLeft(node);
        }else{
            prev.setRight(node);
        }
        return true;
    }

    /**
     * 删除某个节点
     * 分为三种情况，待删除节点为叶子节点，则直接删除
     * 待删除节点只有左子树或者右子树，则用左子树或者右子树替代当前节点位置
     * 待删除节点即有左子树又有右子树，则寻找左子树最大节点或者右子树最小节点顶替当前节点(这里使用左子树的最大节点)
     * @param value
     * @return
     */
    public void deleteBST(int value){
        deleteBST(root,value);
    }

    /**
     * 递归删除左子树，或者右子树，或者根节点
     * @param root
     * @param value
     * @return
     */
    public Boolean deleteBST(Node root,int value){
        if(root==null){
            return false;
        }else{
            if(root.getValue()==value){
                delete(root);
            }else if(value&lt;root.getValue()){
                deleteBST(root.getLeft(),value);
            }else{
                deleteBST(root.getRight(),value);
            }
        }
        return true;
    }

    /**
     * 分情况执行具体的删除逻辑
     * @param node
     * @return
     */
    public Boolean delete(Node node){
        if(node.getLeft()==null){
            node = node.getRight();
        }else if(node.getRight()==null){
            node = node.getLeft();
        }else{
            Node temp = node;
            Node s = node;
            //转向左子树，向右走到底
            s = s.getLeft();
            //寻找替换待删除节点的节点
            while(s!=null){
                temp = s;
                s = s.getRight();
            }
            node.setValue(temp.getValue());
            if(temp!=node){
                node.setLeft(temp.getLeft());
            }else{
                node.setRight(temp.getRight());
            }
        }
        return true;
    }

    /**
     * 在二叉查找树中找到对应节点
     * @param value
     * @return
     */
    public Boolean searchBTS(int value){
        Node node = root;
        if(node==null){
            throw new RuntimeException("无此节点！");
        }else{
            if(value==node.getValue()){
                return true;
            }else if(value&lt;node.getValue()){
                node = node.getLeft();
            }else{
                node = node.getRight();
            }
        }
        return false;
    }
}
</code></pre>
<h2><strong>六，红黑树</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 概述：红黑树是一种特化的自平衡二叉排序树，即其左右子树的深度差可以超过1。（详细的插入等操作过段时间会补充）</strong></p>
<h2><strong>七，图，位图</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;图的知识：定义，有向图/无向图，邻接矩阵/邻接表，BFS/DFS，位图的话没怎么搞清楚。</strong></p>
<h3><strong>思维导图：<a href="https://images-cdn.shimo.im/YClQaLxx9e8uEb9U__thumbnail" target="_blank" rel="noopener">数据结构</a></strong></h3>
<h2>&nbsp;</h2>, blogGoods=0, blogRead=7, blogCollection=0, typeName=java面试篇, blogRemark=面试（四）------之数据结构篇, blogComment=0, blogSource=null, createdTime=2020-04-14 14:30:37, blogMonth=null, updateTime=2020-04-23 22:14:43)], params={}, sortColumn=blog_collection, sortMethod=DESC)]
2020-04-26 23:27:29.565 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 889
2020-04-26 23:27:29.567 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，数据库设计--表的命名规范等</strong></p>\n<p>（1），统一采用bl_开头对表进行命名</p>\n<p>（2），对于数据比较重要的表统一添加四个字段，分别为：created_time(创建时间),update_time(修改时间),version(版本号),deleted(删除字段)</p>\n<p>（3），数据库表的字段尽量都设置为NOT_NULL</p>\n<p>（4），数据库中表varchar类型字段需要设置长度的尽量设置为2<sup>n</sup>-1</p>\n<p>（5），因为博客系统分为前台展示界面和后台管理，所以对于有些表，例如bl_type（博客类型表），bl_music（音乐表）等设置了enable（启用字段）</p>\n<p><strong>二，上述第二条--四个字段的解释</strong></p>\n<p>（1），为什么要设置created_time和update_time字段：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;其一，从数据库的通用性上来说，设计这两个字段是必要的，但也需要根据业务的需要来合理添加这两个字段，因为无用的字段会浪费空间，性能，影响系统的运行。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 其二，大部分的应用都有需要根据时间进行排序的功能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 其三，当系统发生异常的时候，我们可以通过这两个字段对异常进行排查和定位。</p>\n<p>（2），为什么要设置version字段：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 1，version字段含义：字段的含义与其字面意思一样，代表版本，在这里作为乐观锁进行使用，从而保证不会出现脏数据的情况。下面解释一下什么叫乐观锁，以及乐观锁和悲观锁</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 2，乐观锁：总是假定最好的情况，即每次用户调用接口从数据库中取出数据到修改数据前的过程中，不会有其它用户对当前数据进行修改，这样在当前用户修改数据的时候，利用版本机制即判断取出的version字段和当前数据库该条数据的version字段是否相等来判断该条数据是否已经被修改，如果未修改，则予以修改（且version字段递增），如果已经修改，则提示用户更新失败。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 悲观锁：总是假定最坏的情况，即每次用户调用接口从数据库取出数据的时候，都认为该条数据会被修改，因此每次取出数据都对数据进行加锁处理，只允许当前用户进行修改，其它用户阻塞，直到当前用户修改完毕。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3，为什么使用乐观锁而不使用悲观锁：因为悲观锁比较浪费性能</p>\n<p>（3），为什么设置deleted字段：deleted字段在这里作为一个逻辑删除字段（0否1是），何为逻辑删除，即执行删除操作操作的时候，不会真正的删除数据库中的数据，而是将deleted字段设置为1即可。&nbsp;这样如果用户出现误删的操作，可以通过数据库修改该字段进行数据的恢复。</p>\n<p><strong>三，上述第三条--数据库表字段尽量设置为NOT_NULL</strong></p>\n<p>（1），数据库表字段尽量设置为NOT_NULL：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 1，有些人可能认为设置为NULL相比于NOT_NULL不是更节省空间吗？但是实际上不是这样的，设计为NULL相比于NOT_NULL要多占用一个字节的空间</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 2，设计为NOT_NULL，这样在做查询的时候能够更好的避免空指针异常，且发生该类错误的时候能够更好的进行排查</p>\n<p><strong>四，上述第四条--表varchar类型字段长度尽量设置为2<sup>n</sup>-1</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>因为计算机只识别二进制，且有一定的范围，例如2<sup>8</sup>，在计算机中的范围为-128~127,因此对于varchar字段长度来说，如果设置为255，则正好是一个字节，而如果设置为256，则占用两个字节，这样会浪费计算机的内存空间，因此数据库varchar类型字段的长度最好设置为2<sup>n</sup>-1</p>\n<p><strong>五，上述第五条--对于设置enable字段的解释</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>enable字段，字面意思启用，在这里表明是否启用（0否1是），因为系统分为前台博客页面和后台管理，对于这两个不同的前端项目，后台可以通过启用字段来控制内容在前台博客页面的展示与否，与deleted字段不同的是，如果执行删除操作，那么我们只能通过手动修改数据库中的字段进行数据的恢复，且如果执行删除操作，则该数据在前台博客页面和后台管理页面都无法看见。但是如果将数据弃用（即修改enable字段值为1），则表明该数据被弃用，在前台博客页面无法显示，但是在后台管理页面可以看见，且无需通过手动修改数据库来恢复数据，可以在后台管理页面操作启用数据。</p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1247745014683947008","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dDViAcnjvAACb6PL1tzA485.jpg","blogRead":21,"blogRemark":"博客开发总结（一）-----之数据库设计篇","blogTitle":"博客开发总结（一）-----之数据库设计篇","createdTime":"2020-04-08 04:36:07","typeName":"博客开发和维护总结","updateTime":"2020-04-20 10:47:54"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，前后端分离开发优势</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，</strong>项目开发过程中，前后端完全解耦，前端只需要负责页面的实现，只需要通过接口拿数据。后端不需要管页面的跳转，只需要负责接口的编写</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，</strong>前后端人员有更多的精力去负责自己的工作，前端人员可以将更多的精力投放在页面的编写，页面的美化，页面特效的制作和用户体验上；而后端人员可以将更多的精力放在接口代码的优化，sql优化，jvm调优上面</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，</strong>前后端分离的项目部署的时候，前端项目往往都是部署在nginx服务器上，而前后端不分离的项目往往都是部署再一台服务器上。因此前后端分离项目大大降低了服务器的负担</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>4，</strong>前后端不分离的项目使用模板引擎例如freemaker，thymeleaf等，前后端人员交流起来较为困难。且前端项目使用原生的DOM操作，极大的增加了前端工作人员的工作量。而前后端分离项目前端通常都是用各种ui框架，框架采用MVVM模式，极大的减轻了前端工作人员的工作量</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，</strong>前后端分离开发，前端可以通过easy-mock来伪造接口数据进行测试，后端人员可以通过postman进行接口测试，开发效率大大提升。</p>","blogGoods":0,"blogId":"1247867141693128704","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dG6CAI6ipAACiM2P5LtI65.jpeg","blogRead":7,"blogRemark":"前后端分离开发的优势所在","blogTitle":"闲谈前后端分离开发","createdTime":"2020-04-08 12:41:25","typeName":"随笔","updateTime":"2020-04-20 11:48:53"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，css之弹性布局</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，</strong>何为弹性布局？</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 弹性布局是css的一种新的布局方式，所谓&ldquo;弹性布局&rdquo;，即页面随着不同设备的屏幕大小拉伸会自适应页面的大小。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，</strong>弹性布局的两种主要元素，container（弹性容器），item（弹性子元素），一个弹性容器中可以放入多个弹性子元素，元素之间是可以进行嵌套的，弹性子元素也可以设置为弹性容器，里面再嵌套弹性子元素。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，</strong>弹性布局的基本属性</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （1）display：flex，声明容器为弹性布局</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （2）flex-direction：声明弹性容器内部元素的排列方式，默认为row。row（横向布局），row-reverse（横向布局，但是元素反方向码），column（纵向布局），column-reverse（纵向布局，但是元素反着码）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （3）flex-wrap：声明弹性盒子中的元素是否可以换行，默认为nowrap（不换行），wrap（换行），wrap-reverse（换行，但是反着码）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （4）align-items：设置容器中元素在纵轴方向上的对齐方式，默认为stretch（即如果不设置子元素高度，则默认拉伸至于容器同宽度），flex-start（子元素位于容器的开始位置），flex-end（子元素位于容器的结尾处），center（元素依纵轴方向居中），baseline（元素位于容器基线，不过没怎么用过，所以不是很清楚）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （5）justify-content（设置元素在主轴上的对齐方式），默认为flex-start（元素从容器主轴开始位置码），flex-end（元素从容器主轴结尾处码），center（元素位于主轴居中处），space-between（元素布局在容器的两端），space-around（元素布局在容器两端，但是元素前后都留有空白）因为项目中大多数只使用了对于容器的操作，对于容器中元素的操作很少，所以这里只介绍这点。谢谢阅读！</p>","blogGoods":0,"blogId":"1248135765829918720","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dGnuAWkLLAAAaRXQXNms575.jpg","blogRead":3,"blogRemark":"CSS----之flex弹性布局","blogTitle":"CSS----之flex弹性布局","createdTime":"2020-04-09 06:28:51","typeName":"CSS","updateTime":"2020-04-20 11:43:57"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2 style=\"text-align: left;\"><strong>一，JVM运行机制</strong></h2>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;jvm即java虚拟机，一共由四个部分组成，分别是类加载器子系统，运行时数据区（程序计数器，本地方法区，jvm栈，方法区，jvm堆），执行引擎（即时编译器，垃圾收集器），本地接口库。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;一个java源程序的运行先是经过编译器将其编译成字节码文件（class文件），然后通过类加载器子系统将其加载进入jvm&mdash;&mdash;&gt;程序运行过程中，运行时数据区存放程序运行过程产生的数据&mdash;&mdash;&gt;执行引擎中的垃圾收集器收集程序运行过程中创建的不再使用的对象，即时编译器将程序的字节码文件编译成机器码&mdash;&mdash;&gt;然后本地接口库利用机器码调用本地方法库中的方法，和操作系统实现交互。</p>\n<h2><strong>二，多线程</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;</strong>在多核操作系统中，jvm支持一个进程中同时并发执行多个线程，且这些线程和本地操作系统的线程相对应。当jvm中的对象初始化，内存空间分配等一系列准备工作完成之后，会调用操作系统中的接口创建一个原生线程，原生线程初始化完毕后，会调用java线程的run（）方法执行该线程，线程结束之后，jvm会释放原生线程和java线程资源。</p>\n<h2><strong>三，JVM的内存区域</strong></h2>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM的内存区域主要分为线程私有区域（程序计数器，本地方法区，JVM栈），线程共享区（方法区，JVM堆）和直接内存。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;程序计数器：线程私有区域，无内存溢出，用来记录程序运行过程中的字节码指令地址，如果是Native方法，则程序计数器为空。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM栈：线程私有区域，用来描述java程序的运行过程，java程序运行每次运行的时候，都会创建一个栈帧，方法的执行和返回对应着栈帧的入栈和出栈操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;本地方法区：线程私有区域，和JVM栈的功能一样，只不过是用来记录Native方法的运行过程。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM堆：线程共享区，主要用来存放程序运行过程中产生的数据，同时也是垃圾收集器进行垃圾回收的主要区域。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;方法区：也被称为永久代，用来存放常量，静态变量，类信息等等。</p>\n<h2><strong>四，JVM的运行时内存</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>JVM的运行时内存又被称为JVM堆，因为JVM的GC算法使用的是分代收集算法，所以JVM堆按照GC标准可以分为三个区域分别为：新生代，老年代，永久代。其中新生代占1/3，老年代占2/3，永久代很少，</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;新生代：存放短生命周期，小对象的区域。新生代又分为Eden区，ServivorTo区，ServivorFrom区，区域的GC算法采用复制算法。Eden区是用来存放新创建的对象（大对象除外），ServivorTo区是用来保存MinorGC幸存下来的对象，ServivorFrom区是用来将上一次MinorGC幸存下来的对象作为下一次MinorGC的扫描对象。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;老年代：存放长生命周期的大对象，区域的GC算法采用标记整理算法</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;永久代：主要用来存放class和meta数据信息的。程序运行过程中不会进行永久代的垃圾回收，这也就导致永久代区域的数据会越来越多，最终造成内存溢出。java8之后永久代已经被元数据区取代，元数据区和永久代的功能都是一样的，但是最大的不同在于永久代区域依赖于虚拟机的内存大小，因而可以存储的class，meta信息非常有限。但是元数据区依赖的是本地操作系统，因而不会受到虚拟机内存的限制。</p>\n<h2><strong>五，垃圾回收与算法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;(1)垃圾回收：</strong>Jvm的垃圾回收判定依赖于两种方法，引用计数法和可达性分析法。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;引用计数法：即如果想要在程序中使用对象，就必须赋予一个引用，这样在对象赋予引用的时候将其引用计数加1，删除一个引用时，将对象引用计数减1，如果引用计数为0，就说明该对象已经不使用，作为垃圾。但是引用计数法存在一个缺陷，即循环引用的问题，如果两个对象相互引用，则这两个对象的引用计数永远都不会为0，造成对象无法被回收。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;可达性分析法：即先创建一些根节点对象ROOTS，然后通过这些根节点对象向下搜索，如果一个对象到任意一个ROOTS之间都没有可达路径，在经过两次标记（下文解释为什么进行两次标记），还是没有可达路径，则说明该对象可回收。</p>\n<p>&nbsp;&nbsp; &nbsp;<strong>（2）GC算法：</strong>常见的GC算法有四种，分别为标记清除算法，复制算法，标记整理算法，分代收集算法</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;标记清除算法：即在进行垃圾回收前，对所有对象进行一次标记，标记可回收的对象，然后进行清理即可。但是标记清除算法在清除回收对象之后，并不会对堆内存进行整理，这样的话如果内存中的对象大部分为小对象，清理之后就会导致没有大片连续的内存空间，即造成了内存碎片化，这样大对象存储的时候就无法找到相应的完整连续内存。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;复制算法：即将内存分为两块同等大小的区域，区域1和区域2，创建的新对象都存储在区域1中，当区域1中的内存占满之后，会对内存中的所有对象进行一次标记，标记存活的对象，将存活的对象复制到区域2，这时区域1中的对象都是可回收对象，回收区域1中的所有对象即可。但是复制算法也存在着一定的缺陷，即每次都只能使用一半的内存空间，造成了大量的内存浪费。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;标记整理算法：即结合标记清除算法和复制算法的优点，先对所有的对象进行标记，标记存活的对象，将存活的对象复制到内存的另一端，然后清除当前端的对象即可。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;分代收集算法：前面的三种算法，都无法按照对象的类型进行收集，分代收集算法正是解决这个问题，按照对象的不同类型采用不同的GC算法。以JVM的分代收集算法为例，JVM的堆内存分为新生代，老年代，永久代。新生代又分为Eden区，ServivorTo区和ServivorFrom区。新生代因为其存储生命周期短的小对象，GC比较频繁，所以采用复制算法。程序运行过程中创建的对象都存储在Eden区（大对象除外，大对象直接复制到老年代区域）。当Eden区的内存不够的时候进行MinorGC，然后将Eden区和ServivorFrom区的存活对象都复制到ServivorTo区，然后将ServivorTo区和ServivorFrom区进行交换，再次进行MinorGC。老年代因为存放的都是生命周期长的大对象，因而进行GC的不会太频繁，且清除的对象并不会太多，因而采用标记整理算法。老年代每次进行MajorGC之前都会先进行一次MinorGC，当MinorGC之后新生代的内存仍然不够的时候，将对象复制到老年代进行MajorGC。永久代区域主要回收常量，无用class等。</p>\n<h2><strong>六，JAVA中的四种引用类型</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;强引用类型<strong>：</strong>即把对象赋给一个引用变量，强引用的对象一定为可达状态，所以不会进行垃圾回收。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;软引用类型：通过SoftReference类实现，当内存不够的时候对其进行GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;弱引用类型：只有弱引用类型的对象，一定会被GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;虚引用类型：虚引用对象主要是用来跟踪对象的GC状态</p>\n<h2><strong>七，分代收集算法和分区收集算法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>分代收集算法：新生代因其存放大量短生命周期小对象，且GC频繁，所以采用复制算法。老年代因其存放长生命周期大对象，且GC不平凡，所以采用标记整理算法。永久代，回收常量，类信息等。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;分区收集算法：即将堆内存区域分为大小不同的区，可以按照不同的区进行快速垃圾回收，减少系统的停顿时间。然后再以并行的方式逐步完成整个GC。</p>\n<h2><strong>八，垃圾收集器</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>新生代区域：Serial垃圾收集器，单线程复制算法，因为单线程无需进行线程之间的交互和切换，所以效率非常高，是JVM默认的client模式下的默认垃圾回收策略，工作期间需要暂停其它所有的线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ParNew垃圾收集器，多线程复制算法，跟单线程Serial一样，是JVM默认的server模式下的垃圾回收策略，工作期间需要暂停所有其它线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Parallel Scavenge垃圾收集器：多线程复制算法，不同的是优先考虑系统吞吐量，可以利用更高效的利用CPU完成GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;老年代区域：Serial Old垃圾收集器，单线程标记整理算法，同新生代的Serial功能一样，只是采取的算法不同而已。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Parallel Old垃圾收集器：多线程标记整理算法，优先考虑了系统的吞吐量，其次考虑停顿时间。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CMS,多线程标记清除算法，优先考虑系统GC时的停顿时间，且过程分为四步（<span style=\"background-color: #ffff00;\">解释上文的可达性分析中的两次标记</span>，第一步：标记GC ROOTS可达对象，暂停其它工作线程；第二步：和用户线程一起工作，跟踪GC ROOTS；第三步，因为第二步用户进程没有暂停，所以有些对象状态</p>\n<p>可能发生了改变，重新进行标记；第四步，清除不可达对象）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; G1垃圾收集器，多线程标记整理算法，将内存分区，与CMS相比，一方面不会产生内存碎片，一方面，可以精确的控制系统停顿时间。</p>\n<h2><strong>九，JAVA的网络编程模型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;</strong>阻塞I/O模型：即用户线程发出I/O请求之后，内核会检查数据是否准备就绪，这时候用户线程始终处于阻塞状态等待数据准备就绪。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;非阻塞I/O模型：即用户线程不断的给内核发出I/O请求，内核接受到I/O请求之后会返回一个状态，如果数据准备就绪，就将数据复制进入用户线程，如果数据没有准备好，返回一个false，用户线程无需阻塞，可以去处理其它事情，而当数据准备好了且刚好用户线程发起I/O请求进行操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;多路复用I/O模型：多路复用I/O模型通过一个Selector线程轮询Socket的状态，如果Socket有读写事件，则进行I/O操作。此模型的优势在于可以更好的处理连接数众多但消息体不大的情况下。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;信号驱动I/O模型：即用户线程发出一个I/O请求，系统会为该请求创建一个信号函数，用户请求可继续执行其它业务逻辑，当内核数据准备就绪之后会返回给用户线程一个信号，用户线程接收到之后进行I/O操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;异步I/O模型：用户线程给内核发起一个asynchronous read操作，内核接收到之后，返回其请求是否成功，然后等待数据准备成功之后复制到用户线程。整个过程中请求的发起和数据读取都在内核中进行，最终发送一个信号告知用户线程I/O操作已经完成，用户直接使用数据就行。（说实话个人感</p>\n<p>觉和信号驱动很像）</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;java NIO：没怎么读懂（<span style=\"background-color: #993300;\">记得补充！</span>）</p>\n<h2><strong>十，JVM的类加载机制</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>JVM类加载分为五个阶段：加载，验证，准备，解析，初始化</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;加载：即将class文件加载到JVM中，且创建class对象，封装其数据结构。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;验证：对class文件进行验证，确保符合JVM的标准，保证JVM的安全。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;准备：即方法区中给类变量分配空间和赋初值。static修改的会在初始化阶段赋值，final修饰的会在准备阶段赋值。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;解析：即将常量池中的引用替换为直接引用</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;初始化：执行类构造器进行初始化。（因为内部流程不是很清楚，所以对于其几种不进行初始化的情况不做说明）</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;类加载器：JVM提供了三种类加载器，启动类加载器（/lib），扩展类加载器(/lib/ext)，应用程序类加载器(classpath)。还可以再应用程序类加载器自定义类加载器。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;双亲委派机制：即当一个类接收到类加载请求的时候，不会自己进行加载，而是将其加载请求委派给其父类加载器，这样一路委派，最终加载请求都会委派到启动类加载器.启动类加载器接收到加载请求之后会去lib目录下寻找相关的class文件，若找不到，则将其加载请求再委培给子类加载器，一路委派，直到能够加载。</p>\n<h3><strong>最后，送给大家一张博主画的JVM的思维导图，以后读《深入JVM虚拟机》的时候可能会出一个JVM专题：<a href=\"https://uploader.shimo.im/f/X0MX3hLaHrevltxW.png!thumbnail\" target=\"_blank\" rel=\"noopener\">JVM思维导图</a></strong></h3>\n<p>&nbsp;</p>\n<h2>水平有限，若发现有误，还望指出！</h2>","blogGoods":0,"blogId":"1248224512563068928","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHLeALxSjAABJTVJPTfk677.jpg","blogRead":17,"blogRemark":"面试（一）------之JVM篇","blogTitle":"面试（一）------之JVM篇","createdTime":"2020-04-09 12:21:30","typeName":"java面试篇","updateTime":"2020-04-20 11:53:29"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，Linux的发展历史</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; </strong>1965年之前，电脑并不像现在这么普遍，除了军事机构和研究即构，一般人基本接触不到电脑，而且那时候的一台大型主机最多也就只能支持30台终端。为了解决数量问题，1965年之后，由贝尔实验室，麻省理工学院以及通用电气一起放弃了Multics项目，准备让大型主机能够支持300台终端，但是在开发过程中，进度缓慢，最终由于资金的短缺，贝尔实验室推出了研究。1969年，从这个项目中退出的Ken Thompson在家无聊，为了让电脑能够运行&ldquo;星际旅行&rdquo;游戏，因而趁着妻子回家探亲的一个月，独自写出了Unix操作系统的原型（！！！！牛批）。1970年，这个人以BCPL语言为基础，又写出了很接近硬件的B语言，并且用B语言写出了第一个Unix操作系统。但是由于B语言的跨平台性比较差，为了解决这个问题。Dennis Ritchie和Ken Thompson决定以B语言为基础开发一种新的语言，1972年，Dennis Ritchie最终设计出了一种新语言，他以BCPL的第二个字母命名，也就是我们后来熟知的C语言。随后两人便迫不及待的用C语言重现Unix操作系统。Unix系统起初开源，但是在Unix7之后，由于政策的变化，代码闭源化，因而大学中不能使用Unix的源代码进行教学。Andrew S. Tanenbaum教授为了能够让学生更好的理解代码细节，在完全不使用任何源代码的情况下开发除了Minix---小型Unix。但是因为其只用于教学，功能并不强大，因而Torvalds以此为基础，开发除了Linux，但是起初Linux并不支持Unix，最终经过全世界网友的帮助，最终让其能够兼容各种硬件。</p>\n<p><strong>二，文件和目录</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; 1，windows和linux的区别：</strong>我们熟知的windows系统，它的文件系统是分盘符的，盘符下的文件构成一个树形结构，但是Linux文件系统没有盘符，所有文件目录都在根目录/之下</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;<strong>2，Linux需要记住的目录：</strong>/bin（存放系统命令的目录），/sbin（只有超级管理员能访问的命令文件目录），/root（存放和root用户相关文件的目录），/etc（存放系统配置文件的目录），/usr（存放系统共享资源的目录），/opt（存放安装的第三方软件的目录，通常在/usr/local下）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;<strong>3，文件权限：</strong>Linux中的文件权限有读（r，可用于数字4表示），写操作（w，可用数字2表示），执行权限（x，可用数字1表示）</p>\n<p><strong>三，常用命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，ls：</strong>列出目录中的所有目录和文件名&nbsp; -a（列出所有，包括隐藏文件和目录），-l（以列表形式列出所有），-h（人性化列出，需要配合-l使用，即文件大小转换为我们熟知的kb，mb等），-d（显示当前目录属性），命令可以联合使用，例如-al，-lh等等。&nbsp;&nbsp;&nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，cd：</strong>用于切换目录，需知（.和..是相对路径，.表示当前目录，..表示上级目录；/表示绝对路径），cd ~（切换到root目录），cd - （切换到前一次切换的目录）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，clear：</strong>清屏</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，pwd：</strong>显示当前所在目录</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，mkdir：</strong>创建目录，-p（如果目录存在则不创建，如果不存在则创建目录再创建自目录），可以一次性创建多级目录，例如：mkdir&nbsp; -p test/test1</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，touch：</strong>创建空文件</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>7，cp：</strong>复制，-r（递归复制目录下的文件目录信息），-i(提示是否覆盖)，-v（显示复制进度）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>8，mv：</strong>移动文件，不过经常用来给文件进行重命名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>9，rm：</strong>删除目录或者文件，-r（递归删除），-f（强制删除），-v（显示删除进度）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>10，cat：</strong>查看文件内部信息</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>11，ln：</strong>文件创建链接，ln 源文件 目标链接文件（创建硬链接，硬链接和源文件大小相同，修改同步，但是删除不同步，使用较少），ln -s（创建软连接，相当于我们平时创建快捷方式，使用较多）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>12，which：</strong>搜索命令所在位置，例如：which&nbsp; &nbsp;ls</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>13，find：</strong>搜索文件所在位置&nbsp; 例如：find&nbsp; &nbsp;test.conf</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>14，grep：</strong>文件内容搜索，例如：grep &ldquo;想要搜索的内容&rdquo;&nbsp; 源文件</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>15，tar：</strong>归档命令，-c（打包成.tar文件），-z（打包的同时压缩），-v（打包的同时显示进度），-f（放在最后，后面跟.tar.gz），-x(解压)，常用：tar -zcvf&nbsp; <em><strong>.tar.gz&nbsp; &nbsp; ;&nbsp; &nbsp; tar -zxvf</strong> tar.gz</em> -C&nbsp; 指定解压目录&nbsp;&nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;还有more，head，tail等命令，不过这些不常用。</p>\n<p><strong>四，用户权限命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，whoami：</strong>查看当前账户的用户名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，who：</strong>查看当前登录用户</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，exit：</strong>退出登录</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，adduser/useradd：</strong>添加用户，-d（指定用户主目录），-g（指定用户用户组），-m（自动建立目录），默认情况下用户主目录和用户组名都和用户名一样</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，passwd：</strong>只有root用户才能使用，用于修改用户密码</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，userdel：</strong>删除用户，默认不删除用户的主目录，-r（删除用户主目录）</p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;7，su：</strong>切换账户</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>8，groupadd/groupdel：</strong>添加用户组和删除用户组</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>9，groups：</strong>查看用户所在用户组，例如：groups&nbsp; 用户名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>10，usermod：</strong>修改用户所在用户组，例如：usermod&nbsp; 用户组名 用户名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>11，chmod：</strong>修改文件权限，例如：chmod&nbsp; 777&nbsp; test</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>12，chown：</strong>修改文件所有者，例如：chown&nbsp; &nbsp;用户&nbsp; 文件名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>13，chgrp：</strong>修改文件所在组，例如：chgrp&nbsp; 组名&nbsp; 文件名</p>\n<p><strong>五，系统命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，cal：</strong>查看日历</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，date：</strong>查看时间，可以设置格式，例如：date '+<span class=\"ql-token hljs-built_in\">%Y</span>-<span class=\"ql-token hljs-built_in\">%m</span>-<span class=\"ql-token hljs-built_in\">%d</span> <span class=\"ql-token hljs-built_in\">%H</span>:<span class=\"ql-token hljs-built_in\">%M</span>:<span class=\"ql-token hljs-built_in\">%S</span>'</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，ps：</strong>查看线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，kill：</strong>杀死线程，-9（强制杀死）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，查看网卡信息：</strong>centos6：ifconfig ；centos7：ip addr</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，ping：</strong>查看网址或者链接的连通性</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>7，防火墙：</strong>centos6：service&nbsp; iptables&nbsp; status（查看防火墙状态），service&nbsp; &nbsp;iptables&nbsp; &nbsp;start(开启),service&nbsp; iptables&nbsp; stop(关闭);centos7:firewall-cmd&nbsp; --state（查看防火墙状态），systemctl&nbsp; start&nbsp; firewalld.service(启动)，systemctl&nbsp; &nbsp;stop&nbsp; firewalld.service（关闭）</p>\n<p><strong>六，网络命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，wget：</strong>下载，例如：wget&nbsp; &nbsp;链接地址</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，yum：</strong>下载安装</p>\n<p><strong>七，vim（这里只说几个常用的命令）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;</strong>vim有三种模式：命令模式，插入模式，编辑模式&nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;vim&nbsp; 文件名：进入文件，且处于命令模式；iao任意一键进入插入模式（i表示在贯标之前插入，a光标之后插入，o在下一行插入），：进入编辑模式</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;命令：set:nu显示行号，set:nonu不显示行号；/strinng，向后搜索字符串，？string向后搜索字符串；：w保存，：wq保存并退出，：q不保存退出</p>","blogGoods":0,"blogId":"1248500061625745408","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dDA6AfCOJAAAyfL52jxY706.jpg","blogRead":2,"blogRemark":"Linux基本命令总结","blogTitle":"Linux基本命令","createdTime":"2020-04-10 06:36:25","typeName":"Linux","updateTime":"2020-04-20 10:42:25"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，集合</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，List：</strong>list是java中一种有序的集合，下有三个实现类，分别为ArrayList，Vector，LinkedList</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ArrayList：基于数组实现，增删慢，查询快，线程不安全。因为其基于数组实现，所以查询的时候可以直接根据数组的索引下标进行快速查询，但是进行增删操作的时候，需要将待增删元素后的元素全部移动，因而效率较低。且ArrayList创建时不需要分配初始大小，其空间不够的时候，会自动创建一个更大的list，然后复制数据。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Vector：基于数组实现，和ArrayList一样增删慢，查询快。但是线程安全，因为同一时间只支持一个线程对Vector进行写操作，然而因为要进行频繁的加锁和释放锁的操作，所以效率要低于ArrayList。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; LinkedList：基于双向链表实现，增删快，查询慢。因为基于链表实现，增删元素的时候，只需要改变元素的指针即可，改动较小，效率较高。然而进行查询操作的时候，需要从链表头部进行遍历，因而效率较低。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，Queue：</strong>队列，满足先进先出，种类较多。（不作详细解释）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，set：</strong>具有独一无二的特性，常用来存储无序且不重复的元素，对象相等的本质是hashcode的值相同，而如果想要比较两个对象是否相等，需要重写对象的hashcode方法和equals方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;hashset：基于hashTable实现，无序。存放的是对象的散列值，即通过hashcode计算得到的值</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;treeset：基于二叉树实现，即其中的对象按照一定的排序方式进行排列（升序，降序），每次添加对象的时候，都会进行排序，将其插入指定位置。基本的数据类型例如Integer，String等可以使用treeset默认的排序方法，而自定义数据类型需要实现compareable接口，实现compareTo方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;LinkHashSet：继承自hashset，只不过使用双向链表记录数据的顺序。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，map：</strong>一种键值对形式的集合</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;hashmap：基于数组+链表实现，增删改查操作快，但是每次遍历hashmap元素的顺序无法保证且线程不安全。如果想要其线程安全，可以使用synchronizedMap和ConcurrentHashmap，hashmap的内部是数组，数组中的每一个元素又是一个单向链表，链表中的每个元素嵌套一个Entry实例，其中包括Key，Value，Hash值，指向下一个节点的next。每次查询的时候，可以根据元素的hash值很快定位所在数组，但是定位之后需要遍历链表查找元素，因而时间复杂度为O（n），但是Java8之后对其进行了优化，将其改为了数组+链表或红黑树的结构，即当链表中的元素大于8个的时候，链表会转换为红黑树（红黑树是一种特化的二叉平衡树，因为其左右子树的深度差可以大于1），这样查询的时间复杂度就缩短到了O（logN）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ConcurrentHashmap：采用分段锁的思想进行并发操作，因而使线程安全的。由多个Segment组成，只要保证每个Segment线程安全就可以保证全局线程安全。ConcurrentHashmap的默认Segment即并发度为16，可以在初始化的时候修改，但是初始化之后不能再修改。每个Segment内部的实现和hashmap一样&middot;。Java8之后也和hashmap进行了一样的优化。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;HashTable：线程安全，即同一时刻只能有一个线程对其进行操作，并发度不如ConcurrentHashmap。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;TreeMap：基于二叉树数据结构实现，实现了SortedMap，默认按照键值的升序进行排列。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;LinkedHashMap：Hashmap的子类，只不过使用链表保存元素的插入顺序。使用迭代器遍历的时候按照插入顺序遍历。</p>\n<h2><strong>二，异常分类及处理</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;1，异常分类：</strong>Throwable是所有异常类的父类，其下有error和Exception，Error下有AwtError，ThreadDeath；Exception下有RuntimeException和CheckedException。</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</strong>对于Error类异常通常是由内部错误和资源耗尽造成的，无法在程序运行期间对其进行捕获和处理，对于这类错误我们只能记录错误的原因和终止程序。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; Exception中的RuntimeException异常（运行时异常）：这类异常是我们程序中异常处理的核心，可以在程序中进行捕获并处理。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Exception中的CheckedException异常（检查异常）：这类异常时程序中需要强制捕获的异常，通常有IO异常，SQL异常等等。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，异常处理：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>异常处理有两种方式：抛出异常和捕获异常</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;抛出异常有三种方法：throws，throw，系统自动抛出。其中throws是作用在方法上，后面跟的是可能产生的异常类。throw是作用在方法内部，后面跟的是具体的异常对象。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 捕获异常：即使用try{}catch语句进行捕获</p>\n<h2><strong>三，反射机制</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，什么叫做反射机制？</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>即在程序运行的过程中，可以获取类的属性和方法，并且可以调用任意一个类的方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，反射机制的使用</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 首先，获取类的class对象，有三种方式，className.getClass()，类对象.class，Class.forName(\"类路径\")，其中最后一种最为安全，性能最好。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 然后利用反射的API可以实现对类中信息的操作，例如getDeclareFields（），getDeclareMethods（），getConstroctors（）等等。反射创建类的对像有两种方法，一，class.newInstance()初始化一个类实例；二，先获取其构造器，然后利用构造器初始化一个实例。利用反射调用类的方法：先获取方法，然后调用method.invoke()执行方法。</p>\n<h2><strong>四，注解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，四种元注解：</strong>@Target（指定注解的使用范围），@Retention（定义注解的保留级别，有三级，SOURCE源程序中保存，CLASS文件中保存，RUNTIME运行时保存），@Documented（可以工具文档化），@Inherited（<span style=\"background-color: #ffff00;\">这个没怎么看懂</span>）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，注解使用示例：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>第一步，定义注解接口</p>\n<pre class=\"language-java\"><code>@Target(ElementType.FIELD)  \n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface FruitProvider {\n\n    //id\n    public int id() default  -1;\n\n    //供应商名称\n    public String name() default \"\";\n\n    //供应商地址\n    public String address() default \"\";\n\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 第二步，使用注解</p>\n<pre class=\"language-java\"><code>public class Apple {\n\n    @FruitProvider(id = 1,name = \"红富士苹果\",address = \"陕西\")\n    private String appleProvider;\n\n    public String getAppleProvider() {\n        return appleProvider;\n    }\n\n    public void setAppleProvider(String appleProvider) {\n        this.appleProvider = appleProvider;\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第三步，定义注解处理器</p>\n<pre class=\"language-java\"><code>public class FruitInfoUtil {\n    public static void getFruitInfo(Class&lt;?&gt; clazz) {\n        String strFruitProvider = \"供应商信息:\";\n        Field[] declaredFields = clazz.getDeclaredFields();\n        for (int i = 0; i &lt; declaredFields.length; i++) {\n            if (declaredFields[i].isAnnotationPresent(FruitProvider.class)) {\n                FruitProvider annotation = declaredFields[i].getAnnotation(FruitProvider.class);\n                strFruitProvider += annotation.id() + \",\" + annotation.name() + \",\" + annotation.address();\n                System.out.println(strFruitProvider);\n            }\n        }\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第四步，主方法入口</p>\n<pre class=\"language-java\"><code>public class FruitRun {\n    public static void main(String[] args) {\n        FruitInfoUtil.getFruitInfo(Apple.class);\n    }\n}</code></pre>\n<h2><strong>五，内部类</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 1，静态内部类：</strong>即在类的内部定义的静态类，静态内部类可以访问外部了的静态变量和方法，外部也可以通过outClassName.innerClassName调用内部类</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2，成员内部类：</strong>在类的内部定义的没有用static修饰的内部类，使用方式和静态内部类一样。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>3，局部内部类：</strong>即一个类只在一个方法中使用，则完全可以将这个类定义为这个方法的内部类，即局部内部类，局部内部类可以实现真正的对外隐藏</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>4，匿名内部类：</strong>通常用于继承一个类或者实现一个接口的时候，使用new关键字定义，例如:Person person = new Student(){new Pupil(){}}</p>\n<h2><strong>六，泛型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 1，为什么要使用泛型：</strong>其根本目的是为了实现代码的复用，举个开发中常见的例子，我们需要定义返回类Result，返回类中包含状态码code，信息msg，以及数据data（任意类型），这个时候我们就需要使用泛型，因为我们返回的数据类型有各种vo，pojo类对象，list等。这时候泛型类result就可以被各种对象使用，实现代码的复用，简化开发。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>2，泛型标记和泛型限定：</strong>E表示集合中的元素，K表示键值，V表示value，N表示数值类型，T表示任意类型（包含基础类型，所有的对象类型），？（不确定的java类型）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>泛型限定：</strong>向上限定，&lt;?&nbsp; extends T&gt;，向下限定，&lt;? super&nbsp; T&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; <strong>3，泛型方法：</strong>即参数类型定义为泛型类型，以便于接收不同类型的参数，做出不同的处理。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>4，泛型类：</strong>例如public class Pair&lt;T&gt;{private T data;}</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>5，泛型接口：</strong>与放泛型类类似</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>6，类型擦除：</strong>即在泛型编译的过程中，会将泛型类型替换为限定类型的操作</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>7，明确的一点：</strong>虚拟机在运行程序的过程中，内部是没有泛型的，只有普通的类和方法。</p>\n<h2><strong>7，序列化</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 序列化是为了确保对象及其状态的持久化</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>序列化的使用：</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </strong>首先，实现序列化接口java.io.Serializble</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 然后，声明序列化ID，通常private static final&nbsp; long&nbsp; serialVersionUid&nbsp; = ***</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 因为序列化是保证对象及其状态的持久化，而静态变量是不属于对象，属于类本身的，所以序列化无法保存静态变量。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果需要序列化父类变量，则父类也要实现Serializable接口</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t'ransient修饰的属性不会序列化</p>\n<h3><strong>最后，提供一张思维导图供大家学习：<a href=\"https://images-cdn.shimo.im/es83SQH0CggucT7f__thumbnail\" target=\"_blank\" rel=\"noopener\">JAVA基础</a></strong></h3>\n<p>&nbsp;</p>\n<h2>水平有限，如有错误，还望指出！</h2>","blogGoods":0,"blogId":"1248605157059497984","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHMKAcvZ8AABJTVJPTfk020.jpg","blogRead":27,"blogRemark":"面试（二）------之JAVA基础篇","blogTitle":"面试（二）------之JAVA基础篇","createdTime":"2020-04-10 13:34:02","typeName":"java面试篇","updateTime":"2020-04-20 11:53:39"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，JAVA线程的创建方式</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>JAVA线程的创建有四种方式，分别为，继承Thread类，实现Runable接口，实现Callable&lt;Class&gt;接口，基于线程池。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>1，继承Thread方式：创建一个类继承Thread类，创建类的实例对象，调用start方法，继而执行线程的run（）方法，代码如下：</strong></p>\n<pre class=\"language-java\"><code>public class NewThread extends Thread{\n    public static void main(String[] args) {\n        NewThread thread = new NewThread();\n        thread.start();\n    }\n    @Override\n    public void run(){\n        System.out.println(\"create  a  new thread by Thread!\");\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>2，当子类已经继承了一个类，这时候就没法再继承Thread类了，这时候就可以实现Runable接口，实例化类的线程实例，创建Thread实例传入类的实例，执行start方法，继而执行run（）方法代码如下：</strong></p>\n<p>&nbsp;</p>\n<pre class=\"language-java\"><code>public class ThreadExample2 implements Runnable {\n    public static void main(String[] args) {\n        ThreadExample2 threadExample2 = new ThreadExample2();\n        Thread thread = new Thread(threadExample2);\n        thread.start();\n    }\n    @Override\n    public void run() {\n        System.out.println(\"create a new thread by Runnable!\");\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，有些情况下，我们需要再一个主线程中并发多个子线程执行同一个任务，然后回收子线程的返回值整理汇总，这时候就需要实现Callable&lt;Class&gt;接口，重写其call（）方法，用于计算结果。然床创建一个线程池用于提交线程，继而执行call方法，并且创建一个Future的list用于接收子线程逻辑代码即call方法的返回，最终遍历list，得到想要的返回值，如下：</strong></p>\n<pre class=\"language-java\"><code>public class ThreadExample3 implements Callable&lt;String&gt; {\n\n    private String name;\n\n    public ThreadExample3(String name){\n        this.name = name;\n    }\n\n    @Override\n    public String call() throws Exception {\n        return name;\n    }\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        ExecutorService pool = Executors.newFixedThreadPool(3);\n        List&lt;Future&gt; list = new ArrayList&lt;&gt;();\n        for(int i=0;i&lt;3;i++){\n            ThreadExample3 threadExample3 = new ThreadExample3(i+\"\");\n            Future future =pool.submit(threadExample3);\n            System.out.println(future.get().toString()+\" is running\");\n            list.add(future);\n        }\n        pool.shutdown();\n        for (Future future : list) {\n            System.out.println(\"currentThread's result is \"+future.get().toString());\n        }\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，基于线程池创建线程</strong></p>\n<pre class=\"language-java\"><code>public class ThreadExample4 {\n    public static void main(String[] args){\n        ExecutorService pool = Executors.newFixedThreadPool(3);\n        for(int i=0;i&lt;3;i++){\n            pool.execute(new Runnable() {\n                @Override\n                public void run() {\n                    System.out.println(\"thread  is running by FixedThreadPool\");\n                }\n            });\n        }\n        pool.shutdown();\n    }\n}</code></pre>\n<h2>二，线程池的工作原理</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong> &nbsp;1，概述：</strong>JVM根据用户提供的参数创建一定数量的线程任务，将其放入队列中，线程创建之后启动这些任务，如果线程的数量大于核心线程数量（用户设置的线程数量），则超出数量的线程排在队列中等待，当有线程任务执行完毕后，线程池调度器就会发现有可用可用线程，继而从队列中取出任务继续执行<strong>。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; </strong><strong>2，线程复用：</strong>（参见JDK源码解读，这里只做简单描述），由前可知，JVM会根据用户提供的参数创建一定数量的线程任务，且将其添加到任务队列中。JVM通过start（）方法创建一个线程之后， 会相应的为其创建一个任务队列，线程会不停的查看任务队列，如果任务队列中有任务，则调用run方法，执行，这样就达到了一次start（）创建线程，多次使用，完成线程复用的任务。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>3，线程池的核心组件和核心类（见JDK源码分类中关于线程的总结）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; </strong><strong>4，JAVA线程的工作流程：</strong>线程池刚被创建的时候，只是向系统申请一个执行线程队列和管理线程池的线程资源，当调用execute方法之后，执行下列流程：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果正在运行的线程数量小于corePoolSize（核心线程数量，即用户定义的的线程数量），则立即创建线程执行线程任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果正在运行的线程数量大于或等于corePoolSize，则将超过数量的线程加入到阻塞队列中</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在阻塞队列已满且线程数量小于MaximumPoolSize（即线程池能够容纳的最大线程数），线程池会创建非核心线程立即执行任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在阻塞队列已满且线程数量大于或等于MaximumPoolSize的时候，线程池会拒绝该线程任务且抛出异常</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在线程任务执行完毕之后，会将其从任务队列中移除，从队列中取出下一个线程任务执行</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在线程处于空闲状态且空闲时间超过KeepAliveTime，且线程数量大于corePoolSize的时候，会停止该线程，这样在没有任务的时候，线程池中的线程数始终维持在corePoolSize。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，线程池的拒绝策略：</strong>分为四种，分别为AbortPolicy，CallerRunsPolicy，DiscardOldestPolicy，DiscardPolicy</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; AbortPolicy：直接抛出异常，阻止线程运行，源码如下：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</p>\n<pre class=\"language-java\"><code>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n            throw new RejectedExecutionException(\"Task \" + r.toString() +\n                                                 \" rejected from \" +\n                                                 e.toString());\n        }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CallerRunsPolicy：如果线程任务没有关闭，则尝试执行该线程任务，源码如下：</p>\n<pre class=\"language-java\"><code>* @param r the runnable task requested to be executed\n* @param e the executor attempting to execute this task\n*/\npublic void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n     if (!e.isShutdown()) {\n         r.run()\n     }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DiscardOldestPolicy：移除任务队列中最早进入的线程任务，执行当前任务线程，源码如下：</p>\n<pre class=\"language-java\"><code>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n       if (!e.isShutdown()) {\n           e.getQueue().poll();\n           e.execute(r);\n       }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DiscardPolicy：直接丢弃线程任务，不做任何处理</p>\n<h2><strong>三，五种常用的线程池</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;newCachedThreadPool（可缓存线程池）：</strong>当线程池创建线程的时候如果发现有可复用的线程（执行完任务，且未关闭的线程），则直接复用，如果没有则创建新线程。可缓存线程池可以高效的利用执行任务时间短的线程，提高系统的性能，且线程池中的线程如果空闲时间超过60s，则会被终止且从缓存中移除，这样可缓存线程池不会占用系统资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>newFixedThreadPool（固定大小的线程池）：</strong>即线程池中的线程是初始化固定的，当任务线程大于线程池中线程数量时，任务线程就会进入阻塞队列等待。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newScheduledThreadPool（可做任务调度的线程池）：</strong>即可以设置线程执行的停顿时间和执行周期，进行定期定时的执行某个任务。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newSingleThreadPool（单个线程的线程池）:&nbsp;</strong>即线程池中永远只有一个线程进行工作，如果下称停止或者异常，则线程池创建新的线程替代当前线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newWorkStealingPool（足够大小的线程池）：</strong>即创建足够数量的线程的线程池，保证更快的进行运算，提高效率。</p>\n<h2><strong>四，线程的生命周期</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;线程的生命周期大致分为五个阶段：新建（new），就绪（Runnable），运行（Running），阻塞（Blocked），死亡（Dead）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;新建：</strong>即使用new创建一个线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>就绪：</strong>调用start方法，</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>运行：</strong>即线程获取cpu资源，执行run（）方法，进入运行状态，运行状态的线程如果调用yield（线程让步方法）或者失去cpu资源，都会导致线程重新回到就绪态；如果调用sleep方法，I/O阻塞，等待同步锁，等待通知以及suspend挂起都会导致线程进入阻塞态。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞：</strong>即线程被放入Blocked池。阻塞状态的线程如果结束了sleep方法，I/O方法返回，获取同步锁，收到通知或者resume都会导致其重新进入就绪态，与其它线程竞争cpu时间片。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>死亡：</strong>线程正常执行完run（）或者call（）方法，或者执行stop方法，或者发生异常或者错误都会导致线程死亡。（stop方法会导致锁混乱和死锁，不建议使用）</p>\n<h2><strong>五，线程的基本方法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;wait（线程等待）：</strong>会让线程进入WAITING状态，并且会释放对象的锁。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>sleep（线程睡眠）：</strong>会让线程进入睡眠，进入TIMED_WAITING状态，但是不会释放对象锁，睡眠时间到了之后，再次恢复运行状态</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>yield（线程让步）:</strong>&nbsp; 当前线程会让出其占有的cpu资源，重新回到就绪态和其它线程竞争cpu时间片</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>interrupt（线程中断）:&nbsp; </strong>中断当前线程，但是并不会导致其停止，只是改变其内部的终端标识位，在使用了thread.sleep()之后使用该方法，会导致抛出异常，且我们可以利用中断标识位进行线程的安全退出</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>join（线程加入）：</strong>即将当前线程进入阻塞态，等待下一个线程执行完毕后进入就绪态，重新竞争锁资源。通常用于主线程下面执行子线程，需要主线程阻塞，等待子线程执行完毕后返回其结果给主线程，主线程再执行的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>notify（线程唤醒）/notifyAll：</strong>前者随机唤醒一个等待线程，后者全部唤醒</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>setDaemon（守护线程）:</strong>级别较低的线程，用于后台运行，服务用户用户线程，例如垃圾收集线程就是典型的守护线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>sleep方法和wait方法的区别：</strong>前者属于Thread，后者属于Object，前者不会释放锁资源，后者会释放锁资源</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>start方法和run方法：</strong>start方法只是创建一个线程，并没有运行，run方法时执行线程的真正代码逻辑。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>线程退出的方式：</strong>见四中最后一条</p>\n<h2><strong>六，JAVA中的锁（知识比较杂乱）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述:JAVA中的锁是为了保护数据的一致性。按照不同的标准可分为乐观锁和悲观锁，公平锁和非公平锁，共享锁和独占锁，偏向锁，轻量级锁，重量级锁，自旋锁，可重入锁。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;乐观锁：</strong>即认为每次读取数据都不会被修改，当修改操作的时候再判断当前数据是否被修改，未修改则修改，若已被修改，则返回失败状态。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>悲观锁：</strong>即认为每次读取数据都会被修改，因而每次读取数据都对其进行加锁，这样只有当前用户可以修改，其它用户阻塞等待直到当前用户修改完毕释放锁资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>自旋锁：</strong>即有些线程任务的执行很短，很快就可以释放锁资源，为了避免在这种情况下竞争线程仍然进行内核态和用户态之间的转换，因而让线程自旋（即等一会），如果有可用锁，则获取，减少了线程在用户态和内核态之间切换的时间损耗。提高了性能（优势）。当然线程自旋是占用cpu资源的，因而需要设置一个自旋的最大等待时间，如果超过此时间，则线程退出自旋模式。对于线程竞争锁资源激烈的情况，自旋有可能会导致cpu资源的损耗（劣势）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>公平锁和非公平锁：</strong>即根据线程竞争锁资源的机制判定，一般如果依据先到先得的原则，则位公平锁；如果依据就近原则，则位非公平锁。公平锁相比于非公平锁会更加耗费性能，因为要维护一个线程任务丢列，根据线程任务在队列中的顺序分配锁资源，因而不常用。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>可重入锁：</strong>又被称为递归锁，即该锁可以然后线程对其进行多次的加锁操作。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>偏向锁：</strong>当线程获取到锁的时候，用来消除线程的锁重入的开销（看起来是偏袒这个线程）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>共享锁和独占锁：</strong>共享锁即多线程共享锁资源（典型例子，读锁）；独占锁即当前锁只能有一个线程获取，其它线程阻塞</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>轻量级锁：</strong>没有多线程竞争的前提下，减少重量级锁的使用提高性能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>重量级锁：</strong>基于操作系统的互斥量而实现的锁，会导致进程在用户态和内核态之间切换，耗费性能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>synchronized：独占式悲观锁，可重入锁，非公平锁，重量级锁。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 作用范围：</strong>作用于成员变量和非静态方法，相当于锁住的是对象的实例，即this对象</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;作用于静态方法，相当于锁住的是class实例</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;作用域代码块，相当于锁住的代码块中的对象</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>实现原理：</strong>内部包括ContentionList（锁竞争队列），EntryList（竞争候选列表），WaitSet（等待集合），OnDeck（竞争候选者），Owner，!Owner，其中ContentionList是用来存放竞争锁资源的线程。EntryList是用来存放有资格竞争锁资源的线程。调用wait方法后放入WaitSet中，onDeck指的是同一时刻，只有一个线程竞争锁资源，Owner指的是得到锁资源的线程，!Owner指的是线程执行完毕，释放锁资源的线程。需要注意的是线程首先采用的都是自旋模式获取锁资源，如果自旋获取不到再加入ContentionList，而且Owner状态的线程并不是直接把锁资源交给onDeck状态线程，而是给它竞争锁资源的权利，因而onDeck状态的线程还需要跟自旋线程竞争锁资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>ReentrantLock：独占式，可重入锁，并且可以实现公平锁和非公平锁，重量级锁。</strong></p>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;用法：</strong>lock()加锁，后跟try代码块，finally中进行释放锁unlock()</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;避免死锁的方法：</strong>响应中断（即可以根据情况中断对锁资源的请求），可轮询锁（tryLock（）即尝试获取锁，如果有可用锁则获取返回true，没有则返回。和lock（）的区别在于lock获取锁资源如果没有则一直等待直到获取到锁资源），定时所（tryLock（time,unit）即再一定时间内如果有可用锁，且线程未中断则获取锁，否则禁用当前线程。）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>Semaphore（信号量）:</strong>机制和ReentrantLock类似</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ReadWriteLock（读写锁）：</strong>如果系统要求支持多线程共享读，但不能多线程写，使用读锁；如果要求同一时刻只能有一个线程写，写的过程中不能读取该共享数据，则使用写锁。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; <strong>分段锁：</strong>一种思想，将数据分段加锁，例如ConcurrentHashMap</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;死锁：</strong>即线程之间互相共享资源会导致死锁</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; <strong>锁优化：</strong>第一，减少锁的持有时间；第二：减小锁粒度，例如分段锁；第三：锁分离，例如读写锁；第四：锁粗化，放置锁粒度太小，造成频繁加锁释放锁；第五：锁消除，消除程序代码不规范而造成的乱用了锁</p>\n<p>&nbsp;</p>\n<h3><strong>并发编程（上）的思维导图送上：<a href=\"https://images-cdn.shimo.im/1UcHkyrlJyGRPYnn.png__thumbnail\" target=\"_blank\" rel=\"noopener\">并发编程（上）</a></strong></h3>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>\n<h1>水平有限，如果错误，还望指出！</h1>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;</p>","blogGoods":0,"blogId":"1249313090567143424","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHM2AQOeZAABJTVJPTfk967.jpg","blogRead":8,"blogRemark":"面试（三）------之并发编程篇（上）","blogTitle":"面试（三）------之并发编程篇（上）","createdTime":"2020-04-12 12:27:07","typeName":"java面试篇","updateTime":"2020-04-20 11:53:51"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，redis简介</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>redis是NoSQL型系统之一，与之相似的还有Memcache，用来存储key-value这种键值型数据。相比于Memcache而言，redis不仅可以做临时缓存，还可以做数据持久化，将数据定时的存入硬盘或者将命令追加到日志文件当中。而Memcache只能做临时缓存，因而现在基本上已经被redis完全取代。redis的读写速度非常快，官方给出的数据是读110000次/s，写81000次/s；而且redis支持多种数据类型，例如String，list，hash，set，zset；redis支持主从复制（集群），进行数据持久化；还支持过期时间，事务等。</p>\n<h2><strong>二，redis的安装与启动（docker环境下）</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;docker安装完毕后，安装redis：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第一步：拉取redis镜像，docker&nbsp; pull&nbsp; redis</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第二步：启动redis，docker&nbsp; &nbsp;run&nbsp; &nbsp;redis&nbsp; &nbsp;</p>\n<p><strong>三，基本知识串讲</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>单进程单线程：redis只有一个进程，且内部为单线程，这样做的优势是不存在线程安全问题，且不需要进行线程间的切换，提高了性能，而且多线程可能会涉及到锁。劣势是无法发挥多核cpu的优势，不过可以通过开启搭建多个redis实例实现</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>redis中默认有16个数据库（0-15），可以通过select n来进行数据库之间的切换</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;常用的基本命令：flushDB（清空当前数据库），flushAll（清空所有数据库），dbSize（查看有多少数据库）</p>\n<h2><strong>四，redis基本数据类型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;string：</strong>字符串类型，数据库中存储Map&lt;String,String&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>list：</strong>列表数组类型，数据库中存储Map&lt;String,List&lt;Object&gt;&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>hash：</strong>哈希类型，数据库中存储Map&lt;String,Map&lt;Object,Object&gt;&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>set：</strong>集合类型，其中元素无序，数据库中存储Map&lt;String,Set&lt;Object,Object&gt;&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>Zset：</strong>有序集合类型，每个元素都有一个可用于排序的权重</p>\n<h2><strong>五，redis相关命令（这里详解一些常用的命令，不常用的一笔带过）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;string：</strong>(1)set&nbsp; key&nbsp; value,插入一条数据&nbsp; （2）mset&nbsp; key value...批量插入 （3）setnx&nbsp; key value&nbsp; 若无则插入（4）get&nbsp; key&nbsp; 获取某条数据&nbsp; （5）mget keys 批量获取&nbsp; （6）getrange key&nbsp; 0 -1获取数据库全部数据&nbsp; （7）incr age 递增&nbsp; (8) incrby&nbsp; age&nbsp; 10&nbsp; 递增 age 步长为10（9）decr&nbsp; age&nbsp; 递减&nbsp; （10）decrby&nbsp; age&nbsp; 10 步长递减&nbsp; &nbsp;（11）del&nbsp; key&nbsp; 删除某条数据&nbsp; <span style=\"background-color: #ffff00;\">（12）exists&nbsp; key&nbsp; 判断是否存在某个key&nbsp; &nbsp;(13)expire&nbsp; key&nbsp; 10&nbsp; 设置过期时间（单位为秒）&nbsp; （14）pexpire&nbsp; key&nbsp; 1000 设置过期时间，单位为毫秒&nbsp; （15）persist key删除过期时间 （</span><span style=\"background-color: #ffff00;\">16）ttl&nbsp; key&nbsp; 查看过期时间</span></p>\n<p><span style=\"background-color: #ffff00;\">&nbsp;<span style=\"background-color: #ffffff;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>list：&nbsp;&nbsp;</strong>（1）lpush&nbsp; key&nbsp; value 左插入一条数据&nbsp; &nbsp;（2）lpush mylist&nbsp; key&nbsp; value....批量左插入&nbsp; （3）rpush&nbsp; key value 右插入一条数据&nbsp; (4)rpush&nbsp; mylist&nbsp; key value...右批量插入&nbsp; （5）lrange&nbsp; mylist&nbsp; 0&nbsp; -1&nbsp; 取出数据集合&nbsp; （6）lpop mylist 左弹出集合中第一条数据&nbsp; （7）rpop&nbsp; </span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">mylist&nbsp; 右弹出集合中第一条数据&nbsp; （8）llen&nbsp; mylist&nbsp; 获取数据集合长度lrem&nbsp; mylist&nbsp; count&nbsp; value&nbsp; （count&gt;0,从表头开始搜索，移除count个与值与value相等的元素；count&lt;0,表尾开始；count=0，移除所有值与value相等的元素） （9）linsert mylist&nbsp; before/after&nbsp; a&nbsp; 在a元素前或后插入。</span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">(10) lpoplpush&nbsp; list&nbsp; list1 转移列表的元素到另一个列表</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>hash：</strong>（1）hset&nbsp; key&nbsp; &nbsp;val-key&nbsp; val-val&nbsp; 插入一条数据&nbsp; （2）hset&nbsp; myhash&nbsp; name&nbsp; xxx&nbsp; 用于给哈希表中的字段赋值，不存在则创建哈希表赋值，存在则覆盖旧值&nbsp; (3) hget&nbsp; &nbsp;myhash&nbsp; name&nbsp; 取哈希表中某个值&nbsp; （4）hmset&nbsp; myhash name&nbsp; xxx age xxx&nbsp; 批量插入字段&nbsp; （5）hmget</span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">批量获取 （6）hgetall&nbsp; myhash&nbsp; 获取哈希表中所有值&nbsp; (7)&nbsp; hexisets myhash&nbsp; name&nbsp; 判断哈希表中是否存在name字段&nbsp; （8）hsetnx&nbsp; myhash score 100 若存在则不插入，若不存在则插入数据&nbsp; （9）hincrby&nbsp; myhash id 1/hdecrby&nbsp; myhash id&nbsp; 10 递增递减 （10）hdel&nbsp; myhash name&nbsp; </span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">删除&nbsp; （11）hkeys&nbsp; myhash&nbsp; 只取key值&nbsp; （12）hvals&nbsp; myhash&nbsp; 只取value值&nbsp; （13）hlen&nbsp; myhash 获取哈希表长度</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>set：</strong>（1）sadd myset&nbsp; redis&nbsp; 添加一条数据&nbsp; （2）smembers myset&nbsp; 获取数据集合&nbsp; （3）srem&nbsp; myset&nbsp; set1&nbsp; 删除set1&nbsp; （4）sismember myset&nbsp; set1 判断set中是否存在set1&nbsp; (5)srandmember&nbsp; key count&nbsp; 随机获取count个元素（6）spop&nbsp; 从集合中弹出一个元素</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>zset：</strong>之后补充</span></span></p>\n<h2><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">六，redis配置文件（常见配置）</span></span></strong></h2>\n<p><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;daemonize no：</span></span></strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">redis默认不是以守护进程的方式运行的，可以更改为yes启用守护进程（即后台运行）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>pidfile&nbsp; /var/run/redis.pid&nbsp; :</strong>启用守护进程后，默认将pid写入/var/run/redis.pid文件，可以更改</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>port&nbsp; 6379 ：</strong>redis默认端口</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp; &nbsp; &nbsp; &nbsp; <strong>bind&nbsp; 127.0.0.1：</strong>绑定的主机地址</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\"> &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>timeout&nbsp; 300</strong><strong>：</strong>redis客户端闲置多长时间后关闭连接，改为0的话，表示关闭该功能</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>loglevel&nbsp; verbose：</strong>默认日志级别（还有debug，notice，warning）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>database 16：</strong>redis默认有16个数据库可以修改</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>save&nbsp; 900&nbsp; 1/save&nbsp; 300&nbsp; 10/save&nbsp; 60&nbsp; 10000：&nbsp;</strong>表示一定时间内有多少条数据发生修改，就将其同步到数据文件一次，例如第一个表示15分钟内有一条数据发生改变就同步</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>rdbcompression yes&nbsp; ：</strong>表示数据存储到本地数据库时是否进行压缩</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>dbfilename&nbsp; dump.rdb：</strong>指定本地数据库文件名</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>dir&nbsp; /...../redis安装目录/bin ：</strong>本地数据库存放目录，默认在redis安装目录的bin目录下</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>slaveof&nbsp; &nbsp;masterip&nbsp; masterport ：</strong>设置当本机为从机时，它的主机的ip和端口</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>masterauth&nbsp; &lt;master-password&gt;：</strong>当master服务设置了密码时，slav服务连接master的密码</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>requirepass&nbsp; foobared：</strong>默认关闭redis连接需要密码，当给redis设置了密码，就需要打开</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>maxclients&nbsp; &nbsp;128：</strong>redis同一时间最大连接客户端的数量</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>appendonly&nbsp; &nbsp;no：</strong>是否开启aof持久化，默认不开启，采用rdb</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>appendfilename&nbsp; appendonlu.aof：</strong>指定aof持久化的文件名</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>appendfsync&nbsp; everysec :</strong>指定更新日志条件，默认每秒更新一次（还有no，指等操作系统进行数据缓存到磁盘，快；always指每次更新操作后都手动写入磁盘，慢但安全）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;虚拟机方面的配置暂不说明</span></span></p>\n<h2><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">七，redis持久化</span></span></strong></h2>\n<p><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;概述：</span></span></strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">redis持久化主要有两种方式，即rdb和aof</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>rdb：</strong>适用于大数据集的恢复，数据的备份，但是因为设置周期时间进行数据的快照，所以如果redis宕机，可能会丢失最后一个写操作的数据，因为数据完整性较差。数据保存在dump.db文件中，只需要移动到redis安装目录，重启即可恢复数据</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>aof：</strong>适用于对数据的完整性要求较高的情况，因为可以设置不同的持久化策略，例如每秒保存一次，这样即时redis宕机，也只会丢失最后一秒的数据。但是因为其日志文件存储的是写入命令，因而其文件大小要大于rdb的数据文件，且每次重启，都要从头执行数据文件中的命令，因而恢复速度也</span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">要慢于rdb。</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>注意：</strong>当rdb和aof同时开启的时候，redis重启，默认会采用aof的形式进行数据的重新构建</span></span></p>\n<h2><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">八，redis事务</span></span></strong></h2>\n<p><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;概述：</span></span></strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">什么是事务？事务即是一系列的命令要买全部执行，要么全部回滚</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <strong>常用命令：</strong>multi(启动事务)，discard（取消事务）,exec（执行事务块内命令）,watch key(监控某个key的变化)，unwatch（取消对所有key的监控）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>注意：</strong>redis的事务中在命令本身出错的情况下会造成命令的全部回滚，但是在命令无错，执行某个命令的时候发生异常的时候，则谁的错，谁停止（这一点和mysql是不同的）</span></span></p>\n<h2><strong>九，redis的主从复制</strong></h2>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>redis的主从复制，即主机数据更新后根据我们设置的策略将数据同步到从机上，主机以写为主，从机以读为主<strong>。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 使用：</strong>配主不配从，在从机中使用slaveof&nbsp; 主机ip&nbsp; &nbsp;主机端口配置从机，但是这种配置方式当redis重启之后就会失效，如果想要redis重启仍然可用，则需要配置redis.conf配置文件中的slaveof&nbsp; masterip&nbsp; masterport。这种配置方式的问题所在，中心化只有一台极其支持写操作，如果主机宕机，则从机等待，且从机宕机重启后不会跟上大部队（即重启后变为主机）。当然我们可以采用命令slave&nbsp; no&nbsp; one 使从机反客为主，成为主机。但是这种手动操作太过麻烦。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>哨兵模式：</strong>即配置之后，如果主机宕机，则哨兵会自动根据投票规则在从机中进行选举，从而产生新的主机顶替。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>主从复制的缺点：</strong>因为所有的写操作都是子主机上进行，从而在同步到从机上，所以存在着一定的延迟，当系统繁忙或者从机数量较多的时候，这种问题就更加明显。</p>\n<h2><strong>十，redis集群</strong></h2>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;概述：</strong>集群是一种去中心化的模式，与中心化模式不同的是，中心化模式中如果主服务挂掉了，那么服务就挂掉了。但是集群模式下，没有主路由，每个节点自身都可以成为路由</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;redis集群：即配置多台主机，多台从机，不同的主机中有不同的槽点，当执行数据写入时，会根据crc16算法计算出数据的槽点，从而将数据存入到对应的主机中，并同步到与其对应的从机中</p>\n<p>&nbsp;</p>\n<h1>水平有限，如有错误，还望指出！</h1>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1249588251598041088","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6caUuADBI7AAAb07iHSRw500.jpg","blogRead":4,"blogRemark":"redis基础（一）","blogTitle":"redis基础（一）","createdTime":"2020-04-13 06:40:30","typeName":"redis","updateTime":"2020-04-20 16:47:37"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，线程上下文切换</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>cpu利用时间片轮询的方式来为每个任务都分配一定的时间片，任务的执行过程中保存任务的状态。任务状态的保存和在加载就叫做上下文切换。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>进程：</strong>指的是一个运行中的程序实例，一个进程中可以有多个线程，并且与进程共享同样的内存和系统资源</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong> 上下文：</strong>指的是寄存器和程序计数器保存的线程的信息</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>寄存器：</strong>指的是内存中很小但是运行速度很快的一块区域（相对于RAM外部内存）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>程序计数器：</strong>一种寄存器，用来保存当前执行指令的位置或者下一个待执行指令的位置</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>上下文切换：</strong>上下文切换指的是操作系统的内核在cpu上对进程或者线程的切换。上下文信息保存在进程控制块中（PCB）。流程如下：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;挂起当前进程，将进程的上下文信息保存在进程控制块中；</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;在进程控制块中寻找下一个任务的上下文信息。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;恢复进程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>上下文切换的原因：</strong>第一，任务正常执行完毕，调度下一个任务；第二，线程出现I/O阻塞，被挂起，cpu调度下一个任务；第三，线程等待同步锁，获取socket通知等，被挂起，cpu调度下一个任务；第四，用户调用sleep方法，让出cpu；第五，硬件中断</p>\n<h2><strong>二，JAVA阻塞队列</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>阻塞队列的是调度当前队列的线程处于阻塞状态</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 消费者阻塞：如果队列为空，则消费者线程被挂起，处于阻塞状态，当有新数据进入队列，则消费者线程被唤醒，消费数据</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 生产者阻塞：如果队列数据已满，则生产者线程挂起，处于阻塞状态，当队列有空闲位置，生产者线程被唤醒，生产数据。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞队列的主要操作：</strong>插入操作和移除（获取）操作</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>插入操作：</strong>add(e)，有空间则插入，无空间报异常；offer(e),有空间则插入，无空间返回false；offer(e,time,unit),有空间插入，无空间等待time时间，若超时返回false；put(e),有空间插入，无空间则线程挂起处于阻塞直到有空间</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>移除操作：</strong>poll(e),有值返回值，无值返回null;poll(e,time,unit),有值返回值，无值等待time时间，超时返回null;take(e),有值返回值，无值等待新数据进入再立即返回；drainTo(collection&lt;Object&gt;)批量移除，提高获取效率</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞队列的实现：</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong> ArrayBlockingQueue：</strong>基于数组的有界阻塞队列，按照先进先出顺序对元素进行排序</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>LinkedBlockingQueue：</strong>基于链表的有界阻塞队列，队头队尾采用不两个不同的锁控制数据同步，并发性高</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>PriorityBlockingQueue：</strong>基于优先级的无界队列，默认升序排列，可以自定义排序规则，根据优先级访问数据。但是有数据优先级一样的情况</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>DelayQueue：</strong>支持延时的队列，即从队列中取数据时等待一定的时间才能获取元素。可以用于缓存系统的设计，设计过期时间，也可以用来设置定时调度任务，即如果能够从队列中获取，说明到了任务的调度时间。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>SynchronousQueue</strong>：该队列是一个不存储元素的阻塞队列，每一个put操作都必须等待一个take操作的完成。吞吐量高于ArrayBlockingQueue和LinkedBlockingQueue。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>LinkedTransferQueue：</strong>基于链表的无界阻塞队列，多了transfer方法(如果消费者等待，直接将任务从生产者传递给消费者，无消费者等待，则将任务加到队尾直到被消费才返回)和tryTransfer（与transfer一致，只不过不管有没有消费者等待获取都会立即返回tryTransfer（e,time,unit）（与tryTransfer一致，只不过设置了超时时间）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>LinkedBlockingDeque：</strong>基于链表的双向阻塞队列，可以在两端同时进行读写操作，提高了队列的操作效率。</p>\n<h2><strong>三，并发关键字</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;CountDownLatch：</strong>适用于一个主线程等待子线程完成任务之后执行（原理：设置一个程序计数器，计数器的值为子线程的个数，子线程并发执行，每个子线程执行完毕后，调用CountDown方法，将其计数器的值减去1，值为0时，唤醒主线程执行）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>CyclicBarrier：</strong>即当所有线程到达一个状态共同执行。await（）方法：确保所有线程到达Barrier状态才执行；await（time,unit）：设置一个超时时间，超过这个时间，执行达到Barrier状态的线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>Semaphore：</strong>因为其限制了多线程访问资源的线程个数，所以适用于多线程并发访问有限资源的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>volatile：</strong>直接用来修饰变量，是一种比Synchronized更加轻量级的机制，用于多线程共享同一变量，可以同时对其进行读写操作。当多个线程共享变量的时候，读取变量将其从内存复制到cpu缓存中，然后线程对其操作进行修改，这样再多cpu的情况下，有可能出现线程修改原数据造成数据不一致的情况，使用volatile关键字直接将线程修改的变量存入内存，解决这个问题。</p>\n<h2><strong>四，多线程共享数据</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>多线程共享数据主要通过共享内存实现，而共享内存的可见性，有序性，原子性已经由JVM和锁解决。理想情况下我们需要解决同步和互斥的问题（<span style=\"background-color: #ffff00;\">怎么解决的有待考证！</span>）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>解决方法一：</strong>将数据抽象成一个类，将对数据的操作封装成类中的方法</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解决方法二：</strong>将Runnable对象作为一个内部类，将共享数据作为这个类的成员变量</p>\n<h2><strong>五，ConcurrentHashmap并发</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ConcurrentHashmap使用了减小锁粒度，这里具体为分段锁的思想优化了锁，因为如果直接对hashmap进行加锁，锁太大，而且同一时刻只能有一个线程操作hashmap，并发性能较差</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;实现原理：</strong>即内部采用分段锁思想，将hashmap分为多个segment，每次读取数据的时候，对数据所在的segment进行加锁，这样只要保证每个segment线程安全，就可以保证整个hashmap线程安全</p>\n<h2><strong>六，JAVA中的线程调度</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;抢占式调度：</strong>即线程对cpu资源进行抢占，这种策略下每个线程抢占到cpu资源的概率是相等的，这样就不会一个线程阻塞造成整个系统阻塞的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>协同式调度：</strong>即一个线程使用完cpu资源之后通知cpu调度下一个任务，适用于多线程交替执行任务。因为如果一个线程阻塞可能会造成整个系统阻塞甚至崩溃</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>JAVA采用的是抢占式调度，但同时又尽可能的保证公平性（即为每个线程分配优先级不同的cpu时间片）</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>&nbsp;线程让出cpu的情况</strong>：第一，线程调用yield方法；第二，I/O阻塞，socket等待等；第三，等待同步锁；第四，正常执行完毕</p>\n<h2>七，进程调度算法</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>优先调度算法：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;先来先服务调度算法：</strong>即遵循先来先被分配cpu资源运行的原则</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>短作业调度算法：</strong>即预估作业的时间长短，优先调度时间短的任务，可能会导致长时间大任务很长时间无法被调度 &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>高优先权调度算法：即每个任务会预先被分配优先级</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;非抢占式优先调度算法：</strong>按照优先级的高低一次分配cpu资源运行</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>抢占式优先调度算法：</strong>按照优先级的高低分配cpu资源运行，但是如果任务再运行过程中有优先级更高的任务加入，则将其cpu资源临时回收分配给紧急任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>高响应比调度算法：</strong>动态调度，即作业时间短，则优先级高；等待时间长，则优先级高。前者遵循短作业调度算法，后者遵循先来先服务原则。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>时间片轮转调度算法：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;时间片轮转法：</strong>按照任务再队列中的顺序进行调度</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>多级反馈队列调度算法：</strong>即再时间片轮转法的基础上维护了就绪队列，默认第一队列优先级高，先调度第一队列的任务，如果再分配的cpu时间片内未完成则将其加入第二队列队尾，以此类推直到其执行完毕。只有第1 -（n-1）队列为空，才会调度第n队列的任务，而且当前任务执行时，如果有优先级高的任务进来，会抢占其cpu资源。</p>\n<h2><strong>八，CAS</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>即比较和交换，CAS（V,E,N）三个参数，只有当V=E的时候才会将V设置为N。如果V!=E，则说明数据已经被其它线程修改，不做任何操作</p>\n<h2><strong>九，ABA问题</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>概述：</strong>即当1线程从V中取出A时，2线程也从中取出1，修改为B，再修改为A。而1线程仍然修改成功，实际上修改过程中V的实际值已经发生改变，只不过1没有发觉。解决这种问题，常采用乐观锁的版本号机制。</p>\n<h2><strong>另外有AQS问题没怎么读懂，下次完善！</strong></h2>\n<p>&nbsp;</p>\n<h3><strong>思维导图：<a href=\"https://images-cdn.shimo.im/myFodjsaVAA3PVV7__thumbnail\" target=\"_blank\" rel=\"noopener\">并发编程（下）</a></strong></h3>\n<p>&nbsp;</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</p>","blogGoods":0,"blogId":"1249742755949817856","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHNmAPuxmAABJTVJPTfk117.jpg","blogRead":17,"blogRemark":"面试（三）------之并发编程篇（下）","blogTitle":"面试（三）------之并发编程篇（下）","createdTime":"2020-04-13 16:54:26","typeName":"java面试篇","updateTime":"2020-04-20 11:54:02"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，栈及其JAVA实现</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：栈是一种先进后出的数据结构，对栈顶元素的添加，删除等操作较快，但是对于栈内的元素操作很慢</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA实现：实现需要定义栈的数据结构，写栈的入栈，出栈，获取栈顶元素的方法，如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n * 基于数组实现栈\n * @author wcj\n * @Date 2020/4/14 20:59\n * @Version 1.0\n */\npublic class StackExample&lt;E&gt; {\n\n    /**\n     * 站的深度\n     */\n    private int maxSize;\n    /**\n     * 存储数据的数组\n     */\n    private Object[] data;\n    /**\n     * 栈顶指针\n     */\n    private int top = -1;\n\n    /**\n     * 默认栈的深度为10\n     */\n    public StackExample(){\n        this(10);\n    }\n\n    /**\n     * 用户自定义栈的深度\n     * @param initialSize\n     */\n    public StackExample(int initialSize){\n        if(initialSize&gt;=0){\n            this.maxSize = initialSize;\n            this.data = new  Object[initialSize];\n            this.top = -1;\n        }else{\n            throw new RuntimeException(\"初始化栈的深度不能小于0!\");\n        }\n    }\n\n    /**\n     * 入栈操作\n     * @param e\n     * @return\n     */\n    public Boolean push(E e){\n        if(top == maxSize-1){\n            throw new RuntimeException(\"栈已满,不能入栈\");\n        }else{\n            data[++top] = e;\n        }\n        return true;\n    }\n\n    /**\n     * 出栈操作\n     * @return\n     */\n    public E pop(){\n        if(top==-1){\n            throw new RuntimeException(\"栈空，不能出栈！\");\n        }else{\n            return (E) data[top--];\n        }\n    }\n\n    /**\n     * 获取栈顶元素\n     * @return\n     */\n    public E peak(){\n        if(top==-1){\n            throw new RuntimeException(\"栈空异常！\");\n        }else{\n            return (E) data[top];\n        }\n    }  </code></pre>\n<h2><strong>二，队列极其JAVA实现</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：队列是一种先进先出的数据结构，对队头和队尾的操作简单，但是队内元素的操作复杂。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA实现：定义队列的数据结构，队列的出队，入队，获取队头元素。代码如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n * 基于数组实现队列\n * @author wcj\n * @Date 2020/4/14 21:14\n * @Version 1.0\n */\npublic class QueueExample&lt;E&gt; {\n\n    /**\n     * 队列长度\n     */\n    private int maxSize;\n    /**\n     * 存储数据数组\n     */\n    private Object[] data;\n    /**\n     * 队头指针\n     */\n    private int front;\n    /**\n     * 队尾指针\n     */\n    private int rear;\n\n    /**\n     * 默认构造器\n     */\n    public QueueExample(){\n        this(10);\n    }\n    /**\n     * 用户自定义队列长度构造器\n     * @param initialSize\n     */\n    public QueueExample(int initialSize){\n        if(initialSize&gt;=0){\n            this.maxSize = initialSize;\n            data = new Object[initialSize];\n            front = rear = 0;\n        }else{\n            throw new RuntimeException(\"初始化队列长度不能小于0！\");\n        }\n    }\n\n    /**\n     * 入队操作\n     * @param e\n     * @return\n     */\n    public Boolean add(E e){\n        if(rear == maxSize){\n            throw new RuntimeException(\"队列已满，无法入队!\");\n        }else{\n            data[rear++] = e;\n        }\n        return true;\n    }\n\n    /**\n     * 出队操作\n     * @return\n     */\n    public E poll(){\n        if(front==rear){\n            throw new RuntimeException(\"队空，无元素可出队！\");\n        }else{\n            E e = (E) data[front];\n            data[front] = null;\n            return e;\n        }\n    }\n\n    /**\n     * 获取队头元素\n     * @return\n     */\n    public E peek(){\n        if(front==rear){\n            throw new RuntimeException(\"队空，无元素可出队!\");\n        }else{\n            return (E) data[front];\n        }\n    }\n}\n</code></pre>\n<h2><strong>三，链表及其JAVA实现</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：链表是由一系列数据节点组成的数据结构，节点可以动态生成。对于元素的增加，删除操作快，查询操作慢</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;这里主要讲述几种有代表性的链表：单向链表，双向链表，双向循环链表</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;单链表的JAVA实现：数据结构定义，添加节点，删除节点，查找节点，代码如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n * 单向链表\n * @author wcj\n * @Date 2020/4/14 21:32\n * @Version 1.0\n */\npublic class SingleLinkedList {\n\n    /**\n     * 链表长度\n     */\n    private int length;\n    /**\n     * 链表头节点\n     */\n    private Node head;\n\n    public SingleLinkedList(){\n        this.length = 0;\n        this.head = null;\n    }\n    /**\n     * 内部类声明每个链表节点\n     * 每个节点包括数据域和指向下一个节点的指针\n     */\n    private class Node{\n        private Object data;\n        private Node next;\n        public Node(Object data){\n            this.data = data;\n        }\n    }\n\n    /**\n     * 插入节点（这里使用头插法）\n     * @param obj\n     * @return\n     */\n    public Boolean add(Object obj){\n        Node node = new Node(obj);\n        if(length==0){\n            head = node;\n        }else{\n            node.next= head;\n            head = node;\n        }\n        length++;\n        return true;\n    }\n\n    /**\n     * 删除某个节点\n     * 先对链表进行判空处理\n     * 然后找到要删除的节点\n     * 最后进行删除\n     * @param obj\n     * @return\n     */\n    public Boolean delete(Object obj){\n        if(length==0){\n            throw new RuntimeException(\"链表为空，无节点可删除!\");\n        }else{\n            Node prev = head;\n            Node current = head;\n            //查找待删除元素\n            while(!current.data.equals(obj)){\n                if(current.next==null){\n                    return false;\n                }else{\n                    prev = current;\n                    current = current.next;\n                }\n            }\n            prev.next = current.next;\n            length--;\n        }\n        return true;\n    }\n\n    /**\n     * 获取某个元素\n     * @param obj\n     * @return\n     */\n    public Object find(Object obj){\n        if(length==0){\n            throw new RuntimeException(\"链表为空\");\n        }else{\n            Node current = head;\n            while(current.data.equals(obj)){\n                if(current.next==null){\n                    return null;\n                }else{\n                    current = current.next;\n                }\n            }\n            return current.data;\n        }\n    }\n}\n</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>双向链表的JAVA实现：定义数据结构，头插法，尾插法，删除头部节点，删除尾部节点（这里只写尾插节点和删除尾部节点），代码如下：</strong></p>\n<pre class=\"language-java\"><code>import com.sun.org.apache.xpath.internal.operations.Bool;\n\n/**\n * 单向循环链表\n * @author wcj\n * @Date 2020/4/14 22:05\n * @Version 1.0\n */\npublic class CircleLinkedList {\n\n    /**\n     * 链表长度\n     */\n    private int length;\n    /**\n     * 头节点\n     */\n    private Node head;\n    /**\n     * 尾节点\n     */\n    private Node tail;\n\n    /**\n     * 初始化构造方法\n     */\n    public CircleLinkedList(){\n        this.length = 0;\n        this.head=this.tail = null;\n    }\n\n    /**\n     * 内部类实现的链表节点\n     */\n    private class Node{\n        private Object data;\n        private Node prev;\n        private Node next;\n        public Node(Object data){\n            this.data = data;\n        }\n    }\n\n    /**\n     * 尾插节点\n     * @param obj\n     * @return\n     */\n    public Boolean addTail(Object obj){\n        Node node = new Node(obj);\n        if(length==0){\n            head = tail= node;\n            length++;\n        }else{\n            tail.next = node;\n            node.prev = tail;\n            tail = node;\n            length++;\n        }\n        return true;\n    }\n\n    /**\n     * 删除尾部节点\n     * @return\n     */\n    public Boolean delTail(){\n        Node temp = tail;\n        if(length==0){\n            throw new RuntimeException(\"链表为空!\");\n        }else{\n            tail = tail.prev;\n            tail.next = null;\n            length--;\n        }\n        return true;\n    }\n}\n</code></pre>\n<h2><strong>四，散列表</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：有一张表M，一个映射函数f(key)，如果对于任意一个key，都有一个函数指与表中的内存地址相对应，则M就为散列表，f(key)就为散列函数。散列函数存储key-value键值对形式的数据，直接生成key与表中地址值的映射，因此查询非常迅速。同时散列表也经常被用于信息安全，用于加密操作。</strong></p>\n<h2><strong>五，二叉排序树</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：二叉查找树又成为二叉搜索树，二叉查找树</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;特征：根节点左边的数据小于根节点，根节点右边的数据大于根节点，且其左右子树还是二叉排序树</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现：定义数据结构，插入操作，删除操作，查找操作，代码如下：</strong></p>\n<pre class=\"language-java\"><code>package interviewFour.example4;\n\n/**\n * 二叉排序树\n * @author wcj\n * @Date 2020/4/14 17:17\n * @Version 1.0\n */\npublic class Node {\n\n    private Node root = null;\n    private int value;\n    private Node left;\n    private Node right;\n\n    public Node(){}\n\n    public Node(int value, Node left, Node right){\n        this.value = value;\n        this.left = left;\n        this.right = right;\n    }\n\n    public Node(int value){\n        this.left = null;\n        this.right = null;\n        this.value = value;\n    }\n\n    public int getValue() {\n        return value;\n    }\n\n    public void setValue(int value) {\n        this.value = value;\n    }\n\n    public Node getLeft() {\n        return left;\n    }\n\n    public void setLeft(Node left) {\n        this.left = left;\n    }\n\n    public Node getRight() {\n        return right;\n    }\n\n    public void setRight(Node right) {\n        this.right = right;\n    }\n\n    /**\n     * 插入节点\n     * @param value\n     * @return\n     */\n    public Boolean insert(int value){\n        //root代表根节点\n        Node p = root;\n        Node prev = null;\n        //创建一个节点\n        Node node = new Node(value);\n        //寻找节点的插入位置\n        while(p!=null){\n            prev = p;\n            if(value==p.getValue()){\n                return false;\n            }else if(value&lt;p.getValue()){\n                p = p.getLeft();\n            }else{\n                p = p.getRight();\n            }\n        }\n        if(root==null){\n            root = node;\n        }else if(value&lt;prev.getValue()){\n            prev.setLeft(node);\n        }else{\n            prev.setRight(node);\n        }\n        return true;\n    }\n\n    /**\n     * 删除某个节点\n     * 分为三种情况，待删除节点为叶子节点，则直接删除\n     * 待删除节点只有左子树或者右子树，则用左子树或者右子树替代当前节点位置\n     * 待删除节点即有左子树又有右子树，则寻找左子树最大节点或者右子树最小节点顶替当前节点(这里使用左子树的最大节点)\n     * @param value\n     * @return\n     */\n    public void deleteBST(int value){\n        deleteBST(root,value);\n    }\n\n    /**\n     * 递归删除左子树，或者右子树，或者根节点\n     * @param root\n     * @param value\n     * @return\n     */\n    public Boolean deleteBST(Node root,int value){\n        if(root==null){\n            return false;\n        }else{\n            if(root.getValue()==value){\n                delete(root);\n            }else if(value&lt;root.getValue()){\n                deleteBST(root.getLeft(),value);\n            }else{\n                deleteBST(root.getRight(),value);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * 分情况执行具体的删除逻辑\n     * @param node\n     * @return\n     */\n    public Boolean delete(Node node){\n        if(node.getLeft()==null){\n            node = node.getRight();\n        }else if(node.getRight()==null){\n            node = node.getLeft();\n        }else{\n            Node temp = node;\n            Node s = node;\n            //转向左子树，向右走到底\n            s = s.getLeft();\n            //寻找替换待删除节点的节点\n            while(s!=null){\n                temp = s;\n                s = s.getRight();\n            }\n            node.setValue(temp.getValue());\n            if(temp!=node){\n                node.setLeft(temp.getLeft());\n            }else{\n                node.setRight(temp.getRight());\n            }\n        }\n        return true;\n    }\n\n    /**\n     * 在二叉查找树中找到对应节点\n     * @param value\n     * @return\n     */\n    public Boolean searchBTS(int value){\n        Node node = root;\n        if(node==null){\n            throw new RuntimeException(\"无此节点！\");\n        }else{\n            if(value==node.getValue()){\n                return true;\n            }else if(value&lt;node.getValue()){\n                node = node.getLeft();\n            }else{\n                node = node.getRight();\n            }\n        }\n        return false;\n    }\n}\n</code></pre>\n<h2><strong>六，红黑树</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 概述：红黑树是一种特化的自平衡二叉排序树，即其左右子树的深度差可以超过1。（详细的插入等操作过段时间会补充）</strong></p>\n<h2><strong>七，图，位图</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;图的知识：定义，有向图/无向图，邻接矩阵/邻接表，BFS/DFS，位图的话没怎么搞清楚。</strong></p>\n<h3><strong>思维导图：<a href=\"https://images-cdn.shimo.im/YClQaLxx9e8uEb9U__thumbnail\" target=\"_blank\" rel=\"noopener\">数据结构</a></strong></h3>\n<h2>&nbsp;</h2>","blogGoods":0,"blogId":"1250068950784536576","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHQGAYlUxAABJTVJPTfk990.jpg","blogRead":7,"blogRemark":"面试（四）------之数据结构篇","blogTitle":"面试（四）------之数据结构篇","createdTime":"2020-04-14 14:30:37","typeName":"java面试篇","updateTime":"2020-04-23 22:14:43"}],"pageSize":10,"params":{},"sortColumn":"blog_collection","sortMethod":"DESC","totalCount":53,"totalPage":6},"msg":"操作成功!"}
2020-04-26 23:27:30.715 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/list
2020-04-26 23:27:30.715 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:27:30.716 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:27:30.716 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogList
2020-04-26 23:27:30.717 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=10, totalPage=6, totalCount=53, list=[BlogVo(blogId=1247745014683947008, blogTitle=博客开发总结（一）-----之数据库设计篇, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dDViAcnjvAACb6PL1tzA485.jpg, blogContent=<p><strong>一，数据库设计--表的命名规范等</strong></p>
<p>（1），统一采用bl_开头对表进行命名</p>
<p>（2），对于数据比较重要的表统一添加四个字段，分别为：created_time(创建时间),update_time(修改时间),version(版本号),deleted(删除字段)</p>
<p>（3），数据库表的字段尽量都设置为NOT_NULL</p>
<p>（4），数据库中表varchar类型字段需要设置长度的尽量设置为2<sup>n</sup>-1</p>
<p>（5），因为博客系统分为前台展示界面和后台管理，所以对于有些表，例如bl_type（博客类型表），bl_music（音乐表）等设置了enable（启用字段）</p>
<p><strong>二，上述第二条--四个字段的解释</strong></p>
<p>（1），为什么要设置created_time和update_time字段：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;其一，从数据库的通用性上来说，设计这两个字段是必要的，但也需要根据业务的需要来合理添加这两个字段，因为无用的字段会浪费空间，性能，影响系统的运行。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 其二，大部分的应用都有需要根据时间进行排序的功能。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 其三，当系统发生异常的时候，我们可以通过这两个字段对异常进行排查和定位。</p>
<p>（2），为什么要设置version字段：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 1，version字段含义：字段的含义与其字面意思一样，代表版本，在这里作为乐观锁进行使用，从而保证不会出现脏数据的情况。下面解释一下什么叫乐观锁，以及乐观锁和悲观锁</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 2，乐观锁：总是假定最好的情况，即每次用户调用接口从数据库中取出数据到修改数据前的过程中，不会有其它用户对当前数据进行修改，这样在当前用户修改数据的时候，利用版本机制即判断取出的version字段和当前数据库该条数据的version字段是否相等来判断该条数据是否已经被修改，如果未修改，则予以修改（且version字段递增），如果已经修改，则提示用户更新失败。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 悲观锁：总是假定最坏的情况，即每次用户调用接口从数据库取出数据的时候，都认为该条数据会被修改，因此每次取出数据都对数据进行加锁处理，只允许当前用户进行修改，其它用户阻塞，直到当前用户修改完毕。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3，为什么使用乐观锁而不使用悲观锁：因为悲观锁比较浪费性能</p>
<p>（3），为什么设置deleted字段：deleted字段在这里作为一个逻辑删除字段（0否1是），何为逻辑删除，即执行删除操作操作的时候，不会真正的删除数据库中的数据，而是将deleted字段设置为1即可。&nbsp;这样如果用户出现误删的操作，可以通过数据库修改该字段进行数据的恢复。</p>
<p><strong>三，上述第三条--数据库表字段尽量设置为NOT_NULL</strong></p>
<p>（1），数据库表字段尽量设置为NOT_NULL：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 1，有些人可能认为设置为NULL相比于NOT_NULL不是更节省空间吗？但是实际上不是这样的，设计为NULL相比于NOT_NULL要多占用一个字节的空间</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 2，设计为NOT_NULL，这样在做查询的时候能够更好的避免空指针异常，且发生该类错误的时候能够更好的进行排查</p>
<p><strong>四，上述第四条--表varchar类型字段长度尽量设置为2<sup>n</sup>-1</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>因为计算机只识别二进制，且有一定的范围，例如2<sup>8</sup>，在计算机中的范围为-128~127,因此对于varchar字段长度来说，如果设置为255，则正好是一个字节，而如果设置为256，则占用两个字节，这样会浪费计算机的内存空间，因此数据库varchar类型字段的长度最好设置为2<sup>n</sup>-1</p>
<p><strong>五，上述第五条--对于设置enable字段的解释</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>enable字段，字面意思启用，在这里表明是否启用（0否1是），因为系统分为前台博客页面和后台管理，对于这两个不同的前端项目，后台可以通过启用字段来控制内容在前台博客页面的展示与否，与deleted字段不同的是，如果执行删除操作，那么我们只能通过手动修改数据库中的字段进行数据的恢复，且如果执行删除操作，则该数据在前台博客页面和后台管理页面都无法看见。但是如果将数据弃用（即修改enable字段值为1），则表明该数据被弃用，在前台博客页面无法显示，但是在后台管理页面可以看见，且无需通过手动修改数据库来恢复数据，可以在后台管理页面操作启用数据。</p>
<p>&nbsp;</p>, blogGoods=0, blogRead=21, blogCollection=0, typeName=博客开发和维护总结, blogRemark=博客开发总结（一）-----之数据库设计篇, blogComment=0, blogSource=null, createdTime=2020-04-08 04:36:07, blogMonth=null, updateTime=2020-04-20 10:47:54), BlogVo(blogId=1247867141693128704, blogTitle=闲谈前后端分离开发, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dG6CAI6ipAACiM2P5LtI65.jpeg, blogContent=<p><strong>一，前后端分离开发优势</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，</strong>项目开发过程中，前后端完全解耦，前端只需要负责页面的实现，只需要通过接口拿数据。后端不需要管页面的跳转，只需要负责接口的编写</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，</strong>前后端人员有更多的精力去负责自己的工作，前端人员可以将更多的精力投放在页面的编写，页面的美化，页面特效的制作和用户体验上；而后端人员可以将更多的精力放在接口代码的优化，sql优化，jvm调优上面</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，</strong>前后端分离的项目部署的时候，前端项目往往都是部署在nginx服务器上，而前后端不分离的项目往往都是部署再一台服务器上。因此前后端分离项目大大降低了服务器的负担</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>4，</strong>前后端不分离的项目使用模板引擎例如freemaker，thymeleaf等，前后端人员交流起来较为困难。且前端项目使用原生的DOM操作，极大的增加了前端工作人员的工作量。而前后端分离项目前端通常都是用各种ui框架，框架采用MVVM模式，极大的减轻了前端工作人员的工作量</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，</strong>前后端分离开发，前端可以通过easy-mock来伪造接口数据进行测试，后端人员可以通过postman进行接口测试，开发效率大大提升。</p>, blogGoods=0, blogRead=7, blogCollection=0, typeName=随笔, blogRemark=前后端分离开发的优势所在, blogComment=0, blogSource=null, createdTime=2020-04-08 12:41:25, blogMonth=null, updateTime=2020-04-20 11:48:53), BlogVo(blogId=1248135765829918720, blogTitle=CSS----之flex弹性布局, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dGnuAWkLLAAAaRXQXNms575.jpg, blogContent=<p><strong>一，css之弹性布局</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，</strong>何为弹性布局？</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 弹性布局是css的一种新的布局方式，所谓&ldquo;弹性布局&rdquo;，即页面随着不同设备的屏幕大小拉伸会自适应页面的大小。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，</strong>弹性布局的两种主要元素，container（弹性容器），item（弹性子元素），一个弹性容器中可以放入多个弹性子元素，元素之间是可以进行嵌套的，弹性子元素也可以设置为弹性容器，里面再嵌套弹性子元素。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，</strong>弹性布局的基本属性</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （1）display：flex，声明容器为弹性布局</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （2）flex-direction：声明弹性容器内部元素的排列方式，默认为row。row（横向布局），row-reverse（横向布局，但是元素反方向码），column（纵向布局），column-reverse（纵向布局，但是元素反着码）。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （3）flex-wrap：声明弹性盒子中的元素是否可以换行，默认为nowrap（不换行），wrap（换行），wrap-reverse（换行，但是反着码）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （4）align-items：设置容器中元素在纵轴方向上的对齐方式，默认为stretch（即如果不设置子元素高度，则默认拉伸至于容器同宽度），flex-start（子元素位于容器的开始位置），flex-end（子元素位于容器的结尾处），center（元素依纵轴方向居中），baseline（元素位于容器基线，不过没怎么用过，所以不是很清楚）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （5）justify-content（设置元素在主轴上的对齐方式），默认为flex-start（元素从容器主轴开始位置码），flex-end（元素从容器主轴结尾处码），center（元素位于主轴居中处），space-between（元素布局在容器的两端），space-around（元素布局在容器两端，但是元素前后都留有空白）因为项目中大多数只使用了对于容器的操作，对于容器中元素的操作很少，所以这里只介绍这点。谢谢阅读！</p>, blogGoods=0, blogRead=3, blogCollection=0, typeName=CSS, blogRemark=CSS----之flex弹性布局, blogComment=0, blogSource=null, createdTime=2020-04-09 06:28:51, blogMonth=null, updateTime=2020-04-20 11:43:57), BlogVo(blogId=1248224512563068928, blogTitle=面试（一）------之JVM篇, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dHLeALxSjAABJTVJPTfk677.jpg, blogContent=<h2 style="text-align: left;"><strong>一，JVM运行机制</strong></h2>
<p>&nbsp;&nbsp; &nbsp; &nbsp;jvm即java虚拟机，一共由四个部分组成，分别是类加载器子系统，运行时数据区（程序计数器，本地方法区，jvm栈，方法区，jvm堆），执行引擎（即时编译器，垃圾收集器），本地接口库。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;一个java源程序的运行先是经过编译器将其编译成字节码文件（class文件），然后通过类加载器子系统将其加载进入jvm&mdash;&mdash;&gt;程序运行过程中，运行时数据区存放程序运行过程产生的数据&mdash;&mdash;&gt;执行引擎中的垃圾收集器收集程序运行过程中创建的不再使用的对象，即时编译器将程序的字节码文件编译成机器码&mdash;&mdash;&gt;然后本地接口库利用机器码调用本地方法库中的方法，和操作系统实现交互。</p>
<h2><strong>二，多线程</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;</strong>在多核操作系统中，jvm支持一个进程中同时并发执行多个线程，且这些线程和本地操作系统的线程相对应。当jvm中的对象初始化，内存空间分配等一系列准备工作完成之后，会调用操作系统中的接口创建一个原生线程，原生线程初始化完毕后，会调用java线程的run（）方法执行该线程，线程结束之后，jvm会释放原生线程和java线程资源。</p>
<h2><strong>三，JVM的内存区域</strong></h2>
<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM的内存区域主要分为线程私有区域（程序计数器，本地方法区，JVM栈），线程共享区（方法区，JVM堆）和直接内存。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;程序计数器：线程私有区域，无内存溢出，用来记录程序运行过程中的字节码指令地址，如果是Native方法，则程序计数器为空。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM栈：线程私有区域，用来描述java程序的运行过程，java程序运行每次运行的时候，都会创建一个栈帧，方法的执行和返回对应着栈帧的入栈和出栈操作。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;本地方法区：线程私有区域，和JVM栈的功能一样，只不过是用来记录Native方法的运行过程。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM堆：线程共享区，主要用来存放程序运行过程中产生的数据，同时也是垃圾收集器进行垃圾回收的主要区域。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;方法区：也被称为永久代，用来存放常量，静态变量，类信息等等。</p>
<h2><strong>四，JVM的运行时内存</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>JVM的运行时内存又被称为JVM堆，因为JVM的GC算法使用的是分代收集算法，所以JVM堆按照GC标准可以分为三个区域分别为：新生代，老年代，永久代。其中新生代占1/3，老年代占2/3，永久代很少，</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;新生代：存放短生命周期，小对象的区域。新生代又分为Eden区，ServivorTo区，ServivorFrom区，区域的GC算法采用复制算法。Eden区是用来存放新创建的对象（大对象除外），ServivorTo区是用来保存MinorGC幸存下来的对象，ServivorFrom区是用来将上一次MinorGC幸存下来的对象作为下一次MinorGC的扫描对象。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;老年代：存放长生命周期的大对象，区域的GC算法采用标记整理算法</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;永久代：主要用来存放class和meta数据信息的。程序运行过程中不会进行永久代的垃圾回收，这也就导致永久代区域的数据会越来越多，最终造成内存溢出。java8之后永久代已经被元数据区取代，元数据区和永久代的功能都是一样的，但是最大的不同在于永久代区域依赖于虚拟机的内存大小，因而可以存储的class，meta信息非常有限。但是元数据区依赖的是本地操作系统，因而不会受到虚拟机内存的限制。</p>
<h2><strong>五，垃圾回收与算法</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;(1)垃圾回收：</strong>Jvm的垃圾回收判定依赖于两种方法，引用计数法和可达性分析法。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;引用计数法：即如果想要在程序中使用对象，就必须赋予一个引用，这样在对象赋予引用的时候将其引用计数加1，删除一个引用时，将对象引用计数减1，如果引用计数为0，就说明该对象已经不使用，作为垃圾。但是引用计数法存在一个缺陷，即循环引用的问题，如果两个对象相互引用，则这两个对象的引用计数永远都不会为0，造成对象无法被回收。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;可达性分析法：即先创建一些根节点对象ROOTS，然后通过这些根节点对象向下搜索，如果一个对象到任意一个ROOTS之间都没有可达路径，在经过两次标记（下文解释为什么进行两次标记），还是没有可达路径，则说明该对象可回收。</p>
<p>&nbsp;&nbsp; &nbsp;<strong>（2）GC算法：</strong>常见的GC算法有四种，分别为标记清除算法，复制算法，标记整理算法，分代收集算法</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;标记清除算法：即在进行垃圾回收前，对所有对象进行一次标记，标记可回收的对象，然后进行清理即可。但是标记清除算法在清除回收对象之后，并不会对堆内存进行整理，这样的话如果内存中的对象大部分为小对象，清理之后就会导致没有大片连续的内存空间，即造成了内存碎片化，这样大对象存储的时候就无法找到相应的完整连续内存。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;复制算法：即将内存分为两块同等大小的区域，区域1和区域2，创建的新对象都存储在区域1中，当区域1中的内存占满之后，会对内存中的所有对象进行一次标记，标记存活的对象，将存活的对象复制到区域2，这时区域1中的对象都是可回收对象，回收区域1中的所有对象即可。但是复制算法也存在着一定的缺陷，即每次都只能使用一半的内存空间，造成了大量的内存浪费。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;标记整理算法：即结合标记清除算法和复制算法的优点，先对所有的对象进行标记，标记存活的对象，将存活的对象复制到内存的另一端，然后清除当前端的对象即可。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;分代收集算法：前面的三种算法，都无法按照对象的类型进行收集，分代收集算法正是解决这个问题，按照对象的不同类型采用不同的GC算法。以JVM的分代收集算法为例，JVM的堆内存分为新生代，老年代，永久代。新生代又分为Eden区，ServivorTo区和ServivorFrom区。新生代因为其存储生命周期短的小对象，GC比较频繁，所以采用复制算法。程序运行过程中创建的对象都存储在Eden区（大对象除外，大对象直接复制到老年代区域）。当Eden区的内存不够的时候进行MinorGC，然后将Eden区和ServivorFrom区的存活对象都复制到ServivorTo区，然后将ServivorTo区和ServivorFrom区进行交换，再次进行MinorGC。老年代因为存放的都是生命周期长的大对象，因而进行GC的不会太频繁，且清除的对象并不会太多，因而采用标记整理算法。老年代每次进行MajorGC之前都会先进行一次MinorGC，当MinorGC之后新生代的内存仍然不够的时候，将对象复制到老年代进行MajorGC。永久代区域主要回收常量，无用class等。</p>
<h2><strong>六，JAVA中的四种引用类型</strong></h2>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;强引用类型<strong>：</strong>即把对象赋给一个引用变量，强引用的对象一定为可达状态，所以不会进行垃圾回收。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;软引用类型：通过SoftReference类实现，当内存不够的时候对其进行GC</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;弱引用类型：只有弱引用类型的对象，一定会被GC</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;虚引用类型：虚引用对象主要是用来跟踪对象的GC状态</p>
<h2><strong>七，分代收集算法和分区收集算法</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>分代收集算法：新生代因其存放大量短生命周期小对象，且GC频繁，所以采用复制算法。老年代因其存放长生命周期大对象，且GC不平凡，所以采用标记整理算法。永久代，回收常量，类信息等。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;分区收集算法：即将堆内存区域分为大小不同的区，可以按照不同的区进行快速垃圾回收，减少系统的停顿时间。然后再以并行的方式逐步完成整个GC。</p>
<h2><strong>八，垃圾收集器</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>新生代区域：Serial垃圾收集器，单线程复制算法，因为单线程无需进行线程之间的交互和切换，所以效率非常高，是JVM默认的client模式下的默认垃圾回收策略，工作期间需要暂停其它所有的线程。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ParNew垃圾收集器，多线程复制算法，跟单线程Serial一样，是JVM默认的server模式下的垃圾回收策略，工作期间需要暂停所有其它线程</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Parallel Scavenge垃圾收集器：多线程复制算法，不同的是优先考虑系统吞吐量，可以利用更高效的利用CPU完成GC</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;老年代区域：Serial Old垃圾收集器，单线程标记整理算法，同新生代的Serial功能一样，只是采取的算法不同而已。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Parallel Old垃圾收集器：多线程标记整理算法，优先考虑了系统的吞吐量，其次考虑停顿时间。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CMS,多线程标记清除算法，优先考虑系统GC时的停顿时间，且过程分为四步（<span style="background-color: #ffff00;">解释上文的可达性分析中的两次标记</span>，第一步：标记GC ROOTS可达对象，暂停其它工作线程；第二步：和用户线程一起工作，跟踪GC ROOTS；第三步，因为第二步用户进程没有暂停，所以有些对象状态</p>
<p>可能发生了改变，重新进行标记；第四步，清除不可达对象）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; G1垃圾收集器，多线程标记整理算法，将内存分区，与CMS相比，一方面不会产生内存碎片，一方面，可以精确的控制系统停顿时间。</p>
<h2><strong>九，JAVA的网络编程模型</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;</strong>阻塞I/O模型：即用户线程发出I/O请求之后，内核会检查数据是否准备就绪，这时候用户线程始终处于阻塞状态等待数据准备就绪。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;非阻塞I/O模型：即用户线程不断的给内核发出I/O请求，内核接受到I/O请求之后会返回一个状态，如果数据准备就绪，就将数据复制进入用户线程，如果数据没有准备好，返回一个false，用户线程无需阻塞，可以去处理其它事情，而当数据准备好了且刚好用户线程发起I/O请求进行操作。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;多路复用I/O模型：多路复用I/O模型通过一个Selector线程轮询Socket的状态，如果Socket有读写事件，则进行I/O操作。此模型的优势在于可以更好的处理连接数众多但消息体不大的情况下。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;信号驱动I/O模型：即用户线程发出一个I/O请求，系统会为该请求创建一个信号函数，用户请求可继续执行其它业务逻辑，当内核数据准备就绪之后会返回给用户线程一个信号，用户线程接收到之后进行I/O操作。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;异步I/O模型：用户线程给内核发起一个asynchronous read操作，内核接收到之后，返回其请求是否成功，然后等待数据准备成功之后复制到用户线程。整个过程中请求的发起和数据读取都在内核中进行，最终发送一个信号告知用户线程I/O操作已经完成，用户直接使用数据就行。（说实话个人感</p>
<p>觉和信号驱动很像）</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;java NIO：没怎么读懂（<span style="background-color: #993300;">记得补充！</span>）</p>
<h2><strong>十，JVM的类加载机制</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>JVM类加载分为五个阶段：加载，验证，准备，解析，初始化</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;加载：即将class文件加载到JVM中，且创建class对象，封装其数据结构。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;验证：对class文件进行验证，确保符合JVM的标准，保证JVM的安全。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;准备：即方法区中给类变量分配空间和赋初值。static修改的会在初始化阶段赋值，final修饰的会在准备阶段赋值。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;解析：即将常量池中的引用替换为直接引用</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;初始化：执行类构造器进行初始化。（因为内部流程不是很清楚，所以对于其几种不进行初始化的情况不做说明）</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;类加载器：JVM提供了三种类加载器，启动类加载器（/lib），扩展类加载器(/lib/ext)，应用程序类加载器(classpath)。还可以再应用程序类加载器自定义类加载器。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;双亲委派机制：即当一个类接收到类加载请求的时候，不会自己进行加载，而是将其加载请求委派给其父类加载器，这样一路委派，最终加载请求都会委派到启动类加载器.启动类加载器接收到加载请求之后会去lib目录下寻找相关的class文件，若找不到，则将其加载请求再委培给子类加载器，一路委派，直到能够加载。</p>
<h3><strong>最后，送给大家一张博主画的JVM的思维导图，以后读《深入JVM虚拟机》的时候可能会出一个JVM专题：<a href="https://uploader.shimo.im/f/X0MX3hLaHrevltxW.png!thumbnail" target="_blank" rel="noopener">JVM思维导图</a></strong></h3>
<p>&nbsp;</p>
<h2>水平有限，若发现有误，还望指出！</h2>, blogGoods=0, blogRead=17, blogCollection=0, typeName=java面试篇, blogRemark=面试（一）------之JVM篇, blogComment=0, blogSource=null, createdTime=2020-04-09 12:21:30, blogMonth=null, updateTime=2020-04-20 11:53:29), BlogVo(blogId=1248500061625745408, blogTitle=Linux基本命令, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dDA6AfCOJAAAyfL52jxY706.jpg, blogContent=<p><strong>一，Linux的发展历史</strong></p>
<p><strong>&nbsp; &nbsp; &nbsp; </strong>1965年之前，电脑并不像现在这么普遍，除了军事机构和研究即构，一般人基本接触不到电脑，而且那时候的一台大型主机最多也就只能支持30台终端。为了解决数量问题，1965年之后，由贝尔实验室，麻省理工学院以及通用电气一起放弃了Multics项目，准备让大型主机能够支持300台终端，但是在开发过程中，进度缓慢，最终由于资金的短缺，贝尔实验室推出了研究。1969年，从这个项目中退出的Ken Thompson在家无聊，为了让电脑能够运行&ldquo;星际旅行&rdquo;游戏，因而趁着妻子回家探亲的一个月，独自写出了Unix操作系统的原型（！！！！牛批）。1970年，这个人以BCPL语言为基础，又写出了很接近硬件的B语言，并且用B语言写出了第一个Unix操作系统。但是由于B语言的跨平台性比较差，为了解决这个问题。Dennis Ritchie和Ken Thompson决定以B语言为基础开发一种新的语言，1972年，Dennis Ritchie最终设计出了一种新语言，他以BCPL的第二个字母命名，也就是我们后来熟知的C语言。随后两人便迫不及待的用C语言重现Unix操作系统。Unix系统起初开源，但是在Unix7之后，由于政策的变化，代码闭源化，因而大学中不能使用Unix的源代码进行教学。Andrew S. Tanenbaum教授为了能够让学生更好的理解代码细节，在完全不使用任何源代码的情况下开发除了Minix---小型Unix。但是因为其只用于教学，功能并不强大，因而Torvalds以此为基础，开发除了Linux，但是起初Linux并不支持Unix，最终经过全世界网友的帮助，最终让其能够兼容各种硬件。</p>
<p><strong>二，文件和目录</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp; 1，windows和linux的区别：</strong>我们熟知的windows系统，它的文件系统是分盘符的，盘符下的文件构成一个树形结构，但是Linux文件系统没有盘符，所有文件目录都在根目录/之下</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;<strong>2，Linux需要记住的目录：</strong>/bin（存放系统命令的目录），/sbin（只有超级管理员能访问的命令文件目录），/root（存放和root用户相关文件的目录），/etc（存放系统配置文件的目录），/usr（存放系统共享资源的目录），/opt（存放安装的第三方软件的目录，通常在/usr/local下）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;<strong>3，文件权限：</strong>Linux中的文件权限有读（r，可用于数字4表示），写操作（w，可用数字2表示），执行权限（x，可用数字1表示）</p>
<p><strong>三，常用命令</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，ls：</strong>列出目录中的所有目录和文件名&nbsp; -a（列出所有，包括隐藏文件和目录），-l（以列表形式列出所有），-h（人性化列出，需要配合-l使用，即文件大小转换为我们熟知的kb，mb等），-d（显示当前目录属性），命令可以联合使用，例如-al，-lh等等。&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，cd：</strong>用于切换目录，需知（.和..是相对路径，.表示当前目录，..表示上级目录；/表示绝对路径），cd ~（切换到root目录），cd - （切换到前一次切换的目录）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，clear：</strong>清屏</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，pwd：</strong>显示当前所在目录</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，mkdir：</strong>创建目录，-p（如果目录存在则不创建，如果不存在则创建目录再创建自目录），可以一次性创建多级目录，例如：mkdir&nbsp; -p test/test1</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，touch：</strong>创建空文件</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>7，cp：</strong>复制，-r（递归复制目录下的文件目录信息），-i(提示是否覆盖)，-v（显示复制进度）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>8，mv：</strong>移动文件，不过经常用来给文件进行重命名</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>9，rm：</strong>删除目录或者文件，-r（递归删除），-f（强制删除），-v（显示删除进度）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>10，cat：</strong>查看文件内部信息</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>11，ln：</strong>文件创建链接，ln 源文件 目标链接文件（创建硬链接，硬链接和源文件大小相同，修改同步，但是删除不同步，使用较少），ln -s（创建软连接，相当于我们平时创建快捷方式，使用较多）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>12，which：</strong>搜索命令所在位置，例如：which&nbsp; &nbsp;ls</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>13，find：</strong>搜索文件所在位置&nbsp; 例如：find&nbsp; &nbsp;test.conf</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>14，grep：</strong>文件内容搜索，例如：grep &ldquo;想要搜索的内容&rdquo;&nbsp; 源文件</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>15，tar：</strong>归档命令，-c（打包成.tar文件），-z（打包的同时压缩），-v（打包的同时显示进度），-f（放在最后，后面跟.tar.gz），-x(解压)，常用：tar -zcvf&nbsp; <em><strong>.tar.gz&nbsp; &nbsp; ;&nbsp; &nbsp; tar -zxvf</strong> tar.gz</em> -C&nbsp; 指定解压目录&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;还有more，head，tail等命令，不过这些不常用。</p>
<p><strong>四，用户权限命令</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，whoami：</strong>查看当前账户的用户名</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，who：</strong>查看当前登录用户</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，exit：</strong>退出登录</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，adduser/useradd：</strong>添加用户，-d（指定用户主目录），-g（指定用户用户组），-m（自动建立目录），默认情况下用户主目录和用户组名都和用户名一样</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，passwd：</strong>只有root用户才能使用，用于修改用户密码</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，userdel：</strong>删除用户，默认不删除用户的主目录，-r（删除用户主目录）</p>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;7，su：</strong>切换账户</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>8，groupadd/groupdel：</strong>添加用户组和删除用户组</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>9，groups：</strong>查看用户所在用户组，例如：groups&nbsp; 用户名</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>10，usermod：</strong>修改用户所在用户组，例如：usermod&nbsp; 用户组名 用户名</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>11，chmod：</strong>修改文件权限，例如：chmod&nbsp; 777&nbsp; test</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>12，chown：</strong>修改文件所有者，例如：chown&nbsp; &nbsp;用户&nbsp; 文件名</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>13，chgrp：</strong>修改文件所在组，例如：chgrp&nbsp; 组名&nbsp; 文件名</p>
<p><strong>五，系统命令</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，cal：</strong>查看日历</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，date：</strong>查看时间，可以设置格式，例如：date '+<span class="ql-token hljs-built_in">%Y</span>-<span class="ql-token hljs-built_in">%m</span>-<span class="ql-token hljs-built_in">%d</span> <span class="ql-token hljs-built_in">%H</span>:<span class="ql-token hljs-built_in">%M</span>:<span class="ql-token hljs-built_in">%S</span>'</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，ps：</strong>查看线程</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，kill：</strong>杀死线程，-9（强制杀死）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，查看网卡信息：</strong>centos6：ifconfig ；centos7：ip addr</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，ping：</strong>查看网址或者链接的连通性</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>7，防火墙：</strong>centos6：service&nbsp; iptables&nbsp; status（查看防火墙状态），service&nbsp; &nbsp;iptables&nbsp; &nbsp;start(开启),service&nbsp; iptables&nbsp; stop(关闭);centos7:firewall-cmd&nbsp; --state（查看防火墙状态），systemctl&nbsp; start&nbsp; firewalld.service(启动)，systemctl&nbsp; &nbsp;stop&nbsp; firewalld.service（关闭）</p>
<p><strong>六，网络命令</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，wget：</strong>下载，例如：wget&nbsp; &nbsp;链接地址</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，yum：</strong>下载安装</p>
<p><strong>七，vim（这里只说几个常用的命令）</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;</strong>vim有三种模式：命令模式，插入模式，编辑模式&nbsp; &nbsp;</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;vim&nbsp; 文件名：进入文件，且处于命令模式；iao任意一键进入插入模式（i表示在贯标之前插入，a光标之后插入，o在下一行插入），：进入编辑模式</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;命令：set:nu显示行号，set:nonu不显示行号；/strinng，向后搜索字符串，？string向后搜索字符串；：w保存，：wq保存并退出，：q不保存退出</p>, blogGoods=0, blogRead=2, blogCollection=0, typeName=Linux, blogRemark=Linux基本命令总结, blogComment=0, blogSource=null, createdTime=2020-04-10 06:36:25, blogMonth=null, updateTime=2020-04-20 10:42:25), BlogVo(blogId=1248605157059497984, blogTitle=面试（二）------之JAVA基础篇, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dHMKAcvZ8AABJTVJPTfk020.jpg, blogContent=<h2><strong>一，集合</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，List：</strong>list是java中一种有序的集合，下有三个实现类，分别为ArrayList，Vector，LinkedList</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ArrayList：基于数组实现，增删慢，查询快，线程不安全。因为其基于数组实现，所以查询的时候可以直接根据数组的索引下标进行快速查询，但是进行增删操作的时候，需要将待增删元素后的元素全部移动，因而效率较低。且ArrayList创建时不需要分配初始大小，其空间不够的时候，会自动创建一个更大的list，然后复制数据。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Vector：基于数组实现，和ArrayList一样增删慢，查询快。但是线程安全，因为同一时间只支持一个线程对Vector进行写操作，然而因为要进行频繁的加锁和释放锁的操作，所以效率要低于ArrayList。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; LinkedList：基于双向链表实现，增删快，查询慢。因为基于链表实现，增删元素的时候，只需要改变元素的指针即可，改动较小，效率较高。然而进行查询操作的时候，需要从链表头部进行遍历，因而效率较低。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，Queue：</strong>队列，满足先进先出，种类较多。（不作详细解释）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，set：</strong>具有独一无二的特性，常用来存储无序且不重复的元素，对象相等的本质是hashcode的值相同，而如果想要比较两个对象是否相等，需要重写对象的hashcode方法和equals方法。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;hashset：基于hashTable实现，无序。存放的是对象的散列值，即通过hashcode计算得到的值</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;treeset：基于二叉树实现，即其中的对象按照一定的排序方式进行排列（升序，降序），每次添加对象的时候，都会进行排序，将其插入指定位置。基本的数据类型例如Integer，String等可以使用treeset默认的排序方法，而自定义数据类型需要实现compareable接口，实现compareTo方法。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;LinkHashSet：继承自hashset，只不过使用双向链表记录数据的顺序。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，map：</strong>一种键值对形式的集合</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;hashmap：基于数组+链表实现，增删改查操作快，但是每次遍历hashmap元素的顺序无法保证且线程不安全。如果想要其线程安全，可以使用synchronizedMap和ConcurrentHashmap，hashmap的内部是数组，数组中的每一个元素又是一个单向链表，链表中的每个元素嵌套一个Entry实例，其中包括Key，Value，Hash值，指向下一个节点的next。每次查询的时候，可以根据元素的hash值很快定位所在数组，但是定位之后需要遍历链表查找元素，因而时间复杂度为O（n），但是Java8之后对其进行了优化，将其改为了数组+链表或红黑树的结构，即当链表中的元素大于8个的时候，链表会转换为红黑树（红黑树是一种特化的二叉平衡树，因为其左右子树的深度差可以大于1），这样查询的时间复杂度就缩短到了O（logN）。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ConcurrentHashmap：采用分段锁的思想进行并发操作，因而使线程安全的。由多个Segment组成，只要保证每个Segment线程安全就可以保证全局线程安全。ConcurrentHashmap的默认Segment即并发度为16，可以在初始化的时候修改，但是初始化之后不能再修改。每个Segment内部的实现和hashmap一样&middot;。Java8之后也和hashmap进行了一样的优化。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;HashTable：线程安全，即同一时刻只能有一个线程对其进行操作，并发度不如ConcurrentHashmap。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;TreeMap：基于二叉树数据结构实现，实现了SortedMap，默认按照键值的升序进行排列。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;LinkedHashMap：Hashmap的子类，只不过使用链表保存元素的插入顺序。使用迭代器遍历的时候按照插入顺序遍历。</p>
<h2><strong>二，异常分类及处理</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;1，异常分类：</strong>Throwable是所有异常类的父类，其下有error和Exception，Error下有AwtError，ThreadDeath；Exception下有RuntimeException和CheckedException。</p>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</strong>对于Error类异常通常是由内部错误和资源耗尽造成的，无法在程序运行期间对其进行捕获和处理，对于这类错误我们只能记录错误的原因和终止程序。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; Exception中的RuntimeException异常（运行时异常）：这类异常是我们程序中异常处理的核心，可以在程序中进行捕获并处理。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Exception中的CheckedException异常（检查异常）：这类异常时程序中需要强制捕获的异常，通常有IO异常，SQL异常等等。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，异常处理：</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>异常处理有两种方式：抛出异常和捕获异常</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;抛出异常有三种方法：throws，throw，系统自动抛出。其中throws是作用在方法上，后面跟的是可能产生的异常类。throw是作用在方法内部，后面跟的是具体的异常对象。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 捕获异常：即使用try{}catch语句进行捕获</p>
<h2><strong>三，反射机制</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，什么叫做反射机制？</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>即在程序运行的过程中，可以获取类的属性和方法，并且可以调用任意一个类的方法。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，反射机制的使用</strong></p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 首先，获取类的class对象，有三种方式，className.getClass()，类对象.class，Class.forName("类路径")，其中最后一种最为安全，性能最好。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 然后利用反射的API可以实现对类中信息的操作，例如getDeclareFields（），getDeclareMethods（），getConstroctors（）等等。反射创建类的对像有两种方法，一，class.newInstance()初始化一个类实例；二，先获取其构造器，然后利用构造器初始化一个实例。利用反射调用类的方法：先获取方法，然后调用method.invoke()执行方法。</p>
<h2><strong>四，注解</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，四种元注解：</strong>@Target（指定注解的使用范围），@Retention（定义注解的保留级别，有三级，SOURCE源程序中保存，CLASS文件中保存，RUNTIME运行时保存），@Documented（可以工具文档化），@Inherited（<span style="background-color: #ffff00;">这个没怎么看懂</span>）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，注解使用示例：</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>第一步，定义注解接口</p>
<pre class="language-java"><code>@Target(ElementType.FIELD)  
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FruitProvider {

    //id
    public int id() default  -1;

    //供应商名称
    public String name() default "";

    //供应商地址
    public String address() default "";

}</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 第二步，使用注解</p>
<pre class="language-java"><code>public class Apple {

    @FruitProvider(id = 1,name = "红富士苹果",address = "陕西")
    private String appleProvider;

    public String getAppleProvider() {
        return appleProvider;
    }

    public void setAppleProvider(String appleProvider) {
        this.appleProvider = appleProvider;
    }
}</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第三步，定义注解处理器</p>
<pre class="language-java"><code>public class FruitInfoUtil {
    public static void getFruitInfo(Class&lt;?&gt; clazz) {
        String strFruitProvider = "供应商信息:";
        Field[] declaredFields = clazz.getDeclaredFields();
        for (int i = 0; i &lt; declaredFields.length; i++) {
            if (declaredFields[i].isAnnotationPresent(FruitProvider.class)) {
                FruitProvider annotation = declaredFields[i].getAnnotation(FruitProvider.class);
                strFruitProvider += annotation.id() + "," + annotation.name() + "," + annotation.address();
                System.out.println(strFruitProvider);
            }
        }
    }
}</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第四步，主方法入口</p>
<pre class="language-java"><code>public class FruitRun {
    public static void main(String[] args) {
        FruitInfoUtil.getFruitInfo(Apple.class);
    }
}</code></pre>
<h2><strong>五，内部类</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 1，静态内部类：</strong>即在类的内部定义的静态类，静态内部类可以访问外部了的静态变量和方法，外部也可以通过outClassName.innerClassName调用内部类</p>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2，成员内部类：</strong>在类的内部定义的没有用static修饰的内部类，使用方式和静态内部类一样。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>3，局部内部类：</strong>即一个类只在一个方法中使用，则完全可以将这个类定义为这个方法的内部类，即局部内部类，局部内部类可以实现真正的对外隐藏</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>4，匿名内部类：</strong>通常用于继承一个类或者实现一个接口的时候，使用new关键字定义，例如:Person person = new Student(){new Pupil(){}}</p>
<h2><strong>六，泛型</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 1，为什么要使用泛型：</strong>其根本目的是为了实现代码的复用，举个开发中常见的例子，我们需要定义返回类Result，返回类中包含状态码code，信息msg，以及数据data（任意类型），这个时候我们就需要使用泛型，因为我们返回的数据类型有各种vo，pojo类对象，list等。这时候泛型类result就可以被各种对象使用，实现代码的复用，简化开发。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>2，泛型标记和泛型限定：</strong>E表示集合中的元素，K表示键值，V表示value，N表示数值类型，T表示任意类型（包含基础类型，所有的对象类型），？（不确定的java类型）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>泛型限定：</strong>向上限定，&lt;?&nbsp; extends T&gt;，向下限定，&lt;? super&nbsp; T&gt;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; <strong>3，泛型方法：</strong>即参数类型定义为泛型类型，以便于接收不同类型的参数，做出不同的处理。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>4，泛型类：</strong>例如public class Pair&lt;T&gt;{private T data;}</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>5，泛型接口：</strong>与放泛型类类似</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>6，类型擦除：</strong>即在泛型编译的过程中，会将泛型类型替换为限定类型的操作</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>7，明确的一点：</strong>虚拟机在运行程序的过程中，内部是没有泛型的，只有普通的类和方法。</p>
<h2><strong>7，序列化</strong></h2>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 序列化是为了确保对象及其状态的持久化</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>序列化的使用：</strong></p>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </strong>首先，实现序列化接口java.io.Serializble</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 然后，声明序列化ID，通常private static final&nbsp; long&nbsp; serialVersionUid&nbsp; = ***</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 因为序列化是保证对象及其状态的持久化，而静态变量是不属于对象，属于类本身的，所以序列化无法保存静态变量。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果需要序列化父类变量，则父类也要实现Serializable接口</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t'ransient修饰的属性不会序列化</p>
<h3><strong>最后，提供一张思维导图供大家学习：<a href="https://images-cdn.shimo.im/es83SQH0CggucT7f__thumbnail" target="_blank" rel="noopener">JAVA基础</a></strong></h3>
<p>&nbsp;</p>
<h2>水平有限，如有错误，还望指出！</h2>, blogGoods=0, blogRead=27, blogCollection=0, typeName=java面试篇, blogRemark=面试（二）------之JAVA基础篇, blogComment=0, blogSource=null, createdTime=2020-04-10 13:34:02, blogMonth=null, updateTime=2020-04-20 11:53:39), BlogVo(blogId=1249313090567143424, blogTitle=面试（三）------之并发编程篇（上）, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dHM2AQOeZAABJTVJPTfk967.jpg, blogContent=<h2><strong>一，JAVA线程的创建方式</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>JAVA线程的创建有四种方式，分别为，继承Thread类，实现Runable接口，实现Callable&lt;Class&gt;接口，基于线程池。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>1，继承Thread方式：创建一个类继承Thread类，创建类的实例对象，调用start方法，继而执行线程的run（）方法，代码如下：</strong></p>
<pre class="language-java"><code>public class NewThread extends Thread{
    public static void main(String[] args) {
        NewThread thread = new NewThread();
        thread.start();
    }
    @Override
    public void run(){
        System.out.println("create  a  new thread by Thread!");
    }
}</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>2，当子类已经继承了一个类，这时候就没法再继承Thread类了，这时候就可以实现Runable接口，实例化类的线程实例，创建Thread实例传入类的实例，执行start方法，继而执行run（）方法代码如下：</strong></p>
<p>&nbsp;</p>
<pre class="language-java"><code>public class ThreadExample2 implements Runnable {
    public static void main(String[] args) {
        ThreadExample2 threadExample2 = new ThreadExample2();
        Thread thread = new Thread(threadExample2);
        thread.start();
    }
    @Override
    public void run() {
        System.out.println("create a new thread by Runnable!");
    }
}</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，有些情况下，我们需要再一个主线程中并发多个子线程执行同一个任务，然后回收子线程的返回值整理汇总，这时候就需要实现Callable&lt;Class&gt;接口，重写其call（）方法，用于计算结果。然床创建一个线程池用于提交线程，继而执行call方法，并且创建一个Future的list用于接收子线程逻辑代码即call方法的返回，最终遍历list，得到想要的返回值，如下：</strong></p>
<pre class="language-java"><code>public class ThreadExample3 implements Callable&lt;String&gt; {

    private String name;

    public ThreadExample3(String name){
        this.name = name;
    }

    @Override
    public String call() throws Exception {
        return name;
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService pool = Executors.newFixedThreadPool(3);
        List&lt;Future&gt; list = new ArrayList&lt;&gt;();
        for(int i=0;i&lt;3;i++){
            ThreadExample3 threadExample3 = new ThreadExample3(i+"");
            Future future =pool.submit(threadExample3);
            System.out.println(future.get().toString()+" is running");
            list.add(future);
        }
        pool.shutdown();
        for (Future future : list) {
            System.out.println("currentThread's result is "+future.get().toString());
        }
    }
}</code></pre>
<p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，基于线程池创建线程</strong></p>
<pre class="language-java"><code>public class ThreadExample4 {
    public static void main(String[] args){
        ExecutorService pool = Executors.newFixedThreadPool(3);
        for(int i=0;i&lt;3;i++){
            pool.execute(new Runnable() {
                @Override
                public void run() {
                    System.out.println("thread  is running by FixedThreadPool");
                }
            });
        }
        pool.shutdown();
    }
}</code></pre>
<h2>二，线程池的工作原理</h2>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong> &nbsp;1，概述：</strong>JVM根据用户提供的参数创建一定数量的线程任务，将其放入队列中，线程创建之后启动这些任务，如果线程的数量大于核心线程数量（用户设置的线程数量），则超出数量的线程排在队列中等待，当有线程任务执行完毕后，线程池调度器就会发现有可用可用线程，继而从队列中取出任务继续执行<strong>。</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; </strong><strong>2，线程复用：</strong>（参见JDK源码解读，这里只做简单描述），由前可知，JVM会根据用户提供的参数创建一定数量的线程任务，且将其添加到任务队列中。JVM通过start（）方法创建一个线程之后， 会相应的为其创建一个任务队列，线程会不停的查看任务队列，如果任务队列中有任务，则调用run方法，执行，这样就达到了一次start（）创建线程，多次使用，完成线程复用的任务。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>3，线程池的核心组件和核心类（见JDK源码分类中关于线程的总结）</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; </strong><strong>4，JAVA线程的工作流程：</strong>线程池刚被创建的时候，只是向系统申请一个执行线程队列和管理线程池的线程资源，当调用execute方法之后，执行下列流程：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果正在运行的线程数量小于corePoolSize（核心线程数量，即用户定义的的线程数量），则立即创建线程执行线程任务</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果正在运行的线程数量大于或等于corePoolSize，则将超过数量的线程加入到阻塞队列中</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在阻塞队列已满且线程数量小于MaximumPoolSize（即线程池能够容纳的最大线程数），线程池会创建非核心线程立即执行任务</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在阻塞队列已满且线程数量大于或等于MaximumPoolSize的时候，线程池会拒绝该线程任务且抛出异常</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在线程任务执行完毕之后，会将其从任务队列中移除，从队列中取出下一个线程任务执行</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在线程处于空闲状态且空闲时间超过KeepAliveTime，且线程数量大于corePoolSize的时候，会停止该线程，这样在没有任务的时候，线程池中的线程数始终维持在corePoolSize。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，线程池的拒绝策略：</strong>分为四种，分别为AbortPolicy，CallerRunsPolicy，DiscardOldestPolicy，DiscardPolicy</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; AbortPolicy：直接抛出异常，阻止线程运行，源码如下：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</p>
<pre class="language-java"><code>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
            throw new RejectedExecutionException("Task " + r.toString() +
                                                 " rejected from " +
                                                 e.toString());
        }</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CallerRunsPolicy：如果线程任务没有关闭，则尝试执行该线程任务，源码如下：</p>
<pre class="language-java"><code>* @param r the runnable task requested to be executed
* @param e the executor attempting to execute this task
*/
public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
     if (!e.isShutdown()) {
         r.run()
     }
}</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DiscardOldestPolicy：移除任务队列中最早进入的线程任务，执行当前任务线程，源码如下：</p>
<pre class="language-java"><code>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
       if (!e.isShutdown()) {
           e.getQueue().poll();
           e.execute(r);
       }
}</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DiscardPolicy：直接丢弃线程任务，不做任何处理</p>
<h2><strong>三，五种常用的线程池</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;newCachedThreadPool（可缓存线程池）：</strong>当线程池创建线程的时候如果发现有可复用的线程（执行完任务，且未关闭的线程），则直接复用，如果没有则创建新线程。可缓存线程池可以高效的利用执行任务时间短的线程，提高系统的性能，且线程池中的线程如果空闲时间超过60s，则会被终止且从缓存中移除，这样可缓存线程池不会占用系统资源。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>newFixedThreadPool（固定大小的线程池）：</strong>即线程池中的线程是初始化固定的，当任务线程大于线程池中线程数量时，任务线程就会进入阻塞队列等待。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newScheduledThreadPool（可做任务调度的线程池）：</strong>即可以设置线程执行的停顿时间和执行周期，进行定期定时的执行某个任务。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newSingleThreadPool（单个线程的线程池）:&nbsp;</strong>即线程池中永远只有一个线程进行工作，如果下称停止或者异常，则线程池创建新的线程替代当前线程</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newWorkStealingPool（足够大小的线程池）：</strong>即创建足够数量的线程的线程池，保证更快的进行运算，提高效率。</p>
<h2><strong>四，线程的生命周期</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;线程的生命周期大致分为五个阶段：新建（new），就绪（Runnable），运行（Running），阻塞（Blocked），死亡（Dead）</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;新建：</strong>即使用new创建一个线程</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>就绪：</strong>调用start方法，</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>运行：</strong>即线程获取cpu资源，执行run（）方法，进入运行状态，运行状态的线程如果调用yield（线程让步方法）或者失去cpu资源，都会导致线程重新回到就绪态；如果调用sleep方法，I/O阻塞，等待同步锁，等待通知以及suspend挂起都会导致线程进入阻塞态。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞：</strong>即线程被放入Blocked池。阻塞状态的线程如果结束了sleep方法，I/O方法返回，获取同步锁，收到通知或者resume都会导致其重新进入就绪态，与其它线程竞争cpu时间片。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>死亡：</strong>线程正常执行完run（）或者call（）方法，或者执行stop方法，或者发生异常或者错误都会导致线程死亡。（stop方法会导致锁混乱和死锁，不建议使用）</p>
<h2><strong>五，线程的基本方法</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;wait（线程等待）：</strong>会让线程进入WAITING状态，并且会释放对象的锁。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>sleep（线程睡眠）：</strong>会让线程进入睡眠，进入TIMED_WAITING状态，但是不会释放对象锁，睡眠时间到了之后，再次恢复运行状态</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>yield（线程让步）:</strong>&nbsp; 当前线程会让出其占有的cpu资源，重新回到就绪态和其它线程竞争cpu时间片</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>interrupt（线程中断）:&nbsp; </strong>中断当前线程，但是并不会导致其停止，只是改变其内部的终端标识位，在使用了thread.sleep()之后使用该方法，会导致抛出异常，且我们可以利用中断标识位进行线程的安全退出</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>join（线程加入）：</strong>即将当前线程进入阻塞态，等待下一个线程执行完毕后进入就绪态，重新竞争锁资源。通常用于主线程下面执行子线程，需要主线程阻塞，等待子线程执行完毕后返回其结果给主线程，主线程再执行的情况。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>notify（线程唤醒）/notifyAll：</strong>前者随机唤醒一个等待线程，后者全部唤醒</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>setDaemon（守护线程）:</strong>级别较低的线程，用于后台运行，服务用户用户线程，例如垃圾收集线程就是典型的守护线程。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>sleep方法和wait方法的区别：</strong>前者属于Thread，后者属于Object，前者不会释放锁资源，后者会释放锁资源</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>start方法和run方法：</strong>start方法只是创建一个线程，并没有运行，run方法时执行线程的真正代码逻辑。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>线程退出的方式：</strong>见四中最后一条</p>
<h2><strong>六，JAVA中的锁（知识比较杂乱）</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述:JAVA中的锁是为了保护数据的一致性。按照不同的标准可分为乐观锁和悲观锁，公平锁和非公平锁，共享锁和独占锁，偏向锁，轻量级锁，重量级锁，自旋锁，可重入锁。</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;乐观锁：</strong>即认为每次读取数据都不会被修改，当修改操作的时候再判断当前数据是否被修改，未修改则修改，若已被修改，则返回失败状态。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>悲观锁：</strong>即认为每次读取数据都会被修改，因而每次读取数据都对其进行加锁，这样只有当前用户可以修改，其它用户阻塞等待直到当前用户修改完毕释放锁资源。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>自旋锁：</strong>即有些线程任务的执行很短，很快就可以释放锁资源，为了避免在这种情况下竞争线程仍然进行内核态和用户态之间的转换，因而让线程自旋（即等一会），如果有可用锁，则获取，减少了线程在用户态和内核态之间切换的时间损耗。提高了性能（优势）。当然线程自旋是占用cpu资源的，因而需要设置一个自旋的最大等待时间，如果超过此时间，则线程退出自旋模式。对于线程竞争锁资源激烈的情况，自旋有可能会导致cpu资源的损耗（劣势）。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>公平锁和非公平锁：</strong>即根据线程竞争锁资源的机制判定，一般如果依据先到先得的原则，则位公平锁；如果依据就近原则，则位非公平锁。公平锁相比于非公平锁会更加耗费性能，因为要维护一个线程任务丢列，根据线程任务在队列中的顺序分配锁资源，因而不常用。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>可重入锁：</strong>又被称为递归锁，即该锁可以然后线程对其进行多次的加锁操作。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>偏向锁：</strong>当线程获取到锁的时候，用来消除线程的锁重入的开销（看起来是偏袒这个线程）。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>共享锁和独占锁：</strong>共享锁即多线程共享锁资源（典型例子，读锁）；独占锁即当前锁只能有一个线程获取，其它线程阻塞</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>轻量级锁：</strong>没有多线程竞争的前提下，减少重量级锁的使用提高性能。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>重量级锁：</strong>基于操作系统的互斥量而实现的锁，会导致进程在用户态和内核态之间切换，耗费性能。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>synchronized：独占式悲观锁，可重入锁，非公平锁，重量级锁。</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 作用范围：</strong>作用于成员变量和非静态方法，相当于锁住的是对象的实例，即this对象</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;作用于静态方法，相当于锁住的是class实例</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;作用域代码块，相当于锁住的代码块中的对象</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>实现原理：</strong>内部包括ContentionList（锁竞争队列），EntryList（竞争候选列表），WaitSet（等待集合），OnDeck（竞争候选者），Owner，!Owner，其中ContentionList是用来存放竞争锁资源的线程。EntryList是用来存放有资格竞争锁资源的线程。调用wait方法后放入WaitSet中，onDeck指的是同一时刻，只有一个线程竞争锁资源，Owner指的是得到锁资源的线程，!Owner指的是线程执行完毕，释放锁资源的线程。需要注意的是线程首先采用的都是自旋模式获取锁资源，如果自旋获取不到再加入ContentionList，而且Owner状态的线程并不是直接把锁资源交给onDeck状态线程，而是给它竞争锁资源的权利，因而onDeck状态的线程还需要跟自旋线程竞争锁资源。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>ReentrantLock：独占式，可重入锁，并且可以实现公平锁和非公平锁，重量级锁。</strong></p>
<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;用法：</strong>lock()加锁，后跟try代码块，finally中进行释放锁unlock()</p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;避免死锁的方法：</strong>响应中断（即可以根据情况中断对锁资源的请求），可轮询锁（tryLock（）即尝试获取锁，如果有可用锁则获取返回true，没有则返回。和lock（）的区别在于lock获取锁资源如果没有则一直等待直到获取到锁资源），定时所（tryLock（time,unit）即再一定时间内如果有可用锁，且线程未中断则获取锁，否则禁用当前线程。）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>Semaphore（信号量）:</strong>机制和ReentrantLock类似</p>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ReadWriteLock（读写锁）：</strong>如果系统要求支持多线程共享读，但不能多线程写，使用读锁；如果要求同一时刻只能有一个线程写，写的过程中不能读取该共享数据，则使用写锁。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; <strong>分段锁：</strong>一种思想，将数据分段加锁，例如ConcurrentHashMap</p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;死锁：</strong>即线程之间互相共享资源会导致死锁</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; <strong>锁优化：</strong>第一，减少锁的持有时间；第二：减小锁粒度，例如分段锁；第三：锁分离，例如读写锁；第四：锁粗化，放置锁粒度太小，造成频繁加锁释放锁；第五：锁消除，消除程序代码不规范而造成的乱用了锁</p>
<p>&nbsp;</p>
<h3><strong>并发编程（上）的思维导图送上：<a href="https://images-cdn.shimo.im/1UcHkyrlJyGRPYnn.png__thumbnail" target="_blank" rel="noopener">并发编程（上）</a></strong></h3>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>
<h1>水平有限，如果错误，还望指出！</h1>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;</p>, blogGoods=0, blogRead=8, blogCollection=0, typeName=java面试篇, blogRemark=面试（三）------之并发编程篇（上）, blogComment=0, blogSource=null, createdTime=2020-04-12 12:27:07, blogMonth=null, updateTime=2020-04-20 11:53:51), BlogVo(blogId=1249588251598041088, blogTitle=redis基础（一）, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6caUuADBI7AAAb07iHSRw500.jpg, blogContent=<h2><strong>一，redis简介</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>redis是NoSQL型系统之一，与之相似的还有Memcache，用来存储key-value这种键值型数据。相比于Memcache而言，redis不仅可以做临时缓存，还可以做数据持久化，将数据定时的存入硬盘或者将命令追加到日志文件当中。而Memcache只能做临时缓存，因而现在基本上已经被redis完全取代。redis的读写速度非常快，官方给出的数据是读110000次/s，写81000次/s；而且redis支持多种数据类型，例如String，list，hash，set，zset；redis支持主从复制（集群），进行数据持久化；还支持过期时间，事务等。</p>
<h2><strong>二，redis的安装与启动（docker环境下）</strong></h2>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;docker安装完毕后，安装redis：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第一步：拉取redis镜像，docker&nbsp; pull&nbsp; redis</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第二步：启动redis，docker&nbsp; &nbsp;run&nbsp; &nbsp;redis&nbsp; &nbsp;</p>
<p><strong>三，基本知识串讲</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>单进程单线程：redis只有一个进程，且内部为单线程，这样做的优势是不存在线程安全问题，且不需要进行线程间的切换，提高了性能，而且多线程可能会涉及到锁。劣势是无法发挥多核cpu的优势，不过可以通过开启搭建多个redis实例实现</p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>redis中默认有16个数据库（0-15），可以通过select n来进行数据库之间的切换</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;常用的基本命令：flushDB（清空当前数据库），flushAll（清空所有数据库），dbSize（查看有多少数据库）</p>
<h2><strong>四，redis基本数据类型</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;string：</strong>字符串类型，数据库中存储Map&lt;String,String&gt;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>list：</strong>列表数组类型，数据库中存储Map&lt;String,List&lt;Object&gt;&gt;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>hash：</strong>哈希类型，数据库中存储Map&lt;String,Map&lt;Object,Object&gt;&gt;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>set：</strong>集合类型，其中元素无序，数据库中存储Map&lt;String,Set&lt;Object,Object&gt;&gt;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>Zset：</strong>有序集合类型，每个元素都有一个可用于排序的权重</p>
<h2><strong>五，redis相关命令（这里详解一些常用的命令，不常用的一笔带过）</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;string：</strong>(1)set&nbsp; key&nbsp; value,插入一条数据&nbsp; （2）mset&nbsp; key value...批量插入 （3）setnx&nbsp; key value&nbsp; 若无则插入（4）get&nbsp; key&nbsp; 获取某条数据&nbsp; （5）mget keys 批量获取&nbsp; （6）getrange key&nbsp; 0 -1获取数据库全部数据&nbsp; （7）incr age 递增&nbsp; (8) incrby&nbsp; age&nbsp; 10&nbsp; 递增 age 步长为10（9）decr&nbsp; age&nbsp; 递减&nbsp; （10）decrby&nbsp; age&nbsp; 10 步长递减&nbsp; &nbsp;（11）del&nbsp; key&nbsp; 删除某条数据&nbsp; <span style="background-color: #ffff00;">（12）exists&nbsp; key&nbsp; 判断是否存在某个key&nbsp; &nbsp;(13)expire&nbsp; key&nbsp; 10&nbsp; 设置过期时间（单位为秒）&nbsp; （14）pexpire&nbsp; key&nbsp; 1000 设置过期时间，单位为毫秒&nbsp; （15）persist key删除过期时间 （</span><span style="background-color: #ffff00;">16）ttl&nbsp; key&nbsp; 查看过期时间</span></p>
<p><span style="background-color: #ffff00;">&nbsp;<span style="background-color: #ffffff;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>list：&nbsp;&nbsp;</strong>（1）lpush&nbsp; key&nbsp; value 左插入一条数据&nbsp; &nbsp;（2）lpush mylist&nbsp; key&nbsp; value....批量左插入&nbsp; （3）rpush&nbsp; key value 右插入一条数据&nbsp; (4)rpush&nbsp; mylist&nbsp; key value...右批量插入&nbsp; （5）lrange&nbsp; mylist&nbsp; 0&nbsp; -1&nbsp; 取出数据集合&nbsp; （6）lpop mylist 左弹出集合中第一条数据&nbsp; （7）rpop&nbsp; </span></span><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">mylist&nbsp; 右弹出集合中第一条数据&nbsp; （8）llen&nbsp; mylist&nbsp; 获取数据集合长度lrem&nbsp; mylist&nbsp; count&nbsp; value&nbsp; （count&gt;0,从表头开始搜索，移除count个与值与value相等的元素；count&lt;0,表尾开始；count=0，移除所有值与value相等的元素） （9）linsert mylist&nbsp; before/after&nbsp; a&nbsp; 在a元素前或后插入。</span></span><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">(10) lpoplpush&nbsp; list&nbsp; list1 转移列表的元素到另一个列表</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>hash：</strong>（1）hset&nbsp; key&nbsp; &nbsp;val-key&nbsp; val-val&nbsp; 插入一条数据&nbsp; （2）hset&nbsp; myhash&nbsp; name&nbsp; xxx&nbsp; 用于给哈希表中的字段赋值，不存在则创建哈希表赋值，存在则覆盖旧值&nbsp; (3) hget&nbsp; &nbsp;myhash&nbsp; name&nbsp; 取哈希表中某个值&nbsp; （4）hmset&nbsp; myhash name&nbsp; xxx age xxx&nbsp; 批量插入字段&nbsp; （5）hmget</span></span><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">批量获取 （6）hgetall&nbsp; myhash&nbsp; 获取哈希表中所有值&nbsp; (7)&nbsp; hexisets myhash&nbsp; name&nbsp; 判断哈希表中是否存在name字段&nbsp; （8）hsetnx&nbsp; myhash score 100 若存在则不插入，若不存在则插入数据&nbsp; （9）hincrby&nbsp; myhash id 1/hdecrby&nbsp; myhash id&nbsp; 10 递增递减 （10）hdel&nbsp; myhash name&nbsp; </span></span><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">删除&nbsp; （11）hkeys&nbsp; myhash&nbsp; 只取key值&nbsp; （12）hvals&nbsp; myhash&nbsp; 只取value值&nbsp; （13）hlen&nbsp; myhash 获取哈希表长度</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>set：</strong>（1）sadd myset&nbsp; redis&nbsp; 添加一条数据&nbsp; （2）smembers myset&nbsp; 获取数据集合&nbsp; （3）srem&nbsp; myset&nbsp; set1&nbsp; 删除set1&nbsp; （4）sismember myset&nbsp; set1 判断set中是否存在set1&nbsp; (5)srandmember&nbsp; key count&nbsp; 随机获取count个元素（6）spop&nbsp; 从集合中弹出一个元素</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>zset：</strong>之后补充</span></span></p>
<h2><strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">六，redis配置文件（常见配置）</span></span></strong></h2>
<p><strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;daemonize no：</span></span></strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">redis默认不是以守护进程的方式运行的，可以更改为yes启用守护进程（即后台运行）</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>pidfile&nbsp; /var/run/redis.pid&nbsp; :</strong>启用守护进程后，默认将pid写入/var/run/redis.pid文件，可以更改</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>port&nbsp; 6379 ：</strong>redis默认端口</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp; &nbsp; &nbsp; &nbsp; <strong>bind&nbsp; 127.0.0.1：</strong>绑定的主机地址</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;"> &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>timeout&nbsp; 300</strong><strong>：</strong>redis客户端闲置多长时间后关闭连接，改为0的话，表示关闭该功能</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>loglevel&nbsp; verbose：</strong>默认日志级别（还有debug，notice，warning）</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>database 16：</strong>redis默认有16个数据库可以修改</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>save&nbsp; 900&nbsp; 1/save&nbsp; 300&nbsp; 10/save&nbsp; 60&nbsp; 10000：&nbsp;</strong>表示一定时间内有多少条数据发生修改，就将其同步到数据文件一次，例如第一个表示15分钟内有一条数据发生改变就同步</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>rdbcompression yes&nbsp; ：</strong>表示数据存储到本地数据库时是否进行压缩</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>dbfilename&nbsp; dump.rdb：</strong>指定本地数据库文件名</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>dir&nbsp; /...../redis安装目录/bin ：</strong>本地数据库存放目录，默认在redis安装目录的bin目录下</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>slaveof&nbsp; &nbsp;masterip&nbsp; masterport ：</strong>设置当本机为从机时，它的主机的ip和端口</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>masterauth&nbsp; &lt;master-password&gt;：</strong>当master服务设置了密码时，slav服务连接master的密码</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>requirepass&nbsp; foobared：</strong>默认关闭redis连接需要密码，当给redis设置了密码，就需要打开</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>maxclients&nbsp; &nbsp;128：</strong>redis同一时间最大连接客户端的数量</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>appendonly&nbsp; &nbsp;no：</strong>是否开启aof持久化，默认不开启，采用rdb</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>appendfilename&nbsp; appendonlu.aof：</strong>指定aof持久化的文件名</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>appendfsync&nbsp; everysec :</strong>指定更新日志条件，默认每秒更新一次（还有no，指等操作系统进行数据缓存到磁盘，快；always指每次更新操作后都手动写入磁盘，慢但安全）</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;虚拟机方面的配置暂不说明</span></span></p>
<h2><strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">七，redis持久化</span></span></strong></h2>
<p><strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;概述：</span></span></strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">redis持久化主要有两种方式，即rdb和aof</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>rdb：</strong>适用于大数据集的恢复，数据的备份，但是因为设置周期时间进行数据的快照，所以如果redis宕机，可能会丢失最后一个写操作的数据，因为数据完整性较差。数据保存在dump.db文件中，只需要移动到redis安装目录，重启即可恢复数据</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>aof：</strong>适用于对数据的完整性要求较高的情况，因为可以设置不同的持久化策略，例如每秒保存一次，这样即时redis宕机，也只会丢失最后一秒的数据。但是因为其日志文件存储的是写入命令，因而其文件大小要大于rdb的数据文件，且每次重启，都要从头执行数据文件中的命令，因而恢复速度也</span></span><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">要慢于rdb。</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>注意：</strong>当rdb和aof同时开启的时候，redis重启，默认会采用aof的形式进行数据的重新构建</span></span></p>
<h2><strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">八，redis事务</span></span></strong></h2>
<p><strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;概述：</span></span></strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">什么是事务？事务即是一系列的命令要买全部执行，要么全部回滚</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <strong>常用命令：</strong>multi(启动事务)，discard（取消事务）,exec（执行事务块内命令）,watch key(监控某个key的变化)，unwatch（取消对所有key的监控）</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>注意：</strong>redis的事务中在命令本身出错的情况下会造成命令的全部回滚，但是在命令无错，执行某个命令的时候发生异常的时候，则谁的错，谁停止（这一点和mysql是不同的）</span></span></p>
<h2><strong>九，redis的主从复制</strong></h2>
<p><strong>&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>redis的主从复制，即主机数据更新后根据我们设置的策略将数据同步到从机上，主机以写为主，从机以读为主<strong>。</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 使用：</strong>配主不配从，在从机中使用slaveof&nbsp; 主机ip&nbsp; &nbsp;主机端口配置从机，但是这种配置方式当redis重启之后就会失效，如果想要redis重启仍然可用，则需要配置redis.conf配置文件中的slaveof&nbsp; masterip&nbsp; masterport。这种配置方式的问题所在，中心化只有一台极其支持写操作，如果主机宕机，则从机等待，且从机宕机重启后不会跟上大部队（即重启后变为主机）。当然我们可以采用命令slave&nbsp; no&nbsp; one 使从机反客为主，成为主机。但是这种手动操作太过麻烦。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>哨兵模式：</strong>即配置之后，如果主机宕机，则哨兵会自动根据投票规则在从机中进行选举，从而产生新的主机顶替。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>主从复制的缺点：</strong>因为所有的写操作都是子主机上进行，从而在同步到从机上，所以存在着一定的延迟，当系统繁忙或者从机数量较多的时候，这种问题就更加明显。</p>
<h2><strong>十，redis集群</strong></h2>
<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;概述：</strong>集群是一种去中心化的模式，与中心化模式不同的是，中心化模式中如果主服务挂掉了，那么服务就挂掉了。但是集群模式下，没有主路由，每个节点自身都可以成为路由</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;redis集群：即配置多台主机，多台从机，不同的主机中有不同的槽点，当执行数据写入时，会根据crc16算法计算出数据的槽点，从而将数据存入到对应的主机中，并同步到与其对应的从机中</p>
<p>&nbsp;</p>
<h1>水平有限，如有错误，还望指出！</h1>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong></p>, blogGoods=0, blogRead=4, blogCollection=0, typeName=redis, blogRemark=redis基础（一）, blogComment=0, blogSource=null, createdTime=2020-04-13 06:40:30, blogMonth=null, updateTime=2020-04-20 16:47:37), BlogVo(blogId=1249742755949817856, blogTitle=面试（三）------之并发编程篇（下）, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dHNmAPuxmAABJTVJPTfk117.jpg, blogContent=<h2><strong>一，线程上下文切换</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>cpu利用时间片轮询的方式来为每个任务都分配一定的时间片，任务的执行过程中保存任务的状态。任务状态的保存和在加载就叫做上下文切换。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>进程：</strong>指的是一个运行中的程序实例，一个进程中可以有多个线程，并且与进程共享同样的内存和系统资源</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong> 上下文：</strong>指的是寄存器和程序计数器保存的线程的信息</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>寄存器：</strong>指的是内存中很小但是运行速度很快的一块区域（相对于RAM外部内存）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>程序计数器：</strong>一种寄存器，用来保存当前执行指令的位置或者下一个待执行指令的位置</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>上下文切换：</strong>上下文切换指的是操作系统的内核在cpu上对进程或者线程的切换。上下文信息保存在进程控制块中（PCB）。流程如下：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;挂起当前进程，将进程的上下文信息保存在进程控制块中；</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;在进程控制块中寻找下一个任务的上下文信息。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;恢复进程</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>上下文切换的原因：</strong>第一，任务正常执行完毕，调度下一个任务；第二，线程出现I/O阻塞，被挂起，cpu调度下一个任务；第三，线程等待同步锁，获取socket通知等，被挂起，cpu调度下一个任务；第四，用户调用sleep方法，让出cpu；第五，硬件中断</p>
<h2><strong>二，JAVA阻塞队列</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>阻塞队列的是调度当前队列的线程处于阻塞状态</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 消费者阻塞：如果队列为空，则消费者线程被挂起，处于阻塞状态，当有新数据进入队列，则消费者线程被唤醒，消费数据</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 生产者阻塞：如果队列数据已满，则生产者线程挂起，处于阻塞状态，当队列有空闲位置，生产者线程被唤醒，生产数据。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞队列的主要操作：</strong>插入操作和移除（获取）操作</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>插入操作：</strong>add(e)，有空间则插入，无空间报异常；offer(e),有空间则插入，无空间返回false；offer(e,time,unit),有空间插入，无空间等待time时间，若超时返回false；put(e),有空间插入，无空间则线程挂起处于阻塞直到有空间</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>移除操作：</strong>poll(e),有值返回值，无值返回null;poll(e,time,unit),有值返回值，无值等待time时间，超时返回null;take(e),有值返回值，无值等待新数据进入再立即返回；drainTo(collection&lt;Object&gt;)批量移除，提高获取效率</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞队列的实现：</strong></p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong> ArrayBlockingQueue：</strong>基于数组的有界阻塞队列，按照先进先出顺序对元素进行排序</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>LinkedBlockingQueue：</strong>基于链表的有界阻塞队列，队头队尾采用不两个不同的锁控制数据同步，并发性高</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>PriorityBlockingQueue：</strong>基于优先级的无界队列，默认升序排列，可以自定义排序规则，根据优先级访问数据。但是有数据优先级一样的情况</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>DelayQueue：</strong>支持延时的队列，即从队列中取数据时等待一定的时间才能获取元素。可以用于缓存系统的设计，设计过期时间，也可以用来设置定时调度任务，即如果能够从队列中获取，说明到了任务的调度时间。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>SynchronousQueue</strong>：该队列是一个不存储元素的阻塞队列，每一个put操作都必须等待一个take操作的完成。吞吐量高于ArrayBlockingQueue和LinkedBlockingQueue。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>LinkedTransferQueue：</strong>基于链表的无界阻塞队列，多了transfer方法(如果消费者等待，直接将任务从生产者传递给消费者，无消费者等待，则将任务加到队尾直到被消费才返回)和tryTransfer（与transfer一致，只不过不管有没有消费者等待获取都会立即返回tryTransfer（e,time,unit）（与tryTransfer一致，只不过设置了超时时间）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>LinkedBlockingDeque：</strong>基于链表的双向阻塞队列，可以在两端同时进行读写操作，提高了队列的操作效率。</p>
<h2><strong>三，并发关键字</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;CountDownLatch：</strong>适用于一个主线程等待子线程完成任务之后执行（原理：设置一个程序计数器，计数器的值为子线程的个数，子线程并发执行，每个子线程执行完毕后，调用CountDown方法，将其计数器的值减去1，值为0时，唤醒主线程执行）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>CyclicBarrier：</strong>即当所有线程到达一个状态共同执行。await（）方法：确保所有线程到达Barrier状态才执行；await（time,unit）：设置一个超时时间，超过这个时间，执行达到Barrier状态的线程。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>Semaphore：</strong>因为其限制了多线程访问资源的线程个数，所以适用于多线程并发访问有限资源的情况。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>volatile：</strong>直接用来修饰变量，是一种比Synchronized更加轻量级的机制，用于多线程共享同一变量，可以同时对其进行读写操作。当多个线程共享变量的时候，读取变量将其从内存复制到cpu缓存中，然后线程对其操作进行修改，这样再多cpu的情况下，有可能出现线程修改原数据造成数据不一致的情况，使用volatile关键字直接将线程修改的变量存入内存，解决这个问题。</p>
<h2><strong>四，多线程共享数据</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>多线程共享数据主要通过共享内存实现，而共享内存的可见性，有序性，原子性已经由JVM和锁解决。理想情况下我们需要解决同步和互斥的问题（<span style="background-color: #ffff00;">怎么解决的有待考证！</span>）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>解决方法一：</strong>将数据抽象成一个类，将对数据的操作封装成类中的方法</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解决方法二：</strong>将Runnable对象作为一个内部类，将共享数据作为这个类的成员变量</p>
<h2><strong>五，ConcurrentHashmap并发</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ConcurrentHashmap使用了减小锁粒度，这里具体为分段锁的思想优化了锁，因为如果直接对hashmap进行加锁，锁太大，而且同一时刻只能有一个线程操作hashmap，并发性能较差</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;实现原理：</strong>即内部采用分段锁思想，将hashmap分为多个segment，每次读取数据的时候，对数据所在的segment进行加锁，这样只要保证每个segment线程安全，就可以保证整个hashmap线程安全</p>
<h2><strong>六，JAVA中的线程调度</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;抢占式调度：</strong>即线程对cpu资源进行抢占，这种策略下每个线程抢占到cpu资源的概率是相等的，这样就不会一个线程阻塞造成整个系统阻塞的情况。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>协同式调度：</strong>即一个线程使用完cpu资源之后通知cpu调度下一个任务，适用于多线程交替执行任务。因为如果一个线程阻塞可能会造成整个系统阻塞甚至崩溃</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>JAVA采用的是抢占式调度，但同时又尽可能的保证公平性（即为每个线程分配优先级不同的cpu时间片）</strong></p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>&nbsp;线程让出cpu的情况</strong>：第一，线程调用yield方法；第二，I/O阻塞，socket等待等；第三，等待同步锁；第四，正常执行完毕</p>
<h2>七，进程调度算法</h2>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>优先调度算法：</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;先来先服务调度算法：</strong>即遵循先来先被分配cpu资源运行的原则</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>短作业调度算法：</strong>即预估作业的时间长短，优先调度时间短的任务，可能会导致长时间大任务很长时间无法被调度 &nbsp;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>高优先权调度算法：即每个任务会预先被分配优先级</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;非抢占式优先调度算法：</strong>按照优先级的高低一次分配cpu资源运行</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>抢占式优先调度算法：</strong>按照优先级的高低分配cpu资源运行，但是如果任务再运行过程中有优先级更高的任务加入，则将其cpu资源临时回收分配给紧急任务</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>高响应比调度算法：</strong>动态调度，即作业时间短，则优先级高；等待时间长，则优先级高。前者遵循短作业调度算法，后者遵循先来先服务原则。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>时间片轮转调度算法：</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;时间片轮转法：</strong>按照任务再队列中的顺序进行调度</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>多级反馈队列调度算法：</strong>即再时间片轮转法的基础上维护了就绪队列，默认第一队列优先级高，先调度第一队列的任务，如果再分配的cpu时间片内未完成则将其加入第二队列队尾，以此类推直到其执行完毕。只有第1 -（n-1）队列为空，才会调度第n队列的任务，而且当前任务执行时，如果有优先级高的任务进来，会抢占其cpu资源。</p>
<h2><strong>八，CAS</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>即比较和交换，CAS（V,E,N）三个参数，只有当V=E的时候才会将V设置为N。如果V!=E，则说明数据已经被其它线程修改，不做任何操作</p>
<h2><strong>九，ABA问题</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>概述：</strong>即当1线程从V中取出A时，2线程也从中取出1，修改为B，再修改为A。而1线程仍然修改成功，实际上修改过程中V的实际值已经发生改变，只不过1没有发觉。解决这种问题，常采用乐观锁的版本号机制。</p>
<h2><strong>另外有AQS问题没怎么读懂，下次完善！</strong></h2>
<p>&nbsp;</p>
<h3><strong>思维导图：<a href="https://images-cdn.shimo.im/myFodjsaVAA3PVV7__thumbnail" target="_blank" rel="noopener">并发编程（下）</a></strong></h3>
<p>&nbsp;</p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</p>, blogGoods=0, blogRead=17, blogCollection=0, typeName=java面试篇, blogRemark=面试（三）------之并发编程篇（下）, blogComment=0, blogSource=null, createdTime=2020-04-13 16:54:26, blogMonth=null, updateTime=2020-04-20 11:54:02), BlogVo(blogId=1250068950784536576, blogTitle=面试（四）------之数据结构篇, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dHQGAYlUxAABJTVJPTfk990.jpg, blogContent=<h2><strong>一，栈及其JAVA实现</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：栈是一种先进后出的数据结构，对栈顶元素的添加，删除等操作较快，但是对于栈内的元素操作很慢</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA实现：实现需要定义栈的数据结构，写栈的入栈，出栈，获取栈顶元素的方法，如下：</strong></p>
<pre class="language-java"><code>/**
 * 基于数组实现栈
 * @author wcj
 * @Date 2020/4/14 20:59
 * @Version 1.0
 */
public class StackExample&lt;E&gt; {

    /**
     * 站的深度
     */
    private int maxSize;
    /**
     * 存储数据的数组
     */
    private Object[] data;
    /**
     * 栈顶指针
     */
    private int top = -1;

    /**
     * 默认栈的深度为10
     */
    public StackExample(){
        this(10);
    }

    /**
     * 用户自定义栈的深度
     * @param initialSize
     */
    public StackExample(int initialSize){
        if(initialSize&gt;=0){
            this.maxSize = initialSize;
            this.data = new  Object[initialSize];
            this.top = -1;
        }else{
            throw new RuntimeException("初始化栈的深度不能小于0!");
        }
    }

    /**
     * 入栈操作
     * @param e
     * @return
     */
    public Boolean push(E e){
        if(top == maxSize-1){
            throw new RuntimeException("栈已满,不能入栈");
        }else{
            data[++top] = e;
        }
        return true;
    }

    /**
     * 出栈操作
     * @return
     */
    public E pop(){
        if(top==-1){
            throw new RuntimeException("栈空，不能出栈！");
        }else{
            return (E) data[top--];
        }
    }

    /**
     * 获取栈顶元素
     * @return
     */
    public E peak(){
        if(top==-1){
            throw new RuntimeException("栈空异常！");
        }else{
            return (E) data[top];
        }
    }  </code></pre>
<h2><strong>二，队列极其JAVA实现</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：队列是一种先进先出的数据结构，对队头和队尾的操作简单，但是队内元素的操作复杂。</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA实现：定义队列的数据结构，队列的出队，入队，获取队头元素。代码如下：</strong></p>
<pre class="language-java"><code>/**
 * 基于数组实现队列
 * @author wcj
 * @Date 2020/4/14 21:14
 * @Version 1.0
 */
public class QueueExample&lt;E&gt; {

    /**
     * 队列长度
     */
    private int maxSize;
    /**
     * 存储数据数组
     */
    private Object[] data;
    /**
     * 队头指针
     */
    private int front;
    /**
     * 队尾指针
     */
    private int rear;

    /**
     * 默认构造器
     */
    public QueueExample(){
        this(10);
    }
    /**
     * 用户自定义队列长度构造器
     * @param initialSize
     */
    public QueueExample(int initialSize){
        if(initialSize&gt;=0){
            this.maxSize = initialSize;
            data = new Object[initialSize];
            front = rear = 0;
        }else{
            throw new RuntimeException("初始化队列长度不能小于0！");
        }
    }

    /**
     * 入队操作
     * @param e
     * @return
     */
    public Boolean add(E e){
        if(rear == maxSize){
            throw new RuntimeException("队列已满，无法入队!");
        }else{
            data[rear++] = e;
        }
        return true;
    }

    /**
     * 出队操作
     * @return
     */
    public E poll(){
        if(front==rear){
            throw new RuntimeException("队空，无元素可出队！");
        }else{
            E e = (E) data[front];
            data[front] = null;
            return e;
        }
    }

    /**
     * 获取队头元素
     * @return
     */
    public E peek(){
        if(front==rear){
            throw new RuntimeException("队空，无元素可出队!");
        }else{
            return (E) data[front];
        }
    }
}
</code></pre>
<h2><strong>三，链表及其JAVA实现</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：链表是由一系列数据节点组成的数据结构，节点可以动态生成。对于元素的增加，删除操作快，查询操作慢</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;这里主要讲述几种有代表性的链表：单向链表，双向链表，双向循环链表</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;单链表的JAVA实现：数据结构定义，添加节点，删除节点，查找节点，代码如下：</strong></p>
<pre class="language-java"><code>/**
 * 单向链表
 * @author wcj
 * @Date 2020/4/14 21:32
 * @Version 1.0
 */
public class SingleLinkedList {

    /**
     * 链表长度
     */
    private int length;
    /**
     * 链表头节点
     */
    private Node head;

    public SingleLinkedList(){
        this.length = 0;
        this.head = null;
    }
    /**
     * 内部类声明每个链表节点
     * 每个节点包括数据域和指向下一个节点的指针
     */
    private class Node{
        private Object data;
        private Node next;
        public Node(Object data){
            this.data = data;
        }
    }

    /**
     * 插入节点（这里使用头插法）
     * @param obj
     * @return
     */
    public Boolean add(Object obj){
        Node node = new Node(obj);
        if(length==0){
            head = node;
        }else{
            node.next= head;
            head = node;
        }
        length++;
        return true;
    }

    /**
     * 删除某个节点
     * 先对链表进行判空处理
     * 然后找到要删除的节点
     * 最后进行删除
     * @param obj
     * @return
     */
    public Boolean delete(Object obj){
        if(length==0){
            throw new RuntimeException("链表为空，无节点可删除!");
        }else{
            Node prev = head;
            Node current = head;
            //查找待删除元素
            while(!current.data.equals(obj)){
                if(current.next==null){
                    return false;
                }else{
                    prev = current;
                    current = current.next;
                }
            }
            prev.next = current.next;
            length--;
        }
        return true;
    }

    /**
     * 获取某个元素
     * @param obj
     * @return
     */
    public Object find(Object obj){
        if(length==0){
            throw new RuntimeException("链表为空");
        }else{
            Node current = head;
            while(current.data.equals(obj)){
                if(current.next==null){
                    return null;
                }else{
                    current = current.next;
                }
            }
            return current.data;
        }
    }
}
</code></pre>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>双向链表的JAVA实现：定义数据结构，头插法，尾插法，删除头部节点，删除尾部节点（这里只写尾插节点和删除尾部节点），代码如下：</strong></p>
<pre class="language-java"><code>import com.sun.org.apache.xpath.internal.operations.Bool;

/**
 * 单向循环链表
 * @author wcj
 * @Date 2020/4/14 22:05
 * @Version 1.0
 */
public class CircleLinkedList {

    /**
     * 链表长度
     */
    private int length;
    /**
     * 头节点
     */
    private Node head;
    /**
     * 尾节点
     */
    private Node tail;

    /**
     * 初始化构造方法
     */
    public CircleLinkedList(){
        this.length = 0;
        this.head=this.tail = null;
    }

    /**
     * 内部类实现的链表节点
     */
    private class Node{
        private Object data;
        private Node prev;
        private Node next;
        public Node(Object data){
            this.data = data;
        }
    }

    /**
     * 尾插节点
     * @param obj
     * @return
     */
    public Boolean addTail(Object obj){
        Node node = new Node(obj);
        if(length==0){
            head = tail= node;
            length++;
        }else{
            tail.next = node;
            node.prev = tail;
            tail = node;
            length++;
        }
        return true;
    }

    /**
     * 删除尾部节点
     * @return
     */
    public Boolean delTail(){
        Node temp = tail;
        if(length==0){
            throw new RuntimeException("链表为空!");
        }else{
            tail = tail.prev;
            tail.next = null;
            length--;
        }
        return true;
    }
}
</code></pre>
<h2><strong>四，散列表</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：有一张表M，一个映射函数f(key)，如果对于任意一个key，都有一个函数指与表中的内存地址相对应，则M就为散列表，f(key)就为散列函数。散列函数存储key-value键值对形式的数据，直接生成key与表中地址值的映射，因此查询非常迅速。同时散列表也经常被用于信息安全，用于加密操作。</strong></p>
<h2><strong>五，二叉排序树</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：二叉查找树又成为二叉搜索树，二叉查找树</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;特征：根节点左边的数据小于根节点，根节点右边的数据大于根节点，且其左右子树还是二叉排序树</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现：定义数据结构，插入操作，删除操作，查找操作，代码如下：</strong></p>
<pre class="language-java"><code>package interviewFour.example4;

/**
 * 二叉排序树
 * @author wcj
 * @Date 2020/4/14 17:17
 * @Version 1.0
 */
public class Node {

    private Node root = null;
    private int value;
    private Node left;
    private Node right;

    public Node(){}

    public Node(int value, Node left, Node right){
        this.value = value;
        this.left = left;
        this.right = right;
    }

    public Node(int value){
        this.left = null;
        this.right = null;
        this.value = value;
    }

    public int getValue() {
        return value;
    }

    public void setValue(int value) {
        this.value = value;
    }

    public Node getLeft() {
        return left;
    }

    public void setLeft(Node left) {
        this.left = left;
    }

    public Node getRight() {
        return right;
    }

    public void setRight(Node right) {
        this.right = right;
    }

    /**
     * 插入节点
     * @param value
     * @return
     */
    public Boolean insert(int value){
        //root代表根节点
        Node p = root;
        Node prev = null;
        //创建一个节点
        Node node = new Node(value);
        //寻找节点的插入位置
        while(p!=null){
            prev = p;
            if(value==p.getValue()){
                return false;
            }else if(value&lt;p.getValue()){
                p = p.getLeft();
            }else{
                p = p.getRight();
            }
        }
        if(root==null){
            root = node;
        }else if(value&lt;prev.getValue()){
            prev.setLeft(node);
        }else{
            prev.setRight(node);
        }
        return true;
    }

    /**
     * 删除某个节点
     * 分为三种情况，待删除节点为叶子节点，则直接删除
     * 待删除节点只有左子树或者右子树，则用左子树或者右子树替代当前节点位置
     * 待删除节点即有左子树又有右子树，则寻找左子树最大节点或者右子树最小节点顶替当前节点(这里使用左子树的最大节点)
     * @param value
     * @return
     */
    public void deleteBST(int value){
        deleteBST(root,value);
    }

    /**
     * 递归删除左子树，或者右子树，或者根节点
     * @param root
     * @param value
     * @return
     */
    public Boolean deleteBST(Node root,int value){
        if(root==null){
            return false;
        }else{
            if(root.getValue()==value){
                delete(root);
            }else if(value&lt;root.getValue()){
                deleteBST(root.getLeft(),value);
            }else{
                deleteBST(root.getRight(),value);
            }
        }
        return true;
    }

    /**
     * 分情况执行具体的删除逻辑
     * @param node
     * @return
     */
    public Boolean delete(Node node){
        if(node.getLeft()==null){
            node = node.getRight();
        }else if(node.getRight()==null){
            node = node.getLeft();
        }else{
            Node temp = node;
            Node s = node;
            //转向左子树，向右走到底
            s = s.getLeft();
            //寻找替换待删除节点的节点
            while(s!=null){
                temp = s;
                s = s.getRight();
            }
            node.setValue(temp.getValue());
            if(temp!=node){
                node.setLeft(temp.getLeft());
            }else{
                node.setRight(temp.getRight());
            }
        }
        return true;
    }

    /**
     * 在二叉查找树中找到对应节点
     * @param value
     * @return
     */
    public Boolean searchBTS(int value){
        Node node = root;
        if(node==null){
            throw new RuntimeException("无此节点！");
        }else{
            if(value==node.getValue()){
                return true;
            }else if(value&lt;node.getValue()){
                node = node.getLeft();
            }else{
                node = node.getRight();
            }
        }
        return false;
    }
}
</code></pre>
<h2><strong>六，红黑树</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 概述：红黑树是一种特化的自平衡二叉排序树，即其左右子树的深度差可以超过1。（详细的插入等操作过段时间会补充）</strong></p>
<h2><strong>七，图，位图</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;图的知识：定义，有向图/无向图，邻接矩阵/邻接表，BFS/DFS，位图的话没怎么搞清楚。</strong></p>
<h3><strong>思维导图：<a href="https://images-cdn.shimo.im/YClQaLxx9e8uEb9U__thumbnail" target="_blank" rel="noopener">数据结构</a></strong></h3>
<h2>&nbsp;</h2>, blogGoods=0, blogRead=7, blogCollection=0, typeName=java面试篇, blogRemark=面试（四）------之数据结构篇, blogComment=0, blogSource=null, createdTime=2020-04-14 14:30:37, blogMonth=null, updateTime=2020-04-23 22:14:43)], params={}, sortColumn=blog_collection, sortMethod=ASC)]
2020-04-26 23:27:31.911 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 1196
2020-04-26 23:27:31.913 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，数据库设计--表的命名规范等</strong></p>\n<p>（1），统一采用bl_开头对表进行命名</p>\n<p>（2），对于数据比较重要的表统一添加四个字段，分别为：created_time(创建时间),update_time(修改时间),version(版本号),deleted(删除字段)</p>\n<p>（3），数据库表的字段尽量都设置为NOT_NULL</p>\n<p>（4），数据库中表varchar类型字段需要设置长度的尽量设置为2<sup>n</sup>-1</p>\n<p>（5），因为博客系统分为前台展示界面和后台管理，所以对于有些表，例如bl_type（博客类型表），bl_music（音乐表）等设置了enable（启用字段）</p>\n<p><strong>二，上述第二条--四个字段的解释</strong></p>\n<p>（1），为什么要设置created_time和update_time字段：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;其一，从数据库的通用性上来说，设计这两个字段是必要的，但也需要根据业务的需要来合理添加这两个字段，因为无用的字段会浪费空间，性能，影响系统的运行。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 其二，大部分的应用都有需要根据时间进行排序的功能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 其三，当系统发生异常的时候，我们可以通过这两个字段对异常进行排查和定位。</p>\n<p>（2），为什么要设置version字段：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 1，version字段含义：字段的含义与其字面意思一样，代表版本，在这里作为乐观锁进行使用，从而保证不会出现脏数据的情况。下面解释一下什么叫乐观锁，以及乐观锁和悲观锁</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 2，乐观锁：总是假定最好的情况，即每次用户调用接口从数据库中取出数据到修改数据前的过程中，不会有其它用户对当前数据进行修改，这样在当前用户修改数据的时候，利用版本机制即判断取出的version字段和当前数据库该条数据的version字段是否相等来判断该条数据是否已经被修改，如果未修改，则予以修改（且version字段递增），如果已经修改，则提示用户更新失败。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 悲观锁：总是假定最坏的情况，即每次用户调用接口从数据库取出数据的时候，都认为该条数据会被修改，因此每次取出数据都对数据进行加锁处理，只允许当前用户进行修改，其它用户阻塞，直到当前用户修改完毕。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3，为什么使用乐观锁而不使用悲观锁：因为悲观锁比较浪费性能</p>\n<p>（3），为什么设置deleted字段：deleted字段在这里作为一个逻辑删除字段（0否1是），何为逻辑删除，即执行删除操作操作的时候，不会真正的删除数据库中的数据，而是将deleted字段设置为1即可。&nbsp;这样如果用户出现误删的操作，可以通过数据库修改该字段进行数据的恢复。</p>\n<p><strong>三，上述第三条--数据库表字段尽量设置为NOT_NULL</strong></p>\n<p>（1），数据库表字段尽量设置为NOT_NULL：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 1，有些人可能认为设置为NULL相比于NOT_NULL不是更节省空间吗？但是实际上不是这样的，设计为NULL相比于NOT_NULL要多占用一个字节的空间</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 2，设计为NOT_NULL，这样在做查询的时候能够更好的避免空指针异常，且发生该类错误的时候能够更好的进行排查</p>\n<p><strong>四，上述第四条--表varchar类型字段长度尽量设置为2<sup>n</sup>-1</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>因为计算机只识别二进制，且有一定的范围，例如2<sup>8</sup>，在计算机中的范围为-128~127,因此对于varchar字段长度来说，如果设置为255，则正好是一个字节，而如果设置为256，则占用两个字节，这样会浪费计算机的内存空间，因此数据库varchar类型字段的长度最好设置为2<sup>n</sup>-1</p>\n<p><strong>五，上述第五条--对于设置enable字段的解释</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>enable字段，字面意思启用，在这里表明是否启用（0否1是），因为系统分为前台博客页面和后台管理，对于这两个不同的前端项目，后台可以通过启用字段来控制内容在前台博客页面的展示与否，与deleted字段不同的是，如果执行删除操作，那么我们只能通过手动修改数据库中的字段进行数据的恢复，且如果执行删除操作，则该数据在前台博客页面和后台管理页面都无法看见。但是如果将数据弃用（即修改enable字段值为1），则表明该数据被弃用，在前台博客页面无法显示，但是在后台管理页面可以看见，且无需通过手动修改数据库来恢复数据，可以在后台管理页面操作启用数据。</p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1247745014683947008","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dDViAcnjvAACb6PL1tzA485.jpg","blogRead":21,"blogRemark":"博客开发总结（一）-----之数据库设计篇","blogTitle":"博客开发总结（一）-----之数据库设计篇","createdTime":"2020-04-08 04:36:07","typeName":"博客开发和维护总结","updateTime":"2020-04-20 10:47:54"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，前后端分离开发优势</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，</strong>项目开发过程中，前后端完全解耦，前端只需要负责页面的实现，只需要通过接口拿数据。后端不需要管页面的跳转，只需要负责接口的编写</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，</strong>前后端人员有更多的精力去负责自己的工作，前端人员可以将更多的精力投放在页面的编写，页面的美化，页面特效的制作和用户体验上；而后端人员可以将更多的精力放在接口代码的优化，sql优化，jvm调优上面</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，</strong>前后端分离的项目部署的时候，前端项目往往都是部署在nginx服务器上，而前后端不分离的项目往往都是部署再一台服务器上。因此前后端分离项目大大降低了服务器的负担</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>4，</strong>前后端不分离的项目使用模板引擎例如freemaker，thymeleaf等，前后端人员交流起来较为困难。且前端项目使用原生的DOM操作，极大的增加了前端工作人员的工作量。而前后端分离项目前端通常都是用各种ui框架，框架采用MVVM模式，极大的减轻了前端工作人员的工作量</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，</strong>前后端分离开发，前端可以通过easy-mock来伪造接口数据进行测试，后端人员可以通过postman进行接口测试，开发效率大大提升。</p>","blogGoods":0,"blogId":"1247867141693128704","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dG6CAI6ipAACiM2P5LtI65.jpeg","blogRead":7,"blogRemark":"前后端分离开发的优势所在","blogTitle":"闲谈前后端分离开发","createdTime":"2020-04-08 12:41:25","typeName":"随笔","updateTime":"2020-04-20 11:48:53"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，css之弹性布局</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，</strong>何为弹性布局？</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 弹性布局是css的一种新的布局方式，所谓&ldquo;弹性布局&rdquo;，即页面随着不同设备的屏幕大小拉伸会自适应页面的大小。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，</strong>弹性布局的两种主要元素，container（弹性容器），item（弹性子元素），一个弹性容器中可以放入多个弹性子元素，元素之间是可以进行嵌套的，弹性子元素也可以设置为弹性容器，里面再嵌套弹性子元素。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，</strong>弹性布局的基本属性</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （1）display：flex，声明容器为弹性布局</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （2）flex-direction：声明弹性容器内部元素的排列方式，默认为row。row（横向布局），row-reverse（横向布局，但是元素反方向码），column（纵向布局），column-reverse（纵向布局，但是元素反着码）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （3）flex-wrap：声明弹性盒子中的元素是否可以换行，默认为nowrap（不换行），wrap（换行），wrap-reverse（换行，但是反着码）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （4）align-items：设置容器中元素在纵轴方向上的对齐方式，默认为stretch（即如果不设置子元素高度，则默认拉伸至于容器同宽度），flex-start（子元素位于容器的开始位置），flex-end（子元素位于容器的结尾处），center（元素依纵轴方向居中），baseline（元素位于容器基线，不过没怎么用过，所以不是很清楚）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （5）justify-content（设置元素在主轴上的对齐方式），默认为flex-start（元素从容器主轴开始位置码），flex-end（元素从容器主轴结尾处码），center（元素位于主轴居中处），space-between（元素布局在容器的两端），space-around（元素布局在容器两端，但是元素前后都留有空白）因为项目中大多数只使用了对于容器的操作，对于容器中元素的操作很少，所以这里只介绍这点。谢谢阅读！</p>","blogGoods":0,"blogId":"1248135765829918720","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dGnuAWkLLAAAaRXQXNms575.jpg","blogRead":3,"blogRemark":"CSS----之flex弹性布局","blogTitle":"CSS----之flex弹性布局","createdTime":"2020-04-09 06:28:51","typeName":"CSS","updateTime":"2020-04-20 11:43:57"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2 style=\"text-align: left;\"><strong>一，JVM运行机制</strong></h2>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;jvm即java虚拟机，一共由四个部分组成，分别是类加载器子系统，运行时数据区（程序计数器，本地方法区，jvm栈，方法区，jvm堆），执行引擎（即时编译器，垃圾收集器），本地接口库。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;一个java源程序的运行先是经过编译器将其编译成字节码文件（class文件），然后通过类加载器子系统将其加载进入jvm&mdash;&mdash;&gt;程序运行过程中，运行时数据区存放程序运行过程产生的数据&mdash;&mdash;&gt;执行引擎中的垃圾收集器收集程序运行过程中创建的不再使用的对象，即时编译器将程序的字节码文件编译成机器码&mdash;&mdash;&gt;然后本地接口库利用机器码调用本地方法库中的方法，和操作系统实现交互。</p>\n<h2><strong>二，多线程</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;</strong>在多核操作系统中，jvm支持一个进程中同时并发执行多个线程，且这些线程和本地操作系统的线程相对应。当jvm中的对象初始化，内存空间分配等一系列准备工作完成之后，会调用操作系统中的接口创建一个原生线程，原生线程初始化完毕后，会调用java线程的run（）方法执行该线程，线程结束之后，jvm会释放原生线程和java线程资源。</p>\n<h2><strong>三，JVM的内存区域</strong></h2>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM的内存区域主要分为线程私有区域（程序计数器，本地方法区，JVM栈），线程共享区（方法区，JVM堆）和直接内存。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;程序计数器：线程私有区域，无内存溢出，用来记录程序运行过程中的字节码指令地址，如果是Native方法，则程序计数器为空。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM栈：线程私有区域，用来描述java程序的运行过程，java程序运行每次运行的时候，都会创建一个栈帧，方法的执行和返回对应着栈帧的入栈和出栈操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;本地方法区：线程私有区域，和JVM栈的功能一样，只不过是用来记录Native方法的运行过程。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM堆：线程共享区，主要用来存放程序运行过程中产生的数据，同时也是垃圾收集器进行垃圾回收的主要区域。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;方法区：也被称为永久代，用来存放常量，静态变量，类信息等等。</p>\n<h2><strong>四，JVM的运行时内存</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>JVM的运行时内存又被称为JVM堆，因为JVM的GC算法使用的是分代收集算法，所以JVM堆按照GC标准可以分为三个区域分别为：新生代，老年代，永久代。其中新生代占1/3，老年代占2/3，永久代很少，</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;新生代：存放短生命周期，小对象的区域。新生代又分为Eden区，ServivorTo区，ServivorFrom区，区域的GC算法采用复制算法。Eden区是用来存放新创建的对象（大对象除外），ServivorTo区是用来保存MinorGC幸存下来的对象，ServivorFrom区是用来将上一次MinorGC幸存下来的对象作为下一次MinorGC的扫描对象。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;老年代：存放长生命周期的大对象，区域的GC算法采用标记整理算法</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;永久代：主要用来存放class和meta数据信息的。程序运行过程中不会进行永久代的垃圾回收，这也就导致永久代区域的数据会越来越多，最终造成内存溢出。java8之后永久代已经被元数据区取代，元数据区和永久代的功能都是一样的，但是最大的不同在于永久代区域依赖于虚拟机的内存大小，因而可以存储的class，meta信息非常有限。但是元数据区依赖的是本地操作系统，因而不会受到虚拟机内存的限制。</p>\n<h2><strong>五，垃圾回收与算法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;(1)垃圾回收：</strong>Jvm的垃圾回收判定依赖于两种方法，引用计数法和可达性分析法。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;引用计数法：即如果想要在程序中使用对象，就必须赋予一个引用，这样在对象赋予引用的时候将其引用计数加1，删除一个引用时，将对象引用计数减1，如果引用计数为0，就说明该对象已经不使用，作为垃圾。但是引用计数法存在一个缺陷，即循环引用的问题，如果两个对象相互引用，则这两个对象的引用计数永远都不会为0，造成对象无法被回收。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;可达性分析法：即先创建一些根节点对象ROOTS，然后通过这些根节点对象向下搜索，如果一个对象到任意一个ROOTS之间都没有可达路径，在经过两次标记（下文解释为什么进行两次标记），还是没有可达路径，则说明该对象可回收。</p>\n<p>&nbsp;&nbsp; &nbsp;<strong>（2）GC算法：</strong>常见的GC算法有四种，分别为标记清除算法，复制算法，标记整理算法，分代收集算法</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;标记清除算法：即在进行垃圾回收前，对所有对象进行一次标记，标记可回收的对象，然后进行清理即可。但是标记清除算法在清除回收对象之后，并不会对堆内存进行整理，这样的话如果内存中的对象大部分为小对象，清理之后就会导致没有大片连续的内存空间，即造成了内存碎片化，这样大对象存储的时候就无法找到相应的完整连续内存。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;复制算法：即将内存分为两块同等大小的区域，区域1和区域2，创建的新对象都存储在区域1中，当区域1中的内存占满之后，会对内存中的所有对象进行一次标记，标记存活的对象，将存活的对象复制到区域2，这时区域1中的对象都是可回收对象，回收区域1中的所有对象即可。但是复制算法也存在着一定的缺陷，即每次都只能使用一半的内存空间，造成了大量的内存浪费。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;标记整理算法：即结合标记清除算法和复制算法的优点，先对所有的对象进行标记，标记存活的对象，将存活的对象复制到内存的另一端，然后清除当前端的对象即可。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;分代收集算法：前面的三种算法，都无法按照对象的类型进行收集，分代收集算法正是解决这个问题，按照对象的不同类型采用不同的GC算法。以JVM的分代收集算法为例，JVM的堆内存分为新生代，老年代，永久代。新生代又分为Eden区，ServivorTo区和ServivorFrom区。新生代因为其存储生命周期短的小对象，GC比较频繁，所以采用复制算法。程序运行过程中创建的对象都存储在Eden区（大对象除外，大对象直接复制到老年代区域）。当Eden区的内存不够的时候进行MinorGC，然后将Eden区和ServivorFrom区的存活对象都复制到ServivorTo区，然后将ServivorTo区和ServivorFrom区进行交换，再次进行MinorGC。老年代因为存放的都是生命周期长的大对象，因而进行GC的不会太频繁，且清除的对象并不会太多，因而采用标记整理算法。老年代每次进行MajorGC之前都会先进行一次MinorGC，当MinorGC之后新生代的内存仍然不够的时候，将对象复制到老年代进行MajorGC。永久代区域主要回收常量，无用class等。</p>\n<h2><strong>六，JAVA中的四种引用类型</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;强引用类型<strong>：</strong>即把对象赋给一个引用变量，强引用的对象一定为可达状态，所以不会进行垃圾回收。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;软引用类型：通过SoftReference类实现，当内存不够的时候对其进行GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;弱引用类型：只有弱引用类型的对象，一定会被GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;虚引用类型：虚引用对象主要是用来跟踪对象的GC状态</p>\n<h2><strong>七，分代收集算法和分区收集算法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>分代收集算法：新生代因其存放大量短生命周期小对象，且GC频繁，所以采用复制算法。老年代因其存放长生命周期大对象，且GC不平凡，所以采用标记整理算法。永久代，回收常量，类信息等。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;分区收集算法：即将堆内存区域分为大小不同的区，可以按照不同的区进行快速垃圾回收，减少系统的停顿时间。然后再以并行的方式逐步完成整个GC。</p>\n<h2><strong>八，垃圾收集器</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>新生代区域：Serial垃圾收集器，单线程复制算法，因为单线程无需进行线程之间的交互和切换，所以效率非常高，是JVM默认的client模式下的默认垃圾回收策略，工作期间需要暂停其它所有的线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ParNew垃圾收集器，多线程复制算法，跟单线程Serial一样，是JVM默认的server模式下的垃圾回收策略，工作期间需要暂停所有其它线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Parallel Scavenge垃圾收集器：多线程复制算法，不同的是优先考虑系统吞吐量，可以利用更高效的利用CPU完成GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;老年代区域：Serial Old垃圾收集器，单线程标记整理算法，同新生代的Serial功能一样，只是采取的算法不同而已。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Parallel Old垃圾收集器：多线程标记整理算法，优先考虑了系统的吞吐量，其次考虑停顿时间。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CMS,多线程标记清除算法，优先考虑系统GC时的停顿时间，且过程分为四步（<span style=\"background-color: #ffff00;\">解释上文的可达性分析中的两次标记</span>，第一步：标记GC ROOTS可达对象，暂停其它工作线程；第二步：和用户线程一起工作，跟踪GC ROOTS；第三步，因为第二步用户进程没有暂停，所以有些对象状态</p>\n<p>可能发生了改变，重新进行标记；第四步，清除不可达对象）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; G1垃圾收集器，多线程标记整理算法，将内存分区，与CMS相比，一方面不会产生内存碎片，一方面，可以精确的控制系统停顿时间。</p>\n<h2><strong>九，JAVA的网络编程模型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;</strong>阻塞I/O模型：即用户线程发出I/O请求之后，内核会检查数据是否准备就绪，这时候用户线程始终处于阻塞状态等待数据准备就绪。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;非阻塞I/O模型：即用户线程不断的给内核发出I/O请求，内核接受到I/O请求之后会返回一个状态，如果数据准备就绪，就将数据复制进入用户线程，如果数据没有准备好，返回一个false，用户线程无需阻塞，可以去处理其它事情，而当数据准备好了且刚好用户线程发起I/O请求进行操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;多路复用I/O模型：多路复用I/O模型通过一个Selector线程轮询Socket的状态，如果Socket有读写事件，则进行I/O操作。此模型的优势在于可以更好的处理连接数众多但消息体不大的情况下。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;信号驱动I/O模型：即用户线程发出一个I/O请求，系统会为该请求创建一个信号函数，用户请求可继续执行其它业务逻辑，当内核数据准备就绪之后会返回给用户线程一个信号，用户线程接收到之后进行I/O操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;异步I/O模型：用户线程给内核发起一个asynchronous read操作，内核接收到之后，返回其请求是否成功，然后等待数据准备成功之后复制到用户线程。整个过程中请求的发起和数据读取都在内核中进行，最终发送一个信号告知用户线程I/O操作已经完成，用户直接使用数据就行。（说实话个人感</p>\n<p>觉和信号驱动很像）</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;java NIO：没怎么读懂（<span style=\"background-color: #993300;\">记得补充！</span>）</p>\n<h2><strong>十，JVM的类加载机制</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>JVM类加载分为五个阶段：加载，验证，准备，解析，初始化</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;加载：即将class文件加载到JVM中，且创建class对象，封装其数据结构。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;验证：对class文件进行验证，确保符合JVM的标准，保证JVM的安全。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;准备：即方法区中给类变量分配空间和赋初值。static修改的会在初始化阶段赋值，final修饰的会在准备阶段赋值。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;解析：即将常量池中的引用替换为直接引用</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;初始化：执行类构造器进行初始化。（因为内部流程不是很清楚，所以对于其几种不进行初始化的情况不做说明）</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;类加载器：JVM提供了三种类加载器，启动类加载器（/lib），扩展类加载器(/lib/ext)，应用程序类加载器(classpath)。还可以再应用程序类加载器自定义类加载器。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;双亲委派机制：即当一个类接收到类加载请求的时候，不会自己进行加载，而是将其加载请求委派给其父类加载器，这样一路委派，最终加载请求都会委派到启动类加载器.启动类加载器接收到加载请求之后会去lib目录下寻找相关的class文件，若找不到，则将其加载请求再委培给子类加载器，一路委派，直到能够加载。</p>\n<h3><strong>最后，送给大家一张博主画的JVM的思维导图，以后读《深入JVM虚拟机》的时候可能会出一个JVM专题：<a href=\"https://uploader.shimo.im/f/X0MX3hLaHrevltxW.png!thumbnail\" target=\"_blank\" rel=\"noopener\">JVM思维导图</a></strong></h3>\n<p>&nbsp;</p>\n<h2>水平有限，若发现有误，还望指出！</h2>","blogGoods":0,"blogId":"1248224512563068928","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHLeALxSjAABJTVJPTfk677.jpg","blogRead":17,"blogRemark":"面试（一）------之JVM篇","blogTitle":"面试（一）------之JVM篇","createdTime":"2020-04-09 12:21:30","typeName":"java面试篇","updateTime":"2020-04-20 11:53:29"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，Linux的发展历史</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; </strong>1965年之前，电脑并不像现在这么普遍，除了军事机构和研究即构，一般人基本接触不到电脑，而且那时候的一台大型主机最多也就只能支持30台终端。为了解决数量问题，1965年之后，由贝尔实验室，麻省理工学院以及通用电气一起放弃了Multics项目，准备让大型主机能够支持300台终端，但是在开发过程中，进度缓慢，最终由于资金的短缺，贝尔实验室推出了研究。1969年，从这个项目中退出的Ken Thompson在家无聊，为了让电脑能够运行&ldquo;星际旅行&rdquo;游戏，因而趁着妻子回家探亲的一个月，独自写出了Unix操作系统的原型（！！！！牛批）。1970年，这个人以BCPL语言为基础，又写出了很接近硬件的B语言，并且用B语言写出了第一个Unix操作系统。但是由于B语言的跨平台性比较差，为了解决这个问题。Dennis Ritchie和Ken Thompson决定以B语言为基础开发一种新的语言，1972年，Dennis Ritchie最终设计出了一种新语言，他以BCPL的第二个字母命名，也就是我们后来熟知的C语言。随后两人便迫不及待的用C语言重现Unix操作系统。Unix系统起初开源，但是在Unix7之后，由于政策的变化，代码闭源化，因而大学中不能使用Unix的源代码进行教学。Andrew S. Tanenbaum教授为了能够让学生更好的理解代码细节，在完全不使用任何源代码的情况下开发除了Minix---小型Unix。但是因为其只用于教学，功能并不强大，因而Torvalds以此为基础，开发除了Linux，但是起初Linux并不支持Unix，最终经过全世界网友的帮助，最终让其能够兼容各种硬件。</p>\n<p><strong>二，文件和目录</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; 1，windows和linux的区别：</strong>我们熟知的windows系统，它的文件系统是分盘符的，盘符下的文件构成一个树形结构，但是Linux文件系统没有盘符，所有文件目录都在根目录/之下</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;<strong>2，Linux需要记住的目录：</strong>/bin（存放系统命令的目录），/sbin（只有超级管理员能访问的命令文件目录），/root（存放和root用户相关文件的目录），/etc（存放系统配置文件的目录），/usr（存放系统共享资源的目录），/opt（存放安装的第三方软件的目录，通常在/usr/local下）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;<strong>3，文件权限：</strong>Linux中的文件权限有读（r，可用于数字4表示），写操作（w，可用数字2表示），执行权限（x，可用数字1表示）</p>\n<p><strong>三，常用命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，ls：</strong>列出目录中的所有目录和文件名&nbsp; -a（列出所有，包括隐藏文件和目录），-l（以列表形式列出所有），-h（人性化列出，需要配合-l使用，即文件大小转换为我们熟知的kb，mb等），-d（显示当前目录属性），命令可以联合使用，例如-al，-lh等等。&nbsp;&nbsp;&nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，cd：</strong>用于切换目录，需知（.和..是相对路径，.表示当前目录，..表示上级目录；/表示绝对路径），cd ~（切换到root目录），cd - （切换到前一次切换的目录）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，clear：</strong>清屏</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，pwd：</strong>显示当前所在目录</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，mkdir：</strong>创建目录，-p（如果目录存在则不创建，如果不存在则创建目录再创建自目录），可以一次性创建多级目录，例如：mkdir&nbsp; -p test/test1</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，touch：</strong>创建空文件</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>7，cp：</strong>复制，-r（递归复制目录下的文件目录信息），-i(提示是否覆盖)，-v（显示复制进度）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>8，mv：</strong>移动文件，不过经常用来给文件进行重命名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>9，rm：</strong>删除目录或者文件，-r（递归删除），-f（强制删除），-v（显示删除进度）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>10，cat：</strong>查看文件内部信息</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>11，ln：</strong>文件创建链接，ln 源文件 目标链接文件（创建硬链接，硬链接和源文件大小相同，修改同步，但是删除不同步，使用较少），ln -s（创建软连接，相当于我们平时创建快捷方式，使用较多）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>12，which：</strong>搜索命令所在位置，例如：which&nbsp; &nbsp;ls</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>13，find：</strong>搜索文件所在位置&nbsp; 例如：find&nbsp; &nbsp;test.conf</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>14，grep：</strong>文件内容搜索，例如：grep &ldquo;想要搜索的内容&rdquo;&nbsp; 源文件</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>15，tar：</strong>归档命令，-c（打包成.tar文件），-z（打包的同时压缩），-v（打包的同时显示进度），-f（放在最后，后面跟.tar.gz），-x(解压)，常用：tar -zcvf&nbsp; <em><strong>.tar.gz&nbsp; &nbsp; ;&nbsp; &nbsp; tar -zxvf</strong> tar.gz</em> -C&nbsp; 指定解压目录&nbsp;&nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;还有more，head，tail等命令，不过这些不常用。</p>\n<p><strong>四，用户权限命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，whoami：</strong>查看当前账户的用户名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，who：</strong>查看当前登录用户</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，exit：</strong>退出登录</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，adduser/useradd：</strong>添加用户，-d（指定用户主目录），-g（指定用户用户组），-m（自动建立目录），默认情况下用户主目录和用户组名都和用户名一样</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，passwd：</strong>只有root用户才能使用，用于修改用户密码</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，userdel：</strong>删除用户，默认不删除用户的主目录，-r（删除用户主目录）</p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;7，su：</strong>切换账户</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>8，groupadd/groupdel：</strong>添加用户组和删除用户组</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>9，groups：</strong>查看用户所在用户组，例如：groups&nbsp; 用户名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>10，usermod：</strong>修改用户所在用户组，例如：usermod&nbsp; 用户组名 用户名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>11，chmod：</strong>修改文件权限，例如：chmod&nbsp; 777&nbsp; test</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>12，chown：</strong>修改文件所有者，例如：chown&nbsp; &nbsp;用户&nbsp; 文件名</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>13，chgrp：</strong>修改文件所在组，例如：chgrp&nbsp; 组名&nbsp; 文件名</p>\n<p><strong>五，系统命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，cal：</strong>查看日历</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，date：</strong>查看时间，可以设置格式，例如：date '+<span class=\"ql-token hljs-built_in\">%Y</span>-<span class=\"ql-token hljs-built_in\">%m</span>-<span class=\"ql-token hljs-built_in\">%d</span> <span class=\"ql-token hljs-built_in\">%H</span>:<span class=\"ql-token hljs-built_in\">%M</span>:<span class=\"ql-token hljs-built_in\">%S</span>'</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，ps：</strong>查看线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，kill：</strong>杀死线程，-9（强制杀死）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，查看网卡信息：</strong>centos6：ifconfig ；centos7：ip addr</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，ping：</strong>查看网址或者链接的连通性</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>7，防火墙：</strong>centos6：service&nbsp; iptables&nbsp; status（查看防火墙状态），service&nbsp; &nbsp;iptables&nbsp; &nbsp;start(开启),service&nbsp; iptables&nbsp; stop(关闭);centos7:firewall-cmd&nbsp; --state（查看防火墙状态），systemctl&nbsp; start&nbsp; firewalld.service(启动)，systemctl&nbsp; &nbsp;stop&nbsp; firewalld.service（关闭）</p>\n<p><strong>六，网络命令</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，wget：</strong>下载，例如：wget&nbsp; &nbsp;链接地址</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，yum：</strong>下载安装</p>\n<p><strong>七，vim（这里只说几个常用的命令）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;</strong>vim有三种模式：命令模式，插入模式，编辑模式&nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;vim&nbsp; 文件名：进入文件，且处于命令模式；iao任意一键进入插入模式（i表示在贯标之前插入，a光标之后插入，o在下一行插入），：进入编辑模式</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;命令：set:nu显示行号，set:nonu不显示行号；/strinng，向后搜索字符串，？string向后搜索字符串；：w保存，：wq保存并退出，：q不保存退出</p>","blogGoods":0,"blogId":"1248500061625745408","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dDA6AfCOJAAAyfL52jxY706.jpg","blogRead":2,"blogRemark":"Linux基本命令总结","blogTitle":"Linux基本命令","createdTime":"2020-04-10 06:36:25","typeName":"Linux","updateTime":"2020-04-20 10:42:25"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，集合</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，List：</strong>list是java中一种有序的集合，下有三个实现类，分别为ArrayList，Vector，LinkedList</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ArrayList：基于数组实现，增删慢，查询快，线程不安全。因为其基于数组实现，所以查询的时候可以直接根据数组的索引下标进行快速查询，但是进行增删操作的时候，需要将待增删元素后的元素全部移动，因而效率较低。且ArrayList创建时不需要分配初始大小，其空间不够的时候，会自动创建一个更大的list，然后复制数据。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Vector：基于数组实现，和ArrayList一样增删慢，查询快。但是线程安全，因为同一时间只支持一个线程对Vector进行写操作，然而因为要进行频繁的加锁和释放锁的操作，所以效率要低于ArrayList。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; LinkedList：基于双向链表实现，增删快，查询慢。因为基于链表实现，增删元素的时候，只需要改变元素的指针即可，改动较小，效率较高。然而进行查询操作的时候，需要从链表头部进行遍历，因而效率较低。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，Queue：</strong>队列，满足先进先出，种类较多。（不作详细解释）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，set：</strong>具有独一无二的特性，常用来存储无序且不重复的元素，对象相等的本质是hashcode的值相同，而如果想要比较两个对象是否相等，需要重写对象的hashcode方法和equals方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;hashset：基于hashTable实现，无序。存放的是对象的散列值，即通过hashcode计算得到的值</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;treeset：基于二叉树实现，即其中的对象按照一定的排序方式进行排列（升序，降序），每次添加对象的时候，都会进行排序，将其插入指定位置。基本的数据类型例如Integer，String等可以使用treeset默认的排序方法，而自定义数据类型需要实现compareable接口，实现compareTo方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;LinkHashSet：继承自hashset，只不过使用双向链表记录数据的顺序。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，map：</strong>一种键值对形式的集合</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;hashmap：基于数组+链表实现，增删改查操作快，但是每次遍历hashmap元素的顺序无法保证且线程不安全。如果想要其线程安全，可以使用synchronizedMap和ConcurrentHashmap，hashmap的内部是数组，数组中的每一个元素又是一个单向链表，链表中的每个元素嵌套一个Entry实例，其中包括Key，Value，Hash值，指向下一个节点的next。每次查询的时候，可以根据元素的hash值很快定位所在数组，但是定位之后需要遍历链表查找元素，因而时间复杂度为O（n），但是Java8之后对其进行了优化，将其改为了数组+链表或红黑树的结构，即当链表中的元素大于8个的时候，链表会转换为红黑树（红黑树是一种特化的二叉平衡树，因为其左右子树的深度差可以大于1），这样查询的时间复杂度就缩短到了O（logN）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ConcurrentHashmap：采用分段锁的思想进行并发操作，因而使线程安全的。由多个Segment组成，只要保证每个Segment线程安全就可以保证全局线程安全。ConcurrentHashmap的默认Segment即并发度为16，可以在初始化的时候修改，但是初始化之后不能再修改。每个Segment内部的实现和hashmap一样&middot;。Java8之后也和hashmap进行了一样的优化。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;HashTable：线程安全，即同一时刻只能有一个线程对其进行操作，并发度不如ConcurrentHashmap。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;TreeMap：基于二叉树数据结构实现，实现了SortedMap，默认按照键值的升序进行排列。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;LinkedHashMap：Hashmap的子类，只不过使用链表保存元素的插入顺序。使用迭代器遍历的时候按照插入顺序遍历。</p>\n<h2><strong>二，异常分类及处理</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;1，异常分类：</strong>Throwable是所有异常类的父类，其下有error和Exception，Error下有AwtError，ThreadDeath；Exception下有RuntimeException和CheckedException。</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</strong>对于Error类异常通常是由内部错误和资源耗尽造成的，无法在程序运行期间对其进行捕获和处理，对于这类错误我们只能记录错误的原因和终止程序。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; Exception中的RuntimeException异常（运行时异常）：这类异常是我们程序中异常处理的核心，可以在程序中进行捕获并处理。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Exception中的CheckedException异常（检查异常）：这类异常时程序中需要强制捕获的异常，通常有IO异常，SQL异常等等。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，异常处理：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>异常处理有两种方式：抛出异常和捕获异常</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;抛出异常有三种方法：throws，throw，系统自动抛出。其中throws是作用在方法上，后面跟的是可能产生的异常类。throw是作用在方法内部，后面跟的是具体的异常对象。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 捕获异常：即使用try{}catch语句进行捕获</p>\n<h2><strong>三，反射机制</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，什么叫做反射机制？</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>即在程序运行的过程中，可以获取类的属性和方法，并且可以调用任意一个类的方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，反射机制的使用</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 首先，获取类的class对象，有三种方式，className.getClass()，类对象.class，Class.forName(\"类路径\")，其中最后一种最为安全，性能最好。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 然后利用反射的API可以实现对类中信息的操作，例如getDeclareFields（），getDeclareMethods（），getConstroctors（）等等。反射创建类的对像有两种方法，一，class.newInstance()初始化一个类实例；二，先获取其构造器，然后利用构造器初始化一个实例。利用反射调用类的方法：先获取方法，然后调用method.invoke()执行方法。</p>\n<h2><strong>四，注解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，四种元注解：</strong>@Target（指定注解的使用范围），@Retention（定义注解的保留级别，有三级，SOURCE源程序中保存，CLASS文件中保存，RUNTIME运行时保存），@Documented（可以工具文档化），@Inherited（<span style=\"background-color: #ffff00;\">这个没怎么看懂</span>）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，注解使用示例：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>第一步，定义注解接口</p>\n<pre class=\"language-java\"><code>@Target(ElementType.FIELD)  \n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface FruitProvider {\n\n    //id\n    public int id() default  -1;\n\n    //供应商名称\n    public String name() default \"\";\n\n    //供应商地址\n    public String address() default \"\";\n\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 第二步，使用注解</p>\n<pre class=\"language-java\"><code>public class Apple {\n\n    @FruitProvider(id = 1,name = \"红富士苹果\",address = \"陕西\")\n    private String appleProvider;\n\n    public String getAppleProvider() {\n        return appleProvider;\n    }\n\n    public void setAppleProvider(String appleProvider) {\n        this.appleProvider = appleProvider;\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第三步，定义注解处理器</p>\n<pre class=\"language-java\"><code>public class FruitInfoUtil {\n    public static void getFruitInfo(Class&lt;?&gt; clazz) {\n        String strFruitProvider = \"供应商信息:\";\n        Field[] declaredFields = clazz.getDeclaredFields();\n        for (int i = 0; i &lt; declaredFields.length; i++) {\n            if (declaredFields[i].isAnnotationPresent(FruitProvider.class)) {\n                FruitProvider annotation = declaredFields[i].getAnnotation(FruitProvider.class);\n                strFruitProvider += annotation.id() + \",\" + annotation.name() + \",\" + annotation.address();\n                System.out.println(strFruitProvider);\n            }\n        }\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第四步，主方法入口</p>\n<pre class=\"language-java\"><code>public class FruitRun {\n    public static void main(String[] args) {\n        FruitInfoUtil.getFruitInfo(Apple.class);\n    }\n}</code></pre>\n<h2><strong>五，内部类</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 1，静态内部类：</strong>即在类的内部定义的静态类，静态内部类可以访问外部了的静态变量和方法，外部也可以通过outClassName.innerClassName调用内部类</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2，成员内部类：</strong>在类的内部定义的没有用static修饰的内部类，使用方式和静态内部类一样。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>3，局部内部类：</strong>即一个类只在一个方法中使用，则完全可以将这个类定义为这个方法的内部类，即局部内部类，局部内部类可以实现真正的对外隐藏</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>4，匿名内部类：</strong>通常用于继承一个类或者实现一个接口的时候，使用new关键字定义，例如:Person person = new Student(){new Pupil(){}}</p>\n<h2><strong>六，泛型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 1，为什么要使用泛型：</strong>其根本目的是为了实现代码的复用，举个开发中常见的例子，我们需要定义返回类Result，返回类中包含状态码code，信息msg，以及数据data（任意类型），这个时候我们就需要使用泛型，因为我们返回的数据类型有各种vo，pojo类对象，list等。这时候泛型类result就可以被各种对象使用，实现代码的复用，简化开发。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>2，泛型标记和泛型限定：</strong>E表示集合中的元素，K表示键值，V表示value，N表示数值类型，T表示任意类型（包含基础类型，所有的对象类型），？（不确定的java类型）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>泛型限定：</strong>向上限定，&lt;?&nbsp; extends T&gt;，向下限定，&lt;? super&nbsp; T&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; <strong>3，泛型方法：</strong>即参数类型定义为泛型类型，以便于接收不同类型的参数，做出不同的处理。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>4，泛型类：</strong>例如public class Pair&lt;T&gt;{private T data;}</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>5，泛型接口：</strong>与放泛型类类似</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>6，类型擦除：</strong>即在泛型编译的过程中，会将泛型类型替换为限定类型的操作</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>7，明确的一点：</strong>虚拟机在运行程序的过程中，内部是没有泛型的，只有普通的类和方法。</p>\n<h2><strong>7，序列化</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 序列化是为了确保对象及其状态的持久化</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>序列化的使用：</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </strong>首先，实现序列化接口java.io.Serializble</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 然后，声明序列化ID，通常private static final&nbsp; long&nbsp; serialVersionUid&nbsp; = ***</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 因为序列化是保证对象及其状态的持久化，而静态变量是不属于对象，属于类本身的，所以序列化无法保存静态变量。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果需要序列化父类变量，则父类也要实现Serializable接口</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t'ransient修饰的属性不会序列化</p>\n<h3><strong>最后，提供一张思维导图供大家学习：<a href=\"https://images-cdn.shimo.im/es83SQH0CggucT7f__thumbnail\" target=\"_blank\" rel=\"noopener\">JAVA基础</a></strong></h3>\n<p>&nbsp;</p>\n<h2>水平有限，如有错误，还望指出！</h2>","blogGoods":0,"blogId":"1248605157059497984","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHMKAcvZ8AABJTVJPTfk020.jpg","blogRead":27,"blogRemark":"面试（二）------之JAVA基础篇","blogTitle":"面试（二）------之JAVA基础篇","createdTime":"2020-04-10 13:34:02","typeName":"java面试篇","updateTime":"2020-04-20 11:53:39"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，JAVA线程的创建方式</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>JAVA线程的创建有四种方式，分别为，继承Thread类，实现Runable接口，实现Callable&lt;Class&gt;接口，基于线程池。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>1，继承Thread方式：创建一个类继承Thread类，创建类的实例对象，调用start方法，继而执行线程的run（）方法，代码如下：</strong></p>\n<pre class=\"language-java\"><code>public class NewThread extends Thread{\n    public static void main(String[] args) {\n        NewThread thread = new NewThread();\n        thread.start();\n    }\n    @Override\n    public void run(){\n        System.out.println(\"create  a  new thread by Thread!\");\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>2，当子类已经继承了一个类，这时候就没法再继承Thread类了，这时候就可以实现Runable接口，实例化类的线程实例，创建Thread实例传入类的实例，执行start方法，继而执行run（）方法代码如下：</strong></p>\n<p>&nbsp;</p>\n<pre class=\"language-java\"><code>public class ThreadExample2 implements Runnable {\n    public static void main(String[] args) {\n        ThreadExample2 threadExample2 = new ThreadExample2();\n        Thread thread = new Thread(threadExample2);\n        thread.start();\n    }\n    @Override\n    public void run() {\n        System.out.println(\"create a new thread by Runnable!\");\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，有些情况下，我们需要再一个主线程中并发多个子线程执行同一个任务，然后回收子线程的返回值整理汇总，这时候就需要实现Callable&lt;Class&gt;接口，重写其call（）方法，用于计算结果。然床创建一个线程池用于提交线程，继而执行call方法，并且创建一个Future的list用于接收子线程逻辑代码即call方法的返回，最终遍历list，得到想要的返回值，如下：</strong></p>\n<pre class=\"language-java\"><code>public class ThreadExample3 implements Callable&lt;String&gt; {\n\n    private String name;\n\n    public ThreadExample3(String name){\n        this.name = name;\n    }\n\n    @Override\n    public String call() throws Exception {\n        return name;\n    }\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        ExecutorService pool = Executors.newFixedThreadPool(3);\n        List&lt;Future&gt; list = new ArrayList&lt;&gt;();\n        for(int i=0;i&lt;3;i++){\n            ThreadExample3 threadExample3 = new ThreadExample3(i+\"\");\n            Future future =pool.submit(threadExample3);\n            System.out.println(future.get().toString()+\" is running\");\n            list.add(future);\n        }\n        pool.shutdown();\n        for (Future future : list) {\n            System.out.println(\"currentThread's result is \"+future.get().toString());\n        }\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，基于线程池创建线程</strong></p>\n<pre class=\"language-java\"><code>public class ThreadExample4 {\n    public static void main(String[] args){\n        ExecutorService pool = Executors.newFixedThreadPool(3);\n        for(int i=0;i&lt;3;i++){\n            pool.execute(new Runnable() {\n                @Override\n                public void run() {\n                    System.out.println(\"thread  is running by FixedThreadPool\");\n                }\n            });\n        }\n        pool.shutdown();\n    }\n}</code></pre>\n<h2>二，线程池的工作原理</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong> &nbsp;1，概述：</strong>JVM根据用户提供的参数创建一定数量的线程任务，将其放入队列中，线程创建之后启动这些任务，如果线程的数量大于核心线程数量（用户设置的线程数量），则超出数量的线程排在队列中等待，当有线程任务执行完毕后，线程池调度器就会发现有可用可用线程，继而从队列中取出任务继续执行<strong>。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; </strong><strong>2，线程复用：</strong>（参见JDK源码解读，这里只做简单描述），由前可知，JVM会根据用户提供的参数创建一定数量的线程任务，且将其添加到任务队列中。JVM通过start（）方法创建一个线程之后， 会相应的为其创建一个任务队列，线程会不停的查看任务队列，如果任务队列中有任务，则调用run方法，执行，这样就达到了一次start（）创建线程，多次使用，完成线程复用的任务。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>3，线程池的核心组件和核心类（见JDK源码分类中关于线程的总结）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; </strong><strong>4，JAVA线程的工作流程：</strong>线程池刚被创建的时候，只是向系统申请一个执行线程队列和管理线程池的线程资源，当调用execute方法之后，执行下列流程：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果正在运行的线程数量小于corePoolSize（核心线程数量，即用户定义的的线程数量），则立即创建线程执行线程任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果正在运行的线程数量大于或等于corePoolSize，则将超过数量的线程加入到阻塞队列中</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在阻塞队列已满且线程数量小于MaximumPoolSize（即线程池能够容纳的最大线程数），线程池会创建非核心线程立即执行任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在阻塞队列已满且线程数量大于或等于MaximumPoolSize的时候，线程池会拒绝该线程任务且抛出异常</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在线程任务执行完毕之后，会将其从任务队列中移除，从队列中取出下一个线程任务执行</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在线程处于空闲状态且空闲时间超过KeepAliveTime，且线程数量大于corePoolSize的时候，会停止该线程，这样在没有任务的时候，线程池中的线程数始终维持在corePoolSize。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，线程池的拒绝策略：</strong>分为四种，分别为AbortPolicy，CallerRunsPolicy，DiscardOldestPolicy，DiscardPolicy</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; AbortPolicy：直接抛出异常，阻止线程运行，源码如下：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</p>\n<pre class=\"language-java\"><code>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n            throw new RejectedExecutionException(\"Task \" + r.toString() +\n                                                 \" rejected from \" +\n                                                 e.toString());\n        }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CallerRunsPolicy：如果线程任务没有关闭，则尝试执行该线程任务，源码如下：</p>\n<pre class=\"language-java\"><code>* @param r the runnable task requested to be executed\n* @param e the executor attempting to execute this task\n*/\npublic void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n     if (!e.isShutdown()) {\n         r.run()\n     }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DiscardOldestPolicy：移除任务队列中最早进入的线程任务，执行当前任务线程，源码如下：</p>\n<pre class=\"language-java\"><code>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n       if (!e.isShutdown()) {\n           e.getQueue().poll();\n           e.execute(r);\n       }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DiscardPolicy：直接丢弃线程任务，不做任何处理</p>\n<h2><strong>三，五种常用的线程池</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;newCachedThreadPool（可缓存线程池）：</strong>当线程池创建线程的时候如果发现有可复用的线程（执行完任务，且未关闭的线程），则直接复用，如果没有则创建新线程。可缓存线程池可以高效的利用执行任务时间短的线程，提高系统的性能，且线程池中的线程如果空闲时间超过60s，则会被终止且从缓存中移除，这样可缓存线程池不会占用系统资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>newFixedThreadPool（固定大小的线程池）：</strong>即线程池中的线程是初始化固定的，当任务线程大于线程池中线程数量时，任务线程就会进入阻塞队列等待。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newScheduledThreadPool（可做任务调度的线程池）：</strong>即可以设置线程执行的停顿时间和执行周期，进行定期定时的执行某个任务。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newSingleThreadPool（单个线程的线程池）:&nbsp;</strong>即线程池中永远只有一个线程进行工作，如果下称停止或者异常，则线程池创建新的线程替代当前线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newWorkStealingPool（足够大小的线程池）：</strong>即创建足够数量的线程的线程池，保证更快的进行运算，提高效率。</p>\n<h2><strong>四，线程的生命周期</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;线程的生命周期大致分为五个阶段：新建（new），就绪（Runnable），运行（Running），阻塞（Blocked），死亡（Dead）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;新建：</strong>即使用new创建一个线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>就绪：</strong>调用start方法，</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>运行：</strong>即线程获取cpu资源，执行run（）方法，进入运行状态，运行状态的线程如果调用yield（线程让步方法）或者失去cpu资源，都会导致线程重新回到就绪态；如果调用sleep方法，I/O阻塞，等待同步锁，等待通知以及suspend挂起都会导致线程进入阻塞态。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞：</strong>即线程被放入Blocked池。阻塞状态的线程如果结束了sleep方法，I/O方法返回，获取同步锁，收到通知或者resume都会导致其重新进入就绪态，与其它线程竞争cpu时间片。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>死亡：</strong>线程正常执行完run（）或者call（）方法，或者执行stop方法，或者发生异常或者错误都会导致线程死亡。（stop方法会导致锁混乱和死锁，不建议使用）</p>\n<h2><strong>五，线程的基本方法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;wait（线程等待）：</strong>会让线程进入WAITING状态，并且会释放对象的锁。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>sleep（线程睡眠）：</strong>会让线程进入睡眠，进入TIMED_WAITING状态，但是不会释放对象锁，睡眠时间到了之后，再次恢复运行状态</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>yield（线程让步）:</strong>&nbsp; 当前线程会让出其占有的cpu资源，重新回到就绪态和其它线程竞争cpu时间片</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>interrupt（线程中断）:&nbsp; </strong>中断当前线程，但是并不会导致其停止，只是改变其内部的终端标识位，在使用了thread.sleep()之后使用该方法，会导致抛出异常，且我们可以利用中断标识位进行线程的安全退出</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>join（线程加入）：</strong>即将当前线程进入阻塞态，等待下一个线程执行完毕后进入就绪态，重新竞争锁资源。通常用于主线程下面执行子线程，需要主线程阻塞，等待子线程执行完毕后返回其结果给主线程，主线程再执行的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>notify（线程唤醒）/notifyAll：</strong>前者随机唤醒一个等待线程，后者全部唤醒</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>setDaemon（守护线程）:</strong>级别较低的线程，用于后台运行，服务用户用户线程，例如垃圾收集线程就是典型的守护线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>sleep方法和wait方法的区别：</strong>前者属于Thread，后者属于Object，前者不会释放锁资源，后者会释放锁资源</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>start方法和run方法：</strong>start方法只是创建一个线程，并没有运行，run方法时执行线程的真正代码逻辑。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>线程退出的方式：</strong>见四中最后一条</p>\n<h2><strong>六，JAVA中的锁（知识比较杂乱）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述:JAVA中的锁是为了保护数据的一致性。按照不同的标准可分为乐观锁和悲观锁，公平锁和非公平锁，共享锁和独占锁，偏向锁，轻量级锁，重量级锁，自旋锁，可重入锁。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;乐观锁：</strong>即认为每次读取数据都不会被修改，当修改操作的时候再判断当前数据是否被修改，未修改则修改，若已被修改，则返回失败状态。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>悲观锁：</strong>即认为每次读取数据都会被修改，因而每次读取数据都对其进行加锁，这样只有当前用户可以修改，其它用户阻塞等待直到当前用户修改完毕释放锁资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>自旋锁：</strong>即有些线程任务的执行很短，很快就可以释放锁资源，为了避免在这种情况下竞争线程仍然进行内核态和用户态之间的转换，因而让线程自旋（即等一会），如果有可用锁，则获取，减少了线程在用户态和内核态之间切换的时间损耗。提高了性能（优势）。当然线程自旋是占用cpu资源的，因而需要设置一个自旋的最大等待时间，如果超过此时间，则线程退出自旋模式。对于线程竞争锁资源激烈的情况，自旋有可能会导致cpu资源的损耗（劣势）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>公平锁和非公平锁：</strong>即根据线程竞争锁资源的机制判定，一般如果依据先到先得的原则，则位公平锁；如果依据就近原则，则位非公平锁。公平锁相比于非公平锁会更加耗费性能，因为要维护一个线程任务丢列，根据线程任务在队列中的顺序分配锁资源，因而不常用。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>可重入锁：</strong>又被称为递归锁，即该锁可以然后线程对其进行多次的加锁操作。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>偏向锁：</strong>当线程获取到锁的时候，用来消除线程的锁重入的开销（看起来是偏袒这个线程）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>共享锁和独占锁：</strong>共享锁即多线程共享锁资源（典型例子，读锁）；独占锁即当前锁只能有一个线程获取，其它线程阻塞</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>轻量级锁：</strong>没有多线程竞争的前提下，减少重量级锁的使用提高性能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>重量级锁：</strong>基于操作系统的互斥量而实现的锁，会导致进程在用户态和内核态之间切换，耗费性能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>synchronized：独占式悲观锁，可重入锁，非公平锁，重量级锁。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 作用范围：</strong>作用于成员变量和非静态方法，相当于锁住的是对象的实例，即this对象</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;作用于静态方法，相当于锁住的是class实例</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;作用域代码块，相当于锁住的代码块中的对象</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>实现原理：</strong>内部包括ContentionList（锁竞争队列），EntryList（竞争候选列表），WaitSet（等待集合），OnDeck（竞争候选者），Owner，!Owner，其中ContentionList是用来存放竞争锁资源的线程。EntryList是用来存放有资格竞争锁资源的线程。调用wait方法后放入WaitSet中，onDeck指的是同一时刻，只有一个线程竞争锁资源，Owner指的是得到锁资源的线程，!Owner指的是线程执行完毕，释放锁资源的线程。需要注意的是线程首先采用的都是自旋模式获取锁资源，如果自旋获取不到再加入ContentionList，而且Owner状态的线程并不是直接把锁资源交给onDeck状态线程，而是给它竞争锁资源的权利，因而onDeck状态的线程还需要跟自旋线程竞争锁资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>ReentrantLock：独占式，可重入锁，并且可以实现公平锁和非公平锁，重量级锁。</strong></p>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;用法：</strong>lock()加锁，后跟try代码块，finally中进行释放锁unlock()</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;避免死锁的方法：</strong>响应中断（即可以根据情况中断对锁资源的请求），可轮询锁（tryLock（）即尝试获取锁，如果有可用锁则获取返回true，没有则返回。和lock（）的区别在于lock获取锁资源如果没有则一直等待直到获取到锁资源），定时所（tryLock（time,unit）即再一定时间内如果有可用锁，且线程未中断则获取锁，否则禁用当前线程。）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>Semaphore（信号量）:</strong>机制和ReentrantLock类似</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ReadWriteLock（读写锁）：</strong>如果系统要求支持多线程共享读，但不能多线程写，使用读锁；如果要求同一时刻只能有一个线程写，写的过程中不能读取该共享数据，则使用写锁。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; <strong>分段锁：</strong>一种思想，将数据分段加锁，例如ConcurrentHashMap</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;死锁：</strong>即线程之间互相共享资源会导致死锁</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; <strong>锁优化：</strong>第一，减少锁的持有时间；第二：减小锁粒度，例如分段锁；第三：锁分离，例如读写锁；第四：锁粗化，放置锁粒度太小，造成频繁加锁释放锁；第五：锁消除，消除程序代码不规范而造成的乱用了锁</p>\n<p>&nbsp;</p>\n<h3><strong>并发编程（上）的思维导图送上：<a href=\"https://images-cdn.shimo.im/1UcHkyrlJyGRPYnn.png__thumbnail\" target=\"_blank\" rel=\"noopener\">并发编程（上）</a></strong></h3>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>\n<h1>水平有限，如果错误，还望指出！</h1>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;</p>","blogGoods":0,"blogId":"1249313090567143424","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHM2AQOeZAABJTVJPTfk967.jpg","blogRead":8,"blogRemark":"面试（三）------之并发编程篇（上）","blogTitle":"面试（三）------之并发编程篇（上）","createdTime":"2020-04-12 12:27:07","typeName":"java面试篇","updateTime":"2020-04-20 11:53:51"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，redis简介</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>redis是NoSQL型系统之一，与之相似的还有Memcache，用来存储key-value这种键值型数据。相比于Memcache而言，redis不仅可以做临时缓存，还可以做数据持久化，将数据定时的存入硬盘或者将命令追加到日志文件当中。而Memcache只能做临时缓存，因而现在基本上已经被redis完全取代。redis的读写速度非常快，官方给出的数据是读110000次/s，写81000次/s；而且redis支持多种数据类型，例如String，list，hash，set，zset；redis支持主从复制（集群），进行数据持久化；还支持过期时间，事务等。</p>\n<h2><strong>二，redis的安装与启动（docker环境下）</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;docker安装完毕后，安装redis：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第一步：拉取redis镜像，docker&nbsp; pull&nbsp; redis</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第二步：启动redis，docker&nbsp; &nbsp;run&nbsp; &nbsp;redis&nbsp; &nbsp;</p>\n<p><strong>三，基本知识串讲</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>单进程单线程：redis只有一个进程，且内部为单线程，这样做的优势是不存在线程安全问题，且不需要进行线程间的切换，提高了性能，而且多线程可能会涉及到锁。劣势是无法发挥多核cpu的优势，不过可以通过开启搭建多个redis实例实现</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>redis中默认有16个数据库（0-15），可以通过select n来进行数据库之间的切换</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;常用的基本命令：flushDB（清空当前数据库），flushAll（清空所有数据库），dbSize（查看有多少数据库）</p>\n<h2><strong>四，redis基本数据类型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;string：</strong>字符串类型，数据库中存储Map&lt;String,String&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>list：</strong>列表数组类型，数据库中存储Map&lt;String,List&lt;Object&gt;&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>hash：</strong>哈希类型，数据库中存储Map&lt;String,Map&lt;Object,Object&gt;&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>set：</strong>集合类型，其中元素无序，数据库中存储Map&lt;String,Set&lt;Object,Object&gt;&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>Zset：</strong>有序集合类型，每个元素都有一个可用于排序的权重</p>\n<h2><strong>五，redis相关命令（这里详解一些常用的命令，不常用的一笔带过）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;string：</strong>(1)set&nbsp; key&nbsp; value,插入一条数据&nbsp; （2）mset&nbsp; key value...批量插入 （3）setnx&nbsp; key value&nbsp; 若无则插入（4）get&nbsp; key&nbsp; 获取某条数据&nbsp; （5）mget keys 批量获取&nbsp; （6）getrange key&nbsp; 0 -1获取数据库全部数据&nbsp; （7）incr age 递增&nbsp; (8) incrby&nbsp; age&nbsp; 10&nbsp; 递增 age 步长为10（9）decr&nbsp; age&nbsp; 递减&nbsp; （10）decrby&nbsp; age&nbsp; 10 步长递减&nbsp; &nbsp;（11）del&nbsp; key&nbsp; 删除某条数据&nbsp; <span style=\"background-color: #ffff00;\">（12）exists&nbsp; key&nbsp; 判断是否存在某个key&nbsp; &nbsp;(13)expire&nbsp; key&nbsp; 10&nbsp; 设置过期时间（单位为秒）&nbsp; （14）pexpire&nbsp; key&nbsp; 1000 设置过期时间，单位为毫秒&nbsp; （15）persist key删除过期时间 （</span><span style=\"background-color: #ffff00;\">16）ttl&nbsp; key&nbsp; 查看过期时间</span></p>\n<p><span style=\"background-color: #ffff00;\">&nbsp;<span style=\"background-color: #ffffff;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>list：&nbsp;&nbsp;</strong>（1）lpush&nbsp; key&nbsp; value 左插入一条数据&nbsp; &nbsp;（2）lpush mylist&nbsp; key&nbsp; value....批量左插入&nbsp; （3）rpush&nbsp; key value 右插入一条数据&nbsp; (4)rpush&nbsp; mylist&nbsp; key value...右批量插入&nbsp; （5）lrange&nbsp; mylist&nbsp; 0&nbsp; -1&nbsp; 取出数据集合&nbsp; （6）lpop mylist 左弹出集合中第一条数据&nbsp; （7）rpop&nbsp; </span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">mylist&nbsp; 右弹出集合中第一条数据&nbsp; （8）llen&nbsp; mylist&nbsp; 获取数据集合长度lrem&nbsp; mylist&nbsp; count&nbsp; value&nbsp; （count&gt;0,从表头开始搜索，移除count个与值与value相等的元素；count&lt;0,表尾开始；count=0，移除所有值与value相等的元素） （9）linsert mylist&nbsp; before/after&nbsp; a&nbsp; 在a元素前或后插入。</span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">(10) lpoplpush&nbsp; list&nbsp; list1 转移列表的元素到另一个列表</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>hash：</strong>（1）hset&nbsp; key&nbsp; &nbsp;val-key&nbsp; val-val&nbsp; 插入一条数据&nbsp; （2）hset&nbsp; myhash&nbsp; name&nbsp; xxx&nbsp; 用于给哈希表中的字段赋值，不存在则创建哈希表赋值，存在则覆盖旧值&nbsp; (3) hget&nbsp; &nbsp;myhash&nbsp; name&nbsp; 取哈希表中某个值&nbsp; （4）hmset&nbsp; myhash name&nbsp; xxx age xxx&nbsp; 批量插入字段&nbsp; （5）hmget</span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">批量获取 （6）hgetall&nbsp; myhash&nbsp; 获取哈希表中所有值&nbsp; (7)&nbsp; hexisets myhash&nbsp; name&nbsp; 判断哈希表中是否存在name字段&nbsp; （8）hsetnx&nbsp; myhash score 100 若存在则不插入，若不存在则插入数据&nbsp; （9）hincrby&nbsp; myhash id 1/hdecrby&nbsp; myhash id&nbsp; 10 递增递减 （10）hdel&nbsp; myhash name&nbsp; </span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">删除&nbsp; （11）hkeys&nbsp; myhash&nbsp; 只取key值&nbsp; （12）hvals&nbsp; myhash&nbsp; 只取value值&nbsp; （13）hlen&nbsp; myhash 获取哈希表长度</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>set：</strong>（1）sadd myset&nbsp; redis&nbsp; 添加一条数据&nbsp; （2）smembers myset&nbsp; 获取数据集合&nbsp; （3）srem&nbsp; myset&nbsp; set1&nbsp; 删除set1&nbsp; （4）sismember myset&nbsp; set1 判断set中是否存在set1&nbsp; (5)srandmember&nbsp; key count&nbsp; 随机获取count个元素（6）spop&nbsp; 从集合中弹出一个元素</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>zset：</strong>之后补充</span></span></p>\n<h2><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">六，redis配置文件（常见配置）</span></span></strong></h2>\n<p><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;daemonize no：</span></span></strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">redis默认不是以守护进程的方式运行的，可以更改为yes启用守护进程（即后台运行）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>pidfile&nbsp; /var/run/redis.pid&nbsp; :</strong>启用守护进程后，默认将pid写入/var/run/redis.pid文件，可以更改</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>port&nbsp; 6379 ：</strong>redis默认端口</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp; &nbsp; &nbsp; &nbsp; <strong>bind&nbsp; 127.0.0.1：</strong>绑定的主机地址</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\"> &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>timeout&nbsp; 300</strong><strong>：</strong>redis客户端闲置多长时间后关闭连接，改为0的话，表示关闭该功能</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>loglevel&nbsp; verbose：</strong>默认日志级别（还有debug，notice，warning）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>database 16：</strong>redis默认有16个数据库可以修改</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>save&nbsp; 900&nbsp; 1/save&nbsp; 300&nbsp; 10/save&nbsp; 60&nbsp; 10000：&nbsp;</strong>表示一定时间内有多少条数据发生修改，就将其同步到数据文件一次，例如第一个表示15分钟内有一条数据发生改变就同步</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>rdbcompression yes&nbsp; ：</strong>表示数据存储到本地数据库时是否进行压缩</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>dbfilename&nbsp; dump.rdb：</strong>指定本地数据库文件名</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>dir&nbsp; /...../redis安装目录/bin ：</strong>本地数据库存放目录，默认在redis安装目录的bin目录下</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>slaveof&nbsp; &nbsp;masterip&nbsp; masterport ：</strong>设置当本机为从机时，它的主机的ip和端口</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>masterauth&nbsp; &lt;master-password&gt;：</strong>当master服务设置了密码时，slav服务连接master的密码</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>requirepass&nbsp; foobared：</strong>默认关闭redis连接需要密码，当给redis设置了密码，就需要打开</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>maxclients&nbsp; &nbsp;128：</strong>redis同一时间最大连接客户端的数量</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>appendonly&nbsp; &nbsp;no：</strong>是否开启aof持久化，默认不开启，采用rdb</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>appendfilename&nbsp; appendonlu.aof：</strong>指定aof持久化的文件名</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>appendfsync&nbsp; everysec :</strong>指定更新日志条件，默认每秒更新一次（还有no，指等操作系统进行数据缓存到磁盘，快；always指每次更新操作后都手动写入磁盘，慢但安全）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;虚拟机方面的配置暂不说明</span></span></p>\n<h2><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">七，redis持久化</span></span></strong></h2>\n<p><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;概述：</span></span></strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">redis持久化主要有两种方式，即rdb和aof</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>rdb：</strong>适用于大数据集的恢复，数据的备份，但是因为设置周期时间进行数据的快照，所以如果redis宕机，可能会丢失最后一个写操作的数据，因为数据完整性较差。数据保存在dump.db文件中，只需要移动到redis安装目录，重启即可恢复数据</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>aof：</strong>适用于对数据的完整性要求较高的情况，因为可以设置不同的持久化策略，例如每秒保存一次，这样即时redis宕机，也只会丢失最后一秒的数据。但是因为其日志文件存储的是写入命令，因而其文件大小要大于rdb的数据文件，且每次重启，都要从头执行数据文件中的命令，因而恢复速度也</span></span><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">要慢于rdb。</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>注意：</strong>当rdb和aof同时开启的时候，redis重启，默认会采用aof的形式进行数据的重新构建</span></span></p>\n<h2><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">八，redis事务</span></span></strong></h2>\n<p><strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;概述：</span></span></strong><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">什么是事务？事务即是一系列的命令要买全部执行，要么全部回滚</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <strong>常用命令：</strong>multi(启动事务)，discard（取消事务）,exec（执行事务块内命令）,watch key(监控某个key的变化)，unwatch（取消对所有key的监控）</span></span></p>\n<p><span style=\"background-color: #ffff00;\"><span style=\"background-color: #ffffff;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>注意：</strong>redis的事务中在命令本身出错的情况下会造成命令的全部回滚，但是在命令无错，执行某个命令的时候发生异常的时候，则谁的错，谁停止（这一点和mysql是不同的）</span></span></p>\n<h2><strong>九，redis的主从复制</strong></h2>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>redis的主从复制，即主机数据更新后根据我们设置的策略将数据同步到从机上，主机以写为主，从机以读为主<strong>。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 使用：</strong>配主不配从，在从机中使用slaveof&nbsp; 主机ip&nbsp; &nbsp;主机端口配置从机，但是这种配置方式当redis重启之后就会失效，如果想要redis重启仍然可用，则需要配置redis.conf配置文件中的slaveof&nbsp; masterip&nbsp; masterport。这种配置方式的问题所在，中心化只有一台极其支持写操作，如果主机宕机，则从机等待，且从机宕机重启后不会跟上大部队（即重启后变为主机）。当然我们可以采用命令slave&nbsp; no&nbsp; one 使从机反客为主，成为主机。但是这种手动操作太过麻烦。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>哨兵模式：</strong>即配置之后，如果主机宕机，则哨兵会自动根据投票规则在从机中进行选举，从而产生新的主机顶替。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>主从复制的缺点：</strong>因为所有的写操作都是子主机上进行，从而在同步到从机上，所以存在着一定的延迟，当系统繁忙或者从机数量较多的时候，这种问题就更加明显。</p>\n<h2><strong>十，redis集群</strong></h2>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;概述：</strong>集群是一种去中心化的模式，与中心化模式不同的是，中心化模式中如果主服务挂掉了，那么服务就挂掉了。但是集群模式下，没有主路由，每个节点自身都可以成为路由</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;redis集群：即配置多台主机，多台从机，不同的主机中有不同的槽点，当执行数据写入时，会根据crc16算法计算出数据的槽点，从而将数据存入到对应的主机中，并同步到与其对应的从机中</p>\n<p>&nbsp;</p>\n<h1>水平有限，如有错误，还望指出！</h1>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1249588251598041088","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6caUuADBI7AAAb07iHSRw500.jpg","blogRead":4,"blogRemark":"redis基础（一）","blogTitle":"redis基础（一）","createdTime":"2020-04-13 06:40:30","typeName":"redis","updateTime":"2020-04-20 16:47:37"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，线程上下文切换</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>cpu利用时间片轮询的方式来为每个任务都分配一定的时间片，任务的执行过程中保存任务的状态。任务状态的保存和在加载就叫做上下文切换。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>进程：</strong>指的是一个运行中的程序实例，一个进程中可以有多个线程，并且与进程共享同样的内存和系统资源</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong> 上下文：</strong>指的是寄存器和程序计数器保存的线程的信息</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>寄存器：</strong>指的是内存中很小但是运行速度很快的一块区域（相对于RAM外部内存）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>程序计数器：</strong>一种寄存器，用来保存当前执行指令的位置或者下一个待执行指令的位置</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>上下文切换：</strong>上下文切换指的是操作系统的内核在cpu上对进程或者线程的切换。上下文信息保存在进程控制块中（PCB）。流程如下：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;挂起当前进程，将进程的上下文信息保存在进程控制块中；</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;在进程控制块中寻找下一个任务的上下文信息。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;恢复进程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>上下文切换的原因：</strong>第一，任务正常执行完毕，调度下一个任务；第二，线程出现I/O阻塞，被挂起，cpu调度下一个任务；第三，线程等待同步锁，获取socket通知等，被挂起，cpu调度下一个任务；第四，用户调用sleep方法，让出cpu；第五，硬件中断</p>\n<h2><strong>二，JAVA阻塞队列</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>阻塞队列的是调度当前队列的线程处于阻塞状态</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 消费者阻塞：如果队列为空，则消费者线程被挂起，处于阻塞状态，当有新数据进入队列，则消费者线程被唤醒，消费数据</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 生产者阻塞：如果队列数据已满，则生产者线程挂起，处于阻塞状态，当队列有空闲位置，生产者线程被唤醒，生产数据。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞队列的主要操作：</strong>插入操作和移除（获取）操作</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>插入操作：</strong>add(e)，有空间则插入，无空间报异常；offer(e),有空间则插入，无空间返回false；offer(e,time,unit),有空间插入，无空间等待time时间，若超时返回false；put(e),有空间插入，无空间则线程挂起处于阻塞直到有空间</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>移除操作：</strong>poll(e),有值返回值，无值返回null;poll(e,time,unit),有值返回值，无值等待time时间，超时返回null;take(e),有值返回值，无值等待新数据进入再立即返回；drainTo(collection&lt;Object&gt;)批量移除，提高获取效率</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞队列的实现：</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong> ArrayBlockingQueue：</strong>基于数组的有界阻塞队列，按照先进先出顺序对元素进行排序</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>LinkedBlockingQueue：</strong>基于链表的有界阻塞队列，队头队尾采用不两个不同的锁控制数据同步，并发性高</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>PriorityBlockingQueue：</strong>基于优先级的无界队列，默认升序排列，可以自定义排序规则，根据优先级访问数据。但是有数据优先级一样的情况</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>DelayQueue：</strong>支持延时的队列，即从队列中取数据时等待一定的时间才能获取元素。可以用于缓存系统的设计，设计过期时间，也可以用来设置定时调度任务，即如果能够从队列中获取，说明到了任务的调度时间。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>SynchronousQueue</strong>：该队列是一个不存储元素的阻塞队列，每一个put操作都必须等待一个take操作的完成。吞吐量高于ArrayBlockingQueue和LinkedBlockingQueue。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>LinkedTransferQueue：</strong>基于链表的无界阻塞队列，多了transfer方法(如果消费者等待，直接将任务从生产者传递给消费者，无消费者等待，则将任务加到队尾直到被消费才返回)和tryTransfer（与transfer一致，只不过不管有没有消费者等待获取都会立即返回tryTransfer（e,time,unit）（与tryTransfer一致，只不过设置了超时时间）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>LinkedBlockingDeque：</strong>基于链表的双向阻塞队列，可以在两端同时进行读写操作，提高了队列的操作效率。</p>\n<h2><strong>三，并发关键字</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;CountDownLatch：</strong>适用于一个主线程等待子线程完成任务之后执行（原理：设置一个程序计数器，计数器的值为子线程的个数，子线程并发执行，每个子线程执行完毕后，调用CountDown方法，将其计数器的值减去1，值为0时，唤醒主线程执行）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>CyclicBarrier：</strong>即当所有线程到达一个状态共同执行。await（）方法：确保所有线程到达Barrier状态才执行；await（time,unit）：设置一个超时时间，超过这个时间，执行达到Barrier状态的线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>Semaphore：</strong>因为其限制了多线程访问资源的线程个数，所以适用于多线程并发访问有限资源的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>volatile：</strong>直接用来修饰变量，是一种比Synchronized更加轻量级的机制，用于多线程共享同一变量，可以同时对其进行读写操作。当多个线程共享变量的时候，读取变量将其从内存复制到cpu缓存中，然后线程对其操作进行修改，这样再多cpu的情况下，有可能出现线程修改原数据造成数据不一致的情况，使用volatile关键字直接将线程修改的变量存入内存，解决这个问题。</p>\n<h2><strong>四，多线程共享数据</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>多线程共享数据主要通过共享内存实现，而共享内存的可见性，有序性，原子性已经由JVM和锁解决。理想情况下我们需要解决同步和互斥的问题（<span style=\"background-color: #ffff00;\">怎么解决的有待考证！</span>）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>解决方法一：</strong>将数据抽象成一个类，将对数据的操作封装成类中的方法</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解决方法二：</strong>将Runnable对象作为一个内部类，将共享数据作为这个类的成员变量</p>\n<h2><strong>五，ConcurrentHashmap并发</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ConcurrentHashmap使用了减小锁粒度，这里具体为分段锁的思想优化了锁，因为如果直接对hashmap进行加锁，锁太大，而且同一时刻只能有一个线程操作hashmap，并发性能较差</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;实现原理：</strong>即内部采用分段锁思想，将hashmap分为多个segment，每次读取数据的时候，对数据所在的segment进行加锁，这样只要保证每个segment线程安全，就可以保证整个hashmap线程安全</p>\n<h2><strong>六，JAVA中的线程调度</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;抢占式调度：</strong>即线程对cpu资源进行抢占，这种策略下每个线程抢占到cpu资源的概率是相等的，这样就不会一个线程阻塞造成整个系统阻塞的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>协同式调度：</strong>即一个线程使用完cpu资源之后通知cpu调度下一个任务，适用于多线程交替执行任务。因为如果一个线程阻塞可能会造成整个系统阻塞甚至崩溃</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>JAVA采用的是抢占式调度，但同时又尽可能的保证公平性（即为每个线程分配优先级不同的cpu时间片）</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>&nbsp;线程让出cpu的情况</strong>：第一，线程调用yield方法；第二，I/O阻塞，socket等待等；第三，等待同步锁；第四，正常执行完毕</p>\n<h2>七，进程调度算法</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>优先调度算法：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;先来先服务调度算法：</strong>即遵循先来先被分配cpu资源运行的原则</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>短作业调度算法：</strong>即预估作业的时间长短，优先调度时间短的任务，可能会导致长时间大任务很长时间无法被调度 &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>高优先权调度算法：即每个任务会预先被分配优先级</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;非抢占式优先调度算法：</strong>按照优先级的高低一次分配cpu资源运行</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>抢占式优先调度算法：</strong>按照优先级的高低分配cpu资源运行，但是如果任务再运行过程中有优先级更高的任务加入，则将其cpu资源临时回收分配给紧急任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>高响应比调度算法：</strong>动态调度，即作业时间短，则优先级高；等待时间长，则优先级高。前者遵循短作业调度算法，后者遵循先来先服务原则。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>时间片轮转调度算法：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;时间片轮转法：</strong>按照任务再队列中的顺序进行调度</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>多级反馈队列调度算法：</strong>即再时间片轮转法的基础上维护了就绪队列，默认第一队列优先级高，先调度第一队列的任务，如果再分配的cpu时间片内未完成则将其加入第二队列队尾，以此类推直到其执行完毕。只有第1 -（n-1）队列为空，才会调度第n队列的任务，而且当前任务执行时，如果有优先级高的任务进来，会抢占其cpu资源。</p>\n<h2><strong>八，CAS</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>即比较和交换，CAS（V,E,N）三个参数，只有当V=E的时候才会将V设置为N。如果V!=E，则说明数据已经被其它线程修改，不做任何操作</p>\n<h2><strong>九，ABA问题</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>概述：</strong>即当1线程从V中取出A时，2线程也从中取出1，修改为B，再修改为A。而1线程仍然修改成功，实际上修改过程中V的实际值已经发生改变，只不过1没有发觉。解决这种问题，常采用乐观锁的版本号机制。</p>\n<h2><strong>另外有AQS问题没怎么读懂，下次完善！</strong></h2>\n<p>&nbsp;</p>\n<h3><strong>思维导图：<a href=\"https://images-cdn.shimo.im/myFodjsaVAA3PVV7__thumbnail\" target=\"_blank\" rel=\"noopener\">并发编程（下）</a></strong></h3>\n<p>&nbsp;</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</p>","blogGoods":0,"blogId":"1249742755949817856","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHNmAPuxmAABJTVJPTfk117.jpg","blogRead":17,"blogRemark":"面试（三）------之并发编程篇（下）","blogTitle":"面试（三）------之并发编程篇（下）","createdTime":"2020-04-13 16:54:26","typeName":"java面试篇","updateTime":"2020-04-20 11:54:02"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，栈及其JAVA实现</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：栈是一种先进后出的数据结构，对栈顶元素的添加，删除等操作较快，但是对于栈内的元素操作很慢</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA实现：实现需要定义栈的数据结构，写栈的入栈，出栈，获取栈顶元素的方法，如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n * 基于数组实现栈\n * @author wcj\n * @Date 2020/4/14 20:59\n * @Version 1.0\n */\npublic class StackExample&lt;E&gt; {\n\n    /**\n     * 站的深度\n     */\n    private int maxSize;\n    /**\n     * 存储数据的数组\n     */\n    private Object[] data;\n    /**\n     * 栈顶指针\n     */\n    private int top = -1;\n\n    /**\n     * 默认栈的深度为10\n     */\n    public StackExample(){\n        this(10);\n    }\n\n    /**\n     * 用户自定义栈的深度\n     * @param initialSize\n     */\n    public StackExample(int initialSize){\n        if(initialSize&gt;=0){\n            this.maxSize = initialSize;\n            this.data = new  Object[initialSize];\n            this.top = -1;\n        }else{\n            throw new RuntimeException(\"初始化栈的深度不能小于0!\");\n        }\n    }\n\n    /**\n     * 入栈操作\n     * @param e\n     * @return\n     */\n    public Boolean push(E e){\n        if(top == maxSize-1){\n            throw new RuntimeException(\"栈已满,不能入栈\");\n        }else{\n            data[++top] = e;\n        }\n        return true;\n    }\n\n    /**\n     * 出栈操作\n     * @return\n     */\n    public E pop(){\n        if(top==-1){\n            throw new RuntimeException(\"栈空，不能出栈！\");\n        }else{\n            return (E) data[top--];\n        }\n    }\n\n    /**\n     * 获取栈顶元素\n     * @return\n     */\n    public E peak(){\n        if(top==-1){\n            throw new RuntimeException(\"栈空异常！\");\n        }else{\n            return (E) data[top];\n        }\n    }  </code></pre>\n<h2><strong>二，队列极其JAVA实现</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：队列是一种先进先出的数据结构，对队头和队尾的操作简单，但是队内元素的操作复杂。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA实现：定义队列的数据结构，队列的出队，入队，获取队头元素。代码如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n * 基于数组实现队列\n * @author wcj\n * @Date 2020/4/14 21:14\n * @Version 1.0\n */\npublic class QueueExample&lt;E&gt; {\n\n    /**\n     * 队列长度\n     */\n    private int maxSize;\n    /**\n     * 存储数据数组\n     */\n    private Object[] data;\n    /**\n     * 队头指针\n     */\n    private int front;\n    /**\n     * 队尾指针\n     */\n    private int rear;\n\n    /**\n     * 默认构造器\n     */\n    public QueueExample(){\n        this(10);\n    }\n    /**\n     * 用户自定义队列长度构造器\n     * @param initialSize\n     */\n    public QueueExample(int initialSize){\n        if(initialSize&gt;=0){\n            this.maxSize = initialSize;\n            data = new Object[initialSize];\n            front = rear = 0;\n        }else{\n            throw new RuntimeException(\"初始化队列长度不能小于0！\");\n        }\n    }\n\n    /**\n     * 入队操作\n     * @param e\n     * @return\n     */\n    public Boolean add(E e){\n        if(rear == maxSize){\n            throw new RuntimeException(\"队列已满，无法入队!\");\n        }else{\n            data[rear++] = e;\n        }\n        return true;\n    }\n\n    /**\n     * 出队操作\n     * @return\n     */\n    public E poll(){\n        if(front==rear){\n            throw new RuntimeException(\"队空，无元素可出队！\");\n        }else{\n            E e = (E) data[front];\n            data[front] = null;\n            return e;\n        }\n    }\n\n    /**\n     * 获取队头元素\n     * @return\n     */\n    public E peek(){\n        if(front==rear){\n            throw new RuntimeException(\"队空，无元素可出队!\");\n        }else{\n            return (E) data[front];\n        }\n    }\n}\n</code></pre>\n<h2><strong>三，链表及其JAVA实现</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：链表是由一系列数据节点组成的数据结构，节点可以动态生成。对于元素的增加，删除操作快，查询操作慢</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;这里主要讲述几种有代表性的链表：单向链表，双向链表，双向循环链表</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;单链表的JAVA实现：数据结构定义，添加节点，删除节点，查找节点，代码如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n * 单向链表\n * @author wcj\n * @Date 2020/4/14 21:32\n * @Version 1.0\n */\npublic class SingleLinkedList {\n\n    /**\n     * 链表长度\n     */\n    private int length;\n    /**\n     * 链表头节点\n     */\n    private Node head;\n\n    public SingleLinkedList(){\n        this.length = 0;\n        this.head = null;\n    }\n    /**\n     * 内部类声明每个链表节点\n     * 每个节点包括数据域和指向下一个节点的指针\n     */\n    private class Node{\n        private Object data;\n        private Node next;\n        public Node(Object data){\n            this.data = data;\n        }\n    }\n\n    /**\n     * 插入节点（这里使用头插法）\n     * @param obj\n     * @return\n     */\n    public Boolean add(Object obj){\n        Node node = new Node(obj);\n        if(length==0){\n            head = node;\n        }else{\n            node.next= head;\n            head = node;\n        }\n        length++;\n        return true;\n    }\n\n    /**\n     * 删除某个节点\n     * 先对链表进行判空处理\n     * 然后找到要删除的节点\n     * 最后进行删除\n     * @param obj\n     * @return\n     */\n    public Boolean delete(Object obj){\n        if(length==0){\n            throw new RuntimeException(\"链表为空，无节点可删除!\");\n        }else{\n            Node prev = head;\n            Node current = head;\n            //查找待删除元素\n            while(!current.data.equals(obj)){\n                if(current.next==null){\n                    return false;\n                }else{\n                    prev = current;\n                    current = current.next;\n                }\n            }\n            prev.next = current.next;\n            length--;\n        }\n        return true;\n    }\n\n    /**\n     * 获取某个元素\n     * @param obj\n     * @return\n     */\n    public Object find(Object obj){\n        if(length==0){\n            throw new RuntimeException(\"链表为空\");\n        }else{\n            Node current = head;\n            while(current.data.equals(obj)){\n                if(current.next==null){\n                    return null;\n                }else{\n                    current = current.next;\n                }\n            }\n            return current.data;\n        }\n    }\n}\n</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>双向链表的JAVA实现：定义数据结构，头插法，尾插法，删除头部节点，删除尾部节点（这里只写尾插节点和删除尾部节点），代码如下：</strong></p>\n<pre class=\"language-java\"><code>import com.sun.org.apache.xpath.internal.operations.Bool;\n\n/**\n * 单向循环链表\n * @author wcj\n * @Date 2020/4/14 22:05\n * @Version 1.0\n */\npublic class CircleLinkedList {\n\n    /**\n     * 链表长度\n     */\n    private int length;\n    /**\n     * 头节点\n     */\n    private Node head;\n    /**\n     * 尾节点\n     */\n    private Node tail;\n\n    /**\n     * 初始化构造方法\n     */\n    public CircleLinkedList(){\n        this.length = 0;\n        this.head=this.tail = null;\n    }\n\n    /**\n     * 内部类实现的链表节点\n     */\n    private class Node{\n        private Object data;\n        private Node prev;\n        private Node next;\n        public Node(Object data){\n            this.data = data;\n        }\n    }\n\n    /**\n     * 尾插节点\n     * @param obj\n     * @return\n     */\n    public Boolean addTail(Object obj){\n        Node node = new Node(obj);\n        if(length==0){\n            head = tail= node;\n            length++;\n        }else{\n            tail.next = node;\n            node.prev = tail;\n            tail = node;\n            length++;\n        }\n        return true;\n    }\n\n    /**\n     * 删除尾部节点\n     * @return\n     */\n    public Boolean delTail(){\n        Node temp = tail;\n        if(length==0){\n            throw new RuntimeException(\"链表为空!\");\n        }else{\n            tail = tail.prev;\n            tail.next = null;\n            length--;\n        }\n        return true;\n    }\n}\n</code></pre>\n<h2><strong>四，散列表</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：有一张表M，一个映射函数f(key)，如果对于任意一个key，都有一个函数指与表中的内存地址相对应，则M就为散列表，f(key)就为散列函数。散列函数存储key-value键值对形式的数据，直接生成key与表中地址值的映射，因此查询非常迅速。同时散列表也经常被用于信息安全，用于加密操作。</strong></p>\n<h2><strong>五，二叉排序树</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：二叉查找树又成为二叉搜索树，二叉查找树</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;特征：根节点左边的数据小于根节点，根节点右边的数据大于根节点，且其左右子树还是二叉排序树</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现：定义数据结构，插入操作，删除操作，查找操作，代码如下：</strong></p>\n<pre class=\"language-java\"><code>package interviewFour.example4;\n\n/**\n * 二叉排序树\n * @author wcj\n * @Date 2020/4/14 17:17\n * @Version 1.0\n */\npublic class Node {\n\n    private Node root = null;\n    private int value;\n    private Node left;\n    private Node right;\n\n    public Node(){}\n\n    public Node(int value, Node left, Node right){\n        this.value = value;\n        this.left = left;\n        this.right = right;\n    }\n\n    public Node(int value){\n        this.left = null;\n        this.right = null;\n        this.value = value;\n    }\n\n    public int getValue() {\n        return value;\n    }\n\n    public void setValue(int value) {\n        this.value = value;\n    }\n\n    public Node getLeft() {\n        return left;\n    }\n\n    public void setLeft(Node left) {\n        this.left = left;\n    }\n\n    public Node getRight() {\n        return right;\n    }\n\n    public void setRight(Node right) {\n        this.right = right;\n    }\n\n    /**\n     * 插入节点\n     * @param value\n     * @return\n     */\n    public Boolean insert(int value){\n        //root代表根节点\n        Node p = root;\n        Node prev = null;\n        //创建一个节点\n        Node node = new Node(value);\n        //寻找节点的插入位置\n        while(p!=null){\n            prev = p;\n            if(value==p.getValue()){\n                return false;\n            }else if(value&lt;p.getValue()){\n                p = p.getLeft();\n            }else{\n                p = p.getRight();\n            }\n        }\n        if(root==null){\n            root = node;\n        }else if(value&lt;prev.getValue()){\n            prev.setLeft(node);\n        }else{\n            prev.setRight(node);\n        }\n        return true;\n    }\n\n    /**\n     * 删除某个节点\n     * 分为三种情况，待删除节点为叶子节点，则直接删除\n     * 待删除节点只有左子树或者右子树，则用左子树或者右子树替代当前节点位置\n     * 待删除节点即有左子树又有右子树，则寻找左子树最大节点或者右子树最小节点顶替当前节点(这里使用左子树的最大节点)\n     * @param value\n     * @return\n     */\n    public void deleteBST(int value){\n        deleteBST(root,value);\n    }\n\n    /**\n     * 递归删除左子树，或者右子树，或者根节点\n     * @param root\n     * @param value\n     * @return\n     */\n    public Boolean deleteBST(Node root,int value){\n        if(root==null){\n            return false;\n        }else{\n            if(root.getValue()==value){\n                delete(root);\n            }else if(value&lt;root.getValue()){\n                deleteBST(root.getLeft(),value);\n            }else{\n                deleteBST(root.getRight(),value);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * 分情况执行具体的删除逻辑\n     * @param node\n     * @return\n     */\n    public Boolean delete(Node node){\n        if(node.getLeft()==null){\n            node = node.getRight();\n        }else if(node.getRight()==null){\n            node = node.getLeft();\n        }else{\n            Node temp = node;\n            Node s = node;\n            //转向左子树，向右走到底\n            s = s.getLeft();\n            //寻找替换待删除节点的节点\n            while(s!=null){\n                temp = s;\n                s = s.getRight();\n            }\n            node.setValue(temp.getValue());\n            if(temp!=node){\n                node.setLeft(temp.getLeft());\n            }else{\n                node.setRight(temp.getRight());\n            }\n        }\n        return true;\n    }\n\n    /**\n     * 在二叉查找树中找到对应节点\n     * @param value\n     * @return\n     */\n    public Boolean searchBTS(int value){\n        Node node = root;\n        if(node==null){\n            throw new RuntimeException(\"无此节点！\");\n        }else{\n            if(value==node.getValue()){\n                return true;\n            }else if(value&lt;node.getValue()){\n                node = node.getLeft();\n            }else{\n                node = node.getRight();\n            }\n        }\n        return false;\n    }\n}\n</code></pre>\n<h2><strong>六，红黑树</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 概述：红黑树是一种特化的自平衡二叉排序树，即其左右子树的深度差可以超过1。（详细的插入等操作过段时间会补充）</strong></p>\n<h2><strong>七，图，位图</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;图的知识：定义，有向图/无向图，邻接矩阵/邻接表，BFS/DFS，位图的话没怎么搞清楚。</strong></p>\n<h3><strong>思维导图：<a href=\"https://images-cdn.shimo.im/YClQaLxx9e8uEb9U__thumbnail\" target=\"_blank\" rel=\"noopener\">数据结构</a></strong></h3>\n<h2>&nbsp;</h2>","blogGoods":0,"blogId":"1250068950784536576","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHQGAYlUxAABJTVJPTfk990.jpg","blogRead":7,"blogRemark":"面试（四）------之数据结构篇","blogTitle":"面试（四）------之数据结构篇","createdTime":"2020-04-14 14:30:37","typeName":"java面试篇","updateTime":"2020-04-23 22:14:43"}],"pageSize":10,"params":{},"sortColumn":"blog_collection","sortMethod":"ASC","totalCount":53,"totalPage":6},"msg":"操作成功!"}
2020-04-26 23:27:32.508 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/list
2020-04-26 23:27:32.508 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:27:32.509 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:27:32.509 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogList
2020-04-26 23:27:32.510 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=10, totalPage=6, totalCount=53, list=[BlogVo(blogId=1247745014683947008, blogTitle=博客开发总结（一）-----之数据库设计篇, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dDViAcnjvAACb6PL1tzA485.jpg, blogContent=<p><strong>一，数据库设计--表的命名规范等</strong></p>
<p>（1），统一采用bl_开头对表进行命名</p>
<p>（2），对于数据比较重要的表统一添加四个字段，分别为：created_time(创建时间),update_time(修改时间),version(版本号),deleted(删除字段)</p>
<p>（3），数据库表的字段尽量都设置为NOT_NULL</p>
<p>（4），数据库中表varchar类型字段需要设置长度的尽量设置为2<sup>n</sup>-1</p>
<p>（5），因为博客系统分为前台展示界面和后台管理，所以对于有些表，例如bl_type（博客类型表），bl_music（音乐表）等设置了enable（启用字段）</p>
<p><strong>二，上述第二条--四个字段的解释</strong></p>
<p>（1），为什么要设置created_time和update_time字段：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;其一，从数据库的通用性上来说，设计这两个字段是必要的，但也需要根据业务的需要来合理添加这两个字段，因为无用的字段会浪费空间，性能，影响系统的运行。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 其二，大部分的应用都有需要根据时间进行排序的功能。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 其三，当系统发生异常的时候，我们可以通过这两个字段对异常进行排查和定位。</p>
<p>（2），为什么要设置version字段：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 1，version字段含义：字段的含义与其字面意思一样，代表版本，在这里作为乐观锁进行使用，从而保证不会出现脏数据的情况。下面解释一下什么叫乐观锁，以及乐观锁和悲观锁</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 2，乐观锁：总是假定最好的情况，即每次用户调用接口从数据库中取出数据到修改数据前的过程中，不会有其它用户对当前数据进行修改，这样在当前用户修改数据的时候，利用版本机制即判断取出的version字段和当前数据库该条数据的version字段是否相等来判断该条数据是否已经被修改，如果未修改，则予以修改（且version字段递增），如果已经修改，则提示用户更新失败。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 悲观锁：总是假定最坏的情况，即每次用户调用接口从数据库取出数据的时候，都认为该条数据会被修改，因此每次取出数据都对数据进行加锁处理，只允许当前用户进行修改，其它用户阻塞，直到当前用户修改完毕。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3，为什么使用乐观锁而不使用悲观锁：因为悲观锁比较浪费性能</p>
<p>（3），为什么设置deleted字段：deleted字段在这里作为一个逻辑删除字段（0否1是），何为逻辑删除，即执行删除操作操作的时候，不会真正的删除数据库中的数据，而是将deleted字段设置为1即可。&nbsp;这样如果用户出现误删的操作，可以通过数据库修改该字段进行数据的恢复。</p>
<p><strong>三，上述第三条--数据库表字段尽量设置为NOT_NULL</strong></p>
<p>（1），数据库表字段尽量设置为NOT_NULL：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 1，有些人可能认为设置为NULL相比于NOT_NULL不是更节省空间吗？但是实际上不是这样的，设计为NULL相比于NOT_NULL要多占用一个字节的空间</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 2，设计为NOT_NULL，这样在做查询的时候能够更好的避免空指针异常，且发生该类错误的时候能够更好的进行排查</p>
<p><strong>四，上述第四条--表varchar类型字段长度尽量设置为2<sup>n</sup>-1</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>因为计算机只识别二进制，且有一定的范围，例如2<sup>8</sup>，在计算机中的范围为-128~127,因此对于varchar字段长度来说，如果设置为255，则正好是一个字节，而如果设置为256，则占用两个字节，这样会浪费计算机的内存空间，因此数据库varchar类型字段的长度最好设置为2<sup>n</sup>-1</p>
<p><strong>五，上述第五条--对于设置enable字段的解释</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>enable字段，字面意思启用，在这里表明是否启用（0否1是），因为系统分为前台博客页面和后台管理，对于这两个不同的前端项目，后台可以通过启用字段来控制内容在前台博客页面的展示与否，与deleted字段不同的是，如果执行删除操作，那么我们只能通过手动修改数据库中的字段进行数据的恢复，且如果执行删除操作，则该数据在前台博客页面和后台管理页面都无法看见。但是如果将数据弃用（即修改enable字段值为1），则表明该数据被弃用，在前台博客页面无法显示，但是在后台管理页面可以看见，且无需通过手动修改数据库来恢复数据，可以在后台管理页面操作启用数据。</p>
<p>&nbsp;</p>, blogGoods=0, blogRead=21, blogCollection=0, typeName=博客开发和维护总结, blogRemark=博客开发总结（一）-----之数据库设计篇, blogComment=0, blogSource=null, createdTime=2020-04-08 04:36:07, blogMonth=null, updateTime=2020-04-20 10:47:54), BlogVo(blogId=1247867141693128704, blogTitle=闲谈前后端分离开发, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dG6CAI6ipAACiM2P5LtI65.jpeg, blogContent=<p><strong>一，前后端分离开发优势</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，</strong>项目开发过程中，前后端完全解耦，前端只需要负责页面的实现，只需要通过接口拿数据。后端不需要管页面的跳转，只需要负责接口的编写</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，</strong>前后端人员有更多的精力去负责自己的工作，前端人员可以将更多的精力投放在页面的编写，页面的美化，页面特效的制作和用户体验上；而后端人员可以将更多的精力放在接口代码的优化，sql优化，jvm调优上面</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，</strong>前后端分离的项目部署的时候，前端项目往往都是部署在nginx服务器上，而前后端不分离的项目往往都是部署再一台服务器上。因此前后端分离项目大大降低了服务器的负担</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>4，</strong>前后端不分离的项目使用模板引擎例如freemaker，thymeleaf等，前后端人员交流起来较为困难。且前端项目使用原生的DOM操作，极大的增加了前端工作人员的工作量。而前后端分离项目前端通常都是用各种ui框架，框架采用MVVM模式，极大的减轻了前端工作人员的工作量</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，</strong>前后端分离开发，前端可以通过easy-mock来伪造接口数据进行测试，后端人员可以通过postman进行接口测试，开发效率大大提升。</p>, blogGoods=0, blogRead=7, blogCollection=0, typeName=随笔, blogRemark=前后端分离开发的优势所在, blogComment=0, blogSource=null, createdTime=2020-04-08 12:41:25, blogMonth=null, updateTime=2020-04-20 11:48:53), BlogVo(blogId=1248135765829918720, blogTitle=CSS----之flex弹性布局, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dGnuAWkLLAAAaRXQXNms575.jpg, blogContent=<p><strong>一，css之弹性布局</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，</strong>何为弹性布局？</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 弹性布局是css的一种新的布局方式，所谓&ldquo;弹性布局&rdquo;，即页面随着不同设备的屏幕大小拉伸会自适应页面的大小。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，</strong>弹性布局的两种主要元素，container（弹性容器），item（弹性子元素），一个弹性容器中可以放入多个弹性子元素，元素之间是可以进行嵌套的，弹性子元素也可以设置为弹性容器，里面再嵌套弹性子元素。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，</strong>弹性布局的基本属性</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （1）display：flex，声明容器为弹性布局</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （2）flex-direction：声明弹性容器内部元素的排列方式，默认为row。row（横向布局），row-reverse（横向布局，但是元素反方向码），column（纵向布局），column-reverse（纵向布局，但是元素反着码）。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （3）flex-wrap：声明弹性盒子中的元素是否可以换行，默认为nowrap（不换行），wrap（换行），wrap-reverse（换行，但是反着码）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （4）align-items：设置容器中元素在纵轴方向上的对齐方式，默认为stretch（即如果不设置子元素高度，则默认拉伸至于容器同宽度），flex-start（子元素位于容器的开始位置），flex-end（子元素位于容器的结尾处），center（元素依纵轴方向居中），baseline（元素位于容器基线，不过没怎么用过，所以不是很清楚）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （5）justify-content（设置元素在主轴上的对齐方式），默认为flex-start（元素从容器主轴开始位置码），flex-end（元素从容器主轴结尾处码），center（元素位于主轴居中处），space-between（元素布局在容器的两端），space-around（元素布局在容器两端，但是元素前后都留有空白）因为项目中大多数只使用了对于容器的操作，对于容器中元素的操作很少，所以这里只介绍这点。谢谢阅读！</p>, blogGoods=0, blogRead=3, blogCollection=0, typeName=CSS, blogRemark=CSS----之flex弹性布局, blogComment=0, blogSource=null, createdTime=2020-04-09 06:28:51, blogMonth=null, updateTime=2020-04-20 11:43:57), BlogVo(blogId=1248224512563068928, blogTitle=面试（一）------之JVM篇, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dHLeALxSjAABJTVJPTfk677.jpg, blogContent=<h2 style="text-align: left;"><strong>一，JVM运行机制</strong></h2>
<p>&nbsp;&nbsp; &nbsp; &nbsp;jvm即java虚拟机，一共由四个部分组成，分别是类加载器子系统，运行时数据区（程序计数器，本地方法区，jvm栈，方法区，jvm堆），执行引擎（即时编译器，垃圾收集器），本地接口库。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;一个java源程序的运行先是经过编译器将其编译成字节码文件（class文件），然后通过类加载器子系统将其加载进入jvm&mdash;&mdash;&gt;程序运行过程中，运行时数据区存放程序运行过程产生的数据&mdash;&mdash;&gt;执行引擎中的垃圾收集器收集程序运行过程中创建的不再使用的对象，即时编译器将程序的字节码文件编译成机器码&mdash;&mdash;&gt;然后本地接口库利用机器码调用本地方法库中的方法，和操作系统实现交互。</p>
<h2><strong>二，多线程</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;</strong>在多核操作系统中，jvm支持一个进程中同时并发执行多个线程，且这些线程和本地操作系统的线程相对应。当jvm中的对象初始化，内存空间分配等一系列准备工作完成之后，会调用操作系统中的接口创建一个原生线程，原生线程初始化完毕后，会调用java线程的run（）方法执行该线程，线程结束之后，jvm会释放原生线程和java线程资源。</p>
<h2><strong>三，JVM的内存区域</strong></h2>
<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM的内存区域主要分为线程私有区域（程序计数器，本地方法区，JVM栈），线程共享区（方法区，JVM堆）和直接内存。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;程序计数器：线程私有区域，无内存溢出，用来记录程序运行过程中的字节码指令地址，如果是Native方法，则程序计数器为空。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM栈：线程私有区域，用来描述java程序的运行过程，java程序运行每次运行的时候，都会创建一个栈帧，方法的执行和返回对应着栈帧的入栈和出栈操作。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;本地方法区：线程私有区域，和JVM栈的功能一样，只不过是用来记录Native方法的运行过程。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM堆：线程共享区，主要用来存放程序运行过程中产生的数据，同时也是垃圾收集器进行垃圾回收的主要区域。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;方法区：也被称为永久代，用来存放常量，静态变量，类信息等等。</p>
<h2><strong>四，JVM的运行时内存</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>JVM的运行时内存又被称为JVM堆，因为JVM的GC算法使用的是分代收集算法，所以JVM堆按照GC标准可以分为三个区域分别为：新生代，老年代，永久代。其中新生代占1/3，老年代占2/3，永久代很少，</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;新生代：存放短生命周期，小对象的区域。新生代又分为Eden区，ServivorTo区，ServivorFrom区，区域的GC算法采用复制算法。Eden区是用来存放新创建的对象（大对象除外），ServivorTo区是用来保存MinorGC幸存下来的对象，ServivorFrom区是用来将上一次MinorGC幸存下来的对象作为下一次MinorGC的扫描对象。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;老年代：存放长生命周期的大对象，区域的GC算法采用标记整理算法</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;永久代：主要用来存放class和meta数据信息的。程序运行过程中不会进行永久代的垃圾回收，这也就导致永久代区域的数据会越来越多，最终造成内存溢出。java8之后永久代已经被元数据区取代，元数据区和永久代的功能都是一样的，但是最大的不同在于永久代区域依赖于虚拟机的内存大小，因而可以存储的class，meta信息非常有限。但是元数据区依赖的是本地操作系统，因而不会受到虚拟机内存的限制。</p>
<h2><strong>五，垃圾回收与算法</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;(1)垃圾回收：</strong>Jvm的垃圾回收判定依赖于两种方法，引用计数法和可达性分析法。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;引用计数法：即如果想要在程序中使用对象，就必须赋予一个引用，这样在对象赋予引用的时候将其引用计数加1，删除一个引用时，将对象引用计数减1，如果引用计数为0，就说明该对象已经不使用，作为垃圾。但是引用计数法存在一个缺陷，即循环引用的问题，如果两个对象相互引用，则这两个对象的引用计数永远都不会为0，造成对象无法被回收。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;可达性分析法：即先创建一些根节点对象ROOTS，然后通过这些根节点对象向下搜索，如果一个对象到任意一个ROOTS之间都没有可达路径，在经过两次标记（下文解释为什么进行两次标记），还是没有可达路径，则说明该对象可回收。</p>
<p>&nbsp;&nbsp; &nbsp;<strong>（2）GC算法：</strong>常见的GC算法有四种，分别为标记清除算法，复制算法，标记整理算法，分代收集算法</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;标记清除算法：即在进行垃圾回收前，对所有对象进行一次标记，标记可回收的对象，然后进行清理即可。但是标记清除算法在清除回收对象之后，并不会对堆内存进行整理，这样的话如果内存中的对象大部分为小对象，清理之后就会导致没有大片连续的内存空间，即造成了内存碎片化，这样大对象存储的时候就无法找到相应的完整连续内存。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;复制算法：即将内存分为两块同等大小的区域，区域1和区域2，创建的新对象都存储在区域1中，当区域1中的内存占满之后，会对内存中的所有对象进行一次标记，标记存活的对象，将存活的对象复制到区域2，这时区域1中的对象都是可回收对象，回收区域1中的所有对象即可。但是复制算法也存在着一定的缺陷，即每次都只能使用一半的内存空间，造成了大量的内存浪费。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;标记整理算法：即结合标记清除算法和复制算法的优点，先对所有的对象进行标记，标记存活的对象，将存活的对象复制到内存的另一端，然后清除当前端的对象即可。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;分代收集算法：前面的三种算法，都无法按照对象的类型进行收集，分代收集算法正是解决这个问题，按照对象的不同类型采用不同的GC算法。以JVM的分代收集算法为例，JVM的堆内存分为新生代，老年代，永久代。新生代又分为Eden区，ServivorTo区和ServivorFrom区。新生代因为其存储生命周期短的小对象，GC比较频繁，所以采用复制算法。程序运行过程中创建的对象都存储在Eden区（大对象除外，大对象直接复制到老年代区域）。当Eden区的内存不够的时候进行MinorGC，然后将Eden区和ServivorFrom区的存活对象都复制到ServivorTo区，然后将ServivorTo区和ServivorFrom区进行交换，再次进行MinorGC。老年代因为存放的都是生命周期长的大对象，因而进行GC的不会太频繁，且清除的对象并不会太多，因而采用标记整理算法。老年代每次进行MajorGC之前都会先进行一次MinorGC，当MinorGC之后新生代的内存仍然不够的时候，将对象复制到老年代进行MajorGC。永久代区域主要回收常量，无用class等。</p>
<h2><strong>六，JAVA中的四种引用类型</strong></h2>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;强引用类型<strong>：</strong>即把对象赋给一个引用变量，强引用的对象一定为可达状态，所以不会进行垃圾回收。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;软引用类型：通过SoftReference类实现，当内存不够的时候对其进行GC</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;弱引用类型：只有弱引用类型的对象，一定会被GC</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;虚引用类型：虚引用对象主要是用来跟踪对象的GC状态</p>
<h2><strong>七，分代收集算法和分区收集算法</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>分代收集算法：新生代因其存放大量短生命周期小对象，且GC频繁，所以采用复制算法。老年代因其存放长生命周期大对象，且GC不平凡，所以采用标记整理算法。永久代，回收常量，类信息等。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;分区收集算法：即将堆内存区域分为大小不同的区，可以按照不同的区进行快速垃圾回收，减少系统的停顿时间。然后再以并行的方式逐步完成整个GC。</p>
<h2><strong>八，垃圾收集器</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>新生代区域：Serial垃圾收集器，单线程复制算法，因为单线程无需进行线程之间的交互和切换，所以效率非常高，是JVM默认的client模式下的默认垃圾回收策略，工作期间需要暂停其它所有的线程。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ParNew垃圾收集器，多线程复制算法，跟单线程Serial一样，是JVM默认的server模式下的垃圾回收策略，工作期间需要暂停所有其它线程</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Parallel Scavenge垃圾收集器：多线程复制算法，不同的是优先考虑系统吞吐量，可以利用更高效的利用CPU完成GC</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;老年代区域：Serial Old垃圾收集器，单线程标记整理算法，同新生代的Serial功能一样，只是采取的算法不同而已。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Parallel Old垃圾收集器：多线程标记整理算法，优先考虑了系统的吞吐量，其次考虑停顿时间。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CMS,多线程标记清除算法，优先考虑系统GC时的停顿时间，且过程分为四步（<span style="background-color: #ffff00;">解释上文的可达性分析中的两次标记</span>，第一步：标记GC ROOTS可达对象，暂停其它工作线程；第二步：和用户线程一起工作，跟踪GC ROOTS；第三步，因为第二步用户进程没有暂停，所以有些对象状态</p>
<p>可能发生了改变，重新进行标记；第四步，清除不可达对象）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; G1垃圾收集器，多线程标记整理算法，将内存分区，与CMS相比，一方面不会产生内存碎片，一方面，可以精确的控制系统停顿时间。</p>
<h2><strong>九，JAVA的网络编程模型</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;</strong>阻塞I/O模型：即用户线程发出I/O请求之后，内核会检查数据是否准备就绪，这时候用户线程始终处于阻塞状态等待数据准备就绪。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;非阻塞I/O模型：即用户线程不断的给内核发出I/O请求，内核接受到I/O请求之后会返回一个状态，如果数据准备就绪，就将数据复制进入用户线程，如果数据没有准备好，返回一个false，用户线程无需阻塞，可以去处理其它事情，而当数据准备好了且刚好用户线程发起I/O请求进行操作。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;多路复用I/O模型：多路复用I/O模型通过一个Selector线程轮询Socket的状态，如果Socket有读写事件，则进行I/O操作。此模型的优势在于可以更好的处理连接数众多但消息体不大的情况下。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;信号驱动I/O模型：即用户线程发出一个I/O请求，系统会为该请求创建一个信号函数，用户请求可继续执行其它业务逻辑，当内核数据准备就绪之后会返回给用户线程一个信号，用户线程接收到之后进行I/O操作。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;异步I/O模型：用户线程给内核发起一个asynchronous read操作，内核接收到之后，返回其请求是否成功，然后等待数据准备成功之后复制到用户线程。整个过程中请求的发起和数据读取都在内核中进行，最终发送一个信号告知用户线程I/O操作已经完成，用户直接使用数据就行。（说实话个人感</p>
<p>觉和信号驱动很像）</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;java NIO：没怎么读懂（<span style="background-color: #993300;">记得补充！</span>）</p>
<h2><strong>十，JVM的类加载机制</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>JVM类加载分为五个阶段：加载，验证，准备，解析，初始化</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;加载：即将class文件加载到JVM中，且创建class对象，封装其数据结构。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;验证：对class文件进行验证，确保符合JVM的标准，保证JVM的安全。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;准备：即方法区中给类变量分配空间和赋初值。static修改的会在初始化阶段赋值，final修饰的会在准备阶段赋值。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;解析：即将常量池中的引用替换为直接引用</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;初始化：执行类构造器进行初始化。（因为内部流程不是很清楚，所以对于其几种不进行初始化的情况不做说明）</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;类加载器：JVM提供了三种类加载器，启动类加载器（/lib），扩展类加载器(/lib/ext)，应用程序类加载器(classpath)。还可以再应用程序类加载器自定义类加载器。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;双亲委派机制：即当一个类接收到类加载请求的时候，不会自己进行加载，而是将其加载请求委派给其父类加载器，这样一路委派，最终加载请求都会委派到启动类加载器.启动类加载器接收到加载请求之后会去lib目录下寻找相关的class文件，若找不到，则将其加载请求再委培给子类加载器，一路委派，直到能够加载。</p>
<h3><strong>最后，送给大家一张博主画的JVM的思维导图，以后读《深入JVM虚拟机》的时候可能会出一个JVM专题：<a href="https://uploader.shimo.im/f/X0MX3hLaHrevltxW.png!thumbnail" target="_blank" rel="noopener">JVM思维导图</a></strong></h3>
<p>&nbsp;</p>
<h2>水平有限，若发现有误，还望指出！</h2>, blogGoods=0, blogRead=17, blogCollection=0, typeName=java面试篇, blogRemark=面试（一）------之JVM篇, blogComment=0, blogSource=null, createdTime=2020-04-09 12:21:30, blogMonth=null, updateTime=2020-04-20 11:53:29), BlogVo(blogId=1248500061625745408, blogTitle=Linux基本命令, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dDA6AfCOJAAAyfL52jxY706.jpg, blogContent=<p><strong>一，Linux的发展历史</strong></p>
<p><strong>&nbsp; &nbsp; &nbsp; </strong>1965年之前，电脑并不像现在这么普遍，除了军事机构和研究即构，一般人基本接触不到电脑，而且那时候的一台大型主机最多也就只能支持30台终端。为了解决数量问题，1965年之后，由贝尔实验室，麻省理工学院以及通用电气一起放弃了Multics项目，准备让大型主机能够支持300台终端，但是在开发过程中，进度缓慢，最终由于资金的短缺，贝尔实验室推出了研究。1969年，从这个项目中退出的Ken Thompson在家无聊，为了让电脑能够运行&ldquo;星际旅行&rdquo;游戏，因而趁着妻子回家探亲的一个月，独自写出了Unix操作系统的原型（！！！！牛批）。1970年，这个人以BCPL语言为基础，又写出了很接近硬件的B语言，并且用B语言写出了第一个Unix操作系统。但是由于B语言的跨平台性比较差，为了解决这个问题。Dennis Ritchie和Ken Thompson决定以B语言为基础开发一种新的语言，1972年，Dennis Ritchie最终设计出了一种新语言，他以BCPL的第二个字母命名，也就是我们后来熟知的C语言。随后两人便迫不及待的用C语言重现Unix操作系统。Unix系统起初开源，但是在Unix7之后，由于政策的变化，代码闭源化，因而大学中不能使用Unix的源代码进行教学。Andrew S. Tanenbaum教授为了能够让学生更好的理解代码细节，在完全不使用任何源代码的情况下开发除了Minix---小型Unix。但是因为其只用于教学，功能并不强大，因而Torvalds以此为基础，开发除了Linux，但是起初Linux并不支持Unix，最终经过全世界网友的帮助，最终让其能够兼容各种硬件。</p>
<p><strong>二，文件和目录</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp; 1，windows和linux的区别：</strong>我们熟知的windows系统，它的文件系统是分盘符的，盘符下的文件构成一个树形结构，但是Linux文件系统没有盘符，所有文件目录都在根目录/之下</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;<strong>2，Linux需要记住的目录：</strong>/bin（存放系统命令的目录），/sbin（只有超级管理员能访问的命令文件目录），/root（存放和root用户相关文件的目录），/etc（存放系统配置文件的目录），/usr（存放系统共享资源的目录），/opt（存放安装的第三方软件的目录，通常在/usr/local下）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;<strong>3，文件权限：</strong>Linux中的文件权限有读（r，可用于数字4表示），写操作（w，可用数字2表示），执行权限（x，可用数字1表示）</p>
<p><strong>三，常用命令</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，ls：</strong>列出目录中的所有目录和文件名&nbsp; -a（列出所有，包括隐藏文件和目录），-l（以列表形式列出所有），-h（人性化列出，需要配合-l使用，即文件大小转换为我们熟知的kb，mb等），-d（显示当前目录属性），命令可以联合使用，例如-al，-lh等等。&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，cd：</strong>用于切换目录，需知（.和..是相对路径，.表示当前目录，..表示上级目录；/表示绝对路径），cd ~（切换到root目录），cd - （切换到前一次切换的目录）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，clear：</strong>清屏</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，pwd：</strong>显示当前所在目录</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，mkdir：</strong>创建目录，-p（如果目录存在则不创建，如果不存在则创建目录再创建自目录），可以一次性创建多级目录，例如：mkdir&nbsp; -p test/test1</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，touch：</strong>创建空文件</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>7，cp：</strong>复制，-r（递归复制目录下的文件目录信息），-i(提示是否覆盖)，-v（显示复制进度）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>8，mv：</strong>移动文件，不过经常用来给文件进行重命名</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>9，rm：</strong>删除目录或者文件，-r（递归删除），-f（强制删除），-v（显示删除进度）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>10，cat：</strong>查看文件内部信息</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>11，ln：</strong>文件创建链接，ln 源文件 目标链接文件（创建硬链接，硬链接和源文件大小相同，修改同步，但是删除不同步，使用较少），ln -s（创建软连接，相当于我们平时创建快捷方式，使用较多）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>12，which：</strong>搜索命令所在位置，例如：which&nbsp; &nbsp;ls</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>13，find：</strong>搜索文件所在位置&nbsp; 例如：find&nbsp; &nbsp;test.conf</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>14，grep：</strong>文件内容搜索，例如：grep &ldquo;想要搜索的内容&rdquo;&nbsp; 源文件</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>15，tar：</strong>归档命令，-c（打包成.tar文件），-z（打包的同时压缩），-v（打包的同时显示进度），-f（放在最后，后面跟.tar.gz），-x(解压)，常用：tar -zcvf&nbsp; <em><strong>.tar.gz&nbsp; &nbsp; ;&nbsp; &nbsp; tar -zxvf</strong> tar.gz</em> -C&nbsp; 指定解压目录&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;还有more，head，tail等命令，不过这些不常用。</p>
<p><strong>四，用户权限命令</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，whoami：</strong>查看当前账户的用户名</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，who：</strong>查看当前登录用户</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，exit：</strong>退出登录</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，adduser/useradd：</strong>添加用户，-d（指定用户主目录），-g（指定用户用户组），-m（自动建立目录），默认情况下用户主目录和用户组名都和用户名一样</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，passwd：</strong>只有root用户才能使用，用于修改用户密码</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，userdel：</strong>删除用户，默认不删除用户的主目录，-r（删除用户主目录）</p>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;7，su：</strong>切换账户</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>8，groupadd/groupdel：</strong>添加用户组和删除用户组</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>9，groups：</strong>查看用户所在用户组，例如：groups&nbsp; 用户名</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>10，usermod：</strong>修改用户所在用户组，例如：usermod&nbsp; 用户组名 用户名</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>11，chmod：</strong>修改文件权限，例如：chmod&nbsp; 777&nbsp; test</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>12，chown：</strong>修改文件所有者，例如：chown&nbsp; &nbsp;用户&nbsp; 文件名</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>13，chgrp：</strong>修改文件所在组，例如：chgrp&nbsp; 组名&nbsp; 文件名</p>
<p><strong>五，系统命令</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，cal：</strong>查看日历</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，date：</strong>查看时间，可以设置格式，例如：date '+<span class="ql-token hljs-built_in">%Y</span>-<span class="ql-token hljs-built_in">%m</span>-<span class="ql-token hljs-built_in">%d</span> <span class="ql-token hljs-built_in">%H</span>:<span class="ql-token hljs-built_in">%M</span>:<span class="ql-token hljs-built_in">%S</span>'</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，ps：</strong>查看线程</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，kill：</strong>杀死线程，-9（强制杀死）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，查看网卡信息：</strong>centos6：ifconfig ；centos7：ip addr</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，ping：</strong>查看网址或者链接的连通性</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>7，防火墙：</strong>centos6：service&nbsp; iptables&nbsp; status（查看防火墙状态），service&nbsp; &nbsp;iptables&nbsp; &nbsp;start(开启),service&nbsp; iptables&nbsp; stop(关闭);centos7:firewall-cmd&nbsp; --state（查看防火墙状态），systemctl&nbsp; start&nbsp; firewalld.service(启动)，systemctl&nbsp; &nbsp;stop&nbsp; firewalld.service（关闭）</p>
<p><strong>六，网络命令</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，wget：</strong>下载，例如：wget&nbsp; &nbsp;链接地址</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，yum：</strong>下载安装</p>
<p><strong>七，vim（这里只说几个常用的命令）</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;</strong>vim有三种模式：命令模式，插入模式，编辑模式&nbsp; &nbsp;</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;vim&nbsp; 文件名：进入文件，且处于命令模式；iao任意一键进入插入模式（i表示在贯标之前插入，a光标之后插入，o在下一行插入），：进入编辑模式</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;命令：set:nu显示行号，set:nonu不显示行号；/strinng，向后搜索字符串，？string向后搜索字符串；：w保存，：wq保存并退出，：q不保存退出</p>, blogGoods=0, blogRead=2, blogCollection=0, typeName=Linux, blogRemark=Linux基本命令总结, blogComment=0, blogSource=null, createdTime=2020-04-10 06:36:25, blogMonth=null, updateTime=2020-04-20 10:42:25), BlogVo(blogId=1248605157059497984, blogTitle=面试（二）------之JAVA基础篇, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dHMKAcvZ8AABJTVJPTfk020.jpg, blogContent=<h2><strong>一，集合</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，List：</strong>list是java中一种有序的集合，下有三个实现类，分别为ArrayList，Vector，LinkedList</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ArrayList：基于数组实现，增删慢，查询快，线程不安全。因为其基于数组实现，所以查询的时候可以直接根据数组的索引下标进行快速查询，但是进行增删操作的时候，需要将待增删元素后的元素全部移动，因而效率较低。且ArrayList创建时不需要分配初始大小，其空间不够的时候，会自动创建一个更大的list，然后复制数据。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Vector：基于数组实现，和ArrayList一样增删慢，查询快。但是线程安全，因为同一时间只支持一个线程对Vector进行写操作，然而因为要进行频繁的加锁和释放锁的操作，所以效率要低于ArrayList。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; LinkedList：基于双向链表实现，增删快，查询慢。因为基于链表实现，增删元素的时候，只需要改变元素的指针即可，改动较小，效率较高。然而进行查询操作的时候，需要从链表头部进行遍历，因而效率较低。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，Queue：</strong>队列，满足先进先出，种类较多。（不作详细解释）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，set：</strong>具有独一无二的特性，常用来存储无序且不重复的元素，对象相等的本质是hashcode的值相同，而如果想要比较两个对象是否相等，需要重写对象的hashcode方法和equals方法。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;hashset：基于hashTable实现，无序。存放的是对象的散列值，即通过hashcode计算得到的值</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;treeset：基于二叉树实现，即其中的对象按照一定的排序方式进行排列（升序，降序），每次添加对象的时候，都会进行排序，将其插入指定位置。基本的数据类型例如Integer，String等可以使用treeset默认的排序方法，而自定义数据类型需要实现compareable接口，实现compareTo方法。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;LinkHashSet：继承自hashset，只不过使用双向链表记录数据的顺序。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，map：</strong>一种键值对形式的集合</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;hashmap：基于数组+链表实现，增删改查操作快，但是每次遍历hashmap元素的顺序无法保证且线程不安全。如果想要其线程安全，可以使用synchronizedMap和ConcurrentHashmap，hashmap的内部是数组，数组中的每一个元素又是一个单向链表，链表中的每个元素嵌套一个Entry实例，其中包括Key，Value，Hash值，指向下一个节点的next。每次查询的时候，可以根据元素的hash值很快定位所在数组，但是定位之后需要遍历链表查找元素，因而时间复杂度为O（n），但是Java8之后对其进行了优化，将其改为了数组+链表或红黑树的结构，即当链表中的元素大于8个的时候，链表会转换为红黑树（红黑树是一种特化的二叉平衡树，因为其左右子树的深度差可以大于1），这样查询的时间复杂度就缩短到了O（logN）。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ConcurrentHashmap：采用分段锁的思想进行并发操作，因而使线程安全的。由多个Segment组成，只要保证每个Segment线程安全就可以保证全局线程安全。ConcurrentHashmap的默认Segment即并发度为16，可以在初始化的时候修改，但是初始化之后不能再修改。每个Segment内部的实现和hashmap一样&middot;。Java8之后也和hashmap进行了一样的优化。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;HashTable：线程安全，即同一时刻只能有一个线程对其进行操作，并发度不如ConcurrentHashmap。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;TreeMap：基于二叉树数据结构实现，实现了SortedMap，默认按照键值的升序进行排列。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;LinkedHashMap：Hashmap的子类，只不过使用链表保存元素的插入顺序。使用迭代器遍历的时候按照插入顺序遍历。</p>
<h2><strong>二，异常分类及处理</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;1，异常分类：</strong>Throwable是所有异常类的父类，其下有error和Exception，Error下有AwtError，ThreadDeath；Exception下有RuntimeException和CheckedException。</p>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</strong>对于Error类异常通常是由内部错误和资源耗尽造成的，无法在程序运行期间对其进行捕获和处理，对于这类错误我们只能记录错误的原因和终止程序。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; Exception中的RuntimeException异常（运行时异常）：这类异常是我们程序中异常处理的核心，可以在程序中进行捕获并处理。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Exception中的CheckedException异常（检查异常）：这类异常时程序中需要强制捕获的异常，通常有IO异常，SQL异常等等。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，异常处理：</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>异常处理有两种方式：抛出异常和捕获异常</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;抛出异常有三种方法：throws，throw，系统自动抛出。其中throws是作用在方法上，后面跟的是可能产生的异常类。throw是作用在方法内部，后面跟的是具体的异常对象。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 捕获异常：即使用try{}catch语句进行捕获</p>
<h2><strong>三，反射机制</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，什么叫做反射机制？</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>即在程序运行的过程中，可以获取类的属性和方法，并且可以调用任意一个类的方法。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，反射机制的使用</strong></p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 首先，获取类的class对象，有三种方式，className.getClass()，类对象.class，Class.forName("类路径")，其中最后一种最为安全，性能最好。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 然后利用反射的API可以实现对类中信息的操作，例如getDeclareFields（），getDeclareMethods（），getConstroctors（）等等。反射创建类的对像有两种方法，一，class.newInstance()初始化一个类实例；二，先获取其构造器，然后利用构造器初始化一个实例。利用反射调用类的方法：先获取方法，然后调用method.invoke()执行方法。</p>
<h2><strong>四，注解</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，四种元注解：</strong>@Target（指定注解的使用范围），@Retention（定义注解的保留级别，有三级，SOURCE源程序中保存，CLASS文件中保存，RUNTIME运行时保存），@Documented（可以工具文档化），@Inherited（<span style="background-color: #ffff00;">这个没怎么看懂</span>）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，注解使用示例：</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>第一步，定义注解接口</p>
<pre class="language-java"><code>@Target(ElementType.FIELD)  
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FruitProvider {

    //id
    public int id() default  -1;

    //供应商名称
    public String name() default "";

    //供应商地址
    public String address() default "";

}</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 第二步，使用注解</p>
<pre class="language-java"><code>public class Apple {

    @FruitProvider(id = 1,name = "红富士苹果",address = "陕西")
    private String appleProvider;

    public String getAppleProvider() {
        return appleProvider;
    }

    public void setAppleProvider(String appleProvider) {
        this.appleProvider = appleProvider;
    }
}</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第三步，定义注解处理器</p>
<pre class="language-java"><code>public class FruitInfoUtil {
    public static void getFruitInfo(Class&lt;?&gt; clazz) {
        String strFruitProvider = "供应商信息:";
        Field[] declaredFields = clazz.getDeclaredFields();
        for (int i = 0; i &lt; declaredFields.length; i++) {
            if (declaredFields[i].isAnnotationPresent(FruitProvider.class)) {
                FruitProvider annotation = declaredFields[i].getAnnotation(FruitProvider.class);
                strFruitProvider += annotation.id() + "," + annotation.name() + "," + annotation.address();
                System.out.println(strFruitProvider);
            }
        }
    }
}</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第四步，主方法入口</p>
<pre class="language-java"><code>public class FruitRun {
    public static void main(String[] args) {
        FruitInfoUtil.getFruitInfo(Apple.class);
    }
}</code></pre>
<h2><strong>五，内部类</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 1，静态内部类：</strong>即在类的内部定义的静态类，静态内部类可以访问外部了的静态变量和方法，外部也可以通过outClassName.innerClassName调用内部类</p>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2，成员内部类：</strong>在类的内部定义的没有用static修饰的内部类，使用方式和静态内部类一样。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>3，局部内部类：</strong>即一个类只在一个方法中使用，则完全可以将这个类定义为这个方法的内部类，即局部内部类，局部内部类可以实现真正的对外隐藏</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>4，匿名内部类：</strong>通常用于继承一个类或者实现一个接口的时候，使用new关键字定义，例如:Person person = new Student(){new Pupil(){}}</p>
<h2><strong>六，泛型</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 1，为什么要使用泛型：</strong>其根本目的是为了实现代码的复用，举个开发中常见的例子，我们需要定义返回类Result，返回类中包含状态码code，信息msg，以及数据data（任意类型），这个时候我们就需要使用泛型，因为我们返回的数据类型有各种vo，pojo类对象，list等。这时候泛型类result就可以被各种对象使用，实现代码的复用，简化开发。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>2，泛型标记和泛型限定：</strong>E表示集合中的元素，K表示键值，V表示value，N表示数值类型，T表示任意类型（包含基础类型，所有的对象类型），？（不确定的java类型）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>泛型限定：</strong>向上限定，&lt;?&nbsp; extends T&gt;，向下限定，&lt;? super&nbsp; T&gt;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; <strong>3，泛型方法：</strong>即参数类型定义为泛型类型，以便于接收不同类型的参数，做出不同的处理。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>4，泛型类：</strong>例如public class Pair&lt;T&gt;{private T data;}</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>5，泛型接口：</strong>与放泛型类类似</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>6，类型擦除：</strong>即在泛型编译的过程中，会将泛型类型替换为限定类型的操作</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>7，明确的一点：</strong>虚拟机在运行程序的过程中，内部是没有泛型的，只有普通的类和方法。</p>
<h2><strong>7，序列化</strong></h2>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 序列化是为了确保对象及其状态的持久化</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>序列化的使用：</strong></p>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </strong>首先，实现序列化接口java.io.Serializble</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 然后，声明序列化ID，通常private static final&nbsp; long&nbsp; serialVersionUid&nbsp; = ***</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 因为序列化是保证对象及其状态的持久化，而静态变量是不属于对象，属于类本身的，所以序列化无法保存静态变量。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果需要序列化父类变量，则父类也要实现Serializable接口</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t'ransient修饰的属性不会序列化</p>
<h3><strong>最后，提供一张思维导图供大家学习：<a href="https://images-cdn.shimo.im/es83SQH0CggucT7f__thumbnail" target="_blank" rel="noopener">JAVA基础</a></strong></h3>
<p>&nbsp;</p>
<h2>水平有限，如有错误，还望指出！</h2>, blogGoods=0, blogRead=27, blogCollection=0, typeName=java面试篇, blogRemark=面试（二）------之JAVA基础篇, blogComment=0, blogSource=null, createdTime=2020-04-10 13:34:02, blogMonth=null, updateTime=2020-04-20 11:53:39), BlogVo(blogId=1249313090567143424, blogTitle=面试（三）------之并发编程篇（上）, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dHM2AQOeZAABJTVJPTfk967.jpg, blogContent=<h2><strong>一，JAVA线程的创建方式</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>JAVA线程的创建有四种方式，分别为，继承Thread类，实现Runable接口，实现Callable&lt;Class&gt;接口，基于线程池。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>1，继承Thread方式：创建一个类继承Thread类，创建类的实例对象，调用start方法，继而执行线程的run（）方法，代码如下：</strong></p>
<pre class="language-java"><code>public class NewThread extends Thread{
    public static void main(String[] args) {
        NewThread thread = new NewThread();
        thread.start();
    }
    @Override
    public void run(){
        System.out.println("create  a  new thread by Thread!");
    }
}</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>2，当子类已经继承了一个类，这时候就没法再继承Thread类了，这时候就可以实现Runable接口，实例化类的线程实例，创建Thread实例传入类的实例，执行start方法，继而执行run（）方法代码如下：</strong></p>
<p>&nbsp;</p>
<pre class="language-java"><code>public class ThreadExample2 implements Runnable {
    public static void main(String[] args) {
        ThreadExample2 threadExample2 = new ThreadExample2();
        Thread thread = new Thread(threadExample2);
        thread.start();
    }
    @Override
    public void run() {
        System.out.println("create a new thread by Runnable!");
    }
}</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，有些情况下，我们需要再一个主线程中并发多个子线程执行同一个任务，然后回收子线程的返回值整理汇总，这时候就需要实现Callable&lt;Class&gt;接口，重写其call（）方法，用于计算结果。然床创建一个线程池用于提交线程，继而执行call方法，并且创建一个Future的list用于接收子线程逻辑代码即call方法的返回，最终遍历list，得到想要的返回值，如下：</strong></p>
<pre class="language-java"><code>public class ThreadExample3 implements Callable&lt;String&gt; {

    private String name;

    public ThreadExample3(String name){
        this.name = name;
    }

    @Override
    public String call() throws Exception {
        return name;
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService pool = Executors.newFixedThreadPool(3);
        List&lt;Future&gt; list = new ArrayList&lt;&gt;();
        for(int i=0;i&lt;3;i++){
            ThreadExample3 threadExample3 = new ThreadExample3(i+"");
            Future future =pool.submit(threadExample3);
            System.out.println(future.get().toString()+" is running");
            list.add(future);
        }
        pool.shutdown();
        for (Future future : list) {
            System.out.println("currentThread's result is "+future.get().toString());
        }
    }
}</code></pre>
<p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，基于线程池创建线程</strong></p>
<pre class="language-java"><code>public class ThreadExample4 {
    public static void main(String[] args){
        ExecutorService pool = Executors.newFixedThreadPool(3);
        for(int i=0;i&lt;3;i++){
            pool.execute(new Runnable() {
                @Override
                public void run() {
                    System.out.println("thread  is running by FixedThreadPool");
                }
            });
        }
        pool.shutdown();
    }
}</code></pre>
<h2>二，线程池的工作原理</h2>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong> &nbsp;1，概述：</strong>JVM根据用户提供的参数创建一定数量的线程任务，将其放入队列中，线程创建之后启动这些任务，如果线程的数量大于核心线程数量（用户设置的线程数量），则超出数量的线程排在队列中等待，当有线程任务执行完毕后，线程池调度器就会发现有可用可用线程，继而从队列中取出任务继续执行<strong>。</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; </strong><strong>2，线程复用：</strong>（参见JDK源码解读，这里只做简单描述），由前可知，JVM会根据用户提供的参数创建一定数量的线程任务，且将其添加到任务队列中。JVM通过start（）方法创建一个线程之后， 会相应的为其创建一个任务队列，线程会不停的查看任务队列，如果任务队列中有任务，则调用run方法，执行，这样就达到了一次start（）创建线程，多次使用，完成线程复用的任务。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>3，线程池的核心组件和核心类（见JDK源码分类中关于线程的总结）</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; </strong><strong>4，JAVA线程的工作流程：</strong>线程池刚被创建的时候，只是向系统申请一个执行线程队列和管理线程池的线程资源，当调用execute方法之后，执行下列流程：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果正在运行的线程数量小于corePoolSize（核心线程数量，即用户定义的的线程数量），则立即创建线程执行线程任务</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果正在运行的线程数量大于或等于corePoolSize，则将超过数量的线程加入到阻塞队列中</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在阻塞队列已满且线程数量小于MaximumPoolSize（即线程池能够容纳的最大线程数），线程池会创建非核心线程立即执行任务</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在阻塞队列已满且线程数量大于或等于MaximumPoolSize的时候，线程池会拒绝该线程任务且抛出异常</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在线程任务执行完毕之后，会将其从任务队列中移除，从队列中取出下一个线程任务执行</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在线程处于空闲状态且空闲时间超过KeepAliveTime，且线程数量大于corePoolSize的时候，会停止该线程，这样在没有任务的时候，线程池中的线程数始终维持在corePoolSize。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，线程池的拒绝策略：</strong>分为四种，分别为AbortPolicy，CallerRunsPolicy，DiscardOldestPolicy，DiscardPolicy</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; AbortPolicy：直接抛出异常，阻止线程运行，源码如下：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</p>
<pre class="language-java"><code>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
            throw new RejectedExecutionException("Task " + r.toString() +
                                                 " rejected from " +
                                                 e.toString());
        }</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CallerRunsPolicy：如果线程任务没有关闭，则尝试执行该线程任务，源码如下：</p>
<pre class="language-java"><code>* @param r the runnable task requested to be executed
* @param e the executor attempting to execute this task
*/
public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
     if (!e.isShutdown()) {
         r.run()
     }
}</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DiscardOldestPolicy：移除任务队列中最早进入的线程任务，执行当前任务线程，源码如下：</p>
<pre class="language-java"><code>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
       if (!e.isShutdown()) {
           e.getQueue().poll();
           e.execute(r);
       }
}</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DiscardPolicy：直接丢弃线程任务，不做任何处理</p>
<h2><strong>三，五种常用的线程池</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;newCachedThreadPool（可缓存线程池）：</strong>当线程池创建线程的时候如果发现有可复用的线程（执行完任务，且未关闭的线程），则直接复用，如果没有则创建新线程。可缓存线程池可以高效的利用执行任务时间短的线程，提高系统的性能，且线程池中的线程如果空闲时间超过60s，则会被终止且从缓存中移除，这样可缓存线程池不会占用系统资源。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>newFixedThreadPool（固定大小的线程池）：</strong>即线程池中的线程是初始化固定的，当任务线程大于线程池中线程数量时，任务线程就会进入阻塞队列等待。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newScheduledThreadPool（可做任务调度的线程池）：</strong>即可以设置线程执行的停顿时间和执行周期，进行定期定时的执行某个任务。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newSingleThreadPool（单个线程的线程池）:&nbsp;</strong>即线程池中永远只有一个线程进行工作，如果下称停止或者异常，则线程池创建新的线程替代当前线程</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newWorkStealingPool（足够大小的线程池）：</strong>即创建足够数量的线程的线程池，保证更快的进行运算，提高效率。</p>
<h2><strong>四，线程的生命周期</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;线程的生命周期大致分为五个阶段：新建（new），就绪（Runnable），运行（Running），阻塞（Blocked），死亡（Dead）</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;新建：</strong>即使用new创建一个线程</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>就绪：</strong>调用start方法，</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>运行：</strong>即线程获取cpu资源，执行run（）方法，进入运行状态，运行状态的线程如果调用yield（线程让步方法）或者失去cpu资源，都会导致线程重新回到就绪态；如果调用sleep方法，I/O阻塞，等待同步锁，等待通知以及suspend挂起都会导致线程进入阻塞态。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞：</strong>即线程被放入Blocked池。阻塞状态的线程如果结束了sleep方法，I/O方法返回，获取同步锁，收到通知或者resume都会导致其重新进入就绪态，与其它线程竞争cpu时间片。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>死亡：</strong>线程正常执行完run（）或者call（）方法，或者执行stop方法，或者发生异常或者错误都会导致线程死亡。（stop方法会导致锁混乱和死锁，不建议使用）</p>
<h2><strong>五，线程的基本方法</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;wait（线程等待）：</strong>会让线程进入WAITING状态，并且会释放对象的锁。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>sleep（线程睡眠）：</strong>会让线程进入睡眠，进入TIMED_WAITING状态，但是不会释放对象锁，睡眠时间到了之后，再次恢复运行状态</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>yield（线程让步）:</strong>&nbsp; 当前线程会让出其占有的cpu资源，重新回到就绪态和其它线程竞争cpu时间片</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>interrupt（线程中断）:&nbsp; </strong>中断当前线程，但是并不会导致其停止，只是改变其内部的终端标识位，在使用了thread.sleep()之后使用该方法，会导致抛出异常，且我们可以利用中断标识位进行线程的安全退出</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>join（线程加入）：</strong>即将当前线程进入阻塞态，等待下一个线程执行完毕后进入就绪态，重新竞争锁资源。通常用于主线程下面执行子线程，需要主线程阻塞，等待子线程执行完毕后返回其结果给主线程，主线程再执行的情况。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>notify（线程唤醒）/notifyAll：</strong>前者随机唤醒一个等待线程，后者全部唤醒</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>setDaemon（守护线程）:</strong>级别较低的线程，用于后台运行，服务用户用户线程，例如垃圾收集线程就是典型的守护线程。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>sleep方法和wait方法的区别：</strong>前者属于Thread，后者属于Object，前者不会释放锁资源，后者会释放锁资源</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>start方法和run方法：</strong>start方法只是创建一个线程，并没有运行，run方法时执行线程的真正代码逻辑。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>线程退出的方式：</strong>见四中最后一条</p>
<h2><strong>六，JAVA中的锁（知识比较杂乱）</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述:JAVA中的锁是为了保护数据的一致性。按照不同的标准可分为乐观锁和悲观锁，公平锁和非公平锁，共享锁和独占锁，偏向锁，轻量级锁，重量级锁，自旋锁，可重入锁。</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;乐观锁：</strong>即认为每次读取数据都不会被修改，当修改操作的时候再判断当前数据是否被修改，未修改则修改，若已被修改，则返回失败状态。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>悲观锁：</strong>即认为每次读取数据都会被修改，因而每次读取数据都对其进行加锁，这样只有当前用户可以修改，其它用户阻塞等待直到当前用户修改完毕释放锁资源。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>自旋锁：</strong>即有些线程任务的执行很短，很快就可以释放锁资源，为了避免在这种情况下竞争线程仍然进行内核态和用户态之间的转换，因而让线程自旋（即等一会），如果有可用锁，则获取，减少了线程在用户态和内核态之间切换的时间损耗。提高了性能（优势）。当然线程自旋是占用cpu资源的，因而需要设置一个自旋的最大等待时间，如果超过此时间，则线程退出自旋模式。对于线程竞争锁资源激烈的情况，自旋有可能会导致cpu资源的损耗（劣势）。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>公平锁和非公平锁：</strong>即根据线程竞争锁资源的机制判定，一般如果依据先到先得的原则，则位公平锁；如果依据就近原则，则位非公平锁。公平锁相比于非公平锁会更加耗费性能，因为要维护一个线程任务丢列，根据线程任务在队列中的顺序分配锁资源，因而不常用。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>可重入锁：</strong>又被称为递归锁，即该锁可以然后线程对其进行多次的加锁操作。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>偏向锁：</strong>当线程获取到锁的时候，用来消除线程的锁重入的开销（看起来是偏袒这个线程）。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>共享锁和独占锁：</strong>共享锁即多线程共享锁资源（典型例子，读锁）；独占锁即当前锁只能有一个线程获取，其它线程阻塞</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>轻量级锁：</strong>没有多线程竞争的前提下，减少重量级锁的使用提高性能。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>重量级锁：</strong>基于操作系统的互斥量而实现的锁，会导致进程在用户态和内核态之间切换，耗费性能。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>synchronized：独占式悲观锁，可重入锁，非公平锁，重量级锁。</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 作用范围：</strong>作用于成员变量和非静态方法，相当于锁住的是对象的实例，即this对象</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;作用于静态方法，相当于锁住的是class实例</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;作用域代码块，相当于锁住的代码块中的对象</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>实现原理：</strong>内部包括ContentionList（锁竞争队列），EntryList（竞争候选列表），WaitSet（等待集合），OnDeck（竞争候选者），Owner，!Owner，其中ContentionList是用来存放竞争锁资源的线程。EntryList是用来存放有资格竞争锁资源的线程。调用wait方法后放入WaitSet中，onDeck指的是同一时刻，只有一个线程竞争锁资源，Owner指的是得到锁资源的线程，!Owner指的是线程执行完毕，释放锁资源的线程。需要注意的是线程首先采用的都是自旋模式获取锁资源，如果自旋获取不到再加入ContentionList，而且Owner状态的线程并不是直接把锁资源交给onDeck状态线程，而是给它竞争锁资源的权利，因而onDeck状态的线程还需要跟自旋线程竞争锁资源。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>ReentrantLock：独占式，可重入锁，并且可以实现公平锁和非公平锁，重量级锁。</strong></p>
<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;用法：</strong>lock()加锁，后跟try代码块，finally中进行释放锁unlock()</p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;避免死锁的方法：</strong>响应中断（即可以根据情况中断对锁资源的请求），可轮询锁（tryLock（）即尝试获取锁，如果有可用锁则获取返回true，没有则返回。和lock（）的区别在于lock获取锁资源如果没有则一直等待直到获取到锁资源），定时所（tryLock（time,unit）即再一定时间内如果有可用锁，且线程未中断则获取锁，否则禁用当前线程。）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>Semaphore（信号量）:</strong>机制和ReentrantLock类似</p>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ReadWriteLock（读写锁）：</strong>如果系统要求支持多线程共享读，但不能多线程写，使用读锁；如果要求同一时刻只能有一个线程写，写的过程中不能读取该共享数据，则使用写锁。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; <strong>分段锁：</strong>一种思想，将数据分段加锁，例如ConcurrentHashMap</p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;死锁：</strong>即线程之间互相共享资源会导致死锁</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; <strong>锁优化：</strong>第一，减少锁的持有时间；第二：减小锁粒度，例如分段锁；第三：锁分离，例如读写锁；第四：锁粗化，放置锁粒度太小，造成频繁加锁释放锁；第五：锁消除，消除程序代码不规范而造成的乱用了锁</p>
<p>&nbsp;</p>
<h3><strong>并发编程（上）的思维导图送上：<a href="https://images-cdn.shimo.im/1UcHkyrlJyGRPYnn.png__thumbnail" target="_blank" rel="noopener">并发编程（上）</a></strong></h3>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>
<h1>水平有限，如果错误，还望指出！</h1>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;</p>, blogGoods=0, blogRead=8, blogCollection=0, typeName=java面试篇, blogRemark=面试（三）------之并发编程篇（上）, blogComment=0, blogSource=null, createdTime=2020-04-12 12:27:07, blogMonth=null, updateTime=2020-04-20 11:53:51), BlogVo(blogId=1249588251598041088, blogTitle=redis基础（一）, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6caUuADBI7AAAb07iHSRw500.jpg, blogContent=<h2><strong>一，redis简介</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>redis是NoSQL型系统之一，与之相似的还有Memcache，用来存储key-value这种键值型数据。相比于Memcache而言，redis不仅可以做临时缓存，还可以做数据持久化，将数据定时的存入硬盘或者将命令追加到日志文件当中。而Memcache只能做临时缓存，因而现在基本上已经被redis完全取代。redis的读写速度非常快，官方给出的数据是读110000次/s，写81000次/s；而且redis支持多种数据类型，例如String，list，hash，set，zset；redis支持主从复制（集群），进行数据持久化；还支持过期时间，事务等。</p>
<h2><strong>二，redis的安装与启动（docker环境下）</strong></h2>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;docker安装完毕后，安装redis：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第一步：拉取redis镜像，docker&nbsp; pull&nbsp; redis</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第二步：启动redis，docker&nbsp; &nbsp;run&nbsp; &nbsp;redis&nbsp; &nbsp;</p>
<p><strong>三，基本知识串讲</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>单进程单线程：redis只有一个进程，且内部为单线程，这样做的优势是不存在线程安全问题，且不需要进行线程间的切换，提高了性能，而且多线程可能会涉及到锁。劣势是无法发挥多核cpu的优势，不过可以通过开启搭建多个redis实例实现</p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>redis中默认有16个数据库（0-15），可以通过select n来进行数据库之间的切换</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;常用的基本命令：flushDB（清空当前数据库），flushAll（清空所有数据库），dbSize（查看有多少数据库）</p>
<h2><strong>四，redis基本数据类型</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;string：</strong>字符串类型，数据库中存储Map&lt;String,String&gt;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>list：</strong>列表数组类型，数据库中存储Map&lt;String,List&lt;Object&gt;&gt;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>hash：</strong>哈希类型，数据库中存储Map&lt;String,Map&lt;Object,Object&gt;&gt;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>set：</strong>集合类型，其中元素无序，数据库中存储Map&lt;String,Set&lt;Object,Object&gt;&gt;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>Zset：</strong>有序集合类型，每个元素都有一个可用于排序的权重</p>
<h2><strong>五，redis相关命令（这里详解一些常用的命令，不常用的一笔带过）</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;string：</strong>(1)set&nbsp; key&nbsp; value,插入一条数据&nbsp; （2）mset&nbsp; key value...批量插入 （3）setnx&nbsp; key value&nbsp; 若无则插入（4）get&nbsp; key&nbsp; 获取某条数据&nbsp; （5）mget keys 批量获取&nbsp; （6）getrange key&nbsp; 0 -1获取数据库全部数据&nbsp; （7）incr age 递增&nbsp; (8) incrby&nbsp; age&nbsp; 10&nbsp; 递增 age 步长为10（9）decr&nbsp; age&nbsp; 递减&nbsp; （10）decrby&nbsp; age&nbsp; 10 步长递减&nbsp; &nbsp;（11）del&nbsp; key&nbsp; 删除某条数据&nbsp; <span style="background-color: #ffff00;">（12）exists&nbsp; key&nbsp; 判断是否存在某个key&nbsp; &nbsp;(13)expire&nbsp; key&nbsp; 10&nbsp; 设置过期时间（单位为秒）&nbsp; （14）pexpire&nbsp; key&nbsp; 1000 设置过期时间，单位为毫秒&nbsp; （15）persist key删除过期时间 （</span><span style="background-color: #ffff00;">16）ttl&nbsp; key&nbsp; 查看过期时间</span></p>
<p><span style="background-color: #ffff00;">&nbsp;<span style="background-color: #ffffff;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>list：&nbsp;&nbsp;</strong>（1）lpush&nbsp; key&nbsp; value 左插入一条数据&nbsp; &nbsp;（2）lpush mylist&nbsp; key&nbsp; value....批量左插入&nbsp; （3）rpush&nbsp; key value 右插入一条数据&nbsp; (4)rpush&nbsp; mylist&nbsp; key value...右批量插入&nbsp; （5）lrange&nbsp; mylist&nbsp; 0&nbsp; -1&nbsp; 取出数据集合&nbsp; （6）lpop mylist 左弹出集合中第一条数据&nbsp; （7）rpop&nbsp; </span></span><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">mylist&nbsp; 右弹出集合中第一条数据&nbsp; （8）llen&nbsp; mylist&nbsp; 获取数据集合长度lrem&nbsp; mylist&nbsp; count&nbsp; value&nbsp; （count&gt;0,从表头开始搜索，移除count个与值与value相等的元素；count&lt;0,表尾开始；count=0，移除所有值与value相等的元素） （9）linsert mylist&nbsp; before/after&nbsp; a&nbsp; 在a元素前或后插入。</span></span><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">(10) lpoplpush&nbsp; list&nbsp; list1 转移列表的元素到另一个列表</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>hash：</strong>（1）hset&nbsp; key&nbsp; &nbsp;val-key&nbsp; val-val&nbsp; 插入一条数据&nbsp; （2）hset&nbsp; myhash&nbsp; name&nbsp; xxx&nbsp; 用于给哈希表中的字段赋值，不存在则创建哈希表赋值，存在则覆盖旧值&nbsp; (3) hget&nbsp; &nbsp;myhash&nbsp; name&nbsp; 取哈希表中某个值&nbsp; （4）hmset&nbsp; myhash name&nbsp; xxx age xxx&nbsp; 批量插入字段&nbsp; （5）hmget</span></span><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">批量获取 （6）hgetall&nbsp; myhash&nbsp; 获取哈希表中所有值&nbsp; (7)&nbsp; hexisets myhash&nbsp; name&nbsp; 判断哈希表中是否存在name字段&nbsp; （8）hsetnx&nbsp; myhash score 100 若存在则不插入，若不存在则插入数据&nbsp; （9）hincrby&nbsp; myhash id 1/hdecrby&nbsp; myhash id&nbsp; 10 递增递减 （10）hdel&nbsp; myhash name&nbsp; </span></span><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">删除&nbsp; （11）hkeys&nbsp; myhash&nbsp; 只取key值&nbsp; （12）hvals&nbsp; myhash&nbsp; 只取value值&nbsp; （13）hlen&nbsp; myhash 获取哈希表长度</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>set：</strong>（1）sadd myset&nbsp; redis&nbsp; 添加一条数据&nbsp; （2）smembers myset&nbsp; 获取数据集合&nbsp; （3）srem&nbsp; myset&nbsp; set1&nbsp; 删除set1&nbsp; （4）sismember myset&nbsp; set1 判断set中是否存在set1&nbsp; (5)srandmember&nbsp; key count&nbsp; 随机获取count个元素（6）spop&nbsp; 从集合中弹出一个元素</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>zset：</strong>之后补充</span></span></p>
<h2><strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">六，redis配置文件（常见配置）</span></span></strong></h2>
<p><strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;daemonize no：</span></span></strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">redis默认不是以守护进程的方式运行的，可以更改为yes启用守护进程（即后台运行）</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>pidfile&nbsp; /var/run/redis.pid&nbsp; :</strong>启用守护进程后，默认将pid写入/var/run/redis.pid文件，可以更改</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>port&nbsp; 6379 ：</strong>redis默认端口</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp; &nbsp; &nbsp; &nbsp; <strong>bind&nbsp; 127.0.0.1：</strong>绑定的主机地址</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;"> &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>timeout&nbsp; 300</strong><strong>：</strong>redis客户端闲置多长时间后关闭连接，改为0的话，表示关闭该功能</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>loglevel&nbsp; verbose：</strong>默认日志级别（还有debug，notice，warning）</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>database 16：</strong>redis默认有16个数据库可以修改</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>save&nbsp; 900&nbsp; 1/save&nbsp; 300&nbsp; 10/save&nbsp; 60&nbsp; 10000：&nbsp;</strong>表示一定时间内有多少条数据发生修改，就将其同步到数据文件一次，例如第一个表示15分钟内有一条数据发生改变就同步</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>rdbcompression yes&nbsp; ：</strong>表示数据存储到本地数据库时是否进行压缩</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>dbfilename&nbsp; dump.rdb：</strong>指定本地数据库文件名</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>dir&nbsp; /...../redis安装目录/bin ：</strong>本地数据库存放目录，默认在redis安装目录的bin目录下</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>slaveof&nbsp; &nbsp;masterip&nbsp; masterport ：</strong>设置当本机为从机时，它的主机的ip和端口</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>masterauth&nbsp; &lt;master-password&gt;：</strong>当master服务设置了密码时，slav服务连接master的密码</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>requirepass&nbsp; foobared：</strong>默认关闭redis连接需要密码，当给redis设置了密码，就需要打开</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>maxclients&nbsp; &nbsp;128：</strong>redis同一时间最大连接客户端的数量</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>appendonly&nbsp; &nbsp;no：</strong>是否开启aof持久化，默认不开启，采用rdb</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>appendfilename&nbsp; appendonlu.aof：</strong>指定aof持久化的文件名</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>appendfsync&nbsp; everysec :</strong>指定更新日志条件，默认每秒更新一次（还有no，指等操作系统进行数据缓存到磁盘，快；always指每次更新操作后都手动写入磁盘，慢但安全）</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;虚拟机方面的配置暂不说明</span></span></p>
<h2><strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">七，redis持久化</span></span></strong></h2>
<p><strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;概述：</span></span></strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">redis持久化主要有两种方式，即rdb和aof</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>rdb：</strong>适用于大数据集的恢复，数据的备份，但是因为设置周期时间进行数据的快照，所以如果redis宕机，可能会丢失最后一个写操作的数据，因为数据完整性较差。数据保存在dump.db文件中，只需要移动到redis安装目录，重启即可恢复数据</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>aof：</strong>适用于对数据的完整性要求较高的情况，因为可以设置不同的持久化策略，例如每秒保存一次，这样即时redis宕机，也只会丢失最后一秒的数据。但是因为其日志文件存储的是写入命令，因而其文件大小要大于rdb的数据文件，且每次重启，都要从头执行数据文件中的命令，因而恢复速度也</span></span><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">要慢于rdb。</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>注意：</strong>当rdb和aof同时开启的时候，redis重启，默认会采用aof的形式进行数据的重新构建</span></span></p>
<h2><strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">八，redis事务</span></span></strong></h2>
<p><strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;概述：</span></span></strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">什么是事务？事务即是一系列的命令要买全部执行，要么全部回滚</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <strong>常用命令：</strong>multi(启动事务)，discard（取消事务）,exec（执行事务块内命令）,watch key(监控某个key的变化)，unwatch（取消对所有key的监控）</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>注意：</strong>redis的事务中在命令本身出错的情况下会造成命令的全部回滚，但是在命令无错，执行某个命令的时候发生异常的时候，则谁的错，谁停止（这一点和mysql是不同的）</span></span></p>
<h2><strong>九，redis的主从复制</strong></h2>
<p><strong>&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>redis的主从复制，即主机数据更新后根据我们设置的策略将数据同步到从机上，主机以写为主，从机以读为主<strong>。</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 使用：</strong>配主不配从，在从机中使用slaveof&nbsp; 主机ip&nbsp; &nbsp;主机端口配置从机，但是这种配置方式当redis重启之后就会失效，如果想要redis重启仍然可用，则需要配置redis.conf配置文件中的slaveof&nbsp; masterip&nbsp; masterport。这种配置方式的问题所在，中心化只有一台极其支持写操作，如果主机宕机，则从机等待，且从机宕机重启后不会跟上大部队（即重启后变为主机）。当然我们可以采用命令slave&nbsp; no&nbsp; one 使从机反客为主，成为主机。但是这种手动操作太过麻烦。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>哨兵模式：</strong>即配置之后，如果主机宕机，则哨兵会自动根据投票规则在从机中进行选举，从而产生新的主机顶替。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>主从复制的缺点：</strong>因为所有的写操作都是子主机上进行，从而在同步到从机上，所以存在着一定的延迟，当系统繁忙或者从机数量较多的时候，这种问题就更加明显。</p>
<h2><strong>十，redis集群</strong></h2>
<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;概述：</strong>集群是一种去中心化的模式，与中心化模式不同的是，中心化模式中如果主服务挂掉了，那么服务就挂掉了。但是集群模式下，没有主路由，每个节点自身都可以成为路由</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;redis集群：即配置多台主机，多台从机，不同的主机中有不同的槽点，当执行数据写入时，会根据crc16算法计算出数据的槽点，从而将数据存入到对应的主机中，并同步到与其对应的从机中</p>
<p>&nbsp;</p>
<h1>水平有限，如有错误，还望指出！</h1>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong></p>, blogGoods=0, blogRead=4, blogCollection=0, typeName=redis, blogRemark=redis基础（一）, blogComment=0, blogSource=null, createdTime=2020-04-13 06:40:30, blogMonth=null, updateTime=2020-04-20 16:47:37), BlogVo(blogId=1249742755949817856, blogTitle=面试（三）------之并发编程篇（下）, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dHNmAPuxmAABJTVJPTfk117.jpg, blogContent=<h2><strong>一，线程上下文切换</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>cpu利用时间片轮询的方式来为每个任务都分配一定的时间片，任务的执行过程中保存任务的状态。任务状态的保存和在加载就叫做上下文切换。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>进程：</strong>指的是一个运行中的程序实例，一个进程中可以有多个线程，并且与进程共享同样的内存和系统资源</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong> 上下文：</strong>指的是寄存器和程序计数器保存的线程的信息</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>寄存器：</strong>指的是内存中很小但是运行速度很快的一块区域（相对于RAM外部内存）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>程序计数器：</strong>一种寄存器，用来保存当前执行指令的位置或者下一个待执行指令的位置</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>上下文切换：</strong>上下文切换指的是操作系统的内核在cpu上对进程或者线程的切换。上下文信息保存在进程控制块中（PCB）。流程如下：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;挂起当前进程，将进程的上下文信息保存在进程控制块中；</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;在进程控制块中寻找下一个任务的上下文信息。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;恢复进程</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>上下文切换的原因：</strong>第一，任务正常执行完毕，调度下一个任务；第二，线程出现I/O阻塞，被挂起，cpu调度下一个任务；第三，线程等待同步锁，获取socket通知等，被挂起，cpu调度下一个任务；第四，用户调用sleep方法，让出cpu；第五，硬件中断</p>
<h2><strong>二，JAVA阻塞队列</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>阻塞队列的是调度当前队列的线程处于阻塞状态</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 消费者阻塞：如果队列为空，则消费者线程被挂起，处于阻塞状态，当有新数据进入队列，则消费者线程被唤醒，消费数据</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 生产者阻塞：如果队列数据已满，则生产者线程挂起，处于阻塞状态，当队列有空闲位置，生产者线程被唤醒，生产数据。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞队列的主要操作：</strong>插入操作和移除（获取）操作</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>插入操作：</strong>add(e)，有空间则插入，无空间报异常；offer(e),有空间则插入，无空间返回false；offer(e,time,unit),有空间插入，无空间等待time时间，若超时返回false；put(e),有空间插入，无空间则线程挂起处于阻塞直到有空间</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>移除操作：</strong>poll(e),有值返回值，无值返回null;poll(e,time,unit),有值返回值，无值等待time时间，超时返回null;take(e),有值返回值，无值等待新数据进入再立即返回；drainTo(collection&lt;Object&gt;)批量移除，提高获取效率</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞队列的实现：</strong></p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong> ArrayBlockingQueue：</strong>基于数组的有界阻塞队列，按照先进先出顺序对元素进行排序</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>LinkedBlockingQueue：</strong>基于链表的有界阻塞队列，队头队尾采用不两个不同的锁控制数据同步，并发性高</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>PriorityBlockingQueue：</strong>基于优先级的无界队列，默认升序排列，可以自定义排序规则，根据优先级访问数据。但是有数据优先级一样的情况</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>DelayQueue：</strong>支持延时的队列，即从队列中取数据时等待一定的时间才能获取元素。可以用于缓存系统的设计，设计过期时间，也可以用来设置定时调度任务，即如果能够从队列中获取，说明到了任务的调度时间。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>SynchronousQueue</strong>：该队列是一个不存储元素的阻塞队列，每一个put操作都必须等待一个take操作的完成。吞吐量高于ArrayBlockingQueue和LinkedBlockingQueue。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>LinkedTransferQueue：</strong>基于链表的无界阻塞队列，多了transfer方法(如果消费者等待，直接将任务从生产者传递给消费者，无消费者等待，则将任务加到队尾直到被消费才返回)和tryTransfer（与transfer一致，只不过不管有没有消费者等待获取都会立即返回tryTransfer（e,time,unit）（与tryTransfer一致，只不过设置了超时时间）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>LinkedBlockingDeque：</strong>基于链表的双向阻塞队列，可以在两端同时进行读写操作，提高了队列的操作效率。</p>
<h2><strong>三，并发关键字</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;CountDownLatch：</strong>适用于一个主线程等待子线程完成任务之后执行（原理：设置一个程序计数器，计数器的值为子线程的个数，子线程并发执行，每个子线程执行完毕后，调用CountDown方法，将其计数器的值减去1，值为0时，唤醒主线程执行）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>CyclicBarrier：</strong>即当所有线程到达一个状态共同执行。await（）方法：确保所有线程到达Barrier状态才执行；await（time,unit）：设置一个超时时间，超过这个时间，执行达到Barrier状态的线程。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>Semaphore：</strong>因为其限制了多线程访问资源的线程个数，所以适用于多线程并发访问有限资源的情况。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>volatile：</strong>直接用来修饰变量，是一种比Synchronized更加轻量级的机制，用于多线程共享同一变量，可以同时对其进行读写操作。当多个线程共享变量的时候，读取变量将其从内存复制到cpu缓存中，然后线程对其操作进行修改，这样再多cpu的情况下，有可能出现线程修改原数据造成数据不一致的情况，使用volatile关键字直接将线程修改的变量存入内存，解决这个问题。</p>
<h2><strong>四，多线程共享数据</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>多线程共享数据主要通过共享内存实现，而共享内存的可见性，有序性，原子性已经由JVM和锁解决。理想情况下我们需要解决同步和互斥的问题（<span style="background-color: #ffff00;">怎么解决的有待考证！</span>）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>解决方法一：</strong>将数据抽象成一个类，将对数据的操作封装成类中的方法</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解决方法二：</strong>将Runnable对象作为一个内部类，将共享数据作为这个类的成员变量</p>
<h2><strong>五，ConcurrentHashmap并发</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ConcurrentHashmap使用了减小锁粒度，这里具体为分段锁的思想优化了锁，因为如果直接对hashmap进行加锁，锁太大，而且同一时刻只能有一个线程操作hashmap，并发性能较差</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;实现原理：</strong>即内部采用分段锁思想，将hashmap分为多个segment，每次读取数据的时候，对数据所在的segment进行加锁，这样只要保证每个segment线程安全，就可以保证整个hashmap线程安全</p>
<h2><strong>六，JAVA中的线程调度</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;抢占式调度：</strong>即线程对cpu资源进行抢占，这种策略下每个线程抢占到cpu资源的概率是相等的，这样就不会一个线程阻塞造成整个系统阻塞的情况。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>协同式调度：</strong>即一个线程使用完cpu资源之后通知cpu调度下一个任务，适用于多线程交替执行任务。因为如果一个线程阻塞可能会造成整个系统阻塞甚至崩溃</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>JAVA采用的是抢占式调度，但同时又尽可能的保证公平性（即为每个线程分配优先级不同的cpu时间片）</strong></p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>&nbsp;线程让出cpu的情况</strong>：第一，线程调用yield方法；第二，I/O阻塞，socket等待等；第三，等待同步锁；第四，正常执行完毕</p>
<h2>七，进程调度算法</h2>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>优先调度算法：</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;先来先服务调度算法：</strong>即遵循先来先被分配cpu资源运行的原则</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>短作业调度算法：</strong>即预估作业的时间长短，优先调度时间短的任务，可能会导致长时间大任务很长时间无法被调度 &nbsp;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>高优先权调度算法：即每个任务会预先被分配优先级</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;非抢占式优先调度算法：</strong>按照优先级的高低一次分配cpu资源运行</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>抢占式优先调度算法：</strong>按照优先级的高低分配cpu资源运行，但是如果任务再运行过程中有优先级更高的任务加入，则将其cpu资源临时回收分配给紧急任务</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>高响应比调度算法：</strong>动态调度，即作业时间短，则优先级高；等待时间长，则优先级高。前者遵循短作业调度算法，后者遵循先来先服务原则。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>时间片轮转调度算法：</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;时间片轮转法：</strong>按照任务再队列中的顺序进行调度</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>多级反馈队列调度算法：</strong>即再时间片轮转法的基础上维护了就绪队列，默认第一队列优先级高，先调度第一队列的任务，如果再分配的cpu时间片内未完成则将其加入第二队列队尾，以此类推直到其执行完毕。只有第1 -（n-1）队列为空，才会调度第n队列的任务，而且当前任务执行时，如果有优先级高的任务进来，会抢占其cpu资源。</p>
<h2><strong>八，CAS</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>即比较和交换，CAS（V,E,N）三个参数，只有当V=E的时候才会将V设置为N。如果V!=E，则说明数据已经被其它线程修改，不做任何操作</p>
<h2><strong>九，ABA问题</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>概述：</strong>即当1线程从V中取出A时，2线程也从中取出1，修改为B，再修改为A。而1线程仍然修改成功，实际上修改过程中V的实际值已经发生改变，只不过1没有发觉。解决这种问题，常采用乐观锁的版本号机制。</p>
<h2><strong>另外有AQS问题没怎么读懂，下次完善！</strong></h2>
<p>&nbsp;</p>
<h3><strong>思维导图：<a href="https://images-cdn.shimo.im/myFodjsaVAA3PVV7__thumbnail" target="_blank" rel="noopener">并发编程（下）</a></strong></h3>
<p>&nbsp;</p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</p>, blogGoods=0, blogRead=17, blogCollection=0, typeName=java面试篇, blogRemark=面试（三）------之并发编程篇（下）, blogComment=0, blogSource=null, createdTime=2020-04-13 16:54:26, blogMonth=null, updateTime=2020-04-20 11:54:02), BlogVo(blogId=1250068950784536576, blogTitle=面试（四）------之数据结构篇, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dHQGAYlUxAABJTVJPTfk990.jpg, blogContent=<h2><strong>一，栈及其JAVA实现</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：栈是一种先进后出的数据结构，对栈顶元素的添加，删除等操作较快，但是对于栈内的元素操作很慢</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA实现：实现需要定义栈的数据结构，写栈的入栈，出栈，获取栈顶元素的方法，如下：</strong></p>
<pre class="language-java"><code>/**
 * 基于数组实现栈
 * @author wcj
 * @Date 2020/4/14 20:59
 * @Version 1.0
 */
public class StackExample&lt;E&gt; {

    /**
     * 站的深度
     */
    private int maxSize;
    /**
     * 存储数据的数组
     */
    private Object[] data;
    /**
     * 栈顶指针
     */
    private int top = -1;

    /**
     * 默认栈的深度为10
     */
    public StackExample(){
        this(10);
    }

    /**
     * 用户自定义栈的深度
     * @param initialSize
     */
    public StackExample(int initialSize){
        if(initialSize&gt;=0){
            this.maxSize = initialSize;
            this.data = new  Object[initialSize];
            this.top = -1;
        }else{
            throw new RuntimeException("初始化栈的深度不能小于0!");
        }
    }

    /**
     * 入栈操作
     * @param e
     * @return
     */
    public Boolean push(E e){
        if(top == maxSize-1){
            throw new RuntimeException("栈已满,不能入栈");
        }else{
            data[++top] = e;
        }
        return true;
    }

    /**
     * 出栈操作
     * @return
     */
    public E pop(){
        if(top==-1){
            throw new RuntimeException("栈空，不能出栈！");
        }else{
            return (E) data[top--];
        }
    }

    /**
     * 获取栈顶元素
     * @return
     */
    public E peak(){
        if(top==-1){
            throw new RuntimeException("栈空异常！");
        }else{
            return (E) data[top];
        }
    }  </code></pre>
<h2><strong>二，队列极其JAVA实现</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：队列是一种先进先出的数据结构，对队头和队尾的操作简单，但是队内元素的操作复杂。</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA实现：定义队列的数据结构，队列的出队，入队，获取队头元素。代码如下：</strong></p>
<pre class="language-java"><code>/**
 * 基于数组实现队列
 * @author wcj
 * @Date 2020/4/14 21:14
 * @Version 1.0
 */
public class QueueExample&lt;E&gt; {

    /**
     * 队列长度
     */
    private int maxSize;
    /**
     * 存储数据数组
     */
    private Object[] data;
    /**
     * 队头指针
     */
    private int front;
    /**
     * 队尾指针
     */
    private int rear;

    /**
     * 默认构造器
     */
    public QueueExample(){
        this(10);
    }
    /**
     * 用户自定义队列长度构造器
     * @param initialSize
     */
    public QueueExample(int initialSize){
        if(initialSize&gt;=0){
            this.maxSize = initialSize;
            data = new Object[initialSize];
            front = rear = 0;
        }else{
            throw new RuntimeException("初始化队列长度不能小于0！");
        }
    }

    /**
     * 入队操作
     * @param e
     * @return
     */
    public Boolean add(E e){
        if(rear == maxSize){
            throw new RuntimeException("队列已满，无法入队!");
        }else{
            data[rear++] = e;
        }
        return true;
    }

    /**
     * 出队操作
     * @return
     */
    public E poll(){
        if(front==rear){
            throw new RuntimeException("队空，无元素可出队！");
        }else{
            E e = (E) data[front];
            data[front] = null;
            return e;
        }
    }

    /**
     * 获取队头元素
     * @return
     */
    public E peek(){
        if(front==rear){
            throw new RuntimeException("队空，无元素可出队!");
        }else{
            return (E) data[front];
        }
    }
}
</code></pre>
<h2><strong>三，链表及其JAVA实现</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：链表是由一系列数据节点组成的数据结构，节点可以动态生成。对于元素的增加，删除操作快，查询操作慢</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;这里主要讲述几种有代表性的链表：单向链表，双向链表，双向循环链表</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;单链表的JAVA实现：数据结构定义，添加节点，删除节点，查找节点，代码如下：</strong></p>
<pre class="language-java"><code>/**
 * 单向链表
 * @author wcj
 * @Date 2020/4/14 21:32
 * @Version 1.0
 */
public class SingleLinkedList {

    /**
     * 链表长度
     */
    private int length;
    /**
     * 链表头节点
     */
    private Node head;

    public SingleLinkedList(){
        this.length = 0;
        this.head = null;
    }
    /**
     * 内部类声明每个链表节点
     * 每个节点包括数据域和指向下一个节点的指针
     */
    private class Node{
        private Object data;
        private Node next;
        public Node(Object data){
            this.data = data;
        }
    }

    /**
     * 插入节点（这里使用头插法）
     * @param obj
     * @return
     */
    public Boolean add(Object obj){
        Node node = new Node(obj);
        if(length==0){
            head = node;
        }else{
            node.next= head;
            head = node;
        }
        length++;
        return true;
    }

    /**
     * 删除某个节点
     * 先对链表进行判空处理
     * 然后找到要删除的节点
     * 最后进行删除
     * @param obj
     * @return
     */
    public Boolean delete(Object obj){
        if(length==0){
            throw new RuntimeException("链表为空，无节点可删除!");
        }else{
            Node prev = head;
            Node current = head;
            //查找待删除元素
            while(!current.data.equals(obj)){
                if(current.next==null){
                    return false;
                }else{
                    prev = current;
                    current = current.next;
                }
            }
            prev.next = current.next;
            length--;
        }
        return true;
    }

    /**
     * 获取某个元素
     * @param obj
     * @return
     */
    public Object find(Object obj){
        if(length==0){
            throw new RuntimeException("链表为空");
        }else{
            Node current = head;
            while(current.data.equals(obj)){
                if(current.next==null){
                    return null;
                }else{
                    current = current.next;
                }
            }
            return current.data;
        }
    }
}
</code></pre>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>双向链表的JAVA实现：定义数据结构，头插法，尾插法，删除头部节点，删除尾部节点（这里只写尾插节点和删除尾部节点），代码如下：</strong></p>
<pre class="language-java"><code>import com.sun.org.apache.xpath.internal.operations.Bool;

/**
 * 单向循环链表
 * @author wcj
 * @Date 2020/4/14 22:05
 * @Version 1.0
 */
public class CircleLinkedList {

    /**
     * 链表长度
     */
    private int length;
    /**
     * 头节点
     */
    private Node head;
    /**
     * 尾节点
     */
    private Node tail;

    /**
     * 初始化构造方法
     */
    public CircleLinkedList(){
        this.length = 0;
        this.head=this.tail = null;
    }

    /**
     * 内部类实现的链表节点
     */
    private class Node{
        private Object data;
        private Node prev;
        private Node next;
        public Node(Object data){
            this.data = data;
        }
    }

    /**
     * 尾插节点
     * @param obj
     * @return
     */
    public Boolean addTail(Object obj){
        Node node = new Node(obj);
        if(length==0){
            head = tail= node;
            length++;
        }else{
            tail.next = node;
            node.prev = tail;
            tail = node;
            length++;
        }
        return true;
    }

    /**
     * 删除尾部节点
     * @return
     */
    public Boolean delTail(){
        Node temp = tail;
        if(length==0){
            throw new RuntimeException("链表为空!");
        }else{
            tail = tail.prev;
            tail.next = null;
            length--;
        }
        return true;
    }
}
</code></pre>
<h2><strong>四，散列表</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：有一张表M，一个映射函数f(key)，如果对于任意一个key，都有一个函数指与表中的内存地址相对应，则M就为散列表，f(key)就为散列函数。散列函数存储key-value键值对形式的数据，直接生成key与表中地址值的映射，因此查询非常迅速。同时散列表也经常被用于信息安全，用于加密操作。</strong></p>
<h2><strong>五，二叉排序树</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：二叉查找树又成为二叉搜索树，二叉查找树</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;特征：根节点左边的数据小于根节点，根节点右边的数据大于根节点，且其左右子树还是二叉排序树</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现：定义数据结构，插入操作，删除操作，查找操作，代码如下：</strong></p>
<pre class="language-java"><code>package interviewFour.example4;

/**
 * 二叉排序树
 * @author wcj
 * @Date 2020/4/14 17:17
 * @Version 1.0
 */
public class Node {

    private Node root = null;
    private int value;
    private Node left;
    private Node right;

    public Node(){}

    public Node(int value, Node left, Node right){
        this.value = value;
        this.left = left;
        this.right = right;
    }

    public Node(int value){
        this.left = null;
        this.right = null;
        this.value = value;
    }

    public int getValue() {
        return value;
    }

    public void setValue(int value) {
        this.value = value;
    }

    public Node getLeft() {
        return left;
    }

    public void setLeft(Node left) {
        this.left = left;
    }

    public Node getRight() {
        return right;
    }

    public void setRight(Node right) {
        this.right = right;
    }

    /**
     * 插入节点
     * @param value
     * @return
     */
    public Boolean insert(int value){
        //root代表根节点
        Node p = root;
        Node prev = null;
        //创建一个节点
        Node node = new Node(value);
        //寻找节点的插入位置
        while(p!=null){
            prev = p;
            if(value==p.getValue()){
                return false;
            }else if(value&lt;p.getValue()){
                p = p.getLeft();
            }else{
                p = p.getRight();
            }
        }
        if(root==null){
            root = node;
        }else if(value&lt;prev.getValue()){
            prev.setLeft(node);
        }else{
            prev.setRight(node);
        }
        return true;
    }

    /**
     * 删除某个节点
     * 分为三种情况，待删除节点为叶子节点，则直接删除
     * 待删除节点只有左子树或者右子树，则用左子树或者右子树替代当前节点位置
     * 待删除节点即有左子树又有右子树，则寻找左子树最大节点或者右子树最小节点顶替当前节点(这里使用左子树的最大节点)
     * @param value
     * @return
     */
    public void deleteBST(int value){
        deleteBST(root,value);
    }

    /**
     * 递归删除左子树，或者右子树，或者根节点
     * @param root
     * @param value
     * @return
     */
    public Boolean deleteBST(Node root,int value){
        if(root==null){
            return false;
        }else{
            if(root.getValue()==value){
                delete(root);
            }else if(value&lt;root.getValue()){
                deleteBST(root.getLeft(),value);
            }else{
                deleteBST(root.getRight(),value);
            }
        }
        return true;
    }

    /**
     * 分情况执行具体的删除逻辑
     * @param node
     * @return
     */
    public Boolean delete(Node node){
        if(node.getLeft()==null){
            node = node.getRight();
        }else if(node.getRight()==null){
            node = node.getLeft();
        }else{
            Node temp = node;
            Node s = node;
            //转向左子树，向右走到底
            s = s.getLeft();
            //寻找替换待删除节点的节点
            while(s!=null){
                temp = s;
                s = s.getRight();
            }
            node.setValue(temp.getValue());
            if(temp!=node){
                node.setLeft(temp.getLeft());
            }else{
                node.setRight(temp.getRight());
            }
        }
        return true;
    }

    /**
     * 在二叉查找树中找到对应节点
     * @param value
     * @return
     */
    public Boolean searchBTS(int value){
        Node node = root;
        if(node==null){
            throw new RuntimeException("无此节点！");
        }else{
            if(value==node.getValue()){
                return true;
            }else if(value&lt;node.getValue()){
                node = node.getLeft();
            }else{
                node = node.getRight();
            }
        }
        return false;
    }
}
</code></pre>
<h2><strong>六，红黑树</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 概述：红黑树是一种特化的自平衡二叉排序树，即其左右子树的深度差可以超过1。（详细的插入等操作过段时间会补充）</strong></p>
<h2><strong>七，图，位图</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;图的知识：定义，有向图/无向图，邻接矩阵/邻接表，BFS/DFS，位图的话没怎么搞清楚。</strong></p>
<h3><strong>思维导图：<a href="https://images-cdn.shimo.im/YClQaLxx9e8uEb9U__thumbnail" target="_blank" rel="noopener">数据结构</a></strong></h3>
<h2>&nbsp;</h2>, blogGoods=0, blogRead=7, blogCollection=0, typeName=java面试篇, blogRemark=面试（四）------之数据结构篇, blogComment=0, blogSource=null, createdTime=2020-04-14 14:30:37, blogMonth=null, updateTime=2020-04-23 22:14:43)], params={}, sortColumn=blog_read, sortMethod=DESC)]
2020-04-26 23:27:33.564 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 1056
2020-04-26 23:27:33.566 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，集合</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，List：</strong>list是java中一种有序的集合，下有三个实现类，分别为ArrayList，Vector，LinkedList</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ArrayList：基于数组实现，增删慢，查询快，线程不安全。因为其基于数组实现，所以查询的时候可以直接根据数组的索引下标进行快速查询，但是进行增删操作的时候，需要将待增删元素后的元素全部移动，因而效率较低。且ArrayList创建时不需要分配初始大小，其空间不够的时候，会自动创建一个更大的list，然后复制数据。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Vector：基于数组实现，和ArrayList一样增删慢，查询快。但是线程安全，因为同一时间只支持一个线程对Vector进行写操作，然而因为要进行频繁的加锁和释放锁的操作，所以效率要低于ArrayList。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; LinkedList：基于双向链表实现，增删快，查询慢。因为基于链表实现，增删元素的时候，只需要改变元素的指针即可，改动较小，效率较高。然而进行查询操作的时候，需要从链表头部进行遍历，因而效率较低。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，Queue：</strong>队列，满足先进先出，种类较多。（不作详细解释）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，set：</strong>具有独一无二的特性，常用来存储无序且不重复的元素，对象相等的本质是hashcode的值相同，而如果想要比较两个对象是否相等，需要重写对象的hashcode方法和equals方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;hashset：基于hashTable实现，无序。存放的是对象的散列值，即通过hashcode计算得到的值</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;treeset：基于二叉树实现，即其中的对象按照一定的排序方式进行排列（升序，降序），每次添加对象的时候，都会进行排序，将其插入指定位置。基本的数据类型例如Integer，String等可以使用treeset默认的排序方法，而自定义数据类型需要实现compareable接口，实现compareTo方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;LinkHashSet：继承自hashset，只不过使用双向链表记录数据的顺序。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，map：</strong>一种键值对形式的集合</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;hashmap：基于数组+链表实现，增删改查操作快，但是每次遍历hashmap元素的顺序无法保证且线程不安全。如果想要其线程安全，可以使用synchronizedMap和ConcurrentHashmap，hashmap的内部是数组，数组中的每一个元素又是一个单向链表，链表中的每个元素嵌套一个Entry实例，其中包括Key，Value，Hash值，指向下一个节点的next。每次查询的时候，可以根据元素的hash值很快定位所在数组，但是定位之后需要遍历链表查找元素，因而时间复杂度为O（n），但是Java8之后对其进行了优化，将其改为了数组+链表或红黑树的结构，即当链表中的元素大于8个的时候，链表会转换为红黑树（红黑树是一种特化的二叉平衡树，因为其左右子树的深度差可以大于1），这样查询的时间复杂度就缩短到了O（logN）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ConcurrentHashmap：采用分段锁的思想进行并发操作，因而使线程安全的。由多个Segment组成，只要保证每个Segment线程安全就可以保证全局线程安全。ConcurrentHashmap的默认Segment即并发度为16，可以在初始化的时候修改，但是初始化之后不能再修改。每个Segment内部的实现和hashmap一样&middot;。Java8之后也和hashmap进行了一样的优化。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;HashTable：线程安全，即同一时刻只能有一个线程对其进行操作，并发度不如ConcurrentHashmap。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;TreeMap：基于二叉树数据结构实现，实现了SortedMap，默认按照键值的升序进行排列。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;LinkedHashMap：Hashmap的子类，只不过使用链表保存元素的插入顺序。使用迭代器遍历的时候按照插入顺序遍历。</p>\n<h2><strong>二，异常分类及处理</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;1，异常分类：</strong>Throwable是所有异常类的父类，其下有error和Exception，Error下有AwtError，ThreadDeath；Exception下有RuntimeException和CheckedException。</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</strong>对于Error类异常通常是由内部错误和资源耗尽造成的，无法在程序运行期间对其进行捕获和处理，对于这类错误我们只能记录错误的原因和终止程序。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; Exception中的RuntimeException异常（运行时异常）：这类异常是我们程序中异常处理的核心，可以在程序中进行捕获并处理。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Exception中的CheckedException异常（检查异常）：这类异常时程序中需要强制捕获的异常，通常有IO异常，SQL异常等等。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，异常处理：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>异常处理有两种方式：抛出异常和捕获异常</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;抛出异常有三种方法：throws，throw，系统自动抛出。其中throws是作用在方法上，后面跟的是可能产生的异常类。throw是作用在方法内部，后面跟的是具体的异常对象。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 捕获异常：即使用try{}catch语句进行捕获</p>\n<h2><strong>三，反射机制</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，什么叫做反射机制？</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>即在程序运行的过程中，可以获取类的属性和方法，并且可以调用任意一个类的方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，反射机制的使用</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 首先，获取类的class对象，有三种方式，className.getClass()，类对象.class，Class.forName(\"类路径\")，其中最后一种最为安全，性能最好。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 然后利用反射的API可以实现对类中信息的操作，例如getDeclareFields（），getDeclareMethods（），getConstroctors（）等等。反射创建类的对像有两种方法，一，class.newInstance()初始化一个类实例；二，先获取其构造器，然后利用构造器初始化一个实例。利用反射调用类的方法：先获取方法，然后调用method.invoke()执行方法。</p>\n<h2><strong>四，注解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，四种元注解：</strong>@Target（指定注解的使用范围），@Retention（定义注解的保留级别，有三级，SOURCE源程序中保存，CLASS文件中保存，RUNTIME运行时保存），@Documented（可以工具文档化），@Inherited（<span style=\"background-color: #ffff00;\">这个没怎么看懂</span>）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，注解使用示例：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>第一步，定义注解接口</p>\n<pre class=\"language-java\"><code>@Target(ElementType.FIELD)  \n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface FruitProvider {\n\n    //id\n    public int id() default  -1;\n\n    //供应商名称\n    public String name() default \"\";\n\n    //供应商地址\n    public String address() default \"\";\n\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 第二步，使用注解</p>\n<pre class=\"language-java\"><code>public class Apple {\n\n    @FruitProvider(id = 1,name = \"红富士苹果\",address = \"陕西\")\n    private String appleProvider;\n\n    public String getAppleProvider() {\n        return appleProvider;\n    }\n\n    public void setAppleProvider(String appleProvider) {\n        this.appleProvider = appleProvider;\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第三步，定义注解处理器</p>\n<pre class=\"language-java\"><code>public class FruitInfoUtil {\n    public static void getFruitInfo(Class&lt;?&gt; clazz) {\n        String strFruitProvider = \"供应商信息:\";\n        Field[] declaredFields = clazz.getDeclaredFields();\n        for (int i = 0; i &lt; declaredFields.length; i++) {\n            if (declaredFields[i].isAnnotationPresent(FruitProvider.class)) {\n                FruitProvider annotation = declaredFields[i].getAnnotation(FruitProvider.class);\n                strFruitProvider += annotation.id() + \",\" + annotation.name() + \",\" + annotation.address();\n                System.out.println(strFruitProvider);\n            }\n        }\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第四步，主方法入口</p>\n<pre class=\"language-java\"><code>public class FruitRun {\n    public static void main(String[] args) {\n        FruitInfoUtil.getFruitInfo(Apple.class);\n    }\n}</code></pre>\n<h2><strong>五，内部类</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 1，静态内部类：</strong>即在类的内部定义的静态类，静态内部类可以访问外部了的静态变量和方法，外部也可以通过outClassName.innerClassName调用内部类</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2，成员内部类：</strong>在类的内部定义的没有用static修饰的内部类，使用方式和静态内部类一样。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>3，局部内部类：</strong>即一个类只在一个方法中使用，则完全可以将这个类定义为这个方法的内部类，即局部内部类，局部内部类可以实现真正的对外隐藏</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>4，匿名内部类：</strong>通常用于继承一个类或者实现一个接口的时候，使用new关键字定义，例如:Person person = new Student(){new Pupil(){}}</p>\n<h2><strong>六，泛型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 1，为什么要使用泛型：</strong>其根本目的是为了实现代码的复用，举个开发中常见的例子，我们需要定义返回类Result，返回类中包含状态码code，信息msg，以及数据data（任意类型），这个时候我们就需要使用泛型，因为我们返回的数据类型有各种vo，pojo类对象，list等。这时候泛型类result就可以被各种对象使用，实现代码的复用，简化开发。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>2，泛型标记和泛型限定：</strong>E表示集合中的元素，K表示键值，V表示value，N表示数值类型，T表示任意类型（包含基础类型，所有的对象类型），？（不确定的java类型）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>泛型限定：</strong>向上限定，&lt;?&nbsp; extends T&gt;，向下限定，&lt;? super&nbsp; T&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; <strong>3，泛型方法：</strong>即参数类型定义为泛型类型，以便于接收不同类型的参数，做出不同的处理。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>4，泛型类：</strong>例如public class Pair&lt;T&gt;{private T data;}</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>5，泛型接口：</strong>与放泛型类类似</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>6，类型擦除：</strong>即在泛型编译的过程中，会将泛型类型替换为限定类型的操作</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>7，明确的一点：</strong>虚拟机在运行程序的过程中，内部是没有泛型的，只有普通的类和方法。</p>\n<h2><strong>7，序列化</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 序列化是为了确保对象及其状态的持久化</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>序列化的使用：</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </strong>首先，实现序列化接口java.io.Serializble</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 然后，声明序列化ID，通常private static final&nbsp; long&nbsp; serialVersionUid&nbsp; = ***</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 因为序列化是保证对象及其状态的持久化，而静态变量是不属于对象，属于类本身的，所以序列化无法保存静态变量。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果需要序列化父类变量，则父类也要实现Serializable接口</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t'ransient修饰的属性不会序列化</p>\n<h3><strong>最后，提供一张思维导图供大家学习：<a href=\"https://images-cdn.shimo.im/es83SQH0CggucT7f__thumbnail\" target=\"_blank\" rel=\"noopener\">JAVA基础</a></strong></h3>\n<p>&nbsp;</p>\n<h2>水平有限，如有错误，还望指出！</h2>","blogGoods":0,"blogId":"1248605157059497984","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHMKAcvZ8AABJTVJPTfk020.jpg","blogRead":27,"blogRemark":"面试（二）------之JAVA基础篇","blogTitle":"面试（二）------之JAVA基础篇","createdTime":"2020-04-10 13:34:02","typeName":"java面试篇","updateTime":"2020-04-20 11:53:39"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，数据库设计--表的命名规范等</strong></p>\n<p>（1），统一采用bl_开头对表进行命名</p>\n<p>（2），对于数据比较重要的表统一添加四个字段，分别为：created_time(创建时间),update_time(修改时间),version(版本号),deleted(删除字段)</p>\n<p>（3），数据库表的字段尽量都设置为NOT_NULL</p>\n<p>（4），数据库中表varchar类型字段需要设置长度的尽量设置为2<sup>n</sup>-1</p>\n<p>（5），因为博客系统分为前台展示界面和后台管理，所以对于有些表，例如bl_type（博客类型表），bl_music（音乐表）等设置了enable（启用字段）</p>\n<p><strong>二，上述第二条--四个字段的解释</strong></p>\n<p>（1），为什么要设置created_time和update_time字段：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;其一，从数据库的通用性上来说，设计这两个字段是必要的，但也需要根据业务的需要来合理添加这两个字段，因为无用的字段会浪费空间，性能，影响系统的运行。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 其二，大部分的应用都有需要根据时间进行排序的功能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 其三，当系统发生异常的时候，我们可以通过这两个字段对异常进行排查和定位。</p>\n<p>（2），为什么要设置version字段：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 1，version字段含义：字段的含义与其字面意思一样，代表版本，在这里作为乐观锁进行使用，从而保证不会出现脏数据的情况。下面解释一下什么叫乐观锁，以及乐观锁和悲观锁</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 2，乐观锁：总是假定最好的情况，即每次用户调用接口从数据库中取出数据到修改数据前的过程中，不会有其它用户对当前数据进行修改，这样在当前用户修改数据的时候，利用版本机制即判断取出的version字段和当前数据库该条数据的version字段是否相等来判断该条数据是否已经被修改，如果未修改，则予以修改（且version字段递增），如果已经修改，则提示用户更新失败。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 悲观锁：总是假定最坏的情况，即每次用户调用接口从数据库取出数据的时候，都认为该条数据会被修改，因此每次取出数据都对数据进行加锁处理，只允许当前用户进行修改，其它用户阻塞，直到当前用户修改完毕。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3，为什么使用乐观锁而不使用悲观锁：因为悲观锁比较浪费性能</p>\n<p>（3），为什么设置deleted字段：deleted字段在这里作为一个逻辑删除字段（0否1是），何为逻辑删除，即执行删除操作操作的时候，不会真正的删除数据库中的数据，而是将deleted字段设置为1即可。&nbsp;这样如果用户出现误删的操作，可以通过数据库修改该字段进行数据的恢复。</p>\n<p><strong>三，上述第三条--数据库表字段尽量设置为NOT_NULL</strong></p>\n<p>（1），数据库表字段尽量设置为NOT_NULL：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 1，有些人可能认为设置为NULL相比于NOT_NULL不是更节省空间吗？但是实际上不是这样的，设计为NULL相比于NOT_NULL要多占用一个字节的空间</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 2，设计为NOT_NULL，这样在做查询的时候能够更好的避免空指针异常，且发生该类错误的时候能够更好的进行排查</p>\n<p><strong>四，上述第四条--表varchar类型字段长度尽量设置为2<sup>n</sup>-1</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>因为计算机只识别二进制，且有一定的范围，例如2<sup>8</sup>，在计算机中的范围为-128~127,因此对于varchar字段长度来说，如果设置为255，则正好是一个字节，而如果设置为256，则占用两个字节，这样会浪费计算机的内存空间，因此数据库varchar类型字段的长度最好设置为2<sup>n</sup>-1</p>\n<p><strong>五，上述第五条--对于设置enable字段的解释</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>enable字段，字面意思启用，在这里表明是否启用（0否1是），因为系统分为前台博客页面和后台管理，对于这两个不同的前端项目，后台可以通过启用字段来控制内容在前台博客页面的展示与否，与deleted字段不同的是，如果执行删除操作，那么我们只能通过手动修改数据库中的字段进行数据的恢复，且如果执行删除操作，则该数据在前台博客页面和后台管理页面都无法看见。但是如果将数据弃用（即修改enable字段值为1），则表明该数据被弃用，在前台博客页面无法显示，但是在后台管理页面可以看见，且无需通过手动修改数据库来恢复数据，可以在后台管理页面操作启用数据。</p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1247745014683947008","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dDViAcnjvAACb6PL1tzA485.jpg","blogRead":21,"blogRemark":"博客开发总结（一）-----之数据库设计篇","blogTitle":"博客开发总结（一）-----之数据库设计篇","createdTime":"2020-04-08 04:36:07","typeName":"博客开发和维护总结","updateTime":"2020-04-20 10:47:54"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2 style=\"text-align: left;\"><strong>一，JVM运行机制</strong></h2>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;jvm即java虚拟机，一共由四个部分组成，分别是类加载器子系统，运行时数据区（程序计数器，本地方法区，jvm栈，方法区，jvm堆），执行引擎（即时编译器，垃圾收集器），本地接口库。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;一个java源程序的运行先是经过编译器将其编译成字节码文件（class文件），然后通过类加载器子系统将其加载进入jvm&mdash;&mdash;&gt;程序运行过程中，运行时数据区存放程序运行过程产生的数据&mdash;&mdash;&gt;执行引擎中的垃圾收集器收集程序运行过程中创建的不再使用的对象，即时编译器将程序的字节码文件编译成机器码&mdash;&mdash;&gt;然后本地接口库利用机器码调用本地方法库中的方法，和操作系统实现交互。</p>\n<h2><strong>二，多线程</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;</strong>在多核操作系统中，jvm支持一个进程中同时并发执行多个线程，且这些线程和本地操作系统的线程相对应。当jvm中的对象初始化，内存空间分配等一系列准备工作完成之后，会调用操作系统中的接口创建一个原生线程，原生线程初始化完毕后，会调用java线程的run（）方法执行该线程，线程结束之后，jvm会释放原生线程和java线程资源。</p>\n<h2><strong>三，JVM的内存区域</strong></h2>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM的内存区域主要分为线程私有区域（程序计数器，本地方法区，JVM栈），线程共享区（方法区，JVM堆）和直接内存。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;程序计数器：线程私有区域，无内存溢出，用来记录程序运行过程中的字节码指令地址，如果是Native方法，则程序计数器为空。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM栈：线程私有区域，用来描述java程序的运行过程，java程序运行每次运行的时候，都会创建一个栈帧，方法的执行和返回对应着栈帧的入栈和出栈操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;本地方法区：线程私有区域，和JVM栈的功能一样，只不过是用来记录Native方法的运行过程。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM堆：线程共享区，主要用来存放程序运行过程中产生的数据，同时也是垃圾收集器进行垃圾回收的主要区域。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;方法区：也被称为永久代，用来存放常量，静态变量，类信息等等。</p>\n<h2><strong>四，JVM的运行时内存</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>JVM的运行时内存又被称为JVM堆，因为JVM的GC算法使用的是分代收集算法，所以JVM堆按照GC标准可以分为三个区域分别为：新生代，老年代，永久代。其中新生代占1/3，老年代占2/3，永久代很少，</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;新生代：存放短生命周期，小对象的区域。新生代又分为Eden区，ServivorTo区，ServivorFrom区，区域的GC算法采用复制算法。Eden区是用来存放新创建的对象（大对象除外），ServivorTo区是用来保存MinorGC幸存下来的对象，ServivorFrom区是用来将上一次MinorGC幸存下来的对象作为下一次MinorGC的扫描对象。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;老年代：存放长生命周期的大对象，区域的GC算法采用标记整理算法</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;永久代：主要用来存放class和meta数据信息的。程序运行过程中不会进行永久代的垃圾回收，这也就导致永久代区域的数据会越来越多，最终造成内存溢出。java8之后永久代已经被元数据区取代，元数据区和永久代的功能都是一样的，但是最大的不同在于永久代区域依赖于虚拟机的内存大小，因而可以存储的class，meta信息非常有限。但是元数据区依赖的是本地操作系统，因而不会受到虚拟机内存的限制。</p>\n<h2><strong>五，垃圾回收与算法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;(1)垃圾回收：</strong>Jvm的垃圾回收判定依赖于两种方法，引用计数法和可达性分析法。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;引用计数法：即如果想要在程序中使用对象，就必须赋予一个引用，这样在对象赋予引用的时候将其引用计数加1，删除一个引用时，将对象引用计数减1，如果引用计数为0，就说明该对象已经不使用，作为垃圾。但是引用计数法存在一个缺陷，即循环引用的问题，如果两个对象相互引用，则这两个对象的引用计数永远都不会为0，造成对象无法被回收。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;可达性分析法：即先创建一些根节点对象ROOTS，然后通过这些根节点对象向下搜索，如果一个对象到任意一个ROOTS之间都没有可达路径，在经过两次标记（下文解释为什么进行两次标记），还是没有可达路径，则说明该对象可回收。</p>\n<p>&nbsp;&nbsp; &nbsp;<strong>（2）GC算法：</strong>常见的GC算法有四种，分别为标记清除算法，复制算法，标记整理算法，分代收集算法</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;标记清除算法：即在进行垃圾回收前，对所有对象进行一次标记，标记可回收的对象，然后进行清理即可。但是标记清除算法在清除回收对象之后，并不会对堆内存进行整理，这样的话如果内存中的对象大部分为小对象，清理之后就会导致没有大片连续的内存空间，即造成了内存碎片化，这样大对象存储的时候就无法找到相应的完整连续内存。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;复制算法：即将内存分为两块同等大小的区域，区域1和区域2，创建的新对象都存储在区域1中，当区域1中的内存占满之后，会对内存中的所有对象进行一次标记，标记存活的对象，将存活的对象复制到区域2，这时区域1中的对象都是可回收对象，回收区域1中的所有对象即可。但是复制算法也存在着一定的缺陷，即每次都只能使用一半的内存空间，造成了大量的内存浪费。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;标记整理算法：即结合标记清除算法和复制算法的优点，先对所有的对象进行标记，标记存活的对象，将存活的对象复制到内存的另一端，然后清除当前端的对象即可。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;分代收集算法：前面的三种算法，都无法按照对象的类型进行收集，分代收集算法正是解决这个问题，按照对象的不同类型采用不同的GC算法。以JVM的分代收集算法为例，JVM的堆内存分为新生代，老年代，永久代。新生代又分为Eden区，ServivorTo区和ServivorFrom区。新生代因为其存储生命周期短的小对象，GC比较频繁，所以采用复制算法。程序运行过程中创建的对象都存储在Eden区（大对象除外，大对象直接复制到老年代区域）。当Eden区的内存不够的时候进行MinorGC，然后将Eden区和ServivorFrom区的存活对象都复制到ServivorTo区，然后将ServivorTo区和ServivorFrom区进行交换，再次进行MinorGC。老年代因为存放的都是生命周期长的大对象，因而进行GC的不会太频繁，且清除的对象并不会太多，因而采用标记整理算法。老年代每次进行MajorGC之前都会先进行一次MinorGC，当MinorGC之后新生代的内存仍然不够的时候，将对象复制到老年代进行MajorGC。永久代区域主要回收常量，无用class等。</p>\n<h2><strong>六，JAVA中的四种引用类型</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;强引用类型<strong>：</strong>即把对象赋给一个引用变量，强引用的对象一定为可达状态，所以不会进行垃圾回收。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;软引用类型：通过SoftReference类实现，当内存不够的时候对其进行GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;弱引用类型：只有弱引用类型的对象，一定会被GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;虚引用类型：虚引用对象主要是用来跟踪对象的GC状态</p>\n<h2><strong>七，分代收集算法和分区收集算法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>分代收集算法：新生代因其存放大量短生命周期小对象，且GC频繁，所以采用复制算法。老年代因其存放长生命周期大对象，且GC不平凡，所以采用标记整理算法。永久代，回收常量，类信息等。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;分区收集算法：即将堆内存区域分为大小不同的区，可以按照不同的区进行快速垃圾回收，减少系统的停顿时间。然后再以并行的方式逐步完成整个GC。</p>\n<h2><strong>八，垃圾收集器</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>新生代区域：Serial垃圾收集器，单线程复制算法，因为单线程无需进行线程之间的交互和切换，所以效率非常高，是JVM默认的client模式下的默认垃圾回收策略，工作期间需要暂停其它所有的线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ParNew垃圾收集器，多线程复制算法，跟单线程Serial一样，是JVM默认的server模式下的垃圾回收策略，工作期间需要暂停所有其它线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Parallel Scavenge垃圾收集器：多线程复制算法，不同的是优先考虑系统吞吐量，可以利用更高效的利用CPU完成GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;老年代区域：Serial Old垃圾收集器，单线程标记整理算法，同新生代的Serial功能一样，只是采取的算法不同而已。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Parallel Old垃圾收集器：多线程标记整理算法，优先考虑了系统的吞吐量，其次考虑停顿时间。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CMS,多线程标记清除算法，优先考虑系统GC时的停顿时间，且过程分为四步（<span style=\"background-color: #ffff00;\">解释上文的可达性分析中的两次标记</span>，第一步：标记GC ROOTS可达对象，暂停其它工作线程；第二步：和用户线程一起工作，跟踪GC ROOTS；第三步，因为第二步用户进程没有暂停，所以有些对象状态</p>\n<p>可能发生了改变，重新进行标记；第四步，清除不可达对象）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; G1垃圾收集器，多线程标记整理算法，将内存分区，与CMS相比，一方面不会产生内存碎片，一方面，可以精确的控制系统停顿时间。</p>\n<h2><strong>九，JAVA的网络编程模型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;</strong>阻塞I/O模型：即用户线程发出I/O请求之后，内核会检查数据是否准备就绪，这时候用户线程始终处于阻塞状态等待数据准备就绪。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;非阻塞I/O模型：即用户线程不断的给内核发出I/O请求，内核接受到I/O请求之后会返回一个状态，如果数据准备就绪，就将数据复制进入用户线程，如果数据没有准备好，返回一个false，用户线程无需阻塞，可以去处理其它事情，而当数据准备好了且刚好用户线程发起I/O请求进行操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;多路复用I/O模型：多路复用I/O模型通过一个Selector线程轮询Socket的状态，如果Socket有读写事件，则进行I/O操作。此模型的优势在于可以更好的处理连接数众多但消息体不大的情况下。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;信号驱动I/O模型：即用户线程发出一个I/O请求，系统会为该请求创建一个信号函数，用户请求可继续执行其它业务逻辑，当内核数据准备就绪之后会返回给用户线程一个信号，用户线程接收到之后进行I/O操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;异步I/O模型：用户线程给内核发起一个asynchronous read操作，内核接收到之后，返回其请求是否成功，然后等待数据准备成功之后复制到用户线程。整个过程中请求的发起和数据读取都在内核中进行，最终发送一个信号告知用户线程I/O操作已经完成，用户直接使用数据就行。（说实话个人感</p>\n<p>觉和信号驱动很像）</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;java NIO：没怎么读懂（<span style=\"background-color: #993300;\">记得补充！</span>）</p>\n<h2><strong>十，JVM的类加载机制</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>JVM类加载分为五个阶段：加载，验证，准备，解析，初始化</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;加载：即将class文件加载到JVM中，且创建class对象，封装其数据结构。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;验证：对class文件进行验证，确保符合JVM的标准，保证JVM的安全。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;准备：即方法区中给类变量分配空间和赋初值。static修改的会在初始化阶段赋值，final修饰的会在准备阶段赋值。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;解析：即将常量池中的引用替换为直接引用</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;初始化：执行类构造器进行初始化。（因为内部流程不是很清楚，所以对于其几种不进行初始化的情况不做说明）</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;类加载器：JVM提供了三种类加载器，启动类加载器（/lib），扩展类加载器(/lib/ext)，应用程序类加载器(classpath)。还可以再应用程序类加载器自定义类加载器。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;双亲委派机制：即当一个类接收到类加载请求的时候，不会自己进行加载，而是将其加载请求委派给其父类加载器，这样一路委派，最终加载请求都会委派到启动类加载器.启动类加载器接收到加载请求之后会去lib目录下寻找相关的class文件，若找不到，则将其加载请求再委培给子类加载器，一路委派，直到能够加载。</p>\n<h3><strong>最后，送给大家一张博主画的JVM的思维导图，以后读《深入JVM虚拟机》的时候可能会出一个JVM专题：<a href=\"https://uploader.shimo.im/f/X0MX3hLaHrevltxW.png!thumbnail\" target=\"_blank\" rel=\"noopener\">JVM思维导图</a></strong></h3>\n<p>&nbsp;</p>\n<h2>水平有限，若发现有误，还望指出！</h2>","blogGoods":0,"blogId":"1248224512563068928","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHLeALxSjAABJTVJPTfk677.jpg","blogRead":17,"blogRemark":"面试（一）------之JVM篇","blogTitle":"面试（一）------之JVM篇","createdTime":"2020-04-09 12:21:30","typeName":"java面试篇","updateTime":"2020-04-20 11:53:29"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，线程上下文切换</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>cpu利用时间片轮询的方式来为每个任务都分配一定的时间片，任务的执行过程中保存任务的状态。任务状态的保存和在加载就叫做上下文切换。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>进程：</strong>指的是一个运行中的程序实例，一个进程中可以有多个线程，并且与进程共享同样的内存和系统资源</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong> 上下文：</strong>指的是寄存器和程序计数器保存的线程的信息</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>寄存器：</strong>指的是内存中很小但是运行速度很快的一块区域（相对于RAM外部内存）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>程序计数器：</strong>一种寄存器，用来保存当前执行指令的位置或者下一个待执行指令的位置</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>上下文切换：</strong>上下文切换指的是操作系统的内核在cpu上对进程或者线程的切换。上下文信息保存在进程控制块中（PCB）。流程如下：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;挂起当前进程，将进程的上下文信息保存在进程控制块中；</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;在进程控制块中寻找下一个任务的上下文信息。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;恢复进程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>上下文切换的原因：</strong>第一，任务正常执行完毕，调度下一个任务；第二，线程出现I/O阻塞，被挂起，cpu调度下一个任务；第三，线程等待同步锁，获取socket通知等，被挂起，cpu调度下一个任务；第四，用户调用sleep方法，让出cpu；第五，硬件中断</p>\n<h2><strong>二，JAVA阻塞队列</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>阻塞队列的是调度当前队列的线程处于阻塞状态</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 消费者阻塞：如果队列为空，则消费者线程被挂起，处于阻塞状态，当有新数据进入队列，则消费者线程被唤醒，消费数据</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 生产者阻塞：如果队列数据已满，则生产者线程挂起，处于阻塞状态，当队列有空闲位置，生产者线程被唤醒，生产数据。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞队列的主要操作：</strong>插入操作和移除（获取）操作</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>插入操作：</strong>add(e)，有空间则插入，无空间报异常；offer(e),有空间则插入，无空间返回false；offer(e,time,unit),有空间插入，无空间等待time时间，若超时返回false；put(e),有空间插入，无空间则线程挂起处于阻塞直到有空间</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>移除操作：</strong>poll(e),有值返回值，无值返回null;poll(e,time,unit),有值返回值，无值等待time时间，超时返回null;take(e),有值返回值，无值等待新数据进入再立即返回；drainTo(collection&lt;Object&gt;)批量移除，提高获取效率</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞队列的实现：</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong> ArrayBlockingQueue：</strong>基于数组的有界阻塞队列，按照先进先出顺序对元素进行排序</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>LinkedBlockingQueue：</strong>基于链表的有界阻塞队列，队头队尾采用不两个不同的锁控制数据同步，并发性高</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>PriorityBlockingQueue：</strong>基于优先级的无界队列，默认升序排列，可以自定义排序规则，根据优先级访问数据。但是有数据优先级一样的情况</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>DelayQueue：</strong>支持延时的队列，即从队列中取数据时等待一定的时间才能获取元素。可以用于缓存系统的设计，设计过期时间，也可以用来设置定时调度任务，即如果能够从队列中获取，说明到了任务的调度时间。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>SynchronousQueue</strong>：该队列是一个不存储元素的阻塞队列，每一个put操作都必须等待一个take操作的完成。吞吐量高于ArrayBlockingQueue和LinkedBlockingQueue。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>LinkedTransferQueue：</strong>基于链表的无界阻塞队列，多了transfer方法(如果消费者等待，直接将任务从生产者传递给消费者，无消费者等待，则将任务加到队尾直到被消费才返回)和tryTransfer（与transfer一致，只不过不管有没有消费者等待获取都会立即返回tryTransfer（e,time,unit）（与tryTransfer一致，只不过设置了超时时间）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>LinkedBlockingDeque：</strong>基于链表的双向阻塞队列，可以在两端同时进行读写操作，提高了队列的操作效率。</p>\n<h2><strong>三，并发关键字</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;CountDownLatch：</strong>适用于一个主线程等待子线程完成任务之后执行（原理：设置一个程序计数器，计数器的值为子线程的个数，子线程并发执行，每个子线程执行完毕后，调用CountDown方法，将其计数器的值减去1，值为0时，唤醒主线程执行）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>CyclicBarrier：</strong>即当所有线程到达一个状态共同执行。await（）方法：确保所有线程到达Barrier状态才执行；await（time,unit）：设置一个超时时间，超过这个时间，执行达到Barrier状态的线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>Semaphore：</strong>因为其限制了多线程访问资源的线程个数，所以适用于多线程并发访问有限资源的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>volatile：</strong>直接用来修饰变量，是一种比Synchronized更加轻量级的机制，用于多线程共享同一变量，可以同时对其进行读写操作。当多个线程共享变量的时候，读取变量将其从内存复制到cpu缓存中，然后线程对其操作进行修改，这样再多cpu的情况下，有可能出现线程修改原数据造成数据不一致的情况，使用volatile关键字直接将线程修改的变量存入内存，解决这个问题。</p>\n<h2><strong>四，多线程共享数据</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>多线程共享数据主要通过共享内存实现，而共享内存的可见性，有序性，原子性已经由JVM和锁解决。理想情况下我们需要解决同步和互斥的问题（<span style=\"background-color: #ffff00;\">怎么解决的有待考证！</span>）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>解决方法一：</strong>将数据抽象成一个类，将对数据的操作封装成类中的方法</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解决方法二：</strong>将Runnable对象作为一个内部类，将共享数据作为这个类的成员变量</p>\n<h2><strong>五，ConcurrentHashmap并发</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ConcurrentHashmap使用了减小锁粒度，这里具体为分段锁的思想优化了锁，因为如果直接对hashmap进行加锁，锁太大，而且同一时刻只能有一个线程操作hashmap，并发性能较差</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;实现原理：</strong>即内部采用分段锁思想，将hashmap分为多个segment，每次读取数据的时候，对数据所在的segment进行加锁，这样只要保证每个segment线程安全，就可以保证整个hashmap线程安全</p>\n<h2><strong>六，JAVA中的线程调度</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;抢占式调度：</strong>即线程对cpu资源进行抢占，这种策略下每个线程抢占到cpu资源的概率是相等的，这样就不会一个线程阻塞造成整个系统阻塞的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>协同式调度：</strong>即一个线程使用完cpu资源之后通知cpu调度下一个任务，适用于多线程交替执行任务。因为如果一个线程阻塞可能会造成整个系统阻塞甚至崩溃</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>JAVA采用的是抢占式调度，但同时又尽可能的保证公平性（即为每个线程分配优先级不同的cpu时间片）</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>&nbsp;线程让出cpu的情况</strong>：第一，线程调用yield方法；第二，I/O阻塞，socket等待等；第三，等待同步锁；第四，正常执行完毕</p>\n<h2>七，进程调度算法</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>优先调度算法：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;先来先服务调度算法：</strong>即遵循先来先被分配cpu资源运行的原则</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>短作业调度算法：</strong>即预估作业的时间长短，优先调度时间短的任务，可能会导致长时间大任务很长时间无法被调度 &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>高优先权调度算法：即每个任务会预先被分配优先级</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;非抢占式优先调度算法：</strong>按照优先级的高低一次分配cpu资源运行</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>抢占式优先调度算法：</strong>按照优先级的高低分配cpu资源运行，但是如果任务再运行过程中有优先级更高的任务加入，则将其cpu资源临时回收分配给紧急任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>高响应比调度算法：</strong>动态调度，即作业时间短，则优先级高；等待时间长，则优先级高。前者遵循短作业调度算法，后者遵循先来先服务原则。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>时间片轮转调度算法：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;时间片轮转法：</strong>按照任务再队列中的顺序进行调度</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>多级反馈队列调度算法：</strong>即再时间片轮转法的基础上维护了就绪队列，默认第一队列优先级高，先调度第一队列的任务，如果再分配的cpu时间片内未完成则将其加入第二队列队尾，以此类推直到其执行完毕。只有第1 -（n-1）队列为空，才会调度第n队列的任务，而且当前任务执行时，如果有优先级高的任务进来，会抢占其cpu资源。</p>\n<h2><strong>八，CAS</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>即比较和交换，CAS（V,E,N）三个参数，只有当V=E的时候才会将V设置为N。如果V!=E，则说明数据已经被其它线程修改，不做任何操作</p>\n<h2><strong>九，ABA问题</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>概述：</strong>即当1线程从V中取出A时，2线程也从中取出1，修改为B，再修改为A。而1线程仍然修改成功，实际上修改过程中V的实际值已经发生改变，只不过1没有发觉。解决这种问题，常采用乐观锁的版本号机制。</p>\n<h2><strong>另外有AQS问题没怎么读懂，下次完善！</strong></h2>\n<p>&nbsp;</p>\n<h3><strong>思维导图：<a href=\"https://images-cdn.shimo.im/myFodjsaVAA3PVV7__thumbnail\" target=\"_blank\" rel=\"noopener\">并发编程（下）</a></strong></h3>\n<p>&nbsp;</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</p>","blogGoods":0,"blogId":"1249742755949817856","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHNmAPuxmAABJTVJPTfk117.jpg","blogRead":17,"blogRemark":"面试（三）------之并发编程篇（下）","blogTitle":"面试（三）------之并发编程篇（下）","createdTime":"2020-04-13 16:54:26","typeName":"java面试篇","updateTime":"2020-04-20 11:54:02"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，JAVA线程的创建方式</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>JAVA线程的创建有四种方式，分别为，继承Thread类，实现Runable接口，实现Callable&lt;Class&gt;接口，基于线程池。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>1，继承Thread方式：创建一个类继承Thread类，创建类的实例对象，调用start方法，继而执行线程的run（）方法，代码如下：</strong></p>\n<pre class=\"language-java\"><code>public class NewThread extends Thread{\n    public static void main(String[] args) {\n        NewThread thread = new NewThread();\n        thread.start();\n    }\n    @Override\n    public void run(){\n        System.out.println(\"create  a  new thread by Thread!\");\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>2，当子类已经继承了一个类，这时候就没法再继承Thread类了，这时候就可以实现Runable接口，实例化类的线程实例，创建Thread实例传入类的实例，执行start方法，继而执行run（）方法代码如下：</strong></p>\n<p>&nbsp;</p>\n<pre class=\"language-java\"><code>public class ThreadExample2 implements Runnable {\n    public static void main(String[] args) {\n        ThreadExample2 threadExample2 = new ThreadExample2();\n        Thread thread = new Thread(threadExample2);\n        thread.start();\n    }\n    @Override\n    public void run() {\n        System.out.println(\"create a new thread by Runnable!\");\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，有些情况下，我们需要再一个主线程中并发多个子线程执行同一个任务，然后回收子线程的返回值整理汇总，这时候就需要实现Callable&lt;Class&gt;接口，重写其call（）方法，用于计算结果。然床创建一个线程池用于提交线程，继而执行call方法，并且创建一个Future的list用于接收子线程逻辑代码即call方法的返回，最终遍历list，得到想要的返回值，如下：</strong></p>\n<pre class=\"language-java\"><code>public class ThreadExample3 implements Callable&lt;String&gt; {\n\n    private String name;\n\n    public ThreadExample3(String name){\n        this.name = name;\n    }\n\n    @Override\n    public String call() throws Exception {\n        return name;\n    }\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        ExecutorService pool = Executors.newFixedThreadPool(3);\n        List&lt;Future&gt; list = new ArrayList&lt;&gt;();\n        for(int i=0;i&lt;3;i++){\n            ThreadExample3 threadExample3 = new ThreadExample3(i+\"\");\n            Future future =pool.submit(threadExample3);\n            System.out.println(future.get().toString()+\" is running\");\n            list.add(future);\n        }\n        pool.shutdown();\n        for (Future future : list) {\n            System.out.println(\"currentThread's result is \"+future.get().toString());\n        }\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，基于线程池创建线程</strong></p>\n<pre class=\"language-java\"><code>public class ThreadExample4 {\n    public static void main(String[] args){\n        ExecutorService pool = Executors.newFixedThreadPool(3);\n        for(int i=0;i&lt;3;i++){\n            pool.execute(new Runnable() {\n                @Override\n                public void run() {\n                    System.out.println(\"thread  is running by FixedThreadPool\");\n                }\n            });\n        }\n        pool.shutdown();\n    }\n}</code></pre>\n<h2>二，线程池的工作原理</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong> &nbsp;1，概述：</strong>JVM根据用户提供的参数创建一定数量的线程任务，将其放入队列中，线程创建之后启动这些任务，如果线程的数量大于核心线程数量（用户设置的线程数量），则超出数量的线程排在队列中等待，当有线程任务执行完毕后，线程池调度器就会发现有可用可用线程，继而从队列中取出任务继续执行<strong>。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; </strong><strong>2，线程复用：</strong>（参见JDK源码解读，这里只做简单描述），由前可知，JVM会根据用户提供的参数创建一定数量的线程任务，且将其添加到任务队列中。JVM通过start（）方法创建一个线程之后， 会相应的为其创建一个任务队列，线程会不停的查看任务队列，如果任务队列中有任务，则调用run方法，执行，这样就达到了一次start（）创建线程，多次使用，完成线程复用的任务。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>3，线程池的核心组件和核心类（见JDK源码分类中关于线程的总结）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; </strong><strong>4，JAVA线程的工作流程：</strong>线程池刚被创建的时候，只是向系统申请一个执行线程队列和管理线程池的线程资源，当调用execute方法之后，执行下列流程：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果正在运行的线程数量小于corePoolSize（核心线程数量，即用户定义的的线程数量），则立即创建线程执行线程任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果正在运行的线程数量大于或等于corePoolSize，则将超过数量的线程加入到阻塞队列中</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在阻塞队列已满且线程数量小于MaximumPoolSize（即线程池能够容纳的最大线程数），线程池会创建非核心线程立即执行任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在阻塞队列已满且线程数量大于或等于MaximumPoolSize的时候，线程池会拒绝该线程任务且抛出异常</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在线程任务执行完毕之后，会将其从任务队列中移除，从队列中取出下一个线程任务执行</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在线程处于空闲状态且空闲时间超过KeepAliveTime，且线程数量大于corePoolSize的时候，会停止该线程，这样在没有任务的时候，线程池中的线程数始终维持在corePoolSize。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，线程池的拒绝策略：</strong>分为四种，分别为AbortPolicy，CallerRunsPolicy，DiscardOldestPolicy，DiscardPolicy</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; AbortPolicy：直接抛出异常，阻止线程运行，源码如下：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</p>\n<pre class=\"language-java\"><code>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n            throw new RejectedExecutionException(\"Task \" + r.toString() +\n                                                 \" rejected from \" +\n                                                 e.toString());\n        }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CallerRunsPolicy：如果线程任务没有关闭，则尝试执行该线程任务，源码如下：</p>\n<pre class=\"language-java\"><code>* @param r the runnable task requested to be executed\n* @param e the executor attempting to execute this task\n*/\npublic void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n     if (!e.isShutdown()) {\n         r.run()\n     }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DiscardOldestPolicy：移除任务队列中最早进入的线程任务，执行当前任务线程，源码如下：</p>\n<pre class=\"language-java\"><code>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n       if (!e.isShutdown()) {\n           e.getQueue().poll();\n           e.execute(r);\n       }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DiscardPolicy：直接丢弃线程任务，不做任何处理</p>\n<h2><strong>三，五种常用的线程池</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;newCachedThreadPool（可缓存线程池）：</strong>当线程池创建线程的时候如果发现有可复用的线程（执行完任务，且未关闭的线程），则直接复用，如果没有则创建新线程。可缓存线程池可以高效的利用执行任务时间短的线程，提高系统的性能，且线程池中的线程如果空闲时间超过60s，则会被终止且从缓存中移除，这样可缓存线程池不会占用系统资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>newFixedThreadPool（固定大小的线程池）：</strong>即线程池中的线程是初始化固定的，当任务线程大于线程池中线程数量时，任务线程就会进入阻塞队列等待。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newScheduledThreadPool（可做任务调度的线程池）：</strong>即可以设置线程执行的停顿时间和执行周期，进行定期定时的执行某个任务。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newSingleThreadPool（单个线程的线程池）:&nbsp;</strong>即线程池中永远只有一个线程进行工作，如果下称停止或者异常，则线程池创建新的线程替代当前线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newWorkStealingPool（足够大小的线程池）：</strong>即创建足够数量的线程的线程池，保证更快的进行运算，提高效率。</p>\n<h2><strong>四，线程的生命周期</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;线程的生命周期大致分为五个阶段：新建（new），就绪（Runnable），运行（Running），阻塞（Blocked），死亡（Dead）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;新建：</strong>即使用new创建一个线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>就绪：</strong>调用start方法，</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>运行：</strong>即线程获取cpu资源，执行run（）方法，进入运行状态，运行状态的线程如果调用yield（线程让步方法）或者失去cpu资源，都会导致线程重新回到就绪态；如果调用sleep方法，I/O阻塞，等待同步锁，等待通知以及suspend挂起都会导致线程进入阻塞态。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞：</strong>即线程被放入Blocked池。阻塞状态的线程如果结束了sleep方法，I/O方法返回，获取同步锁，收到通知或者resume都会导致其重新进入就绪态，与其它线程竞争cpu时间片。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>死亡：</strong>线程正常执行完run（）或者call（）方法，或者执行stop方法，或者发生异常或者错误都会导致线程死亡。（stop方法会导致锁混乱和死锁，不建议使用）</p>\n<h2><strong>五，线程的基本方法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;wait（线程等待）：</strong>会让线程进入WAITING状态，并且会释放对象的锁。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>sleep（线程睡眠）：</strong>会让线程进入睡眠，进入TIMED_WAITING状态，但是不会释放对象锁，睡眠时间到了之后，再次恢复运行状态</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>yield（线程让步）:</strong>&nbsp; 当前线程会让出其占有的cpu资源，重新回到就绪态和其它线程竞争cpu时间片</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>interrupt（线程中断）:&nbsp; </strong>中断当前线程，但是并不会导致其停止，只是改变其内部的终端标识位，在使用了thread.sleep()之后使用该方法，会导致抛出异常，且我们可以利用中断标识位进行线程的安全退出</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>join（线程加入）：</strong>即将当前线程进入阻塞态，等待下一个线程执行完毕后进入就绪态，重新竞争锁资源。通常用于主线程下面执行子线程，需要主线程阻塞，等待子线程执行完毕后返回其结果给主线程，主线程再执行的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>notify（线程唤醒）/notifyAll：</strong>前者随机唤醒一个等待线程，后者全部唤醒</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>setDaemon（守护线程）:</strong>级别较低的线程，用于后台运行，服务用户用户线程，例如垃圾收集线程就是典型的守护线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>sleep方法和wait方法的区别：</strong>前者属于Thread，后者属于Object，前者不会释放锁资源，后者会释放锁资源</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>start方法和run方法：</strong>start方法只是创建一个线程，并没有运行，run方法时执行线程的真正代码逻辑。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>线程退出的方式：</strong>见四中最后一条</p>\n<h2><strong>六，JAVA中的锁（知识比较杂乱）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述:JAVA中的锁是为了保护数据的一致性。按照不同的标准可分为乐观锁和悲观锁，公平锁和非公平锁，共享锁和独占锁，偏向锁，轻量级锁，重量级锁，自旋锁，可重入锁。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;乐观锁：</strong>即认为每次读取数据都不会被修改，当修改操作的时候再判断当前数据是否被修改，未修改则修改，若已被修改，则返回失败状态。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>悲观锁：</strong>即认为每次读取数据都会被修改，因而每次读取数据都对其进行加锁，这样只有当前用户可以修改，其它用户阻塞等待直到当前用户修改完毕释放锁资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>自旋锁：</strong>即有些线程任务的执行很短，很快就可以释放锁资源，为了避免在这种情况下竞争线程仍然进行内核态和用户态之间的转换，因而让线程自旋（即等一会），如果有可用锁，则获取，减少了线程在用户态和内核态之间切换的时间损耗。提高了性能（优势）。当然线程自旋是占用cpu资源的，因而需要设置一个自旋的最大等待时间，如果超过此时间，则线程退出自旋模式。对于线程竞争锁资源激烈的情况，自旋有可能会导致cpu资源的损耗（劣势）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>公平锁和非公平锁：</strong>即根据线程竞争锁资源的机制判定，一般如果依据先到先得的原则，则位公平锁；如果依据就近原则，则位非公平锁。公平锁相比于非公平锁会更加耗费性能，因为要维护一个线程任务丢列，根据线程任务在队列中的顺序分配锁资源，因而不常用。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>可重入锁：</strong>又被称为递归锁，即该锁可以然后线程对其进行多次的加锁操作。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>偏向锁：</strong>当线程获取到锁的时候，用来消除线程的锁重入的开销（看起来是偏袒这个线程）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>共享锁和独占锁：</strong>共享锁即多线程共享锁资源（典型例子，读锁）；独占锁即当前锁只能有一个线程获取，其它线程阻塞</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>轻量级锁：</strong>没有多线程竞争的前提下，减少重量级锁的使用提高性能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>重量级锁：</strong>基于操作系统的互斥量而实现的锁，会导致进程在用户态和内核态之间切换，耗费性能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>synchronized：独占式悲观锁，可重入锁，非公平锁，重量级锁。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 作用范围：</strong>作用于成员变量和非静态方法，相当于锁住的是对象的实例，即this对象</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;作用于静态方法，相当于锁住的是class实例</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;作用域代码块，相当于锁住的代码块中的对象</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>实现原理：</strong>内部包括ContentionList（锁竞争队列），EntryList（竞争候选列表），WaitSet（等待集合），OnDeck（竞争候选者），Owner，!Owner，其中ContentionList是用来存放竞争锁资源的线程。EntryList是用来存放有资格竞争锁资源的线程。调用wait方法后放入WaitSet中，onDeck指的是同一时刻，只有一个线程竞争锁资源，Owner指的是得到锁资源的线程，!Owner指的是线程执行完毕，释放锁资源的线程。需要注意的是线程首先采用的都是自旋模式获取锁资源，如果自旋获取不到再加入ContentionList，而且Owner状态的线程并不是直接把锁资源交给onDeck状态线程，而是给它竞争锁资源的权利，因而onDeck状态的线程还需要跟自旋线程竞争锁资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>ReentrantLock：独占式，可重入锁，并且可以实现公平锁和非公平锁，重量级锁。</strong></p>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;用法：</strong>lock()加锁，后跟try代码块，finally中进行释放锁unlock()</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;避免死锁的方法：</strong>响应中断（即可以根据情况中断对锁资源的请求），可轮询锁（tryLock（）即尝试获取锁，如果有可用锁则获取返回true，没有则返回。和lock（）的区别在于lock获取锁资源如果没有则一直等待直到获取到锁资源），定时所（tryLock（time,unit）即再一定时间内如果有可用锁，且线程未中断则获取锁，否则禁用当前线程。）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>Semaphore（信号量）:</strong>机制和ReentrantLock类似</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ReadWriteLock（读写锁）：</strong>如果系统要求支持多线程共享读，但不能多线程写，使用读锁；如果要求同一时刻只能有一个线程写，写的过程中不能读取该共享数据，则使用写锁。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; <strong>分段锁：</strong>一种思想，将数据分段加锁，例如ConcurrentHashMap</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;死锁：</strong>即线程之间互相共享资源会导致死锁</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; <strong>锁优化：</strong>第一，减少锁的持有时间；第二：减小锁粒度，例如分段锁；第三：锁分离，例如读写锁；第四：锁粗化，放置锁粒度太小，造成频繁加锁释放锁；第五：锁消除，消除程序代码不规范而造成的乱用了锁</p>\n<p>&nbsp;</p>\n<h3><strong>并发编程（上）的思维导图送上：<a href=\"https://images-cdn.shimo.im/1UcHkyrlJyGRPYnn.png__thumbnail\" target=\"_blank\" rel=\"noopener\">并发编程（上）</a></strong></h3>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>\n<h1>水平有限，如果错误，还望指出！</h1>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;</p>","blogGoods":0,"blogId":"1249313090567143424","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHM2AQOeZAABJTVJPTfk967.jpg","blogRead":8,"blogRemark":"面试（三）------之并发编程篇（上）","blogTitle":"面试（三）------之并发编程篇（上）","createdTime":"2020-04-12 12:27:07","typeName":"java面试篇","updateTime":"2020-04-20 11:53:51"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，二分查找算法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：二分查找算法又称为折半查找算法，待查找的序列必须已经是有序的，每次取序列的中间值与查找值进行比较，若相等则返回；若中间值小于查找值，则在中间值右侧序列中进行查找；若中间值大于查找值，则在中间值左侧序列中进行查找。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现如下：</strong></p>\n<pre class=\"language-java\"><code>public static int binarySearch(int[] arr,int low,int high,int key){\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(arr[mid]==key){\n                return mid;\n            }else if(arr[mid]&lt;key){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        return -1;\n    }</code></pre>\n<h2><strong>二，冒泡排序（这里以升序为例）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：冒泡排序即对于一个无序序列，从第一个元素开始，依次比较相邻的元素，如果前一个元素大于后一个元素，则交换位置，这样一趟比较下来，就确定出最大值。直到整个序列有序为止</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现如下：</strong></p>\n<pre class=\"language-java\"><code>public static void bubbleSort(int[] arr){\n        for (int i = arr.length-1; i &gt;=0 ; i--) {\n            for (int j = 0; j &lt; i; j++) {\n                if(arr[j]&gt;arr[j+1]){\n                    swap(arr,j,j+1);\n                }\n            }\n        }\n    }\n    /**\n     * 交换元素\n     * @param arr\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] arr,int i,int j){\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }</code></pre>\n<h2>三，插入排序（升序为例）</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>概述：即默认无序序列中的第一个元素有序，随后每次排列有序序列后的一个元素，将其排列进入前面的有序序列，同时保证有序序列的有序性即可。（类似于我们打扑克牌时，每拿一张从后往前比较大小，放入正确的位置）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现如下：</strong></p>\n<pre class=\"language-java\"><code>public static void insertSort(int[] arr){\n        for (int i = 1; i &lt; arr.length; i++) {\n            for (int j = i; j &gt;=0; j--) {\n                if(arr[j]&lt;arr[j-1]){\n                    swap(arr,i,j);\n                }\n            }\n        }\n    }\n\n    /**\n     * 交换元素\n     * @param arr\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] arr,int i,int j){\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }</code></pre>\n<h2>四，快速排序（升序为例）</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>概述：在一个无序序列中，取一个基准值，通常取第一个元素为基准值。然后从最右边依次查找，找到第一个比基准值小的元素，与其交换位置；再从最左边查找，查找到第一个比基准值大的元素，与其交换位置。直到从左往右查找的索引等于从右往左查找的索引，结束一次循环，重复以上过程分别比较左右两标的序列，直到整个</strong></p>\n<p><strong>有序为止。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;JAVA代码实现如下：</strong></p>\n<pre class=\"language-java\"><code>public static void quickSort(int[] arr,int low,int high){\n        int base = arr[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //先从右往左查找第一个比基准值小的元素\n            while(R&gt;L&amp;&amp;arr[R]&gt;=base){\n                R--;\n            }\n            if(arr[R]&lt;base){\n             swap(arr,L,R);\n            }\n            //再从左往右查找第一个比基准值大的元素\n            while(R&gt;L&amp;&amp;arr[L]&lt;=base){\n                L++;\n            }\n            if(arr[L]&gt;base){\n                swap(arr,L,R);\n            }\n        }\n        //递归左右序列\n        if(L&gt;low) {\n            quickSort(arr,low,L-1);\n        }\n        if(R&lt;high) {\n            quickSort(arr,R+1,high);\n        }\n    }\n\n    /**\n     * 交换元素\n     * @param arr\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] arr,int i,int j){\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }</code></pre>\n<h2>五，希尔排序（升序为例，以初始dk为length/3+1）</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>概述：希尔排序又称增量排序，是优化的插入排序，即有一个增量dk，根据增量dk将无序序列分为若干个子序列，分别对子序列进行插入排序，每进行完一趟排序，更改增量，直到增量dk为1时，则对整个序列再进行依次插入排序。希尔排序，当增量dk大的时候，因为序列数据较少，排序较快；而当增量dk小的时候，又因为序列</strong></p>\n<p><strong>中的数据已经基本有序了，因而排序也较快。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;JAVA代码实现：为例</strong></p>\n<pre class=\"language-java\"><code>public static void sort(int[] arr){\n\n        int dk = arr.length/3+1;\n        while(dk!=1){\n            shellSort(arr,dk);\n            dk = dk/3+1;\n        }\n        if(dk==1){\n            shellSort(arr,dk);\n        }\n    }\n\n    public static void shellSort(int[] arr,int dk){\n        for (int i = dk; i &lt;arr.length ; i++) {\n            if(arr[i]&lt;arr[i-dk]){\n                swap(arr,i,i-dk);\n            }\n        }\n    }\n\n    /**\n     * 交换元素\n     * @param arr\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] arr,int i,int j){\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }</code></pre>\n<h2><strong>六，归并排序</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：归并排序采用的是典型的分治思想，即先分解，然后再归并。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n     * 先分\n     * @param arr\n     */\n    public static void sortProcess(int[] arr,int L,int R){\n        if(L==R){\n            return;\n        }\n        int mid = (L+R)/2;\n        sortProcess(arr,L,mid);\n        sortProcess(arr,mid+1,R);\n        merge(arr,L,mid,R);\n    }\n\n    /**\n     * 分治中的治\n     * @param arr\n     * @param L\n     * @param mid\n     * @param R\n     */\n    public static void merge(int[] arr,int L,int mid,int R){\n        int[] help = new int[R-L+1];\n        int p1 = L;\n        int p2 = mid+1;\n        int i =0;\n        while(p1&lt;=mid&amp;&amp;p2&lt;=R){\n            help[i++] = arr[p1]&gt;arr[p2]?arr[p2++]:arr[p1++];\n        }\n        while(p1&lt;=mid){\n            help[i++] = arr[p1++];\n        }\n        while(p2&lt;=R){\n            help[i++] = arr[p2++];\n        }\n        //将数组help复制回原数组（注意一定要有这一步，不然无法保证元素比较后的大小顺序性）\n        for (int j = 0; j &lt; help.length; j++) {\n            arr[L+j] = help[j];\n        }\n        System.out.println(Arrays.toString(arr));\n    }</code></pre>\n<h2>七，桶排序算法</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>概述：先找出无序序列中的最大值和最小值，然后根据最大值和最小值计算桶的个数并且初始化桶，然后将每个元素加入到对应的桶中，对每个桶进行排序，再整合桶中的数据即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>JAVA代码如下：</strong></p>\n<pre class=\"language-java\"><code>public static void bucketSort(int[] arr){\n\n        int k = 0;\n        //找出无序序列中的最大值和最小值\n        int max = Integer.MIN_VALUE;\n        int min = Integer.MAX_VALUE;\n        for (int i : arr) {\n            max = Math.max(max,i);\n            min = Math.min(min,i);\n        }\n\n        //根据最大值和最小值确定桶\n        int bucketNum = (max-min)/arr.length+1;\n        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = new ArrayList&lt;&gt;(bucketNum);\n        for (int i = 0; i &lt; bucketNum; i++) {\n            bucketArr.add(new ArrayList&lt;&gt;());\n        }\n\n        //遍历序列中的数据，将其分配进入不同的桶\n        for (int i=0;i&lt;arr.length;i++) {\n            int num = (arr[i]-min)/arr.length;\n            bucketArr.get(num).add(arr[i]);\n        }\n\n        //对每个桶都进行排序\n        for (ArrayList&lt;Integer&gt; bucket : bucketArr) {\n            Collections.sort(bucket);\n        }\n\n        //将桶中的数据按照顺序复制回原数组\n        for (ArrayList&lt;Integer&gt; bucket : bucketArr) {\n            for (Integer integer : bucket) {\n                arr[k++] = integer;\n            }\n        }\n    }</code></pre>\n<h2>八，基数排序（这里以高位优先为例）</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>概述：基数排序是一种优化的桶排序，但是基数排序只能排序整型数据。先要统一数据的位数，位数不够的前面添0，然后按照从低位到高位的位数顺序依据位数上数字的大小进行排序，最终得到一个有序序列。 &nbsp;</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码如下：</strong></p>\n<pre class=\"language-java\"><code>public static void radixSort(int[] arr){\n        //指数\n        int exp = 1;\n\n        //查找数组中的最大值\n        int max= Integer.MIN_VALUE;\n        for (int i : arr) {\n            max = Math.max(max,i);\n        }\n\n        //按照低位到高位的顺序依次排序\n        for (exp=1;(max/exp)&gt;0;exp*=10){\n            int[] temp = new int[arr.length];\n            //初始化桶\n            int[] buckets = new int[10];\n            //统计每个桶中数据的次数\n            for (int i = 0; i &lt; arr.length; i++) {\n                buckets[(arr[i]/exp)%10]++;\n            }\n\n            //更改buckets[i]\n            for (int i = 1; i &lt; buckets.length; i++) {\n                buckets[i]+=buckets[i-1];\n            }\n\n            //将数据存储到临时数组temp中\n            for (int i = 0; i &lt; arr.length; i++) {\n                temp[buckets[(arr[i]/exp)%10]-1] = arr[i];\n                buckets[(arr[i]/exp)%10]--;\n            }\n\n            //将临时数组的数据复制到原数组\n            System.arraycopy(temp,0,arr,0,arr.length);\n        }\n    }</code></pre>\n<h2><strong>九，其它算法（对于最短路径算法和回溯算法后面会单列出来）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;剪枝算法，最短路径算法，回溯算法</strong></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1250364779516665856","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHQyAM97iAABJTVJPTfk047.jpg","blogRead":8,"blogRemark":"面试（五）------之算法","blogTitle":"面试（五）------之算法","createdTime":"2020-04-15 10:06:09","typeName":"java面试篇","updateTime":"2020-04-25 11:53:23"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，OSI七层网络模型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;物理层：主要用于定义物理设备的标准，发送比特流</strong></p>\n<p><strong style=\"font-size: 14px;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;数据链路层：主要用于对数据包中的MAC地址进行解析和封装。这一层的数据单位叫做帧</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;网络层：主要用于对数据包中的ip地址进行解析和封装，这一层的数据单位叫做数据包。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;传输层：定义传输的协议和端口，进行的数据的分段，重组和传输。TCP传输控制协议，适用于对可靠性要求高，数据量大的传输。UDP适用于对可靠性要求不高，数据量不大的传输。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;会话层：用于再传输层的基础上建立连接和管理会话。比如登录，断点续传，数据粘包和分包。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;表示层：用于对接收到的数据进行解析，将计算机识别的信息转换成人也能够识别的信息。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;应用层：构建具体应用</strong></p>\n<h2><strong>二，TCP/IP四层网络模型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：TCP/IP并不是指tcp和ip协议，而是指因特网中的TCP/IP协议簇，分为四层网络模型：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;网络接口层：用来定义主机间的连通协议</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;网络层：用于数据的传输，路由及地址的解析，确保数据能够发送到任何网络的目标上。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;传输层：使源端和目的端的相同实体能够进行通信</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;应用层：负责具体应用协议的定义</strong></p>\n<h2><strong>三，TCP三次握手/四次挥手</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：客户端和服务器之间建立连接之前需要进行三次沟通，称为&ldquo;三次握手&rdquo;；客户端和服务器之间断开连接之前，会进行四次沟通，称为&ldquo;四次挥手&rdquo;。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;三次握手：客户端发送连接请求的标识位SYN给服务器端，进入SYN-SEND状态，请求建立连接；服务器端接收到请求之后，返回一个SYN+ACK报文，进入SYN-RECV状态；客户端接收到请求之后，回应一个ACK报文，至此，三次握手完毕，客户端与服务器端之间的TCP连接已建立，可以进行数据传输。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;四次挥手：客户端和服务器端断开连接要进行四次挥手是因为TCP的关闭是半关闭造成的，即TCP连接是全双工的（即数据可以在两个方向上同时进行交换），因此想要关闭连接，就必须每个方向进行单独关闭。（客户端主动断开连接和服务器端主动断开连接），这里以客户端主动断开连接为例：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;客户端数据传输完毕之后，发送一个释放连接的标识位FIN=1给服务器端，请求断开客户端到服务器端之间的连接操作，进入FIN-WAIT-1状态；</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;服务器端接收到请求之后，返回一个ACK报文给客户端，表</strong><strong>示已经接收到其断开连接的请求，然后释放客户端到服务器端的连接，服务器端进入CLOSE-WAIT状态，客户端接收到请求后进入FIN-WAIT-2状态；</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;服务器端在将待传输到客户端的数据传输完毕之前，发出一个中断连接的标识位FIN=1给客户端，请求客户端中端服务器端到客户端的连接操作，进入进入LAST-ACK状态，等待客户端的最终确认；</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;客户端接收到服务器端的断开连接请求之后，回应一个ACK，表示接收到断开连接请求，随后等待计时器设置的时间后，断开连接。</strong></p>\n<h2><strong>四，HTTP协议</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;概述：http协议是一种无状态的协议，即客户端和服务器端不需要建立持久的连接，客户端发出请求后，服务器端接收到请求，处理数据返回应答之后，连接关闭。http协议遵循请求（Request）和应答（Response）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;传输流程：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 地址解析：通过域名系统DNS获取请求地址的协议，主机名，端口号，对象路径</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 封装HTTP数据包：根据解析出来的请求协议，主机名，端口号，对象路径和本机信息封装出HTTP数据包</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 封装TCP数据包：将HTTP数据包进一步封装成TCP数据包</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;建立TCP连接：利用三次握手协议建立客户端和服务器端的TCP连接</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 客户端发送请求：客户端发送一个请求给服务器端</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 服务器端响应：服务器端接收到客户端发送的请求之后，进行数据处理，返回响应</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;服务器关闭TCP连接：服务器返回应答之后，关闭TCP连接。如果在服务器返回的应答中加上connection：keep-alive，则返回应答后不会关闭TCP连接，下一次浏览器发送请求的时候仍然可以使用该连接（减少了响应时间和带宽资源的消耗）。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;HTTP中常见的状态码：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;20x表示成功，30x表示重定向，40x表示客户端错误，50x表示服务器错误</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;100（继续），101（切换协议），200（成功），201（created创建），202（accepted创建），203（未授权），204（无内容），205（重置内容），206（部分内容）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;300（多种选择），301（永久移动），302（临时移动），303（查看其它位置），304（未修改），305（使用代理），306（未使用），307（临时重定向），308（永久重定向）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;400（客户端请求错误），401（未授权），402（待付款），403（禁止访问），404（未发现），405（不允许使用该方法），406（无法接受），407（需要使用代理身份），408（请求超时），409（冲突），410（已失效），413（请求实体过长），414（请求地址过长），415（媒体类型不支持）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;500（内部服务器错误），501（未实现），502（网关错误），503（服务不可用），504（网关超时），505(Http版本不支持)</strong></p>\n<h2>五，HTTPS</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>概述：HTTPS是在http的基础上增加了SSL协议以保证传输数据的安全性，因为HTTP传输数据使用的明文传输，不安全。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;HTTPS加密流程：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 客户端和服务器端建立TCP连接之后，发送一个请求证书的请求</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 服务器端接收到请求之后，返回应答并且返回证书信息</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 客户端接收到证书之后，进行确认，如果确认正确，则生成密钥</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 客户端将密钥发送给服务器端，服务器端接收到之后利用私钥进行解密</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 经过上面的步骤，客户端和服务器端之间的数传传输就可以进行加密传输了</strong></p>\n<h2><strong>六，CDN原理（待补充）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：CDN即基于分布在不同的地方的机房服务器，通过中心平台的负载均衡，内容分发和任务调度让用户就近获取所需要的内容，降低网络延时，提升用户体验。</strong></p>\n<h2><strong>七，七层负载均衡和四层负载均衡</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;四层负载均衡：即利用ip和端口号，根据负载均衡的配置和分发策略将请求分发给真实服务器</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;七层负载均衡：利用请求的URL或者主机名接受所有用户的请求，然后将其分发给真实服务器</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;区别：四层负载均衡只能根据ip和端口号进行请求的分发，但是七层负载均衡根据URL可以根据具体的请求信息进行分发，例如一个ip下面有多个具体的请求，/user,/business等。四层负载均衡将该ip或者端口号下的所有请求都分配给一台服务器进行处理，但是七层负载均衡可以根据不同的路径信息，将/user分配给一台真实</strong><strong>服务器，将/business分配给一台真实服务器。（Nginx既支持四层负载均衡，又支持七层负载均衡）</strong></p>\n<h2><strong>八，负载均衡算法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;轮询均衡：将请求均等的分发到1-n台服务器上，用于各台服务器之间的软硬件设备没有差距的情况下。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;权重轮询均衡：即根据权重的不同，将不同数量的请求轮询分发到不同的服务器上</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;随即均衡：即将请求随机分发到服务器上</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;权重随即均衡：即根据权重的不同，将请求随机分发到服务器上</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;响应速度均衡：即根据服务器的响应速度，将请求分发到请求速度最快的服务器上</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;最少连接数均衡：即在服务器内部维护一个记录服务器处理连接数量的计数器，将请求分发到连接数最少的服务器上。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;处理能力均衡：将请求分发给内部负荷最轻的服务器</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;DNS响应均衡：不同中心机房的均衡设备接收到域名解析请求时，都进行域名解析，然后返回给客户端，客户端连接第一个返回应答的服务器，忽略其它的均衡设备。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;散列算法均衡：即通过一次性散列算法将相同参数的请求分发到一台服务器上，长期稳定的为客户端进行服务</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;IP地址散列均衡：将来自同一客户端的请求分发到同一台服务器</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;URL散列：将相同URL的请求分发到同一台服务器</strong></p>\n<h2><strong>九，Nginx的反向代理和负载均衡</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;正向代理：即客户端找代理服务器取寻找真实服务器，真实服务器并不知道客户端的ip和端口，因此可以隐藏客户端真实ip和端口</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;反向代理：即服务器找代理服务器去跟客户端打交道，在客户端眼中，代理服务器就是服务器，它并不知道真实服务器是谁</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;负载均衡：即通过Nginx，根据负载均衡的配置和分发策略将不同的请求交给不同的服务器进行处理。</strong></p>\n<p>&nbsp;</p>\n<h3><strong>思维导图：<a href=\"https://images-cdn.shimo.im/ttaA0nsU39ofHH4J__thumbnail\" target=\"_blank\" rel=\"noopener\">网络及负载均衡</a></strong></h3>\n<p>&nbsp;</p>\n<h1><strong>水平有限，如有错误，还望指出！</strong></h1>","blogGoods":0,"blogId":"1250622112591376384","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHReAPuDwAABJTVJPTfk300.jpg","blogRead":8,"blogRemark":"面试（六）------之网络与负载均衡","blogTitle":"面试（六）------之网络与负载均衡","createdTime":"2020-04-16 03:08:42","typeName":"java面试篇","updateTime":"2020-04-20 15:20:46"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，前后端分离开发优势</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，</strong>项目开发过程中，前后端完全解耦，前端只需要负责页面的实现，只需要通过接口拿数据。后端不需要管页面的跳转，只需要负责接口的编写</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，</strong>前后端人员有更多的精力去负责自己的工作，前端人员可以将更多的精力投放在页面的编写，页面的美化，页面特效的制作和用户体验上；而后端人员可以将更多的精力放在接口代码的优化，sql优化，jvm调优上面</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，</strong>前后端分离的项目部署的时候，前端项目往往都是部署在nginx服务器上，而前后端不分离的项目往往都是部署再一台服务器上。因此前后端分离项目大大降低了服务器的负担</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>4，</strong>前后端不分离的项目使用模板引擎例如freemaker，thymeleaf等，前后端人员交流起来较为困难。且前端项目使用原生的DOM操作，极大的增加了前端工作人员的工作量。而前后端分离项目前端通常都是用各种ui框架，框架采用MVVM模式，极大的减轻了前端工作人员的工作量</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，</strong>前后端分离开发，前端可以通过easy-mock来伪造接口数据进行测试，后端人员可以通过postman进行接口测试，开发效率大大提升。</p>","blogGoods":0,"blogId":"1247867141693128704","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dG6CAI6ipAACiM2P5LtI65.jpeg","blogRead":7,"blogRemark":"前后端分离开发的优势所在","blogTitle":"闲谈前后端分离开发","createdTime":"2020-04-08 12:41:25","typeName":"随笔","updateTime":"2020-04-20 11:48:53"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，栈及其JAVA实现</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：栈是一种先进后出的数据结构，对栈顶元素的添加，删除等操作较快，但是对于栈内的元素操作很慢</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA实现：实现需要定义栈的数据结构，写栈的入栈，出栈，获取栈顶元素的方法，如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n * 基于数组实现栈\n * @author wcj\n * @Date 2020/4/14 20:59\n * @Version 1.0\n */\npublic class StackExample&lt;E&gt; {\n\n    /**\n     * 站的深度\n     */\n    private int maxSize;\n    /**\n     * 存储数据的数组\n     */\n    private Object[] data;\n    /**\n     * 栈顶指针\n     */\n    private int top = -1;\n\n    /**\n     * 默认栈的深度为10\n     */\n    public StackExample(){\n        this(10);\n    }\n\n    /**\n     * 用户自定义栈的深度\n     * @param initialSize\n     */\n    public StackExample(int initialSize){\n        if(initialSize&gt;=0){\n            this.maxSize = initialSize;\n            this.data = new  Object[initialSize];\n            this.top = -1;\n        }else{\n            throw new RuntimeException(\"初始化栈的深度不能小于0!\");\n        }\n    }\n\n    /**\n     * 入栈操作\n     * @param e\n     * @return\n     */\n    public Boolean push(E e){\n        if(top == maxSize-1){\n            throw new RuntimeException(\"栈已满,不能入栈\");\n        }else{\n            data[++top] = e;\n        }\n        return true;\n    }\n\n    /**\n     * 出栈操作\n     * @return\n     */\n    public E pop(){\n        if(top==-1){\n            throw new RuntimeException(\"栈空，不能出栈！\");\n        }else{\n            return (E) data[top--];\n        }\n    }\n\n    /**\n     * 获取栈顶元素\n     * @return\n     */\n    public E peak(){\n        if(top==-1){\n            throw new RuntimeException(\"栈空异常！\");\n        }else{\n            return (E) data[top];\n        }\n    }  </code></pre>\n<h2><strong>二，队列极其JAVA实现</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：队列是一种先进先出的数据结构，对队头和队尾的操作简单，但是队内元素的操作复杂。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA实现：定义队列的数据结构，队列的出队，入队，获取队头元素。代码如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n * 基于数组实现队列\n * @author wcj\n * @Date 2020/4/14 21:14\n * @Version 1.0\n */\npublic class QueueExample&lt;E&gt; {\n\n    /**\n     * 队列长度\n     */\n    private int maxSize;\n    /**\n     * 存储数据数组\n     */\n    private Object[] data;\n    /**\n     * 队头指针\n     */\n    private int front;\n    /**\n     * 队尾指针\n     */\n    private int rear;\n\n    /**\n     * 默认构造器\n     */\n    public QueueExample(){\n        this(10);\n    }\n    /**\n     * 用户自定义队列长度构造器\n     * @param initialSize\n     */\n    public QueueExample(int initialSize){\n        if(initialSize&gt;=0){\n            this.maxSize = initialSize;\n            data = new Object[initialSize];\n            front = rear = 0;\n        }else{\n            throw new RuntimeException(\"初始化队列长度不能小于0！\");\n        }\n    }\n\n    /**\n     * 入队操作\n     * @param e\n     * @return\n     */\n    public Boolean add(E e){\n        if(rear == maxSize){\n            throw new RuntimeException(\"队列已满，无法入队!\");\n        }else{\n            data[rear++] = e;\n        }\n        return true;\n    }\n\n    /**\n     * 出队操作\n     * @return\n     */\n    public E poll(){\n        if(front==rear){\n            throw new RuntimeException(\"队空，无元素可出队！\");\n        }else{\n            E e = (E) data[front];\n            data[front] = null;\n            return e;\n        }\n    }\n\n    /**\n     * 获取队头元素\n     * @return\n     */\n    public E peek(){\n        if(front==rear){\n            throw new RuntimeException(\"队空，无元素可出队!\");\n        }else{\n            return (E) data[front];\n        }\n    }\n}\n</code></pre>\n<h2><strong>三，链表及其JAVA实现</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：链表是由一系列数据节点组成的数据结构，节点可以动态生成。对于元素的增加，删除操作快，查询操作慢</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;这里主要讲述几种有代表性的链表：单向链表，双向链表，双向循环链表</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;单链表的JAVA实现：数据结构定义，添加节点，删除节点，查找节点，代码如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n * 单向链表\n * @author wcj\n * @Date 2020/4/14 21:32\n * @Version 1.0\n */\npublic class SingleLinkedList {\n\n    /**\n     * 链表长度\n     */\n    private int length;\n    /**\n     * 链表头节点\n     */\n    private Node head;\n\n    public SingleLinkedList(){\n        this.length = 0;\n        this.head = null;\n    }\n    /**\n     * 内部类声明每个链表节点\n     * 每个节点包括数据域和指向下一个节点的指针\n     */\n    private class Node{\n        private Object data;\n        private Node next;\n        public Node(Object data){\n            this.data = data;\n        }\n    }\n\n    /**\n     * 插入节点（这里使用头插法）\n     * @param obj\n     * @return\n     */\n    public Boolean add(Object obj){\n        Node node = new Node(obj);\n        if(length==0){\n            head = node;\n        }else{\n            node.next= head;\n            head = node;\n        }\n        length++;\n        return true;\n    }\n\n    /**\n     * 删除某个节点\n     * 先对链表进行判空处理\n     * 然后找到要删除的节点\n     * 最后进行删除\n     * @param obj\n     * @return\n     */\n    public Boolean delete(Object obj){\n        if(length==0){\n            throw new RuntimeException(\"链表为空，无节点可删除!\");\n        }else{\n            Node prev = head;\n            Node current = head;\n            //查找待删除元素\n            while(!current.data.equals(obj)){\n                if(current.next==null){\n                    return false;\n                }else{\n                    prev = current;\n                    current = current.next;\n                }\n            }\n            prev.next = current.next;\n            length--;\n        }\n        return true;\n    }\n\n    /**\n     * 获取某个元素\n     * @param obj\n     * @return\n     */\n    public Object find(Object obj){\n        if(length==0){\n            throw new RuntimeException(\"链表为空\");\n        }else{\n            Node current = head;\n            while(current.data.equals(obj)){\n                if(current.next==null){\n                    return null;\n                }else{\n                    current = current.next;\n                }\n            }\n            return current.data;\n        }\n    }\n}\n</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>双向链表的JAVA实现：定义数据结构，头插法，尾插法，删除头部节点，删除尾部节点（这里只写尾插节点和删除尾部节点），代码如下：</strong></p>\n<pre class=\"language-java\"><code>import com.sun.org.apache.xpath.internal.operations.Bool;\n\n/**\n * 单向循环链表\n * @author wcj\n * @Date 2020/4/14 22:05\n * @Version 1.0\n */\npublic class CircleLinkedList {\n\n    /**\n     * 链表长度\n     */\n    private int length;\n    /**\n     * 头节点\n     */\n    private Node head;\n    /**\n     * 尾节点\n     */\n    private Node tail;\n\n    /**\n     * 初始化构造方法\n     */\n    public CircleLinkedList(){\n        this.length = 0;\n        this.head=this.tail = null;\n    }\n\n    /**\n     * 内部类实现的链表节点\n     */\n    private class Node{\n        private Object data;\n        private Node prev;\n        private Node next;\n        public Node(Object data){\n            this.data = data;\n        }\n    }\n\n    /**\n     * 尾插节点\n     * @param obj\n     * @return\n     */\n    public Boolean addTail(Object obj){\n        Node node = new Node(obj);\n        if(length==0){\n            head = tail= node;\n            length++;\n        }else{\n            tail.next = node;\n            node.prev = tail;\n            tail = node;\n            length++;\n        }\n        return true;\n    }\n\n    /**\n     * 删除尾部节点\n     * @return\n     */\n    public Boolean delTail(){\n        Node temp = tail;\n        if(length==0){\n            throw new RuntimeException(\"链表为空!\");\n        }else{\n            tail = tail.prev;\n            tail.next = null;\n            length--;\n        }\n        return true;\n    }\n}\n</code></pre>\n<h2><strong>四，散列表</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：有一张表M，一个映射函数f(key)，如果对于任意一个key，都有一个函数指与表中的内存地址相对应，则M就为散列表，f(key)就为散列函数。散列函数存储key-value键值对形式的数据，直接生成key与表中地址值的映射，因此查询非常迅速。同时散列表也经常被用于信息安全，用于加密操作。</strong></p>\n<h2><strong>五，二叉排序树</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：二叉查找树又成为二叉搜索树，二叉查找树</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;特征：根节点左边的数据小于根节点，根节点右边的数据大于根节点，且其左右子树还是二叉排序树</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现：定义数据结构，插入操作，删除操作，查找操作，代码如下：</strong></p>\n<pre class=\"language-java\"><code>package interviewFour.example4;\n\n/**\n * 二叉排序树\n * @author wcj\n * @Date 2020/4/14 17:17\n * @Version 1.0\n */\npublic class Node {\n\n    private Node root = null;\n    private int value;\n    private Node left;\n    private Node right;\n\n    public Node(){}\n\n    public Node(int value, Node left, Node right){\n        this.value = value;\n        this.left = left;\n        this.right = right;\n    }\n\n    public Node(int value){\n        this.left = null;\n        this.right = null;\n        this.value = value;\n    }\n\n    public int getValue() {\n        return value;\n    }\n\n    public void setValue(int value) {\n        this.value = value;\n    }\n\n    public Node getLeft() {\n        return left;\n    }\n\n    public void setLeft(Node left) {\n        this.left = left;\n    }\n\n    public Node getRight() {\n        return right;\n    }\n\n    public void setRight(Node right) {\n        this.right = right;\n    }\n\n    /**\n     * 插入节点\n     * @param value\n     * @return\n     */\n    public Boolean insert(int value){\n        //root代表根节点\n        Node p = root;\n        Node prev = null;\n        //创建一个节点\n        Node node = new Node(value);\n        //寻找节点的插入位置\n        while(p!=null){\n            prev = p;\n            if(value==p.getValue()){\n                return false;\n            }else if(value&lt;p.getValue()){\n                p = p.getLeft();\n            }else{\n                p = p.getRight();\n            }\n        }\n        if(root==null){\n            root = node;\n        }else if(value&lt;prev.getValue()){\n            prev.setLeft(node);\n        }else{\n            prev.setRight(node);\n        }\n        return true;\n    }\n\n    /**\n     * 删除某个节点\n     * 分为三种情况，待删除节点为叶子节点，则直接删除\n     * 待删除节点只有左子树或者右子树，则用左子树或者右子树替代当前节点位置\n     * 待删除节点即有左子树又有右子树，则寻找左子树最大节点或者右子树最小节点顶替当前节点(这里使用左子树的最大节点)\n     * @param value\n     * @return\n     */\n    public void deleteBST(int value){\n        deleteBST(root,value);\n    }\n\n    /**\n     * 递归删除左子树，或者右子树，或者根节点\n     * @param root\n     * @param value\n     * @return\n     */\n    public Boolean deleteBST(Node root,int value){\n        if(root==null){\n            return false;\n        }else{\n            if(root.getValue()==value){\n                delete(root);\n            }else if(value&lt;root.getValue()){\n                deleteBST(root.getLeft(),value);\n            }else{\n                deleteBST(root.getRight(),value);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * 分情况执行具体的删除逻辑\n     * @param node\n     * @return\n     */\n    public Boolean delete(Node node){\n        if(node.getLeft()==null){\n            node = node.getRight();\n        }else if(node.getRight()==null){\n            node = node.getLeft();\n        }else{\n            Node temp = node;\n            Node s = node;\n            //转向左子树，向右走到底\n            s = s.getLeft();\n            //寻找替换待删除节点的节点\n            while(s!=null){\n                temp = s;\n                s = s.getRight();\n            }\n            node.setValue(temp.getValue());\n            if(temp!=node){\n                node.setLeft(temp.getLeft());\n            }else{\n                node.setRight(temp.getRight());\n            }\n        }\n        return true;\n    }\n\n    /**\n     * 在二叉查找树中找到对应节点\n     * @param value\n     * @return\n     */\n    public Boolean searchBTS(int value){\n        Node node = root;\n        if(node==null){\n            throw new RuntimeException(\"无此节点！\");\n        }else{\n            if(value==node.getValue()){\n                return true;\n            }else if(value&lt;node.getValue()){\n                node = node.getLeft();\n            }else{\n                node = node.getRight();\n            }\n        }\n        return false;\n    }\n}\n</code></pre>\n<h2><strong>六，红黑树</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 概述：红黑树是一种特化的自平衡二叉排序树，即其左右子树的深度差可以超过1。（详细的插入等操作过段时间会补充）</strong></p>\n<h2><strong>七，图，位图</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;图的知识：定义，有向图/无向图，邻接矩阵/邻接表，BFS/DFS，位图的话没怎么搞清楚。</strong></p>\n<h3><strong>思维导图：<a href=\"https://images-cdn.shimo.im/YClQaLxx9e8uEb9U__thumbnail\" target=\"_blank\" rel=\"noopener\">数据结构</a></strong></h3>\n<h2>&nbsp;</h2>","blogGoods":0,"blogId":"1250068950784536576","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHQGAYlUxAABJTVJPTfk990.jpg","blogRead":7,"blogRemark":"面试（四）------之数据结构篇","blogTitle":"面试（四）------之数据结构篇","createdTime":"2020-04-14 14:30:37","typeName":"java面试篇","updateTime":"2020-04-23 22:14:43"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，分布式缓存</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;进程内缓存：对于用户信息，热点数据等信息，访问比较频繁，我们将其存放进入缓存，用户查询数据的时候直接从内存种读取，而不需要从数据库查询，既降低了数据库的负载，同时又提升了查询效率。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;分布式缓存：对于单点web应用，我们使用进程内缓存就足够了，但是对于分布式系统，数据库是部署在多个服务器上分布式数据库，缓存则是部署在多个服务器上的分布式缓存，并且缓存数据存在备份，当一个缓存服务挂掉之后，可以立即启用备份的缓存进行工作（高可用）。</strong></p>\n<h2><strong>二， redis的基本数据类型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;String，hash，List，Set，Zset</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;基本数据类型的基本命令见redis篇：<a href=\"http://localhost:1002/info/1249588251598041088\">http://localhost:1002/info/1249588251598041088</a></strong></p>\n<h2><strong>三，redis管道</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;客户端发出一个redis命令请求之后，会监控socket，客户端处于阻塞状态，直到服务器端返回结果，客户端才可以继续发出下一个请求。且在分布式系统中，redis是部署在不同的服务器上，这样服务器之间的数据传输还会有一定的延迟，redis的性能瓶颈就是在网络延迟上 。redis管道机制，即客户端发出一个请求之</strong><strong>后，可以不等服务器端返回结果就发送下一个请求，然后批量的接收服务器端返回的结果。这样客户端批量发出请求，服务器端接</strong><strong>收到批量请</strong><strong>求之后，进行处理返回批量数据。这样提高了redis的性能。</strong></p>\n<h2><strong>四，redis事务</strong></h2>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>基本命令（multi开启事务，exec执行事务，discard取消事务，watch监听某个key的变化，unwatch取消监听所有key的变化）</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;事务基本流程：客户端执行multi命令开启事务</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;客户端提交命令到事务</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;redis将客户端请求放入事务队列等待</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;服务器返回QURUD，表明命令已经进入事务</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;客户端通过exec执行事务</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;执行事务的过程中，如果有某个命令错误，则其它命令继续执行，不会回滚。</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;服务器端向客户端返回事务的执行结果</strong></p>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong></p>\n<h2><strong>五， redis的发布，订阅</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;发布者向频道发布消息，订阅者从频道获取消息（<span style=\"background-color: #ffcc00;\">有待补充</span>）</strong></p>\n<h2><strong>六，redis集群数据复制原理</strong></h2>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;从数据库（slave）发出数据同步请求SYNC给主数据库（master）</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;主数据库接收到从数据库的请求，进行快照，并将快照期间的命令缓存起来，生成.rdb文件</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;主数据库将.rdb文件发送给从数据库</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;从数据库接收到.rdb文件，载入文件进入本地</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;从数据库执行快照，将数据写入内存，即初始化</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;从数据库初始化完成后，主数据接收到写请求之后，会将写请求发送给从数据库，实现数据的一致性</strong></p>\n<h2><strong>七，</strong><strong>redis持久化</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;redis持久化有rdb和aof两种，rdb即采用快照的方式，每隔一定的时间，进行依次数据的快照，对于大数据集的数据处理较快，但是对于数据的完整性要求较低。aof方式是采用日志的形式，将写操作的命令都存于aof文件中，启动服务的时候直接将aof中的命令按顺序执行用以构建原始数据集，但是速度较慢，</strong><strong>且aof文件的大小要比rdb文件大。如果两种方式都开启，则启动服务的时候默认采用aof的方式进行数据恢复。</strong></p>\n<h2><strong>八， redis的集群模式及工作原理</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;主从模式：中心化，所有的写请求都发送到主数据库，读操作分发给从数据库，分担主句库的压力。但是缺陷很明显，如果主数据库宕机，则从数据库必须要阻塞等待，或者手动切换从数据库为主数据库？</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;哨兵模式：即主数据库宕机，自动选举从数据库。设置一个哨兵监视集群的运行状态，如果主数据库宕机，哨兵会依据投票机制从数据库中选举出一个主数据替换宕机的主数据库。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;集群模式：redis集群实现了redis的数据分片和数据复制能力。数据分片能够让我们对redis进行横向扩展，提升集群的吞吐量。数据复制能力，在一些节点挂掉之后，集群仍然能够对外提供服务。</strong></p>\n<h2><strong>九，redis整合springboot见redis篇</strong></h2>\n<h2><strong>十，分布式缓存设计的核心问题</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;缓存预热：用户请求数据前先将数据保存到缓存中。通常的方法是系统启动加载，定时加载</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;缓存更新：即当数据发生变化的时候，对缓存中的数据进行更改</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;缓存淘汰策略：FIFO（先进先出，即先淘汰时间长远的缓存），LRU（最近最少使用，即判断缓存最近被使用的时间，淘汰离被使用时间最远时间的缓存），LFU（最不经常使用，即在一段时间内，被使用次数最少的缓存淘汰）</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;缓存雪崩：即缓存中同一时间有大量的数据失效，导致用户请求直接访问数据库，增大数据库的负荷，导致数据库宕机甚至整个系统的崩溃。</strong><strong>&nbsp;设置随机的失效时间，缓存更新，请求加锁</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;缓存穿透：即请求一条缓存中没有的数据，则会直接访问数据库，如果同一时间大量不存在的key访问缓存，就会都去访问数据库，导致数据库宕机。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;布隆过滤器：即用户请求访问缓存之前先经过布隆过滤器，如果发现数据库和缓存中都不存在该数据，则拒绝该请求。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;cache&nbsp; null：即如果访问的数据请求返回为null，则对null值也进行缓存，只不过需要给它设置一个短暂的失效时间这样在接收到相同的请求的时候，从缓存中读取返回null，不会访问数据库</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;缓存降级：当读操作增加的时候，我们先从缓存中读取，等到数据库恢复正常再从数据库读取</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;当写操作增加的时候，我们先从写入缓存，然后再异步的写入数据库。</strong></p>\n<p>&nbsp;</p>\n<h3><strong>思维导图：<a href=\"https://images-cdn.shimo.im/uourbKTxfdENHW8g__thumbnail\" target=\"_blank\" rel=\"noopener\">分布式缓存及原理</a></strong></h3>\n<h1><strong>水平有限，如有错误，还望指出！</strong></h1>","blogGoods":0,"blogId":"1250774653945802752","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHSyAAWJ1AABJTVJPTfk093.jpg","blogRead":7,"blogRemark":"面试（八）------之分布式缓存的原理及应用","blogTitle":"面试（八）------之分布式缓存的原理及应用","createdTime":"2020-04-16 13:14:51","typeName":"java面试篇","updateTime":"2020-04-20 17:22:08"}],"pageSize":10,"params":{},"sortColumn":"blog_read","sortMethod":"DESC","totalCount":53,"totalPage":6},"msg":"操作成功!"}
2020-04-26 23:27:35.300 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/list
2020-04-26 23:27:35.301 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:27:35.301 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:27:35.302 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogList
2020-04-26 23:27:35.302 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=10, totalPage=6, totalCount=53, list=[BlogVo(blogId=1247745014683947008, blogTitle=博客开发总结（一）-----之数据库设计篇, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dDViAcnjvAACb6PL1tzA485.jpg, blogContent=<p><strong>一，数据库设计--表的命名规范等</strong></p>
<p>（1），统一采用bl_开头对表进行命名</p>
<p>（2），对于数据比较重要的表统一添加四个字段，分别为：created_time(创建时间),update_time(修改时间),version(版本号),deleted(删除字段)</p>
<p>（3），数据库表的字段尽量都设置为NOT_NULL</p>
<p>（4），数据库中表varchar类型字段需要设置长度的尽量设置为2<sup>n</sup>-1</p>
<p>（5），因为博客系统分为前台展示界面和后台管理，所以对于有些表，例如bl_type（博客类型表），bl_music（音乐表）等设置了enable（启用字段）</p>
<p><strong>二，上述第二条--四个字段的解释</strong></p>
<p>（1），为什么要设置created_time和update_time字段：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;其一，从数据库的通用性上来说，设计这两个字段是必要的，但也需要根据业务的需要来合理添加这两个字段，因为无用的字段会浪费空间，性能，影响系统的运行。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 其二，大部分的应用都有需要根据时间进行排序的功能。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 其三，当系统发生异常的时候，我们可以通过这两个字段对异常进行排查和定位。</p>
<p>（2），为什么要设置version字段：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 1，version字段含义：字段的含义与其字面意思一样，代表版本，在这里作为乐观锁进行使用，从而保证不会出现脏数据的情况。下面解释一下什么叫乐观锁，以及乐观锁和悲观锁</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 2，乐观锁：总是假定最好的情况，即每次用户调用接口从数据库中取出数据到修改数据前的过程中，不会有其它用户对当前数据进行修改，这样在当前用户修改数据的时候，利用版本机制即判断取出的version字段和当前数据库该条数据的version字段是否相等来判断该条数据是否已经被修改，如果未修改，则予以修改（且version字段递增），如果已经修改，则提示用户更新失败。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 悲观锁：总是假定最坏的情况，即每次用户调用接口从数据库取出数据的时候，都认为该条数据会被修改，因此每次取出数据都对数据进行加锁处理，只允许当前用户进行修改，其它用户阻塞，直到当前用户修改完毕。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3，为什么使用乐观锁而不使用悲观锁：因为悲观锁比较浪费性能</p>
<p>（3），为什么设置deleted字段：deleted字段在这里作为一个逻辑删除字段（0否1是），何为逻辑删除，即执行删除操作操作的时候，不会真正的删除数据库中的数据，而是将deleted字段设置为1即可。&nbsp;这样如果用户出现误删的操作，可以通过数据库修改该字段进行数据的恢复。</p>
<p><strong>三，上述第三条--数据库表字段尽量设置为NOT_NULL</strong></p>
<p>（1），数据库表字段尽量设置为NOT_NULL：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 1，有些人可能认为设置为NULL相比于NOT_NULL不是更节省空间吗？但是实际上不是这样的，设计为NULL相比于NOT_NULL要多占用一个字节的空间</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 2，设计为NOT_NULL，这样在做查询的时候能够更好的避免空指针异常，且发生该类错误的时候能够更好的进行排查</p>
<p><strong>四，上述第四条--表varchar类型字段长度尽量设置为2<sup>n</sup>-1</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>因为计算机只识别二进制，且有一定的范围，例如2<sup>8</sup>，在计算机中的范围为-128~127,因此对于varchar字段长度来说，如果设置为255，则正好是一个字节，而如果设置为256，则占用两个字节，这样会浪费计算机的内存空间，因此数据库varchar类型字段的长度最好设置为2<sup>n</sup>-1</p>
<p><strong>五，上述第五条--对于设置enable字段的解释</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>enable字段，字面意思启用，在这里表明是否启用（0否1是），因为系统分为前台博客页面和后台管理，对于这两个不同的前端项目，后台可以通过启用字段来控制内容在前台博客页面的展示与否，与deleted字段不同的是，如果执行删除操作，那么我们只能通过手动修改数据库中的字段进行数据的恢复，且如果执行删除操作，则该数据在前台博客页面和后台管理页面都无法看见。但是如果将数据弃用（即修改enable字段值为1），则表明该数据被弃用，在前台博客页面无法显示，但是在后台管理页面可以看见，且无需通过手动修改数据库来恢复数据，可以在后台管理页面操作启用数据。</p>
<p>&nbsp;</p>, blogGoods=0, blogRead=21, blogCollection=0, typeName=博客开发和维护总结, blogRemark=博客开发总结（一）-----之数据库设计篇, blogComment=0, blogSource=null, createdTime=2020-04-08 04:36:07, blogMonth=null, updateTime=2020-04-20 10:47:54), BlogVo(blogId=1247867141693128704, blogTitle=闲谈前后端分离开发, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dG6CAI6ipAACiM2P5LtI65.jpeg, blogContent=<p><strong>一，前后端分离开发优势</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，</strong>项目开发过程中，前后端完全解耦，前端只需要负责页面的实现，只需要通过接口拿数据。后端不需要管页面的跳转，只需要负责接口的编写</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，</strong>前后端人员有更多的精力去负责自己的工作，前端人员可以将更多的精力投放在页面的编写，页面的美化，页面特效的制作和用户体验上；而后端人员可以将更多的精力放在接口代码的优化，sql优化，jvm调优上面</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，</strong>前后端分离的项目部署的时候，前端项目往往都是部署在nginx服务器上，而前后端不分离的项目往往都是部署再一台服务器上。因此前后端分离项目大大降低了服务器的负担</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>4，</strong>前后端不分离的项目使用模板引擎例如freemaker，thymeleaf等，前后端人员交流起来较为困难。且前端项目使用原生的DOM操作，极大的增加了前端工作人员的工作量。而前后端分离项目前端通常都是用各种ui框架，框架采用MVVM模式，极大的减轻了前端工作人员的工作量</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，</strong>前后端分离开发，前端可以通过easy-mock来伪造接口数据进行测试，后端人员可以通过postman进行接口测试，开发效率大大提升。</p>, blogGoods=0, blogRead=7, blogCollection=0, typeName=随笔, blogRemark=前后端分离开发的优势所在, blogComment=0, blogSource=null, createdTime=2020-04-08 12:41:25, blogMonth=null, updateTime=2020-04-20 11:48:53), BlogVo(blogId=1248135765829918720, blogTitle=CSS----之flex弹性布局, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dGnuAWkLLAAAaRXQXNms575.jpg, blogContent=<p><strong>一，css之弹性布局</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，</strong>何为弹性布局？</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 弹性布局是css的一种新的布局方式，所谓&ldquo;弹性布局&rdquo;，即页面随着不同设备的屏幕大小拉伸会自适应页面的大小。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，</strong>弹性布局的两种主要元素，container（弹性容器），item（弹性子元素），一个弹性容器中可以放入多个弹性子元素，元素之间是可以进行嵌套的，弹性子元素也可以设置为弹性容器，里面再嵌套弹性子元素。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，</strong>弹性布局的基本属性</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （1）display：flex，声明容器为弹性布局</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （2）flex-direction：声明弹性容器内部元素的排列方式，默认为row。row（横向布局），row-reverse（横向布局，但是元素反方向码），column（纵向布局），column-reverse（纵向布局，但是元素反着码）。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （3）flex-wrap：声明弹性盒子中的元素是否可以换行，默认为nowrap（不换行），wrap（换行），wrap-reverse（换行，但是反着码）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （4）align-items：设置容器中元素在纵轴方向上的对齐方式，默认为stretch（即如果不设置子元素高度，则默认拉伸至于容器同宽度），flex-start（子元素位于容器的开始位置），flex-end（子元素位于容器的结尾处），center（元素依纵轴方向居中），baseline（元素位于容器基线，不过没怎么用过，所以不是很清楚）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; （5）justify-content（设置元素在主轴上的对齐方式），默认为flex-start（元素从容器主轴开始位置码），flex-end（元素从容器主轴结尾处码），center（元素位于主轴居中处），space-between（元素布局在容器的两端），space-around（元素布局在容器两端，但是元素前后都留有空白）因为项目中大多数只使用了对于容器的操作，对于容器中元素的操作很少，所以这里只介绍这点。谢谢阅读！</p>, blogGoods=0, blogRead=3, blogCollection=0, typeName=CSS, blogRemark=CSS----之flex弹性布局, blogComment=0, blogSource=null, createdTime=2020-04-09 06:28:51, blogMonth=null, updateTime=2020-04-20 11:43:57), BlogVo(blogId=1248224512563068928, blogTitle=面试（一）------之JVM篇, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dHLeALxSjAABJTVJPTfk677.jpg, blogContent=<h2 style="text-align: left;"><strong>一，JVM运行机制</strong></h2>
<p>&nbsp;&nbsp; &nbsp; &nbsp;jvm即java虚拟机，一共由四个部分组成，分别是类加载器子系统，运行时数据区（程序计数器，本地方法区，jvm栈，方法区，jvm堆），执行引擎（即时编译器，垃圾收集器），本地接口库。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;一个java源程序的运行先是经过编译器将其编译成字节码文件（class文件），然后通过类加载器子系统将其加载进入jvm&mdash;&mdash;&gt;程序运行过程中，运行时数据区存放程序运行过程产生的数据&mdash;&mdash;&gt;执行引擎中的垃圾收集器收集程序运行过程中创建的不再使用的对象，即时编译器将程序的字节码文件编译成机器码&mdash;&mdash;&gt;然后本地接口库利用机器码调用本地方法库中的方法，和操作系统实现交互。</p>
<h2><strong>二，多线程</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;</strong>在多核操作系统中，jvm支持一个进程中同时并发执行多个线程，且这些线程和本地操作系统的线程相对应。当jvm中的对象初始化，内存空间分配等一系列准备工作完成之后，会调用操作系统中的接口创建一个原生线程，原生线程初始化完毕后，会调用java线程的run（）方法执行该线程，线程结束之后，jvm会释放原生线程和java线程资源。</p>
<h2><strong>三，JVM的内存区域</strong></h2>
<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM的内存区域主要分为线程私有区域（程序计数器，本地方法区，JVM栈），线程共享区（方法区，JVM堆）和直接内存。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;程序计数器：线程私有区域，无内存溢出，用来记录程序运行过程中的字节码指令地址，如果是Native方法，则程序计数器为空。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM栈：线程私有区域，用来描述java程序的运行过程，java程序运行每次运行的时候，都会创建一个栈帧，方法的执行和返回对应着栈帧的入栈和出栈操作。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;本地方法区：线程私有区域，和JVM栈的功能一样，只不过是用来记录Native方法的运行过程。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM堆：线程共享区，主要用来存放程序运行过程中产生的数据，同时也是垃圾收集器进行垃圾回收的主要区域。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;方法区：也被称为永久代，用来存放常量，静态变量，类信息等等。</p>
<h2><strong>四，JVM的运行时内存</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>JVM的运行时内存又被称为JVM堆，因为JVM的GC算法使用的是分代收集算法，所以JVM堆按照GC标准可以分为三个区域分别为：新生代，老年代，永久代。其中新生代占1/3，老年代占2/3，永久代很少，</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;新生代：存放短生命周期，小对象的区域。新生代又分为Eden区，ServivorTo区，ServivorFrom区，区域的GC算法采用复制算法。Eden区是用来存放新创建的对象（大对象除外），ServivorTo区是用来保存MinorGC幸存下来的对象，ServivorFrom区是用来将上一次MinorGC幸存下来的对象作为下一次MinorGC的扫描对象。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;老年代：存放长生命周期的大对象，区域的GC算法采用标记整理算法</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;永久代：主要用来存放class和meta数据信息的。程序运行过程中不会进行永久代的垃圾回收，这也就导致永久代区域的数据会越来越多，最终造成内存溢出。java8之后永久代已经被元数据区取代，元数据区和永久代的功能都是一样的，但是最大的不同在于永久代区域依赖于虚拟机的内存大小，因而可以存储的class，meta信息非常有限。但是元数据区依赖的是本地操作系统，因而不会受到虚拟机内存的限制。</p>
<h2><strong>五，垃圾回收与算法</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;(1)垃圾回收：</strong>Jvm的垃圾回收判定依赖于两种方法，引用计数法和可达性分析法。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;引用计数法：即如果想要在程序中使用对象，就必须赋予一个引用，这样在对象赋予引用的时候将其引用计数加1，删除一个引用时，将对象引用计数减1，如果引用计数为0，就说明该对象已经不使用，作为垃圾。但是引用计数法存在一个缺陷，即循环引用的问题，如果两个对象相互引用，则这两个对象的引用计数永远都不会为0，造成对象无法被回收。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;可达性分析法：即先创建一些根节点对象ROOTS，然后通过这些根节点对象向下搜索，如果一个对象到任意一个ROOTS之间都没有可达路径，在经过两次标记（下文解释为什么进行两次标记），还是没有可达路径，则说明该对象可回收。</p>
<p>&nbsp;&nbsp; &nbsp;<strong>（2）GC算法：</strong>常见的GC算法有四种，分别为标记清除算法，复制算法，标记整理算法，分代收集算法</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;标记清除算法：即在进行垃圾回收前，对所有对象进行一次标记，标记可回收的对象，然后进行清理即可。但是标记清除算法在清除回收对象之后，并不会对堆内存进行整理，这样的话如果内存中的对象大部分为小对象，清理之后就会导致没有大片连续的内存空间，即造成了内存碎片化，这样大对象存储的时候就无法找到相应的完整连续内存。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;复制算法：即将内存分为两块同等大小的区域，区域1和区域2，创建的新对象都存储在区域1中，当区域1中的内存占满之后，会对内存中的所有对象进行一次标记，标记存活的对象，将存活的对象复制到区域2，这时区域1中的对象都是可回收对象，回收区域1中的所有对象即可。但是复制算法也存在着一定的缺陷，即每次都只能使用一半的内存空间，造成了大量的内存浪费。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;标记整理算法：即结合标记清除算法和复制算法的优点，先对所有的对象进行标记，标记存活的对象，将存活的对象复制到内存的另一端，然后清除当前端的对象即可。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;分代收集算法：前面的三种算法，都无法按照对象的类型进行收集，分代收集算法正是解决这个问题，按照对象的不同类型采用不同的GC算法。以JVM的分代收集算法为例，JVM的堆内存分为新生代，老年代，永久代。新生代又分为Eden区，ServivorTo区和ServivorFrom区。新生代因为其存储生命周期短的小对象，GC比较频繁，所以采用复制算法。程序运行过程中创建的对象都存储在Eden区（大对象除外，大对象直接复制到老年代区域）。当Eden区的内存不够的时候进行MinorGC，然后将Eden区和ServivorFrom区的存活对象都复制到ServivorTo区，然后将ServivorTo区和ServivorFrom区进行交换，再次进行MinorGC。老年代因为存放的都是生命周期长的大对象，因而进行GC的不会太频繁，且清除的对象并不会太多，因而采用标记整理算法。老年代每次进行MajorGC之前都会先进行一次MinorGC，当MinorGC之后新生代的内存仍然不够的时候，将对象复制到老年代进行MajorGC。永久代区域主要回收常量，无用class等。</p>
<h2><strong>六，JAVA中的四种引用类型</strong></h2>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;强引用类型<strong>：</strong>即把对象赋给一个引用变量，强引用的对象一定为可达状态，所以不会进行垃圾回收。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;软引用类型：通过SoftReference类实现，当内存不够的时候对其进行GC</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;弱引用类型：只有弱引用类型的对象，一定会被GC</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;虚引用类型：虚引用对象主要是用来跟踪对象的GC状态</p>
<h2><strong>七，分代收集算法和分区收集算法</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>分代收集算法：新生代因其存放大量短生命周期小对象，且GC频繁，所以采用复制算法。老年代因其存放长生命周期大对象，且GC不平凡，所以采用标记整理算法。永久代，回收常量，类信息等。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;分区收集算法：即将堆内存区域分为大小不同的区，可以按照不同的区进行快速垃圾回收，减少系统的停顿时间。然后再以并行的方式逐步完成整个GC。</p>
<h2><strong>八，垃圾收集器</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>新生代区域：Serial垃圾收集器，单线程复制算法，因为单线程无需进行线程之间的交互和切换，所以效率非常高，是JVM默认的client模式下的默认垃圾回收策略，工作期间需要暂停其它所有的线程。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ParNew垃圾收集器，多线程复制算法，跟单线程Serial一样，是JVM默认的server模式下的垃圾回收策略，工作期间需要暂停所有其它线程</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Parallel Scavenge垃圾收集器：多线程复制算法，不同的是优先考虑系统吞吐量，可以利用更高效的利用CPU完成GC</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;老年代区域：Serial Old垃圾收集器，单线程标记整理算法，同新生代的Serial功能一样，只是采取的算法不同而已。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Parallel Old垃圾收集器：多线程标记整理算法，优先考虑了系统的吞吐量，其次考虑停顿时间。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CMS,多线程标记清除算法，优先考虑系统GC时的停顿时间，且过程分为四步（<span style="background-color: #ffff00;">解释上文的可达性分析中的两次标记</span>，第一步：标记GC ROOTS可达对象，暂停其它工作线程；第二步：和用户线程一起工作，跟踪GC ROOTS；第三步，因为第二步用户进程没有暂停，所以有些对象状态</p>
<p>可能发生了改变，重新进行标记；第四步，清除不可达对象）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; G1垃圾收集器，多线程标记整理算法，将内存分区，与CMS相比，一方面不会产生内存碎片，一方面，可以精确的控制系统停顿时间。</p>
<h2><strong>九，JAVA的网络编程模型</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;</strong>阻塞I/O模型：即用户线程发出I/O请求之后，内核会检查数据是否准备就绪，这时候用户线程始终处于阻塞状态等待数据准备就绪。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;非阻塞I/O模型：即用户线程不断的给内核发出I/O请求，内核接受到I/O请求之后会返回一个状态，如果数据准备就绪，就将数据复制进入用户线程，如果数据没有准备好，返回一个false，用户线程无需阻塞，可以去处理其它事情，而当数据准备好了且刚好用户线程发起I/O请求进行操作。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;多路复用I/O模型：多路复用I/O模型通过一个Selector线程轮询Socket的状态，如果Socket有读写事件，则进行I/O操作。此模型的优势在于可以更好的处理连接数众多但消息体不大的情况下。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;信号驱动I/O模型：即用户线程发出一个I/O请求，系统会为该请求创建一个信号函数，用户请求可继续执行其它业务逻辑，当内核数据准备就绪之后会返回给用户线程一个信号，用户线程接收到之后进行I/O操作。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;异步I/O模型：用户线程给内核发起一个asynchronous read操作，内核接收到之后，返回其请求是否成功，然后等待数据准备成功之后复制到用户线程。整个过程中请求的发起和数据读取都在内核中进行，最终发送一个信号告知用户线程I/O操作已经完成，用户直接使用数据就行。（说实话个人感</p>
<p>觉和信号驱动很像）</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;java NIO：没怎么读懂（<span style="background-color: #993300;">记得补充！</span>）</p>
<h2><strong>十，JVM的类加载机制</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>JVM类加载分为五个阶段：加载，验证，准备，解析，初始化</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;加载：即将class文件加载到JVM中，且创建class对象，封装其数据结构。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;验证：对class文件进行验证，确保符合JVM的标准，保证JVM的安全。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;准备：即方法区中给类变量分配空间和赋初值。static修改的会在初始化阶段赋值，final修饰的会在准备阶段赋值。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;解析：即将常量池中的引用替换为直接引用</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;初始化：执行类构造器进行初始化。（因为内部流程不是很清楚，所以对于其几种不进行初始化的情况不做说明）</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;类加载器：JVM提供了三种类加载器，启动类加载器（/lib），扩展类加载器(/lib/ext)，应用程序类加载器(classpath)。还可以再应用程序类加载器自定义类加载器。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;双亲委派机制：即当一个类接收到类加载请求的时候，不会自己进行加载，而是将其加载请求委派给其父类加载器，这样一路委派，最终加载请求都会委派到启动类加载器.启动类加载器接收到加载请求之后会去lib目录下寻找相关的class文件，若找不到，则将其加载请求再委培给子类加载器，一路委派，直到能够加载。</p>
<h3><strong>最后，送给大家一张博主画的JVM的思维导图，以后读《深入JVM虚拟机》的时候可能会出一个JVM专题：<a href="https://uploader.shimo.im/f/X0MX3hLaHrevltxW.png!thumbnail" target="_blank" rel="noopener">JVM思维导图</a></strong></h3>
<p>&nbsp;</p>
<h2>水平有限，若发现有误，还望指出！</h2>, blogGoods=0, blogRead=17, blogCollection=0, typeName=java面试篇, blogRemark=面试（一）------之JVM篇, blogComment=0, blogSource=null, createdTime=2020-04-09 12:21:30, blogMonth=null, updateTime=2020-04-20 11:53:29), BlogVo(blogId=1248500061625745408, blogTitle=Linux基本命令, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dDA6AfCOJAAAyfL52jxY706.jpg, blogContent=<p><strong>一，Linux的发展历史</strong></p>
<p><strong>&nbsp; &nbsp; &nbsp; </strong>1965年之前，电脑并不像现在这么普遍，除了军事机构和研究即构，一般人基本接触不到电脑，而且那时候的一台大型主机最多也就只能支持30台终端。为了解决数量问题，1965年之后，由贝尔实验室，麻省理工学院以及通用电气一起放弃了Multics项目，准备让大型主机能够支持300台终端，但是在开发过程中，进度缓慢，最终由于资金的短缺，贝尔实验室推出了研究。1969年，从这个项目中退出的Ken Thompson在家无聊，为了让电脑能够运行&ldquo;星际旅行&rdquo;游戏，因而趁着妻子回家探亲的一个月，独自写出了Unix操作系统的原型（！！！！牛批）。1970年，这个人以BCPL语言为基础，又写出了很接近硬件的B语言，并且用B语言写出了第一个Unix操作系统。但是由于B语言的跨平台性比较差，为了解决这个问题。Dennis Ritchie和Ken Thompson决定以B语言为基础开发一种新的语言，1972年，Dennis Ritchie最终设计出了一种新语言，他以BCPL的第二个字母命名，也就是我们后来熟知的C语言。随后两人便迫不及待的用C语言重现Unix操作系统。Unix系统起初开源，但是在Unix7之后，由于政策的变化，代码闭源化，因而大学中不能使用Unix的源代码进行教学。Andrew S. Tanenbaum教授为了能够让学生更好的理解代码细节，在完全不使用任何源代码的情况下开发除了Minix---小型Unix。但是因为其只用于教学，功能并不强大，因而Torvalds以此为基础，开发除了Linux，但是起初Linux并不支持Unix，最终经过全世界网友的帮助，最终让其能够兼容各种硬件。</p>
<p><strong>二，文件和目录</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp; 1，windows和linux的区别：</strong>我们熟知的windows系统，它的文件系统是分盘符的，盘符下的文件构成一个树形结构，但是Linux文件系统没有盘符，所有文件目录都在根目录/之下</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;<strong>2，Linux需要记住的目录：</strong>/bin（存放系统命令的目录），/sbin（只有超级管理员能访问的命令文件目录），/root（存放和root用户相关文件的目录），/etc（存放系统配置文件的目录），/usr（存放系统共享资源的目录），/opt（存放安装的第三方软件的目录，通常在/usr/local下）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;<strong>3，文件权限：</strong>Linux中的文件权限有读（r，可用于数字4表示），写操作（w，可用数字2表示），执行权限（x，可用数字1表示）</p>
<p><strong>三，常用命令</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，ls：</strong>列出目录中的所有目录和文件名&nbsp; -a（列出所有，包括隐藏文件和目录），-l（以列表形式列出所有），-h（人性化列出，需要配合-l使用，即文件大小转换为我们熟知的kb，mb等），-d（显示当前目录属性），命令可以联合使用，例如-al，-lh等等。&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，cd：</strong>用于切换目录，需知（.和..是相对路径，.表示当前目录，..表示上级目录；/表示绝对路径），cd ~（切换到root目录），cd - （切换到前一次切换的目录）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，clear：</strong>清屏</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，pwd：</strong>显示当前所在目录</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，mkdir：</strong>创建目录，-p（如果目录存在则不创建，如果不存在则创建目录再创建自目录），可以一次性创建多级目录，例如：mkdir&nbsp; -p test/test1</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，touch：</strong>创建空文件</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>7，cp：</strong>复制，-r（递归复制目录下的文件目录信息），-i(提示是否覆盖)，-v（显示复制进度）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>8，mv：</strong>移动文件，不过经常用来给文件进行重命名</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>9，rm：</strong>删除目录或者文件，-r（递归删除），-f（强制删除），-v（显示删除进度）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>10，cat：</strong>查看文件内部信息</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>11，ln：</strong>文件创建链接，ln 源文件 目标链接文件（创建硬链接，硬链接和源文件大小相同，修改同步，但是删除不同步，使用较少），ln -s（创建软连接，相当于我们平时创建快捷方式，使用较多）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>12，which：</strong>搜索命令所在位置，例如：which&nbsp; &nbsp;ls</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>13，find：</strong>搜索文件所在位置&nbsp; 例如：find&nbsp; &nbsp;test.conf</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>14，grep：</strong>文件内容搜索，例如：grep &ldquo;想要搜索的内容&rdquo;&nbsp; 源文件</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>15，tar：</strong>归档命令，-c（打包成.tar文件），-z（打包的同时压缩），-v（打包的同时显示进度），-f（放在最后，后面跟.tar.gz），-x(解压)，常用：tar -zcvf&nbsp; <em><strong>.tar.gz&nbsp; &nbsp; ;&nbsp; &nbsp; tar -zxvf</strong> tar.gz</em> -C&nbsp; 指定解压目录&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;还有more，head，tail等命令，不过这些不常用。</p>
<p><strong>四，用户权限命令</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，whoami：</strong>查看当前账户的用户名</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，who：</strong>查看当前登录用户</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，exit：</strong>退出登录</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，adduser/useradd：</strong>添加用户，-d（指定用户主目录），-g（指定用户用户组），-m（自动建立目录），默认情况下用户主目录和用户组名都和用户名一样</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，passwd：</strong>只有root用户才能使用，用于修改用户密码</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，userdel：</strong>删除用户，默认不删除用户的主目录，-r（删除用户主目录）</p>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;7，su：</strong>切换账户</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>8，groupadd/groupdel：</strong>添加用户组和删除用户组</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>9，groups：</strong>查看用户所在用户组，例如：groups&nbsp; 用户名</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>10，usermod：</strong>修改用户所在用户组，例如：usermod&nbsp; 用户组名 用户名</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>11，chmod：</strong>修改文件权限，例如：chmod&nbsp; 777&nbsp; test</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>12，chown：</strong>修改文件所有者，例如：chown&nbsp; &nbsp;用户&nbsp; 文件名</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>13，chgrp：</strong>修改文件所在组，例如：chgrp&nbsp; 组名&nbsp; 文件名</p>
<p><strong>五，系统命令</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，cal：</strong>查看日历</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，date：</strong>查看时间，可以设置格式，例如：date '+<span class="ql-token hljs-built_in">%Y</span>-<span class="ql-token hljs-built_in">%m</span>-<span class="ql-token hljs-built_in">%d</span> <span class="ql-token hljs-built_in">%H</span>:<span class="ql-token hljs-built_in">%M</span>:<span class="ql-token hljs-built_in">%S</span>'</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，ps：</strong>查看线程</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，kill：</strong>杀死线程，-9（强制杀死）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，查看网卡信息：</strong>centos6：ifconfig ；centos7：ip addr</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>6，ping：</strong>查看网址或者链接的连通性</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>7，防火墙：</strong>centos6：service&nbsp; iptables&nbsp; status（查看防火墙状态），service&nbsp; &nbsp;iptables&nbsp; &nbsp;start(开启),service&nbsp; iptables&nbsp; stop(关闭);centos7:firewall-cmd&nbsp; --state（查看防火墙状态），systemctl&nbsp; start&nbsp; firewalld.service(启动)，systemctl&nbsp; &nbsp;stop&nbsp; firewalld.service（关闭）</p>
<p><strong>六，网络命令</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，wget：</strong>下载，例如：wget&nbsp; &nbsp;链接地址</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，yum：</strong>下载安装</p>
<p><strong>七，vim（这里只说几个常用的命令）</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;</strong>vim有三种模式：命令模式，插入模式，编辑模式&nbsp; &nbsp;</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;vim&nbsp; 文件名：进入文件，且处于命令模式；iao任意一键进入插入模式（i表示在贯标之前插入，a光标之后插入，o在下一行插入），：进入编辑模式</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;命令：set:nu显示行号，set:nonu不显示行号；/strinng，向后搜索字符串，？string向后搜索字符串；：w保存，：wq保存并退出，：q不保存退出</p>, blogGoods=0, blogRead=2, blogCollection=0, typeName=Linux, blogRemark=Linux基本命令总结, blogComment=0, blogSource=null, createdTime=2020-04-10 06:36:25, blogMonth=null, updateTime=2020-04-20 10:42:25), BlogVo(blogId=1248605157059497984, blogTitle=面试（二）------之JAVA基础篇, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dHMKAcvZ8AABJTVJPTfk020.jpg, blogContent=<h2><strong>一，集合</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，List：</strong>list是java中一种有序的集合，下有三个实现类，分别为ArrayList，Vector，LinkedList</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ArrayList：基于数组实现，增删慢，查询快，线程不安全。因为其基于数组实现，所以查询的时候可以直接根据数组的索引下标进行快速查询，但是进行增删操作的时候，需要将待增删元素后的元素全部移动，因而效率较低。且ArrayList创建时不需要分配初始大小，其空间不够的时候，会自动创建一个更大的list，然后复制数据。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Vector：基于数组实现，和ArrayList一样增删慢，查询快。但是线程安全，因为同一时间只支持一个线程对Vector进行写操作，然而因为要进行频繁的加锁和释放锁的操作，所以效率要低于ArrayList。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; LinkedList：基于双向链表实现，增删快，查询慢。因为基于链表实现，增删元素的时候，只需要改变元素的指针即可，改动较小，效率较高。然而进行查询操作的时候，需要从链表头部进行遍历，因而效率较低。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，Queue：</strong>队列，满足先进先出，种类较多。（不作详细解释）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，set：</strong>具有独一无二的特性，常用来存储无序且不重复的元素，对象相等的本质是hashcode的值相同，而如果想要比较两个对象是否相等，需要重写对象的hashcode方法和equals方法。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;hashset：基于hashTable实现，无序。存放的是对象的散列值，即通过hashcode计算得到的值</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;treeset：基于二叉树实现，即其中的对象按照一定的排序方式进行排列（升序，降序），每次添加对象的时候，都会进行排序，将其插入指定位置。基本的数据类型例如Integer，String等可以使用treeset默认的排序方法，而自定义数据类型需要实现compareable接口，实现compareTo方法。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;LinkHashSet：继承自hashset，只不过使用双向链表记录数据的顺序。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，map：</strong>一种键值对形式的集合</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;hashmap：基于数组+链表实现，增删改查操作快，但是每次遍历hashmap元素的顺序无法保证且线程不安全。如果想要其线程安全，可以使用synchronizedMap和ConcurrentHashmap，hashmap的内部是数组，数组中的每一个元素又是一个单向链表，链表中的每个元素嵌套一个Entry实例，其中包括Key，Value，Hash值，指向下一个节点的next。每次查询的时候，可以根据元素的hash值很快定位所在数组，但是定位之后需要遍历链表查找元素，因而时间复杂度为O（n），但是Java8之后对其进行了优化，将其改为了数组+链表或红黑树的结构，即当链表中的元素大于8个的时候，链表会转换为红黑树（红黑树是一种特化的二叉平衡树，因为其左右子树的深度差可以大于1），这样查询的时间复杂度就缩短到了O（logN）。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ConcurrentHashmap：采用分段锁的思想进行并发操作，因而使线程安全的。由多个Segment组成，只要保证每个Segment线程安全就可以保证全局线程安全。ConcurrentHashmap的默认Segment即并发度为16，可以在初始化的时候修改，但是初始化之后不能再修改。每个Segment内部的实现和hashmap一样&middot;。Java8之后也和hashmap进行了一样的优化。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;HashTable：线程安全，即同一时刻只能有一个线程对其进行操作，并发度不如ConcurrentHashmap。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;TreeMap：基于二叉树数据结构实现，实现了SortedMap，默认按照键值的升序进行排列。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;LinkedHashMap：Hashmap的子类，只不过使用链表保存元素的插入顺序。使用迭代器遍历的时候按照插入顺序遍历。</p>
<h2><strong>二，异常分类及处理</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;1，异常分类：</strong>Throwable是所有异常类的父类，其下有error和Exception，Error下有AwtError，ThreadDeath；Exception下有RuntimeException和CheckedException。</p>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</strong>对于Error类异常通常是由内部错误和资源耗尽造成的，无法在程序运行期间对其进行捕获和处理，对于这类错误我们只能记录错误的原因和终止程序。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; Exception中的RuntimeException异常（运行时异常）：这类异常是我们程序中异常处理的核心，可以在程序中进行捕获并处理。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Exception中的CheckedException异常（检查异常）：这类异常时程序中需要强制捕获的异常，通常有IO异常，SQL异常等等。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，异常处理：</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>异常处理有两种方式：抛出异常和捕获异常</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;抛出异常有三种方法：throws，throw，系统自动抛出。其中throws是作用在方法上，后面跟的是可能产生的异常类。throw是作用在方法内部，后面跟的是具体的异常对象。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 捕获异常：即使用try{}catch语句进行捕获</p>
<h2><strong>三，反射机制</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，什么叫做反射机制？</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>即在程序运行的过程中，可以获取类的属性和方法，并且可以调用任意一个类的方法。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，反射机制的使用</strong></p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 首先，获取类的class对象，有三种方式，className.getClass()，类对象.class，Class.forName("类路径")，其中最后一种最为安全，性能最好。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 然后利用反射的API可以实现对类中信息的操作，例如getDeclareFields（），getDeclareMethods（），getConstroctors（）等等。反射创建类的对像有两种方法，一，class.newInstance()初始化一个类实例；二，先获取其构造器，然后利用构造器初始化一个实例。利用反射调用类的方法：先获取方法，然后调用method.invoke()执行方法。</p>
<h2><strong>四，注解</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，四种元注解：</strong>@Target（指定注解的使用范围），@Retention（定义注解的保留级别，有三级，SOURCE源程序中保存，CLASS文件中保存，RUNTIME运行时保存），@Documented（可以工具文档化），@Inherited（<span style="background-color: #ffff00;">这个没怎么看懂</span>）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，注解使用示例：</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>第一步，定义注解接口</p>
<pre class="language-java"><code>@Target(ElementType.FIELD)  
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FruitProvider {

    //id
    public int id() default  -1;

    //供应商名称
    public String name() default "";

    //供应商地址
    public String address() default "";

}</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 第二步，使用注解</p>
<pre class="language-java"><code>public class Apple {

    @FruitProvider(id = 1,name = "红富士苹果",address = "陕西")
    private String appleProvider;

    public String getAppleProvider() {
        return appleProvider;
    }

    public void setAppleProvider(String appleProvider) {
        this.appleProvider = appleProvider;
    }
}</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第三步，定义注解处理器</p>
<pre class="language-java"><code>public class FruitInfoUtil {
    public static void getFruitInfo(Class&lt;?&gt; clazz) {
        String strFruitProvider = "供应商信息:";
        Field[] declaredFields = clazz.getDeclaredFields();
        for (int i = 0; i &lt; declaredFields.length; i++) {
            if (declaredFields[i].isAnnotationPresent(FruitProvider.class)) {
                FruitProvider annotation = declaredFields[i].getAnnotation(FruitProvider.class);
                strFruitProvider += annotation.id() + "," + annotation.name() + "," + annotation.address();
                System.out.println(strFruitProvider);
            }
        }
    }
}</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第四步，主方法入口</p>
<pre class="language-java"><code>public class FruitRun {
    public static void main(String[] args) {
        FruitInfoUtil.getFruitInfo(Apple.class);
    }
}</code></pre>
<h2><strong>五，内部类</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 1，静态内部类：</strong>即在类的内部定义的静态类，静态内部类可以访问外部了的静态变量和方法，外部也可以通过outClassName.innerClassName调用内部类</p>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2，成员内部类：</strong>在类的内部定义的没有用static修饰的内部类，使用方式和静态内部类一样。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>3，局部内部类：</strong>即一个类只在一个方法中使用，则完全可以将这个类定义为这个方法的内部类，即局部内部类，局部内部类可以实现真正的对外隐藏</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>4，匿名内部类：</strong>通常用于继承一个类或者实现一个接口的时候，使用new关键字定义，例如:Person person = new Student(){new Pupil(){}}</p>
<h2><strong>六，泛型</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 1，为什么要使用泛型：</strong>其根本目的是为了实现代码的复用，举个开发中常见的例子，我们需要定义返回类Result，返回类中包含状态码code，信息msg，以及数据data（任意类型），这个时候我们就需要使用泛型，因为我们返回的数据类型有各种vo，pojo类对象，list等。这时候泛型类result就可以被各种对象使用，实现代码的复用，简化开发。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>2，泛型标记和泛型限定：</strong>E表示集合中的元素，K表示键值，V表示value，N表示数值类型，T表示任意类型（包含基础类型，所有的对象类型），？（不确定的java类型）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>泛型限定：</strong>向上限定，&lt;?&nbsp; extends T&gt;，向下限定，&lt;? super&nbsp; T&gt;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; <strong>3，泛型方法：</strong>即参数类型定义为泛型类型，以便于接收不同类型的参数，做出不同的处理。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>4，泛型类：</strong>例如public class Pair&lt;T&gt;{private T data;}</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>5，泛型接口：</strong>与放泛型类类似</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>6，类型擦除：</strong>即在泛型编译的过程中，会将泛型类型替换为限定类型的操作</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>7，明确的一点：</strong>虚拟机在运行程序的过程中，内部是没有泛型的，只有普通的类和方法。</p>
<h2><strong>7，序列化</strong></h2>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 序列化是为了确保对象及其状态的持久化</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>序列化的使用：</strong></p>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </strong>首先，实现序列化接口java.io.Serializble</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 然后，声明序列化ID，通常private static final&nbsp; long&nbsp; serialVersionUid&nbsp; = ***</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 因为序列化是保证对象及其状态的持久化，而静态变量是不属于对象，属于类本身的，所以序列化无法保存静态变量。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果需要序列化父类变量，则父类也要实现Serializable接口</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t'ransient修饰的属性不会序列化</p>
<h3><strong>最后，提供一张思维导图供大家学习：<a href="https://images-cdn.shimo.im/es83SQH0CggucT7f__thumbnail" target="_blank" rel="noopener">JAVA基础</a></strong></h3>
<p>&nbsp;</p>
<h2>水平有限，如有错误，还望指出！</h2>, blogGoods=0, blogRead=27, blogCollection=0, typeName=java面试篇, blogRemark=面试（二）------之JAVA基础篇, blogComment=0, blogSource=null, createdTime=2020-04-10 13:34:02, blogMonth=null, updateTime=2020-04-20 11:53:39), BlogVo(blogId=1249313090567143424, blogTitle=面试（三）------之并发编程篇（上）, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dHM2AQOeZAABJTVJPTfk967.jpg, blogContent=<h2><strong>一，JAVA线程的创建方式</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>JAVA线程的创建有四种方式，分别为，继承Thread类，实现Runable接口，实现Callable&lt;Class&gt;接口，基于线程池。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>1，继承Thread方式：创建一个类继承Thread类，创建类的实例对象，调用start方法，继而执行线程的run（）方法，代码如下：</strong></p>
<pre class="language-java"><code>public class NewThread extends Thread{
    public static void main(String[] args) {
        NewThread thread = new NewThread();
        thread.start();
    }
    @Override
    public void run(){
        System.out.println("create  a  new thread by Thread!");
    }
}</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>2，当子类已经继承了一个类，这时候就没法再继承Thread类了，这时候就可以实现Runable接口，实例化类的线程实例，创建Thread实例传入类的实例，执行start方法，继而执行run（）方法代码如下：</strong></p>
<p>&nbsp;</p>
<pre class="language-java"><code>public class ThreadExample2 implements Runnable {
    public static void main(String[] args) {
        ThreadExample2 threadExample2 = new ThreadExample2();
        Thread thread = new Thread(threadExample2);
        thread.start();
    }
    @Override
    public void run() {
        System.out.println("create a new thread by Runnable!");
    }
}</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，有些情况下，我们需要再一个主线程中并发多个子线程执行同一个任务，然后回收子线程的返回值整理汇总，这时候就需要实现Callable&lt;Class&gt;接口，重写其call（）方法，用于计算结果。然床创建一个线程池用于提交线程，继而执行call方法，并且创建一个Future的list用于接收子线程逻辑代码即call方法的返回，最终遍历list，得到想要的返回值，如下：</strong></p>
<pre class="language-java"><code>public class ThreadExample3 implements Callable&lt;String&gt; {

    private String name;

    public ThreadExample3(String name){
        this.name = name;
    }

    @Override
    public String call() throws Exception {
        return name;
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService pool = Executors.newFixedThreadPool(3);
        List&lt;Future&gt; list = new ArrayList&lt;&gt;();
        for(int i=0;i&lt;3;i++){
            ThreadExample3 threadExample3 = new ThreadExample3(i+"");
            Future future =pool.submit(threadExample3);
            System.out.println(future.get().toString()+" is running");
            list.add(future);
        }
        pool.shutdown();
        for (Future future : list) {
            System.out.println("currentThread's result is "+future.get().toString());
        }
    }
}</code></pre>
<p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，基于线程池创建线程</strong></p>
<pre class="language-java"><code>public class ThreadExample4 {
    public static void main(String[] args){
        ExecutorService pool = Executors.newFixedThreadPool(3);
        for(int i=0;i&lt;3;i++){
            pool.execute(new Runnable() {
                @Override
                public void run() {
                    System.out.println("thread  is running by FixedThreadPool");
                }
            });
        }
        pool.shutdown();
    }
}</code></pre>
<h2>二，线程池的工作原理</h2>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong> &nbsp;1，概述：</strong>JVM根据用户提供的参数创建一定数量的线程任务，将其放入队列中，线程创建之后启动这些任务，如果线程的数量大于核心线程数量（用户设置的线程数量），则超出数量的线程排在队列中等待，当有线程任务执行完毕后，线程池调度器就会发现有可用可用线程，继而从队列中取出任务继续执行<strong>。</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; </strong><strong>2，线程复用：</strong>（参见JDK源码解读，这里只做简单描述），由前可知，JVM会根据用户提供的参数创建一定数量的线程任务，且将其添加到任务队列中。JVM通过start（）方法创建一个线程之后， 会相应的为其创建一个任务队列，线程会不停的查看任务队列，如果任务队列中有任务，则调用run方法，执行，这样就达到了一次start（）创建线程，多次使用，完成线程复用的任务。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>3，线程池的核心组件和核心类（见JDK源码分类中关于线程的总结）</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; </strong><strong>4，JAVA线程的工作流程：</strong>线程池刚被创建的时候，只是向系统申请一个执行线程队列和管理线程池的线程资源，当调用execute方法之后，执行下列流程：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果正在运行的线程数量小于corePoolSize（核心线程数量，即用户定义的的线程数量），则立即创建线程执行线程任务</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果正在运行的线程数量大于或等于corePoolSize，则将超过数量的线程加入到阻塞队列中</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在阻塞队列已满且线程数量小于MaximumPoolSize（即线程池能够容纳的最大线程数），线程池会创建非核心线程立即执行任务</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在阻塞队列已满且线程数量大于或等于MaximumPoolSize的时候，线程池会拒绝该线程任务且抛出异常</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在线程任务执行完毕之后，会将其从任务队列中移除，从队列中取出下一个线程任务执行</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在线程处于空闲状态且空闲时间超过KeepAliveTime，且线程数量大于corePoolSize的时候，会停止该线程，这样在没有任务的时候，线程池中的线程数始终维持在corePoolSize。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，线程池的拒绝策略：</strong>分为四种，分别为AbortPolicy，CallerRunsPolicy，DiscardOldestPolicy，DiscardPolicy</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; AbortPolicy：直接抛出异常，阻止线程运行，源码如下：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</p>
<pre class="language-java"><code>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
            throw new RejectedExecutionException("Task " + r.toString() +
                                                 " rejected from " +
                                                 e.toString());
        }</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CallerRunsPolicy：如果线程任务没有关闭，则尝试执行该线程任务，源码如下：</p>
<pre class="language-java"><code>* @param r the runnable task requested to be executed
* @param e the executor attempting to execute this task
*/
public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
     if (!e.isShutdown()) {
         r.run()
     }
}</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DiscardOldestPolicy：移除任务队列中最早进入的线程任务，执行当前任务线程，源码如下：</p>
<pre class="language-java"><code>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
       if (!e.isShutdown()) {
           e.getQueue().poll();
           e.execute(r);
       }
}</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DiscardPolicy：直接丢弃线程任务，不做任何处理</p>
<h2><strong>三，五种常用的线程池</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;newCachedThreadPool（可缓存线程池）：</strong>当线程池创建线程的时候如果发现有可复用的线程（执行完任务，且未关闭的线程），则直接复用，如果没有则创建新线程。可缓存线程池可以高效的利用执行任务时间短的线程，提高系统的性能，且线程池中的线程如果空闲时间超过60s，则会被终止且从缓存中移除，这样可缓存线程池不会占用系统资源。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>newFixedThreadPool（固定大小的线程池）：</strong>即线程池中的线程是初始化固定的，当任务线程大于线程池中线程数量时，任务线程就会进入阻塞队列等待。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newScheduledThreadPool（可做任务调度的线程池）：</strong>即可以设置线程执行的停顿时间和执行周期，进行定期定时的执行某个任务。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newSingleThreadPool（单个线程的线程池）:&nbsp;</strong>即线程池中永远只有一个线程进行工作，如果下称停止或者异常，则线程池创建新的线程替代当前线程</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newWorkStealingPool（足够大小的线程池）：</strong>即创建足够数量的线程的线程池，保证更快的进行运算，提高效率。</p>
<h2><strong>四，线程的生命周期</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;线程的生命周期大致分为五个阶段：新建（new），就绪（Runnable），运行（Running），阻塞（Blocked），死亡（Dead）</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;新建：</strong>即使用new创建一个线程</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>就绪：</strong>调用start方法，</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>运行：</strong>即线程获取cpu资源，执行run（）方法，进入运行状态，运行状态的线程如果调用yield（线程让步方法）或者失去cpu资源，都会导致线程重新回到就绪态；如果调用sleep方法，I/O阻塞，等待同步锁，等待通知以及suspend挂起都会导致线程进入阻塞态。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞：</strong>即线程被放入Blocked池。阻塞状态的线程如果结束了sleep方法，I/O方法返回，获取同步锁，收到通知或者resume都会导致其重新进入就绪态，与其它线程竞争cpu时间片。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>死亡：</strong>线程正常执行完run（）或者call（）方法，或者执行stop方法，或者发生异常或者错误都会导致线程死亡。（stop方法会导致锁混乱和死锁，不建议使用）</p>
<h2><strong>五，线程的基本方法</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;wait（线程等待）：</strong>会让线程进入WAITING状态，并且会释放对象的锁。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>sleep（线程睡眠）：</strong>会让线程进入睡眠，进入TIMED_WAITING状态，但是不会释放对象锁，睡眠时间到了之后，再次恢复运行状态</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>yield（线程让步）:</strong>&nbsp; 当前线程会让出其占有的cpu资源，重新回到就绪态和其它线程竞争cpu时间片</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>interrupt（线程中断）:&nbsp; </strong>中断当前线程，但是并不会导致其停止，只是改变其内部的终端标识位，在使用了thread.sleep()之后使用该方法，会导致抛出异常，且我们可以利用中断标识位进行线程的安全退出</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>join（线程加入）：</strong>即将当前线程进入阻塞态，等待下一个线程执行完毕后进入就绪态，重新竞争锁资源。通常用于主线程下面执行子线程，需要主线程阻塞，等待子线程执行完毕后返回其结果给主线程，主线程再执行的情况。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>notify（线程唤醒）/notifyAll：</strong>前者随机唤醒一个等待线程，后者全部唤醒</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>setDaemon（守护线程）:</strong>级别较低的线程，用于后台运行，服务用户用户线程，例如垃圾收集线程就是典型的守护线程。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>sleep方法和wait方法的区别：</strong>前者属于Thread，后者属于Object，前者不会释放锁资源，后者会释放锁资源</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>start方法和run方法：</strong>start方法只是创建一个线程，并没有运行，run方法时执行线程的真正代码逻辑。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>线程退出的方式：</strong>见四中最后一条</p>
<h2><strong>六，JAVA中的锁（知识比较杂乱）</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述:JAVA中的锁是为了保护数据的一致性。按照不同的标准可分为乐观锁和悲观锁，公平锁和非公平锁，共享锁和独占锁，偏向锁，轻量级锁，重量级锁，自旋锁，可重入锁。</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;乐观锁：</strong>即认为每次读取数据都不会被修改，当修改操作的时候再判断当前数据是否被修改，未修改则修改，若已被修改，则返回失败状态。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>悲观锁：</strong>即认为每次读取数据都会被修改，因而每次读取数据都对其进行加锁，这样只有当前用户可以修改，其它用户阻塞等待直到当前用户修改完毕释放锁资源。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>自旋锁：</strong>即有些线程任务的执行很短，很快就可以释放锁资源，为了避免在这种情况下竞争线程仍然进行内核态和用户态之间的转换，因而让线程自旋（即等一会），如果有可用锁，则获取，减少了线程在用户态和内核态之间切换的时间损耗。提高了性能（优势）。当然线程自旋是占用cpu资源的，因而需要设置一个自旋的最大等待时间，如果超过此时间，则线程退出自旋模式。对于线程竞争锁资源激烈的情况，自旋有可能会导致cpu资源的损耗（劣势）。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>公平锁和非公平锁：</strong>即根据线程竞争锁资源的机制判定，一般如果依据先到先得的原则，则位公平锁；如果依据就近原则，则位非公平锁。公平锁相比于非公平锁会更加耗费性能，因为要维护一个线程任务丢列，根据线程任务在队列中的顺序分配锁资源，因而不常用。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>可重入锁：</strong>又被称为递归锁，即该锁可以然后线程对其进行多次的加锁操作。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>偏向锁：</strong>当线程获取到锁的时候，用来消除线程的锁重入的开销（看起来是偏袒这个线程）。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>共享锁和独占锁：</strong>共享锁即多线程共享锁资源（典型例子，读锁）；独占锁即当前锁只能有一个线程获取，其它线程阻塞</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>轻量级锁：</strong>没有多线程竞争的前提下，减少重量级锁的使用提高性能。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>重量级锁：</strong>基于操作系统的互斥量而实现的锁，会导致进程在用户态和内核态之间切换，耗费性能。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>synchronized：独占式悲观锁，可重入锁，非公平锁，重量级锁。</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 作用范围：</strong>作用于成员变量和非静态方法，相当于锁住的是对象的实例，即this对象</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;作用于静态方法，相当于锁住的是class实例</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;作用域代码块，相当于锁住的代码块中的对象</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>实现原理：</strong>内部包括ContentionList（锁竞争队列），EntryList（竞争候选列表），WaitSet（等待集合），OnDeck（竞争候选者），Owner，!Owner，其中ContentionList是用来存放竞争锁资源的线程。EntryList是用来存放有资格竞争锁资源的线程。调用wait方法后放入WaitSet中，onDeck指的是同一时刻，只有一个线程竞争锁资源，Owner指的是得到锁资源的线程，!Owner指的是线程执行完毕，释放锁资源的线程。需要注意的是线程首先采用的都是自旋模式获取锁资源，如果自旋获取不到再加入ContentionList，而且Owner状态的线程并不是直接把锁资源交给onDeck状态线程，而是给它竞争锁资源的权利，因而onDeck状态的线程还需要跟自旋线程竞争锁资源。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>ReentrantLock：独占式，可重入锁，并且可以实现公平锁和非公平锁，重量级锁。</strong></p>
<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;用法：</strong>lock()加锁，后跟try代码块，finally中进行释放锁unlock()</p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;避免死锁的方法：</strong>响应中断（即可以根据情况中断对锁资源的请求），可轮询锁（tryLock（）即尝试获取锁，如果有可用锁则获取返回true，没有则返回。和lock（）的区别在于lock获取锁资源如果没有则一直等待直到获取到锁资源），定时所（tryLock（time,unit）即再一定时间内如果有可用锁，且线程未中断则获取锁，否则禁用当前线程。）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>Semaphore（信号量）:</strong>机制和ReentrantLock类似</p>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ReadWriteLock（读写锁）：</strong>如果系统要求支持多线程共享读，但不能多线程写，使用读锁；如果要求同一时刻只能有一个线程写，写的过程中不能读取该共享数据，则使用写锁。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; <strong>分段锁：</strong>一种思想，将数据分段加锁，例如ConcurrentHashMap</p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;死锁：</strong>即线程之间互相共享资源会导致死锁</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; <strong>锁优化：</strong>第一，减少锁的持有时间；第二：减小锁粒度，例如分段锁；第三：锁分离，例如读写锁；第四：锁粗化，放置锁粒度太小，造成频繁加锁释放锁；第五：锁消除，消除程序代码不规范而造成的乱用了锁</p>
<p>&nbsp;</p>
<h3><strong>并发编程（上）的思维导图送上：<a href="https://images-cdn.shimo.im/1UcHkyrlJyGRPYnn.png__thumbnail" target="_blank" rel="noopener">并发编程（上）</a></strong></h3>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>
<h1>水平有限，如果错误，还望指出！</h1>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;</p>, blogGoods=0, blogRead=8, blogCollection=0, typeName=java面试篇, blogRemark=面试（三）------之并发编程篇（上）, blogComment=0, blogSource=null, createdTime=2020-04-12 12:27:07, blogMonth=null, updateTime=2020-04-20 11:53:51), BlogVo(blogId=1249588251598041088, blogTitle=redis基础（一）, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6caUuADBI7AAAb07iHSRw500.jpg, blogContent=<h2><strong>一，redis简介</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>redis是NoSQL型系统之一，与之相似的还有Memcache，用来存储key-value这种键值型数据。相比于Memcache而言，redis不仅可以做临时缓存，还可以做数据持久化，将数据定时的存入硬盘或者将命令追加到日志文件当中。而Memcache只能做临时缓存，因而现在基本上已经被redis完全取代。redis的读写速度非常快，官方给出的数据是读110000次/s，写81000次/s；而且redis支持多种数据类型，例如String，list，hash，set，zset；redis支持主从复制（集群），进行数据持久化；还支持过期时间，事务等。</p>
<h2><strong>二，redis的安装与启动（docker环境下）</strong></h2>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;docker安装完毕后，安装redis：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第一步：拉取redis镜像，docker&nbsp; pull&nbsp; redis</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第二步：启动redis，docker&nbsp; &nbsp;run&nbsp; &nbsp;redis&nbsp; &nbsp;</p>
<p><strong>三，基本知识串讲</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>单进程单线程：redis只有一个进程，且内部为单线程，这样做的优势是不存在线程安全问题，且不需要进行线程间的切换，提高了性能，而且多线程可能会涉及到锁。劣势是无法发挥多核cpu的优势，不过可以通过开启搭建多个redis实例实现</p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>redis中默认有16个数据库（0-15），可以通过select n来进行数据库之间的切换</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;常用的基本命令：flushDB（清空当前数据库），flushAll（清空所有数据库），dbSize（查看有多少数据库）</p>
<h2><strong>四，redis基本数据类型</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;string：</strong>字符串类型，数据库中存储Map&lt;String,String&gt;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>list：</strong>列表数组类型，数据库中存储Map&lt;String,List&lt;Object&gt;&gt;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>hash：</strong>哈希类型，数据库中存储Map&lt;String,Map&lt;Object,Object&gt;&gt;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>set：</strong>集合类型，其中元素无序，数据库中存储Map&lt;String,Set&lt;Object,Object&gt;&gt;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>Zset：</strong>有序集合类型，每个元素都有一个可用于排序的权重</p>
<h2><strong>五，redis相关命令（这里详解一些常用的命令，不常用的一笔带过）</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;string：</strong>(1)set&nbsp; key&nbsp; value,插入一条数据&nbsp; （2）mset&nbsp; key value...批量插入 （3）setnx&nbsp; key value&nbsp; 若无则插入（4）get&nbsp; key&nbsp; 获取某条数据&nbsp; （5）mget keys 批量获取&nbsp; （6）getrange key&nbsp; 0 -1获取数据库全部数据&nbsp; （7）incr age 递增&nbsp; (8) incrby&nbsp; age&nbsp; 10&nbsp; 递增 age 步长为10（9）decr&nbsp; age&nbsp; 递减&nbsp; （10）decrby&nbsp; age&nbsp; 10 步长递减&nbsp; &nbsp;（11）del&nbsp; key&nbsp; 删除某条数据&nbsp; <span style="background-color: #ffff00;">（12）exists&nbsp; key&nbsp; 判断是否存在某个key&nbsp; &nbsp;(13)expire&nbsp; key&nbsp; 10&nbsp; 设置过期时间（单位为秒）&nbsp; （14）pexpire&nbsp; key&nbsp; 1000 设置过期时间，单位为毫秒&nbsp; （15）persist key删除过期时间 （</span><span style="background-color: #ffff00;">16）ttl&nbsp; key&nbsp; 查看过期时间</span></p>
<p><span style="background-color: #ffff00;">&nbsp;<span style="background-color: #ffffff;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>list：&nbsp;&nbsp;</strong>（1）lpush&nbsp; key&nbsp; value 左插入一条数据&nbsp; &nbsp;（2）lpush mylist&nbsp; key&nbsp; value....批量左插入&nbsp; （3）rpush&nbsp; key value 右插入一条数据&nbsp; (4)rpush&nbsp; mylist&nbsp; key value...右批量插入&nbsp; （5）lrange&nbsp; mylist&nbsp; 0&nbsp; -1&nbsp; 取出数据集合&nbsp; （6）lpop mylist 左弹出集合中第一条数据&nbsp; （7）rpop&nbsp; </span></span><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">mylist&nbsp; 右弹出集合中第一条数据&nbsp; （8）llen&nbsp; mylist&nbsp; 获取数据集合长度lrem&nbsp; mylist&nbsp; count&nbsp; value&nbsp; （count&gt;0,从表头开始搜索，移除count个与值与value相等的元素；count&lt;0,表尾开始；count=0，移除所有值与value相等的元素） （9）linsert mylist&nbsp; before/after&nbsp; a&nbsp; 在a元素前或后插入。</span></span><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">(10) lpoplpush&nbsp; list&nbsp; list1 转移列表的元素到另一个列表</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>hash：</strong>（1）hset&nbsp; key&nbsp; &nbsp;val-key&nbsp; val-val&nbsp; 插入一条数据&nbsp; （2）hset&nbsp; myhash&nbsp; name&nbsp; xxx&nbsp; 用于给哈希表中的字段赋值，不存在则创建哈希表赋值，存在则覆盖旧值&nbsp; (3) hget&nbsp; &nbsp;myhash&nbsp; name&nbsp; 取哈希表中某个值&nbsp; （4）hmset&nbsp; myhash name&nbsp; xxx age xxx&nbsp; 批量插入字段&nbsp; （5）hmget</span></span><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">批量获取 （6）hgetall&nbsp; myhash&nbsp; 获取哈希表中所有值&nbsp; (7)&nbsp; hexisets myhash&nbsp; name&nbsp; 判断哈希表中是否存在name字段&nbsp; （8）hsetnx&nbsp; myhash score 100 若存在则不插入，若不存在则插入数据&nbsp; （9）hincrby&nbsp; myhash id 1/hdecrby&nbsp; myhash id&nbsp; 10 递增递减 （10）hdel&nbsp; myhash name&nbsp; </span></span><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">删除&nbsp; （11）hkeys&nbsp; myhash&nbsp; 只取key值&nbsp; （12）hvals&nbsp; myhash&nbsp; 只取value值&nbsp; （13）hlen&nbsp; myhash 获取哈希表长度</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>set：</strong>（1）sadd myset&nbsp; redis&nbsp; 添加一条数据&nbsp; （2）smembers myset&nbsp; 获取数据集合&nbsp; （3）srem&nbsp; myset&nbsp; set1&nbsp; 删除set1&nbsp; （4）sismember myset&nbsp; set1 判断set中是否存在set1&nbsp; (5)srandmember&nbsp; key count&nbsp; 随机获取count个元素（6）spop&nbsp; 从集合中弹出一个元素</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>zset：</strong>之后补充</span></span></p>
<h2><strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">六，redis配置文件（常见配置）</span></span></strong></h2>
<p><strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;daemonize no：</span></span></strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">redis默认不是以守护进程的方式运行的，可以更改为yes启用守护进程（即后台运行）</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>pidfile&nbsp; /var/run/redis.pid&nbsp; :</strong>启用守护进程后，默认将pid写入/var/run/redis.pid文件，可以更改</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>port&nbsp; 6379 ：</strong>redis默认端口</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp; &nbsp; &nbsp; &nbsp; <strong>bind&nbsp; 127.0.0.1：</strong>绑定的主机地址</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;"> &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>timeout&nbsp; 300</strong><strong>：</strong>redis客户端闲置多长时间后关闭连接，改为0的话，表示关闭该功能</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>loglevel&nbsp; verbose：</strong>默认日志级别（还有debug，notice，warning）</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>database 16：</strong>redis默认有16个数据库可以修改</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>save&nbsp; 900&nbsp; 1/save&nbsp; 300&nbsp; 10/save&nbsp; 60&nbsp; 10000：&nbsp;</strong>表示一定时间内有多少条数据发生修改，就将其同步到数据文件一次，例如第一个表示15分钟内有一条数据发生改变就同步</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>rdbcompression yes&nbsp; ：</strong>表示数据存储到本地数据库时是否进行压缩</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>dbfilename&nbsp; dump.rdb：</strong>指定本地数据库文件名</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>dir&nbsp; /...../redis安装目录/bin ：</strong>本地数据库存放目录，默认在redis安装目录的bin目录下</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>slaveof&nbsp; &nbsp;masterip&nbsp; masterport ：</strong>设置当本机为从机时，它的主机的ip和端口</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>masterauth&nbsp; &lt;master-password&gt;：</strong>当master服务设置了密码时，slav服务连接master的密码</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>requirepass&nbsp; foobared：</strong>默认关闭redis连接需要密码，当给redis设置了密码，就需要打开</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>maxclients&nbsp; &nbsp;128：</strong>redis同一时间最大连接客户端的数量</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>appendonly&nbsp; &nbsp;no：</strong>是否开启aof持久化，默认不开启，采用rdb</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>appendfilename&nbsp; appendonlu.aof：</strong>指定aof持久化的文件名</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>appendfsync&nbsp; everysec :</strong>指定更新日志条件，默认每秒更新一次（还有no，指等操作系统进行数据缓存到磁盘，快；always指每次更新操作后都手动写入磁盘，慢但安全）</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;虚拟机方面的配置暂不说明</span></span></p>
<h2><strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">七，redis持久化</span></span></strong></h2>
<p><strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;概述：</span></span></strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">redis持久化主要有两种方式，即rdb和aof</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>rdb：</strong>适用于大数据集的恢复，数据的备份，但是因为设置周期时间进行数据的快照，所以如果redis宕机，可能会丢失最后一个写操作的数据，因为数据完整性较差。数据保存在dump.db文件中，只需要移动到redis安装目录，重启即可恢复数据</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>aof：</strong>适用于对数据的完整性要求较高的情况，因为可以设置不同的持久化策略，例如每秒保存一次，这样即时redis宕机，也只会丢失最后一秒的数据。但是因为其日志文件存储的是写入命令，因而其文件大小要大于rdb的数据文件，且每次重启，都要从头执行数据文件中的命令，因而恢复速度也</span></span><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">要慢于rdb。</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>注意：</strong>当rdb和aof同时开启的时候，redis重启，默认会采用aof的形式进行数据的重新构建</span></span></p>
<h2><strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">八，redis事务</span></span></strong></h2>
<p><strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;概述：</span></span></strong><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">什么是事务？事务即是一系列的命令要买全部执行，要么全部回滚</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <strong>常用命令：</strong>multi(启动事务)，discard（取消事务）,exec（执行事务块内命令）,watch key(监控某个key的变化)，unwatch（取消对所有key的监控）</span></span></p>
<p><span style="background-color: #ffff00;"><span style="background-color: #ffffff;">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>注意：</strong>redis的事务中在命令本身出错的情况下会造成命令的全部回滚，但是在命令无错，执行某个命令的时候发生异常的时候，则谁的错，谁停止（这一点和mysql是不同的）</span></span></p>
<h2><strong>九，redis的主从复制</strong></h2>
<p><strong>&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>redis的主从复制，即主机数据更新后根据我们设置的策略将数据同步到从机上，主机以写为主，从机以读为主<strong>。</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 使用：</strong>配主不配从，在从机中使用slaveof&nbsp; 主机ip&nbsp; &nbsp;主机端口配置从机，但是这种配置方式当redis重启之后就会失效，如果想要redis重启仍然可用，则需要配置redis.conf配置文件中的slaveof&nbsp; masterip&nbsp; masterport。这种配置方式的问题所在，中心化只有一台极其支持写操作，如果主机宕机，则从机等待，且从机宕机重启后不会跟上大部队（即重启后变为主机）。当然我们可以采用命令slave&nbsp; no&nbsp; one 使从机反客为主，成为主机。但是这种手动操作太过麻烦。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>哨兵模式：</strong>即配置之后，如果主机宕机，则哨兵会自动根据投票规则在从机中进行选举，从而产生新的主机顶替。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>主从复制的缺点：</strong>因为所有的写操作都是子主机上进行，从而在同步到从机上，所以存在着一定的延迟，当系统繁忙或者从机数量较多的时候，这种问题就更加明显。</p>
<h2><strong>十，redis集群</strong></h2>
<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;概述：</strong>集群是一种去中心化的模式，与中心化模式不同的是，中心化模式中如果主服务挂掉了，那么服务就挂掉了。但是集群模式下，没有主路由，每个节点自身都可以成为路由</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;redis集群：即配置多台主机，多台从机，不同的主机中有不同的槽点，当执行数据写入时，会根据crc16算法计算出数据的槽点，从而将数据存入到对应的主机中，并同步到与其对应的从机中</p>
<p>&nbsp;</p>
<h1>水平有限，如有错误，还望指出！</h1>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong></p>, blogGoods=0, blogRead=4, blogCollection=0, typeName=redis, blogRemark=redis基础（一）, blogComment=0, blogSource=null, createdTime=2020-04-13 06:40:30, blogMonth=null, updateTime=2020-04-20 16:47:37), BlogVo(blogId=1249742755949817856, blogTitle=面试（三）------之并发编程篇（下）, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dHNmAPuxmAABJTVJPTfk117.jpg, blogContent=<h2><strong>一，线程上下文切换</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>cpu利用时间片轮询的方式来为每个任务都分配一定的时间片，任务的执行过程中保存任务的状态。任务状态的保存和在加载就叫做上下文切换。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>进程：</strong>指的是一个运行中的程序实例，一个进程中可以有多个线程，并且与进程共享同样的内存和系统资源</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong> 上下文：</strong>指的是寄存器和程序计数器保存的线程的信息</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>寄存器：</strong>指的是内存中很小但是运行速度很快的一块区域（相对于RAM外部内存）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>程序计数器：</strong>一种寄存器，用来保存当前执行指令的位置或者下一个待执行指令的位置</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>上下文切换：</strong>上下文切换指的是操作系统的内核在cpu上对进程或者线程的切换。上下文信息保存在进程控制块中（PCB）。流程如下：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;挂起当前进程，将进程的上下文信息保存在进程控制块中；</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;在进程控制块中寻找下一个任务的上下文信息。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;恢复进程</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>上下文切换的原因：</strong>第一，任务正常执行完毕，调度下一个任务；第二，线程出现I/O阻塞，被挂起，cpu调度下一个任务；第三，线程等待同步锁，获取socket通知等，被挂起，cpu调度下一个任务；第四，用户调用sleep方法，让出cpu；第五，硬件中断</p>
<h2><strong>二，JAVA阻塞队列</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>阻塞队列的是调度当前队列的线程处于阻塞状态</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 消费者阻塞：如果队列为空，则消费者线程被挂起，处于阻塞状态，当有新数据进入队列，则消费者线程被唤醒，消费数据</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 生产者阻塞：如果队列数据已满，则生产者线程挂起，处于阻塞状态，当队列有空闲位置，生产者线程被唤醒，生产数据。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞队列的主要操作：</strong>插入操作和移除（获取）操作</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>插入操作：</strong>add(e)，有空间则插入，无空间报异常；offer(e),有空间则插入，无空间返回false；offer(e,time,unit),有空间插入，无空间等待time时间，若超时返回false；put(e),有空间插入，无空间则线程挂起处于阻塞直到有空间</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>移除操作：</strong>poll(e),有值返回值，无值返回null;poll(e,time,unit),有值返回值，无值等待time时间，超时返回null;take(e),有值返回值，无值等待新数据进入再立即返回；drainTo(collection&lt;Object&gt;)批量移除，提高获取效率</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞队列的实现：</strong></p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong> ArrayBlockingQueue：</strong>基于数组的有界阻塞队列，按照先进先出顺序对元素进行排序</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>LinkedBlockingQueue：</strong>基于链表的有界阻塞队列，队头队尾采用不两个不同的锁控制数据同步，并发性高</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>PriorityBlockingQueue：</strong>基于优先级的无界队列，默认升序排列，可以自定义排序规则，根据优先级访问数据。但是有数据优先级一样的情况</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>DelayQueue：</strong>支持延时的队列，即从队列中取数据时等待一定的时间才能获取元素。可以用于缓存系统的设计，设计过期时间，也可以用来设置定时调度任务，即如果能够从队列中获取，说明到了任务的调度时间。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>SynchronousQueue</strong>：该队列是一个不存储元素的阻塞队列，每一个put操作都必须等待一个take操作的完成。吞吐量高于ArrayBlockingQueue和LinkedBlockingQueue。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>LinkedTransferQueue：</strong>基于链表的无界阻塞队列，多了transfer方法(如果消费者等待，直接将任务从生产者传递给消费者，无消费者等待，则将任务加到队尾直到被消费才返回)和tryTransfer（与transfer一致，只不过不管有没有消费者等待获取都会立即返回tryTransfer（e,time,unit）（与tryTransfer一致，只不过设置了超时时间）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>LinkedBlockingDeque：</strong>基于链表的双向阻塞队列，可以在两端同时进行读写操作，提高了队列的操作效率。</p>
<h2><strong>三，并发关键字</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;CountDownLatch：</strong>适用于一个主线程等待子线程完成任务之后执行（原理：设置一个程序计数器，计数器的值为子线程的个数，子线程并发执行，每个子线程执行完毕后，调用CountDown方法，将其计数器的值减去1，值为0时，唤醒主线程执行）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>CyclicBarrier：</strong>即当所有线程到达一个状态共同执行。await（）方法：确保所有线程到达Barrier状态才执行；await（time,unit）：设置一个超时时间，超过这个时间，执行达到Barrier状态的线程。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>Semaphore：</strong>因为其限制了多线程访问资源的线程个数，所以适用于多线程并发访问有限资源的情况。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>volatile：</strong>直接用来修饰变量，是一种比Synchronized更加轻量级的机制，用于多线程共享同一变量，可以同时对其进行读写操作。当多个线程共享变量的时候，读取变量将其从内存复制到cpu缓存中，然后线程对其操作进行修改，这样再多cpu的情况下，有可能出现线程修改原数据造成数据不一致的情况，使用volatile关键字直接将线程修改的变量存入内存，解决这个问题。</p>
<h2><strong>四，多线程共享数据</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>多线程共享数据主要通过共享内存实现，而共享内存的可见性，有序性，原子性已经由JVM和锁解决。理想情况下我们需要解决同步和互斥的问题（<span style="background-color: #ffff00;">怎么解决的有待考证！</span>）</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>解决方法一：</strong>将数据抽象成一个类，将对数据的操作封装成类中的方法</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解决方法二：</strong>将Runnable对象作为一个内部类，将共享数据作为这个类的成员变量</p>
<h2><strong>五，ConcurrentHashmap并发</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ConcurrentHashmap使用了减小锁粒度，这里具体为分段锁的思想优化了锁，因为如果直接对hashmap进行加锁，锁太大，而且同一时刻只能有一个线程操作hashmap，并发性能较差</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;实现原理：</strong>即内部采用分段锁思想，将hashmap分为多个segment，每次读取数据的时候，对数据所在的segment进行加锁，这样只要保证每个segment线程安全，就可以保证整个hashmap线程安全</p>
<h2><strong>六，JAVA中的线程调度</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;抢占式调度：</strong>即线程对cpu资源进行抢占，这种策略下每个线程抢占到cpu资源的概率是相等的，这样就不会一个线程阻塞造成整个系统阻塞的情况。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>协同式调度：</strong>即一个线程使用完cpu资源之后通知cpu调度下一个任务，适用于多线程交替执行任务。因为如果一个线程阻塞可能会造成整个系统阻塞甚至崩溃</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>JAVA采用的是抢占式调度，但同时又尽可能的保证公平性（即为每个线程分配优先级不同的cpu时间片）</strong></p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>&nbsp;线程让出cpu的情况</strong>：第一，线程调用yield方法；第二，I/O阻塞，socket等待等；第三，等待同步锁；第四，正常执行完毕</p>
<h2>七，进程调度算法</h2>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>优先调度算法：</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;先来先服务调度算法：</strong>即遵循先来先被分配cpu资源运行的原则</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>短作业调度算法：</strong>即预估作业的时间长短，优先调度时间短的任务，可能会导致长时间大任务很长时间无法被调度 &nbsp;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>高优先权调度算法：即每个任务会预先被分配优先级</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;非抢占式优先调度算法：</strong>按照优先级的高低一次分配cpu资源运行</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>抢占式优先调度算法：</strong>按照优先级的高低分配cpu资源运行，但是如果任务再运行过程中有优先级更高的任务加入，则将其cpu资源临时回收分配给紧急任务</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>高响应比调度算法：</strong>动态调度，即作业时间短，则优先级高；等待时间长，则优先级高。前者遵循短作业调度算法，后者遵循先来先服务原则。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>时间片轮转调度算法：</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;时间片轮转法：</strong>按照任务再队列中的顺序进行调度</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>多级反馈队列调度算法：</strong>即再时间片轮转法的基础上维护了就绪队列，默认第一队列优先级高，先调度第一队列的任务，如果再分配的cpu时间片内未完成则将其加入第二队列队尾，以此类推直到其执行完毕。只有第1 -（n-1）队列为空，才会调度第n队列的任务，而且当前任务执行时，如果有优先级高的任务进来，会抢占其cpu资源。</p>
<h2><strong>八，CAS</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>即比较和交换，CAS（V,E,N）三个参数，只有当V=E的时候才会将V设置为N。如果V!=E，则说明数据已经被其它线程修改，不做任何操作</p>
<h2><strong>九，ABA问题</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>概述：</strong>即当1线程从V中取出A时，2线程也从中取出1，修改为B，再修改为A。而1线程仍然修改成功，实际上修改过程中V的实际值已经发生改变，只不过1没有发觉。解决这种问题，常采用乐观锁的版本号机制。</p>
<h2><strong>另外有AQS问题没怎么读懂，下次完善！</strong></h2>
<p>&nbsp;</p>
<h3><strong>思维导图：<a href="https://images-cdn.shimo.im/myFodjsaVAA3PVV7__thumbnail" target="_blank" rel="noopener">并发编程（下）</a></strong></h3>
<p>&nbsp;</p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</p>, blogGoods=0, blogRead=17, blogCollection=0, typeName=java面试篇, blogRemark=面试（三）------之并发编程篇（下）, blogComment=0, blogSource=null, createdTime=2020-04-13 16:54:26, blogMonth=null, updateTime=2020-04-20 11:54:02), BlogVo(blogId=1250068950784536576, blogTitle=面试（四）------之数据结构篇, blogImage=http://121.199.34.159/group1/M00/00/00/rBD3pF6dHQGAYlUxAABJTVJPTfk990.jpg, blogContent=<h2><strong>一，栈及其JAVA实现</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：栈是一种先进后出的数据结构，对栈顶元素的添加，删除等操作较快，但是对于栈内的元素操作很慢</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA实现：实现需要定义栈的数据结构，写栈的入栈，出栈，获取栈顶元素的方法，如下：</strong></p>
<pre class="language-java"><code>/**
 * 基于数组实现栈
 * @author wcj
 * @Date 2020/4/14 20:59
 * @Version 1.0
 */
public class StackExample&lt;E&gt; {

    /**
     * 站的深度
     */
    private int maxSize;
    /**
     * 存储数据的数组
     */
    private Object[] data;
    /**
     * 栈顶指针
     */
    private int top = -1;

    /**
     * 默认栈的深度为10
     */
    public StackExample(){
        this(10);
    }

    /**
     * 用户自定义栈的深度
     * @param initialSize
     */
    public StackExample(int initialSize){
        if(initialSize&gt;=0){
            this.maxSize = initialSize;
            this.data = new  Object[initialSize];
            this.top = -1;
        }else{
            throw new RuntimeException("初始化栈的深度不能小于0!");
        }
    }

    /**
     * 入栈操作
     * @param e
     * @return
     */
    public Boolean push(E e){
        if(top == maxSize-1){
            throw new RuntimeException("栈已满,不能入栈");
        }else{
            data[++top] = e;
        }
        return true;
    }

    /**
     * 出栈操作
     * @return
     */
    public E pop(){
        if(top==-1){
            throw new RuntimeException("栈空，不能出栈！");
        }else{
            return (E) data[top--];
        }
    }

    /**
     * 获取栈顶元素
     * @return
     */
    public E peak(){
        if(top==-1){
            throw new RuntimeException("栈空异常！");
        }else{
            return (E) data[top];
        }
    }  </code></pre>
<h2><strong>二，队列极其JAVA实现</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：队列是一种先进先出的数据结构，对队头和队尾的操作简单，但是队内元素的操作复杂。</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA实现：定义队列的数据结构，队列的出队，入队，获取队头元素。代码如下：</strong></p>
<pre class="language-java"><code>/**
 * 基于数组实现队列
 * @author wcj
 * @Date 2020/4/14 21:14
 * @Version 1.0
 */
public class QueueExample&lt;E&gt; {

    /**
     * 队列长度
     */
    private int maxSize;
    /**
     * 存储数据数组
     */
    private Object[] data;
    /**
     * 队头指针
     */
    private int front;
    /**
     * 队尾指针
     */
    private int rear;

    /**
     * 默认构造器
     */
    public QueueExample(){
        this(10);
    }
    /**
     * 用户自定义队列长度构造器
     * @param initialSize
     */
    public QueueExample(int initialSize){
        if(initialSize&gt;=0){
            this.maxSize = initialSize;
            data = new Object[initialSize];
            front = rear = 0;
        }else{
            throw new RuntimeException("初始化队列长度不能小于0！");
        }
    }

    /**
     * 入队操作
     * @param e
     * @return
     */
    public Boolean add(E e){
        if(rear == maxSize){
            throw new RuntimeException("队列已满，无法入队!");
        }else{
            data[rear++] = e;
        }
        return true;
    }

    /**
     * 出队操作
     * @return
     */
    public E poll(){
        if(front==rear){
            throw new RuntimeException("队空，无元素可出队！");
        }else{
            E e = (E) data[front];
            data[front] = null;
            return e;
        }
    }

    /**
     * 获取队头元素
     * @return
     */
    public E peek(){
        if(front==rear){
            throw new RuntimeException("队空，无元素可出队!");
        }else{
            return (E) data[front];
        }
    }
}
</code></pre>
<h2><strong>三，链表及其JAVA实现</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：链表是由一系列数据节点组成的数据结构，节点可以动态生成。对于元素的增加，删除操作快，查询操作慢</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;这里主要讲述几种有代表性的链表：单向链表，双向链表，双向循环链表</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;单链表的JAVA实现：数据结构定义，添加节点，删除节点，查找节点，代码如下：</strong></p>
<pre class="language-java"><code>/**
 * 单向链表
 * @author wcj
 * @Date 2020/4/14 21:32
 * @Version 1.0
 */
public class SingleLinkedList {

    /**
     * 链表长度
     */
    private int length;
    /**
     * 链表头节点
     */
    private Node head;

    public SingleLinkedList(){
        this.length = 0;
        this.head = null;
    }
    /**
     * 内部类声明每个链表节点
     * 每个节点包括数据域和指向下一个节点的指针
     */
    private class Node{
        private Object data;
        private Node next;
        public Node(Object data){
            this.data = data;
        }
    }

    /**
     * 插入节点（这里使用头插法）
     * @param obj
     * @return
     */
    public Boolean add(Object obj){
        Node node = new Node(obj);
        if(length==0){
            head = node;
        }else{
            node.next= head;
            head = node;
        }
        length++;
        return true;
    }

    /**
     * 删除某个节点
     * 先对链表进行判空处理
     * 然后找到要删除的节点
     * 最后进行删除
     * @param obj
     * @return
     */
    public Boolean delete(Object obj){
        if(length==0){
            throw new RuntimeException("链表为空，无节点可删除!");
        }else{
            Node prev = head;
            Node current = head;
            //查找待删除元素
            while(!current.data.equals(obj)){
                if(current.next==null){
                    return false;
                }else{
                    prev = current;
                    current = current.next;
                }
            }
            prev.next = current.next;
            length--;
        }
        return true;
    }

    /**
     * 获取某个元素
     * @param obj
     * @return
     */
    public Object find(Object obj){
        if(length==0){
            throw new RuntimeException("链表为空");
        }else{
            Node current = head;
            while(current.data.equals(obj)){
                if(current.next==null){
                    return null;
                }else{
                    current = current.next;
                }
            }
            return current.data;
        }
    }
}
</code></pre>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>双向链表的JAVA实现：定义数据结构，头插法，尾插法，删除头部节点，删除尾部节点（这里只写尾插节点和删除尾部节点），代码如下：</strong></p>
<pre class="language-java"><code>import com.sun.org.apache.xpath.internal.operations.Bool;

/**
 * 单向循环链表
 * @author wcj
 * @Date 2020/4/14 22:05
 * @Version 1.0
 */
public class CircleLinkedList {

    /**
     * 链表长度
     */
    private int length;
    /**
     * 头节点
     */
    private Node head;
    /**
     * 尾节点
     */
    private Node tail;

    /**
     * 初始化构造方法
     */
    public CircleLinkedList(){
        this.length = 0;
        this.head=this.tail = null;
    }

    /**
     * 内部类实现的链表节点
     */
    private class Node{
        private Object data;
        private Node prev;
        private Node next;
        public Node(Object data){
            this.data = data;
        }
    }

    /**
     * 尾插节点
     * @param obj
     * @return
     */
    public Boolean addTail(Object obj){
        Node node = new Node(obj);
        if(length==0){
            head = tail= node;
            length++;
        }else{
            tail.next = node;
            node.prev = tail;
            tail = node;
            length++;
        }
        return true;
    }

    /**
     * 删除尾部节点
     * @return
     */
    public Boolean delTail(){
        Node temp = tail;
        if(length==0){
            throw new RuntimeException("链表为空!");
        }else{
            tail = tail.prev;
            tail.next = null;
            length--;
        }
        return true;
    }
}
</code></pre>
<h2><strong>四，散列表</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：有一张表M，一个映射函数f(key)，如果对于任意一个key，都有一个函数指与表中的内存地址相对应，则M就为散列表，f(key)就为散列函数。散列函数存储key-value键值对形式的数据，直接生成key与表中地址值的映射，因此查询非常迅速。同时散列表也经常被用于信息安全，用于加密操作。</strong></p>
<h2><strong>五，二叉排序树</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：二叉查找树又成为二叉搜索树，二叉查找树</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;特征：根节点左边的数据小于根节点，根节点右边的数据大于根节点，且其左右子树还是二叉排序树</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现：定义数据结构，插入操作，删除操作，查找操作，代码如下：</strong></p>
<pre class="language-java"><code>package interviewFour.example4;

/**
 * 二叉排序树
 * @author wcj
 * @Date 2020/4/14 17:17
 * @Version 1.0
 */
public class Node {

    private Node root = null;
    private int value;
    private Node left;
    private Node right;

    public Node(){}

    public Node(int value, Node left, Node right){
        this.value = value;
        this.left = left;
        this.right = right;
    }

    public Node(int value){
        this.left = null;
        this.right = null;
        this.value = value;
    }

    public int getValue() {
        return value;
    }

    public void setValue(int value) {
        this.value = value;
    }

    public Node getLeft() {
        return left;
    }

    public void setLeft(Node left) {
        this.left = left;
    }

    public Node getRight() {
        return right;
    }

    public void setRight(Node right) {
        this.right = right;
    }

    /**
     * 插入节点
     * @param value
     * @return
     */
    public Boolean insert(int value){
        //root代表根节点
        Node p = root;
        Node prev = null;
        //创建一个节点
        Node node = new Node(value);
        //寻找节点的插入位置
        while(p!=null){
            prev = p;
            if(value==p.getValue()){
                return false;
            }else if(value&lt;p.getValue()){
                p = p.getLeft();
            }else{
                p = p.getRight();
            }
        }
        if(root==null){
            root = node;
        }else if(value&lt;prev.getValue()){
            prev.setLeft(node);
        }else{
            prev.setRight(node);
        }
        return true;
    }

    /**
     * 删除某个节点
     * 分为三种情况，待删除节点为叶子节点，则直接删除
     * 待删除节点只有左子树或者右子树，则用左子树或者右子树替代当前节点位置
     * 待删除节点即有左子树又有右子树，则寻找左子树最大节点或者右子树最小节点顶替当前节点(这里使用左子树的最大节点)
     * @param value
     * @return
     */
    public void deleteBST(int value){
        deleteBST(root,value);
    }

    /**
     * 递归删除左子树，或者右子树，或者根节点
     * @param root
     * @param value
     * @return
     */
    public Boolean deleteBST(Node root,int value){
        if(root==null){
            return false;
        }else{
            if(root.getValue()==value){
                delete(root);
            }else if(value&lt;root.getValue()){
                deleteBST(root.getLeft(),value);
            }else{
                deleteBST(root.getRight(),value);
            }
        }
        return true;
    }

    /**
     * 分情况执行具体的删除逻辑
     * @param node
     * @return
     */
    public Boolean delete(Node node){
        if(node.getLeft()==null){
            node = node.getRight();
        }else if(node.getRight()==null){
            node = node.getLeft();
        }else{
            Node temp = node;
            Node s = node;
            //转向左子树，向右走到底
            s = s.getLeft();
            //寻找替换待删除节点的节点
            while(s!=null){
                temp = s;
                s = s.getRight();
            }
            node.setValue(temp.getValue());
            if(temp!=node){
                node.setLeft(temp.getLeft());
            }else{
                node.setRight(temp.getRight());
            }
        }
        return true;
    }

    /**
     * 在二叉查找树中找到对应节点
     * @param value
     * @return
     */
    public Boolean searchBTS(int value){
        Node node = root;
        if(node==null){
            throw new RuntimeException("无此节点！");
        }else{
            if(value==node.getValue()){
                return true;
            }else if(value&lt;node.getValue()){
                node = node.getLeft();
            }else{
                node = node.getRight();
            }
        }
        return false;
    }
}
</code></pre>
<h2><strong>六，红黑树</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 概述：红黑树是一种特化的自平衡二叉排序树，即其左右子树的深度差可以超过1。（详细的插入等操作过段时间会补充）</strong></p>
<h2><strong>七，图，位图</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;图的知识：定义，有向图/无向图，邻接矩阵/邻接表，BFS/DFS，位图的话没怎么搞清楚。</strong></p>
<h3><strong>思维导图：<a href="https://images-cdn.shimo.im/YClQaLxx9e8uEb9U__thumbnail" target="_blank" rel="noopener">数据结构</a></strong></h3>
<h2>&nbsp;</h2>, blogGoods=0, blogRead=7, blogCollection=0, typeName=java面试篇, blogRemark=面试（四）------之数据结构篇, blogComment=0, blogSource=null, createdTime=2020-04-14 14:30:37, blogMonth=null, updateTime=2020-04-23 22:14:43)], params={}, sortColumn=blog_read, sortMethod=ASC)]
2020-04-26 23:27:36.144 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 844
2020-04-26 23:27:36.145 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，斐波那契数列</strong></h2>\n<p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</p>\n<p>F(0) = 0,&nbsp; &nbsp;F(1)&nbsp;= 1<br />F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br />斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>\n<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>\n<p>示例 1：</p>\n<p>输入：n = 2<br />输出：1<br />示例 2：</p>\n<p>输入：n = 5<br />输出：5</p>\n<p>提示：</p>\n<p>0 &lt;= n &lt;= 100</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;一般情况下，遇到斐波那契数列，可能首先想到的就是递归解决，时间复杂度为O（2^n），嗯，这个时间复杂度，和没用算法没啥区别。如下：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 递归解决斐波那契数列第n项问题\n     * @param n\n     * @return\n     */\n    public static int findFibonacci2(int n){\n        if(n==0){\n            return 0;\n        }else if(n==1){\n            return 1;\n        }else{\n            int result = findFibonacci2(n-1)+findFibonacci2(n-2);\n            return result%1000000007;\n        }\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>动态规划：因为本题求解的问题可以分解为子问题，并且子问题会出现重复，所以采用动态规划更优。这里，博主使用的动态规划还没有到最优解的情况，因为使用数组，空间复杂度为O（n）,但是实际上可以将空间复杂度降为O（1）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;动态规划的一般解题思路（参照此题，大神勿喷）：（1）找出转台转移方程，即根据1-（n-1）项推导出第n项；（2）使用一个数组存储子状态，这也是动态规划优化时间复杂度的主要途径；</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * dp求斐波那契数列的第n项\n     *\n     * @param n\n     * @return\n     */\n    public static int findFibonacci(int n) {\n        if(n==0||n==1){\n            return n;\n        }\n        int[] dp = new int[n+1];\n        dp[0] = 0;\n        dp[1] = 1;\n\n        for(int i = 2;i&lt;=n;i++){\n            dp[i] = dp[i-1]+dp[i-2];\n            dp[i] = dp[i]%1000000007;\n        }\n        return dp[n];\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>下面贴一下官方的超神解答：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 时间复杂度为O（n）,空间复杂度O（1)动态规划\n     * @param n\n     * @return\n     */\n    public static int findFibonacci3(int n){\n        int a=0,b=1,sum;\n        for(int i=0;i&lt;n;i++){\n            sum = (a+b)%1000000007;\n            a = b;\n            b = sum;\n        }\n        return a;\n    }</code></pre>\n<p>&nbsp;</p>\n<h2><strong>关于动态规划，待博主深入学习之后，再做总结</strong></h2>","blogGoods":0,"blogId":"1252423800151093248","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6eWiCADg7OAAAaZr2Bc1U759.jpg","blogRead":0,"blogRemark":"LeetCode509----斐波那契数列","blogTitle":"LeetCode509----斐波那契数列","createdTime":"2020-04-21 10:27:57","typeName":"LeetCode","updateTime":"2020-04-21 10:34:11"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，青蛙跳台阶</strong></h2>\n<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n&nbsp;级的台阶总共有多少种跳法。</p>\n<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>\n<p>示例 1：</p>\n<p>输入：n = 2<br />输出：2<br />示例 2：</p>\n<p>输入：n = 7<br />输出：21<br />提示：</p>\n<p>0 &lt;= n &lt;= 100</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>分析：因为青蛙只有两种跳法，要么跳一级，要么跳两级。我们设上一个n级台阶的跳法为f(n)种，则对于最后一步只有两种情况：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;当最后一步跳1级台阶时，前面则跳了(n-1)级台阶，跳法为f(n-1)</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;当最后一步跳2级台阶时，前面则跳了（n-2）级台阶，跳法为f(n-2),</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;所以f(n) = f(n-1)+f(n-2)</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;解法一：递归求解，递归出口为f(1)=1,f(2)=2;递归体为f(n)=f(n-1)+f(n-2),但是递归的时间复杂度为指数级，且计算了太多重复数据</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 青蛙跳台阶递归解法\n     *\n     * @param n\n     * @return\n     */\n    public static int jump(int n) {\n        if (n == 1) {\n            return 1;\n        } else if (n == 2) {\n            return 2;\n        } else {\n            int result = jump(n - 1) + jump(n - 2);\n            return result % 1000000007;\n        }\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>解法二：动态规划，因为可以分解为子问题，且子问题的求解依赖于前面求解过的子问题，而且递归存在重复计算的问题。所以可使用动态规划，如下：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 青蛙跳台阶动态规划解法\n     *\n     * @param n\n     * @return\n     */\n    public static int jump2(int n) {\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        dp[1] = 1;\n        for (int i = 2; i &lt;= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n            dp[i] = dp[i] % 1000000007;\n        }\n        return dp[n];\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>官方解法：动态规划，但是用三个变量存储子问题的值，依次交替前进，空间复杂度降为O(1)</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 动态规划解决青蛙跳台阶\n     * @param n\n     * @return\n     */\n    public static int jump3(int n){\n        int a=1,b=1,sum;\n        for(int i=0;i&lt;n;i++){\n            sum = (a+b)%1000000007;\n            a = b;\n            b = sum;\n        }\n        return a;\n    }</code></pre>\n<p>&nbsp;</p>\n<h2><strong>该题和斐波那契数列问题基本一致，只是初始值存在差别。</strong></h2>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1252439650715316224","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6eaOaAXbVhAAAaZr2Bc1U560.jpg","blogRead":0,"blogRemark":"LeetCode70----青蛙跳台阶","blogTitle":"LeetCode70----青蛙跳台阶","createdTime":"2020-04-21 11:30:56","typeName":"LeetCode","updateTime":"2020-04-21 23:17:38"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，旋转数组的最小数字</strong></h2>\n<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组&nbsp;[3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。&nbsp;&nbsp;</p>\n<p>示例 1：</p>\n<p>输入：[3,4,5,1,2]<br />输出：1<br />示例 2：</p>\n<p>输入：[2,2,2,0,1]<br />输出：0</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;暴力环循法：即遍历一遍数组，遍历的过程种如果发现当前元素小于前面的元素，则返回当前元素；否则返回数组第一个元素。时间复杂度为O（N）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 遍历数组，按照升序规则查找需要进行交换的元素，输出后面的一个较小元素即可，时间复杂度为O（n)\n     * @param numbers\n     * @return\n     */\n    public static int minArrays(int[] numbers){\n        for(int i=1;i&lt;numbers.length;i++){\n            if(numbers[i]&lt;numbers[i-1]){\n                return numbers[i];\n            }\n        }\n        return numbers[0];\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>利用二分查找法的特性：该题是二分查找的变版，前后两个递增数组，仍然可以使用二分查找，只是具体的逻辑不同。时间复杂度为O（N），当然特别情况下会退化到O（logN）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 二分查找\n     * @param numbers\n     * @return\n     */\n    public static int minArray(int[] numbers){\n        int i=0;\n        int j=numbers.length-1;\n        while(i&lt;j){\n            int m = (i+j)/2;\n            if(numbers[m]&gt;numbers[j]){\n                i = m+1;\n            }else if(numbers[m]&lt;numbers[j]){\n                j = m;\n            }else{\n                j--;\n            }\n        }\n        return numbers[i];\n    }</code></pre>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1252503447316475904","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6epFCAFjmsAAAaZr2Bc1U324.jpg","blogRead":0,"blogRemark":"LeetCode154----之旋转数组的最小值","blogTitle":"LeetCode154----之旋转数组的最小值","createdTime":"2020-04-21 15:44:26","typeName":"LeetCode","updateTime":"2020-04-21 23:17:51"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，打印从1到最大的n位数</strong></h2>\n<p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>\n<p>示例 1:</p>\n<p>输入: n = 1<br />输出: [1,2,3,4,5,6,7,8,9]</p>\n<p>说明：</p>\n<p>用返回一个整数列表来代替打印<br />n 为正整数</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解法一：读到此题的小伙伴，会觉得这道题很简单，当然，事实上这道题确实很简单，我们只需获取最大的十进制数，然后遍历输出就行了，如下：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 暴力解法,未考虑到大数问题\n     * @param n\n     * @return\n     */\n    public static int[] printNumbers(int n) {\n        int length = (int) Math.pow(10,n);\n        int[] result = new int[length-1];\n        for(int i=1;i&lt;length;i++){\n            result[i-1] = i;\n        }\n        return result;\n    }</code></pre>\n<p>&nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>扩展：LeetCode中此题对结果数进行了限制，默认了在int类型的范围中，那么如果不对n加以限定，造成了输出的最大数超过了int或者long类型的最大上限了怎么办，这时候我们就需要考虑到大数问题。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法：首先当变为大数问题，我们就不能使用int类型或者long类型来进行存储了，会出现内存溢出的情况，那么我们应该选择什么数据结构，对于大数问题通常来说选择数组或者字符串进行解决。博主这里使用字符数组进行解决</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解决的过程中，我们需要怎么做，第一点，我们需要考虑到如果用字符数组，那么模拟数字的加法运算。其次，怎么进行字符数组的输出。先贴代码：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 考虑大数问题，即最大值超过了long类型的上限怎么办，\n     * 这里采用字符数组存储数字，字符数组的每每个元素即是0-9中的任意一个\n     * @param n\n     * @return\n     */\n    public static void printNumbers2(int n){\n        //创建长度为n+1的字符数组，最后一位存储字符结束符'\\0'\n        char[] result = new char[n];\n        Arrays.fill(result,'0');\n        //模拟数字的加法\n        //将字符数组的中表达式按照数字打印出来\n        while(!increment(result)){\n            printChar(result);\n        }\n    }\n\n    /**\n     * 字符数组模拟数字的加法\n     * @param result\n     * @return\n     */\n    public static boolean increment(char[] result){\n        //返回值\n        boolean isBreak = false;\n        //进位标识\n        int carrySign = 0;\n        int length = result.length;\n        for(int i=length-1;i&gt;=0;i--){\n            int sum = result[i]-'0'+carrySign;\n            if(i==length-1){\n                sum++;\n            }\n            if(sum&gt;=10){\n                if(i==0){\n                    isBreak = true;\n                }else{\n                    result[i] = (char) (sum-10+'0');\n                    carrySign = 1;\n                }\n            }else{\n                result[i] = (char) (sum+'0');\n                break;\n            }\n        }\n        return isBreak;\n    }\n\n    /**\n     * 将字符数组中的表达式按照数字输出\n     * 需要去掉前面添加的0\n     * @param result\n     */\n    public static void printChar(char[] result){\n        boolean flag = true;\n        for(int i=0;i&lt;result.length;i++){\n            while(flag&amp;&amp;result[i]!='0'){\n                flag = false;\n            }\n            if(!flag){\n                System.out.print(result[i]);\n            }\n        }\n        System.out.print(\"\\t\");\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>分析：首先，我们新建一个长度为n的字符数组，并且将每个元素都设置为'0'.</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;然后判断increment(result)这个函数。这个函数是用于模拟数字的加法运算的。（模拟加法运算最重要的是考虑什么时候应该终止加法运算，一般情况下我们可能会想到每次加法运算将其与最大十进制数进行比较，如果相等，就终止，但是这种方法，有着O(N)的时间复杂度；再想一</strong></p>\n<p><strong>下，当我们输出1-99时，只有99进行加1才会出现字符数组中最高位进位的情况）因此设定一个布尔类型返回值isBreak，一个进位标识carrySign,然后从后往前遍历字符数组，即从最低位到最高位的顺序遍历，当最低位加1且引起最高位发生进位操作的时候，发生溢出，终止输出操作。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;最后，printChar（result）这个函数用于将字符数组中的表达式按照数字的形式进行输出，输出过程中，我们需要将数字前面的0去掉。即遍历字符数组，当某一个元素不为'0'的时候，我们才进行输出即可。</strong></p>\n<p>&nbsp;</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;思考：本题还可以用递归来简化字符数组模拟加法的操作，因为对于十进制数而言，字符数组中每一位保存的都是0-9，我们只需要将每一位进行0-9的全排列即可。</strong></p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1252604581645398016","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6fAoCAF5lGAAAaZr2Bc1U179.jpg","blogRead":0,"blogRemark":"剑指offer----之打印从1到最大的n位数","blogTitle":"剑指offer----之打印从1到最大的n位数","createdTime":"2020-04-21 22:26:18","typeName":"LeetCode","updateTime":"2020-04-21 23:18:18"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，链表中的倒数第k个节点</strong></h2>\n<p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>\n<p>示例：</p>\n<p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</p>\n<p>返回链表 4-&gt;5.</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>双指针法：初始化两个指针p1,p2都指向头节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;让p2指针先走k步</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;p1,p2指针同时走，直到p2指针为空</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法\n     * 初始化两个指针p1,p2都指向头节点\n     * 让p2指针先走k步\n     * 然后p1,p2指针一块走，直到p2指针为空\n     * @param head\n     * @param k\n     * @return\n     */\n    public ListNode getKthFromEnd(ListNode head, int k) {\n        ListNode p1 = head;\n        ListNode p2 = head;\n        //先让p2指针走两步\n        for(int i=0;i&lt;k;i++){\n            p2 = p2.next;\n        }\n        //再让两个指针同时走，直到p2的下一个节点为空\n        while(p2!=null){\n            p1 = p1.next;\n            p2=p2.next;\n        }\n        return p1;\n    }</code></pre>","blogGoods":0,"blogId":"1252621660096311296","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6fEmuAbVUdAAAaZr2Bc1U613.jpg","blogRead":0,"blogRemark":"剑指offer----之链表中的到数第k个节点","blogTitle":"剑指offer----之链表中的到数第k个节点","createdTime":"2020-04-21 23:34:10","typeName":"LeetCode","updateTime":"2020-04-21 23:34:10"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，合并两个有序链表</strong></h2>\n<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>\n<p>示例1：</p>\n<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br />输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br />限制：</p>\n<p>0 &lt;= 链表长度 &lt;= 1000</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>伪头节点法：即创建一个伪头节点head和一个用于辅助的节点cur</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法：如果l1.val&lt;=l2.val,就让cur指向l1，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l1指向其next</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果l1.val&gt;l2.val,就让cur指向l2，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l2指向其next</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;直到l1和l2有一个为空为止，让cur指向剩余的一个非空链表即可，若两个链表的长度为M,N则时间复杂度为O(M+N)</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用四节点，一个伪头节点，一个当前节点cur，已经链表的两个节点l1,l2\n     * 每次比较l1,l2节点的val大小，将小的节点连接到当前节点cur上即可\n     * 直到l1,l2有一个空，则将剩余的一个非空链表连接到cur尾部即可\n     * @param l1\n     * @param l2\n     * @return\n     */\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode head;\n        ListNode cur;\n        head = cur = new ListNode(0);\n        while(l1!=null&amp;&amp;l2!=null){\n            if(l1.val&lt;=l2.val){\n                cur.next = l1;\n                cur = cur.next;\n                l1 = l1.next;\n            }else{\n                cur.next = l2;\n                cur = cur.next;\n                l2 = l2.next;\n            }\n        }\n        if(l1!=null){\n            cur.next = l1;\n        }\n        if(l2!=null){\n            cur.next = l2;\n        }\n        return head.next;\n    }</code></pre>","blogGoods":0,"blogId":"1252980258446000128","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6gYGWAe-MZAAAaZr2Bc1U550.jpg","blogRead":0,"blogRemark":"剑指offer----之合并有序链表---LeetCode21","blogTitle":"剑指offer----之合并有序链表---LeetCode21","createdTime":"2020-04-22 23:19:06","typeName":"LeetCode","updateTime":"2020-04-22 23:19:06"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，二叉树镜像</strong></h2>\n<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>\n<p>例如输入：</p>\n<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; 2 &nbsp; &nbsp; 7<br />&nbsp;/ \\ &nbsp; / \\<br />1 &nbsp; 3 6 &nbsp; 9<br />镜像输出：</p>\n<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; 7 &nbsp; &nbsp; 2<br />&nbsp;/ \\ &nbsp; / \\<br />9 &nbsp; 6 3&nbsp; &nbsp;1</p>\n<p>示例 1：</p>\n<p>输入：root = [4,2,7,1,3,6,9]<br />输出：[4,7,2,9,6,3,1]</p>\n<p>限制：</p>\n<p>0 &lt;= 节点个数 &lt;= 1000</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;递归法：即递归的去交换根节点的左右子树，直到根节点为叶子节点</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用递归的方法，交换根节点的左子树和右子树\n     * 递归出口为，根节点为叶子节点\n     * @param root\n     * @return\n     */\n    public TreeNode mirrorTree(TreeNode root) {\n        TreeNode center = root;\n        if(center!=null){\n            TreeNode temp = center.left;\n            center.left = center.right;\n            center.right = temp;\n            mirrorTree(center.left);\n            mirrorTree(center.right);\n        }\n        return root;\n    }</code></pre>","blogGoods":0,"blogId":"1252985443281027072","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6gZTWABF55AAAaZr2Bc1U678.jpg","blogRead":0,"blogRemark":"剑指offer----之二叉树的镜像----LeetCode226","blogTitle":"剑指offer----之二叉树的镜像----LeetCode226","createdTime":"2020-04-22 23:39:43","typeName":"LeetCode","updateTime":"2020-04-22 23:39:43"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，顺时针打印矩阵</strong></h2>\n<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>\n<p>示例 1：</p>\n<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br />输出：[1,2,3,6,9,8,7,4,5]<br />示例 2：</p>\n<p>输入：matrix =&nbsp;[[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br />输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p>\n<p>限制：</p>\n<p>0 &lt;= matrix.length &lt;= 100<br />0 &lt;= matrix[i].length&nbsp;&lt;= 100</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;模拟顺时针打印的这种循环结构：设置四个边界条件，l,r,t,b。按照从左往右，从上往下，从右往左，从下网往上的顺序依次读取矩阵的元素，并且每一次都判断边界是否相遇，直到将整个矩阵元素都加入到数组中即可。</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 设置四个边界值，分别为left=0,right=matrix[0].length-1,top=0,bottom=matrix.length-1\n     * 顺时针顺序即先从左到右，再从上到下，再从右向左，再从下向上，每一次执行都要判断边界值\n     * @param matrix\n     * @return\n     */\n    public static int[] spiralOrder(int[][] matrix) {\n        if(matrix.length==0){\n            return new int[0];\n        }\n        int l = 0;\n        int r=matrix[0].length-1;\n        int t=0;\n        int b=matrix.length-1;\n        int x=0;\n        int[] res = new int[(r+1)*(b+1)];\n        while(true){\n            //从左向右\n            for(int i=l;i&lt;=r;i++){\n                res[x++]=matrix[t][i];\n            }\n            if(++t&gt;b) {\n                break;\n            }\n            //从上向下\n            for(int i=t;i&lt;=b;i++){\n                res[x++] = matrix[i][r];\n            }\n            if(--r&lt;l){\n                break;\n            }\n            //从右向左\n            for(int i=r;i&gt;=l;i--){\n                res[x++] = matrix[b][i];\n            }\n            if(--b&lt;t){\n                break;\n            }\n            //从下往上\n            for(int i=b;i&gt;=t;i--){\n                res[x++] = matrix[i][l];\n            }\n            if(++l&gt;r){\n                break;\n            }\n        }\n        return res;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1253250557729087488","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hXB2ASIQwAAAaZr2Bc1U016.jpg","blogRead":0,"blogRemark":"剑指offer-----之顺时针打印矩阵----LeetCode54","blogTitle":"剑指offer-----之顺时针打印矩阵----LeetCode54","createdTime":"2020-04-23 17:13:11","typeName":"LeetCode","updateTime":"2020-04-23 17:13:11"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，从上打印二叉树-1</strong></h2>\n<p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>\n<p>例如:<br />给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>\n<p>3<br />/ \\<br />9 20<br />/ \\<br />15 7<br />返回：</p>\n<p>[3,9,20,15,7]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;BFS（广度优先搜索）：也即是二叉树的层次遍历，代码和注意事项看代码注释</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 二叉树的层次遍历\n     * 这里是将层次遍历的结果存储在数组中\n     * 但是因为二叉树的节点个数并不知道\n     * 所以不能使用数组直接进行存储，因为无法初始化数组的大小\n     * 所以可以想到使用容量能自动扩充的list集合\n     * 然后再根据list集合的size来初始化数组的大小\n     * 并且将list元素赋值到数组中\n     * @param root\n     * @return\n     */\n    public static int[] levelOrder(TreeNode root) {\n        if(root==null){\n            return new int[0];\n        }\n        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n        TreeNode current;\n        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n        while(!queue.isEmpty()){\n            current = queue.poll();\n            list.add(current.val);\n            if(current.left!=null){\n                queue.add(current.left);\n            }\n            if(current.right!=null){\n                queue.add(current.right);\n            }\n        }\n        int[] result = new int[list.size()];\n        for (int i = 0; i &lt; list.size(); i++) {\n            result[i] = list.get(i);\n        }\n        return result;\n    }</code></pre>","blogGoods":0,"blogId":"1253346228108894208","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6htTeAUHGlAAAaZr2Bc1U102.jpg","blogRead":0,"blogRemark":"剑指offer----之从上到下打印二叉树","blogTitle":"剑指offer----之从上到下打印二叉树","createdTime":"2020-04-23 23:33:20","typeName":"LeetCode","updateTime":"2020-04-23 23:33:20"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，数组中出现次数超过一半的元素---即众数</strong></h2>\n<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>\n<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>\n<p>示例&nbsp;1:</p>\n<p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br />输出: 2</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>方法有三：哈希表统计法，数组排序法，摩尔投票法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;哈希统计法：时间复杂度O（N），空间复杂度O（N）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 博主刚开始看到这道题的时候，首先想到的是哈希表统计法，因为博主想的是要找到众数，那么肯定得统计每个数字的出现次数，然后按照次数比较。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 单单是想到这些，用了map集合之后发现还是不行，因为即便用map集合统计出了每个数字和其对应的出现次数之后，你会发现没有办法按照出现的次数进行比较并且得到次数最多的数字（众数</strong><strong>）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 然后，就又审了一遍题目，结果发现了一个本题很关键的点，（<span style=\"background-color: #ffcc00;\">数组中有一个数字出现的次数超过数组长度的一半</span>），也就是说数组中有且仅有一个数字的出现次数会超过数组长度的一半（别笑博主笨，我是真的刚开始没反应过来）</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 那么我为什么要把数组中的所有元素和其次数全部存放进入map集合，然后再取次数进行比较呢？我为什么不在将元素和其次数存入集合的过程中判断次数是否已经超过数组长度的一半了呢？如果超过一半了，那它肯定是众数了呀！</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 思路：根据题意需要找出两个东西，一是多素元素，二是多素元素的出现次数\n     * 所以我们首先想到的是采用map集合\n     * 然后遍历数组，如果元素不存在与集合中，我们就将其加入map，value置为1\n     * 如果元素存在于map中，则我们取出其value将其加1与数组长度的一半做比较\n     * 如果大于数组长度一半，直接返回该元素即可\n     * 小于数组长度一半，则将其value加1存入map覆盖原有的值即可\n     *\n     * @param nums\n     * @return\n     */\n    public static int majorityElement(int[] nums) {\n        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(nums.length);\n        for (int num : nums) {\n            if(!map.containsKey(num)){\n                map.put(num,1);\n            }else{\n                Integer val = map.get(num);\n                if(++val&gt;nums.length/2){\n                    return num;\n                }else{\n                    map.put(num,val);\n                }\n            }\n        }\n        throw new RuntimeException(\"\");\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>数组排序法：由题可知，数组众必然存在一个多数元素，且出现次数超过数组长度的一半。所以我们可以对原数组进行排序，然后取数组中间的元素即可。（我擦，我当时看到这个，就在想，好简单，这个思路，但是我为什么没想到，对，因为我没有仔细的分析题目，超过一半看见没）。既然进行排序，那么我们可以选择快排，这样时间复杂度就是O（NlogN），空间复杂度O（1）.</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 数组排序法，因为多数元素的出现次数超过数组长度一半，\n     * 所以我们可以先对其进行排序，采用快排，时间复杂度O（NlogN）\n     * 然后取数组中点元素即可\n     * @param nums\n     * @return\n     */\n    public static int majorityElement2(int[] nums){\n        quickSort(nums,0,nums.length-1);\n        return nums[nums.length/2];\n    }\n\n    /**\n     * 快排\n     * @param nums\n     * @param low\n     * @param high\n     */\n    public static void quickSort(int[] nums,int low,int high){\n        int base = nums[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //从右向左找到第一个比基准元素小的元素\n            while(L&lt;R&amp;&amp;nums[R]&gt;=base){\n                R--;\n            }\n            if(nums[R]&lt;base){\n                swap(nums,L,R);\n            }\n            //从左向右找到第一个比基准元素大的元素\n            while(L&lt;R&amp;&amp;nums[L]&lt;=base){\n                L++;\n            }\n            if(nums[L]&gt;base){\n                swap(nums,L,R);\n            }\n        }\n        //左递归\n        if(L&gt;low){\n            quickSort(nums,low,L-1);\n        }\n        //右递归\n        if(high&gt;R){\n            quickSort(nums,R+1,high);\n        }\n    }\n\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>摩尔投票法（我将其称为大佬解法）：大概的意思就是采用正负抵消的方法，设置一个投票变量votes，初始设置为0；设置一个本题中的众数变量x，初始设置为数组首元素。然后遍历数组，判断跟设置的众数变量是否相等，如果相等将votes加一，如果不相等，则重置votes为0，且将x设置为数组下一个元素。本题众因为已经声明了肯定存在众数，所以不需要进行验证，但是如果没有声明的话，需要验证，下列代码众添加了验证：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 摩尔投票法\n     * @param nums\n     */\n    public static int majorityElement3(int[] nums){\n        int votes = 0;\n        int x = nums[0];\n        int count = 0;\n        for (int num : nums) {\n            if(votes==0){\n                x = num;\n            }\n            votes+=(num==x)?1:-1;\n        }\n        //验证数组众是否存在众数\n        for (int num : nums) {\n            if(num==x){\n                count++;\n            }\n        }\n        return count&gt;nums.length/2?x:0;\n    }</code></pre>","blogGoods":0,"blogId":"1253674617332162560","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6i5v-AUh39AAAaZr2Bc1U885.jpg","blogRead":0,"blogRemark":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","blogTitle":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","createdTime":"2020-04-24 21:18:14","typeName":"LeetCode","updateTime":"2020-04-24 21:18:14"}],"pageSize":10,"params":{},"sortColumn":"blog_read","sortMethod":"ASC","totalCount":53,"totalPage":6},"msg":"操作成功!"}
2020-04-26 23:27:38.901 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/list
2020-04-26 23:27:38.901 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:27:38.901 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:27:38.901 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogList
2020-04-26 23:27:38.902 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=10, totalPage=6, totalCount=53, list=[BlogVo(blogId=1252423800151093248, blogTitle=LeetCode509----斐波那契数列, blogImage=http://121.199.34.159/group1/M00/00/01/rBD3pF6eWiCADg7OAAAaZr2Bc1U759.jpg, blogContent=<h2><strong>一，斐波那契数列</strong></h2>
<p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</p>
<p>F(0) = 0,&nbsp; &nbsp;F(1)&nbsp;= 1<br />F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br />斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p>示例 1：</p>
<p>输入：n = 2<br />输出：1<br />示例 2：</p>
<p>输入：n = 5<br />输出：5</p>
<p>提示：</p>
<p>0 &lt;= n &lt;= 100</p>
<h2><strong>二，题解</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;一般情况下，遇到斐波那契数列，可能首先想到的就是递归解决，时间复杂度为O（2^n），嗯，这个时间复杂度，和没用算法没啥区别。如下：</strong></p>
<pre class="language-java"><code>    /**
     * 递归解决斐波那契数列第n项问题
     * @param n
     * @return
     */
    public static int findFibonacci2(int n){
        if(n==0){
            return 0;
        }else if(n==1){
            return 1;
        }else{
            int result = findFibonacci2(n-1)+findFibonacci2(n-2);
            return result%1000000007;
        }
    }</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>动态规划：因为本题求解的问题可以分解为子问题，并且子问题会出现重复，所以采用动态规划更优。这里，博主使用的动态规划还没有到最优解的情况，因为使用数组，空间复杂度为O（n）,但是实际上可以将空间复杂度降为O（1）</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;动态规划的一般解题思路（参照此题，大神勿喷）：（1）找出转台转移方程，即根据1-（n-1）项推导出第n项；（2）使用一个数组存储子状态，这也是动态规划优化时间复杂度的主要途径；</strong></p>
<pre class="language-java"><code>    /**
     * dp求斐波那契数列的第n项
     *
     * @param n
     * @return
     */
    public static int findFibonacci(int n) {
        if(n==0||n==1){
            return n;
        }
        int[] dp = new int[n+1];
        dp[0] = 0;
        dp[1] = 1;

        for(int i = 2;i&lt;=n;i++){
            dp[i] = dp[i-1]+dp[i-2];
            dp[i] = dp[i]%1000000007;
        }
        return dp[n];
    }</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>下面贴一下官方的超神解答：</strong></p>
<pre class="language-java"><code>    /**
     * 时间复杂度为O（n）,空间复杂度O（1)动态规划
     * @param n
     * @return
     */
    public static int findFibonacci3(int n){
        int a=0,b=1,sum;
        for(int i=0;i&lt;n;i++){
            sum = (a+b)%1000000007;
            a = b;
            b = sum;
        }
        return a;
    }</code></pre>
<p>&nbsp;</p>
<h2><strong>关于动态规划，待博主深入学习之后，再做总结</strong></h2>, blogGoods=0, blogRead=0, blogCollection=0, typeName=LeetCode, blogRemark=LeetCode509----斐波那契数列, blogComment=0, blogSource=null, createdTime=2020-04-21 10:27:57, blogMonth=null, updateTime=2020-04-21 10:34:11), BlogVo(blogId=1252439650715316224, blogTitle=LeetCode70----青蛙跳台阶, blogImage=http://121.199.34.159/group1/M00/00/01/rBD3pF6eaOaAXbVhAAAaZr2Bc1U560.jpg, blogContent=<h2><strong>一，青蛙跳台阶</strong></h2>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n&nbsp;级的台阶总共有多少种跳法。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p>示例 1：</p>
<p>输入：n = 2<br />输出：2<br />示例 2：</p>
<p>输入：n = 7<br />输出：21<br />提示：</p>
<p>0 &lt;= n &lt;= 100</p>
<h2>二，题解</h2>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>分析：因为青蛙只有两种跳法，要么跳一级，要么跳两级。我们设上一个n级台阶的跳法为f(n)种，则对于最后一步只有两种情况：</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;当最后一步跳1级台阶时，前面则跳了(n-1)级台阶，跳法为f(n-1)</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;当最后一步跳2级台阶时，前面则跳了（n-2）级台阶，跳法为f(n-2),</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;所以f(n) = f(n-1)+f(n-2)</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;解法一：递归求解，递归出口为f(1)=1,f(2)=2;递归体为f(n)=f(n-1)+f(n-2),但是递归的时间复杂度为指数级，且计算了太多重复数据</strong></p>
<pre class="language-java"><code>    /**
     * 青蛙跳台阶递归解法
     *
     * @param n
     * @return
     */
    public static int jump(int n) {
        if (n == 1) {
            return 1;
        } else if (n == 2) {
            return 2;
        } else {
            int result = jump(n - 1) + jump(n - 2);
            return result % 1000000007;
        }
    }</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>解法二：动态规划，因为可以分解为子问题，且子问题的求解依赖于前面求解过的子问题，而且递归存在重复计算的问题。所以可使用动态规划，如下：</strong></p>
<pre class="language-java"><code>    /**
     * 青蛙跳台阶动态规划解法
     *
     * @param n
     * @return
     */
    public static int jump2(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i &lt;= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
            dp[i] = dp[i] % 1000000007;
        }
        return dp[n];
    }</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>官方解法：动态规划，但是用三个变量存储子问题的值，依次交替前进，空间复杂度降为O(1)</strong></p>
<pre class="language-java"><code>    /**
     * 动态规划解决青蛙跳台阶
     * @param n
     * @return
     */
    public static int jump3(int n){
        int a=1,b=1,sum;
        for(int i=0;i&lt;n;i++){
            sum = (a+b)%1000000007;
            a = b;
            b = sum;
        }
        return a;
    }</code></pre>
<p>&nbsp;</p>
<h2><strong>该题和斐波那契数列问题基本一致，只是初始值存在差别。</strong></h2>
<p>&nbsp;</p>, blogGoods=0, blogRead=0, blogCollection=0, typeName=LeetCode, blogRemark=LeetCode70----青蛙跳台阶, blogComment=0, blogSource=null, createdTime=2020-04-21 11:30:56, blogMonth=null, updateTime=2020-04-21 23:17:38), BlogVo(blogId=1252503447316475904, blogTitle=LeetCode154----之旋转数组的最小值, blogImage=http://121.199.34.159/group1/M00/00/01/rBD3pF6epFCAFjmsAAAaZr2Bc1U324.jpg, blogContent=<h2><strong>一，旋转数组的最小数字</strong></h2>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组&nbsp;[3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。&nbsp;&nbsp;</p>
<p>示例 1：</p>
<p>输入：[3,4,5,1,2]<br />输出：1<br />示例 2：</p>
<p>输入：[2,2,2,0,1]<br />输出：0</p>
<h2><strong>二，题解</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;暴力环循法：即遍历一遍数组，遍历的过程种如果发现当前元素小于前面的元素，则返回当前元素；否则返回数组第一个元素。时间复杂度为O（N）</strong></p>
<pre class="language-java"><code>    /**
     * 遍历数组，按照升序规则查找需要进行交换的元素，输出后面的一个较小元素即可，时间复杂度为O（n)
     * @param numbers
     * @return
     */
    public static int minArrays(int[] numbers){
        for(int i=1;i&lt;numbers.length;i++){
            if(numbers[i]&lt;numbers[i-1]){
                return numbers[i];
            }
        }
        return numbers[0];
    }</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>利用二分查找法的特性：该题是二分查找的变版，前后两个递增数组，仍然可以使用二分查找，只是具体的逻辑不同。时间复杂度为O（N），当然特别情况下会退化到O（logN）</strong></p>
<pre class="language-java"><code>    /**
     * 二分查找
     * @param numbers
     * @return
     */
    public static int minArray(int[] numbers){
        int i=0;
        int j=numbers.length-1;
        while(i&lt;j){
            int m = (i+j)/2;
            if(numbers[m]&gt;numbers[j]){
                i = m+1;
            }else if(numbers[m]&lt;numbers[j]){
                j = m;
            }else{
                j--;
            }
        }
        return numbers[i];
    }</code></pre>
<p>&nbsp;</p>, blogGoods=0, blogRead=0, blogCollection=0, typeName=LeetCode, blogRemark=LeetCode154----之旋转数组的最小值, blogComment=0, blogSource=null, createdTime=2020-04-21 15:44:26, blogMonth=null, updateTime=2020-04-21 23:17:51), BlogVo(blogId=1252604581645398016, blogTitle=剑指offer----之打印从1到最大的n位数, blogImage=http://121.199.34.159/group1/M00/00/01/rBD3pF6fAoCAF5lGAAAaZr2Bc1U179.jpg, blogContent=<h2><strong>一，打印从1到最大的n位数</strong></h2>
<p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<p>示例 1:</p>
<p>输入: n = 1<br />输出: [1,2,3,4,5,6,7,8,9]</p>
<p>说明：</p>
<p>用返回一个整数列表来代替打印<br />n 为正整数</p>
<h2><strong>二，题解</strong></h2>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解法一：读到此题的小伙伴，会觉得这道题很简单，当然，事实上这道题确实很简单，我们只需获取最大的十进制数，然后遍历输出就行了，如下：</strong></p>
<pre class="language-java"><code>    /**
     * 暴力解法,未考虑到大数问题
     * @param n
     * @return
     */
    public static int[] printNumbers(int n) {
        int length = (int) Math.pow(10,n);
        int[] result = new int[length-1];
        for(int i=1;i&lt;length;i++){
            result[i-1] = i;
        }
        return result;
    }</code></pre>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>扩展：LeetCode中此题对结果数进行了限制，默认了在int类型的范围中，那么如果不对n加以限定，造成了输出的最大数超过了int或者long类型的最大上限了怎么办，这时候我们就需要考虑到大数问题。</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法：首先当变为大数问题，我们就不能使用int类型或者long类型来进行存储了，会出现内存溢出的情况，那么我们应该选择什么数据结构，对于大数问题通常来说选择数组或者字符串进行解决。博主这里使用字符数组进行解决</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解决的过程中，我们需要怎么做，第一点，我们需要考虑到如果用字符数组，那么模拟数字的加法运算。其次，怎么进行字符数组的输出。先贴代码：</strong></p>
<pre class="language-java"><code>    /**
     * 考虑大数问题，即最大值超过了long类型的上限怎么办，
     * 这里采用字符数组存储数字，字符数组的每每个元素即是0-9中的任意一个
     * @param n
     * @return
     */
    public static void printNumbers2(int n){
        //创建长度为n+1的字符数组，最后一位存储字符结束符'\0'
        char[] result = new char[n];
        Arrays.fill(result,'0');
        //模拟数字的加法
        //将字符数组的中表达式按照数字打印出来
        while(!increment(result)){
            printChar(result);
        }
    }

    /**
     * 字符数组模拟数字的加法
     * @param result
     * @return
     */
    public static boolean increment(char[] result){
        //返回值
        boolean isBreak = false;
        //进位标识
        int carrySign = 0;
        int length = result.length;
        for(int i=length-1;i&gt;=0;i--){
            int sum = result[i]-'0'+carrySign;
            if(i==length-1){
                sum++;
            }
            if(sum&gt;=10){
                if(i==0){
                    isBreak = true;
                }else{
                    result[i] = (char) (sum-10+'0');
                    carrySign = 1;
                }
            }else{
                result[i] = (char) (sum+'0');
                break;
            }
        }
        return isBreak;
    }

    /**
     * 将字符数组中的表达式按照数字输出
     * 需要去掉前面添加的0
     * @param result
     */
    public static void printChar(char[] result){
        boolean flag = true;
        for(int i=0;i&lt;result.length;i++){
            while(flag&amp;&amp;result[i]!='0'){
                flag = false;
            }
            if(!flag){
                System.out.print(result[i]);
            }
        }
        System.out.print("\t");
    }</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>分析：首先，我们新建一个长度为n的字符数组，并且将每个元素都设置为'0'.</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;然后判断increment(result)这个函数。这个函数是用于模拟数字的加法运算的。（模拟加法运算最重要的是考虑什么时候应该终止加法运算，一般情况下我们可能会想到每次加法运算将其与最大十进制数进行比较，如果相等，就终止，但是这种方法，有着O(N)的时间复杂度；再想一</strong></p>
<p><strong>下，当我们输出1-99时，只有99进行加1才会出现字符数组中最高位进位的情况）因此设定一个布尔类型返回值isBreak，一个进位标识carrySign,然后从后往前遍历字符数组，即从最低位到最高位的顺序遍历，当最低位加1且引起最高位发生进位操作的时候，发生溢出，终止输出操作。</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;最后，printChar（result）这个函数用于将字符数组中的表达式按照数字的形式进行输出，输出过程中，我们需要将数字前面的0去掉。即遍历字符数组，当某一个元素不为'0'的时候，我们才进行输出即可。</strong></p>
<p>&nbsp;</p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;思考：本题还可以用递归来简化字符数组模拟加法的操作，因为对于十进制数而言，字符数组中每一位保存的都是0-9，我们只需要将每一位进行0-9的全排列即可。</strong></p>
<p>&nbsp;</p>, blogGoods=0, blogRead=0, blogCollection=0, typeName=LeetCode, blogRemark=剑指offer----之打印从1到最大的n位数, blogComment=0, blogSource=null, createdTime=2020-04-21 22:26:18, blogMonth=null, updateTime=2020-04-21 23:18:18), BlogVo(blogId=1252621660096311296, blogTitle=剑指offer----之链表中的到数第k个节点, blogImage=http://121.199.34.159/group1/M00/00/01/rBD3pF6fEmuAbVUdAAAaZr2Bc1U613.jpg, blogContent=<h2><strong>一，链表中的倒数第k个节点</strong></h2>
<p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
<p>示例：</p>
<p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</p>
<p>返回链表 4-&gt;5.</p>
<h2><strong>二，题解</strong></h2>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>双指针法：初始化两个指针p1,p2都指向头节点</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;让p2指针先走k步</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;p1,p2指针同时走，直到p2指针为空</strong></p>
<pre class="language-java"><code>    /**
     * 双指针法
     * 初始化两个指针p1,p2都指向头节点
     * 让p2指针先走k步
     * 然后p1,p2指针一块走，直到p2指针为空
     * @param head
     * @param k
     * @return
     */
    public ListNode getKthFromEnd(ListNode head, int k) {
        ListNode p1 = head;
        ListNode p2 = head;
        //先让p2指针走两步
        for(int i=0;i&lt;k;i++){
            p2 = p2.next;
        }
        //再让两个指针同时走，直到p2的下一个节点为空
        while(p2!=null){
            p1 = p1.next;
            p2=p2.next;
        }
        return p1;
    }</code></pre>, blogGoods=0, blogRead=0, blogCollection=0, typeName=LeetCode, blogRemark=剑指offer----之链表中的到数第k个节点, blogComment=0, blogSource=null, createdTime=2020-04-21 23:34:10, blogMonth=null, updateTime=2020-04-21 23:34:10), BlogVo(blogId=1252980258446000128, blogTitle=剑指offer----之合并有序链表---LeetCode21, blogImage=http://121.199.34.159/group1/M00/00/01/rBD3pF6gYGWAe-MZAAAaZr2Bc1U550.jpg, blogContent=<h2><strong>一，合并两个有序链表</strong></h2>
<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<p>示例1：</p>
<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br />输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br />限制：</p>
<p>0 &lt;= 链表长度 &lt;= 1000</p>
<h2><strong>二，题解</strong></h2>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>伪头节点法：即创建一个伪头节点head和一个用于辅助的节点cur</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法：如果l1.val&lt;=l2.val,就让cur指向l1，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l1指向其next</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果l1.val&gt;l2.val,就让cur指向l2，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l2指向其next</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;直到l1和l2有一个为空为止，让cur指向剩余的一个非空链表即可，若两个链表的长度为M,N则时间复杂度为O(M+N)</strong></p>
<pre class="language-java"><code>    /**
     * 使用四节点，一个伪头节点，一个当前节点cur，已经链表的两个节点l1,l2
     * 每次比较l1,l2节点的val大小，将小的节点连接到当前节点cur上即可
     * 直到l1,l2有一个空，则将剩余的一个非空链表连接到cur尾部即可
     * @param l1
     * @param l2
     * @return
     */
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode head;
        ListNode cur;
        head = cur = new ListNode(0);
        while(l1!=null&amp;&amp;l2!=null){
            if(l1.val&lt;=l2.val){
                cur.next = l1;
                cur = cur.next;
                l1 = l1.next;
            }else{
                cur.next = l2;
                cur = cur.next;
                l2 = l2.next;
            }
        }
        if(l1!=null){
            cur.next = l1;
        }
        if(l2!=null){
            cur.next = l2;
        }
        return head.next;
    }</code></pre>, blogGoods=0, blogRead=0, blogCollection=0, typeName=LeetCode, blogRemark=剑指offer----之合并有序链表---LeetCode21, blogComment=0, blogSource=null, createdTime=2020-04-22 23:19:06, blogMonth=null, updateTime=2020-04-22 23:19:06), BlogVo(blogId=1252985443281027072, blogTitle=剑指offer----之二叉树的镜像----LeetCode226, blogImage=http://121.199.34.159/group1/M00/00/01/rBD3pF6gZTWABF55AAAaZr2Bc1U678.jpg, blogContent=<h2><strong>一，二叉树镜像</strong></h2>
<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<p>例如输入：</p>
<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \<br />&nbsp; 2 &nbsp; &nbsp; 7<br />&nbsp;/ \ &nbsp; / \<br />1 &nbsp; 3 6 &nbsp; 9<br />镜像输出：</p>
<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \<br />&nbsp; 7 &nbsp; &nbsp; 2<br />&nbsp;/ \ &nbsp; / \<br />9 &nbsp; 6 3&nbsp; &nbsp;1</p>
<p>示例 1：</p>
<p>输入：root = [4,2,7,1,3,6,9]<br />输出：[4,7,2,9,6,3,1]</p>
<p>限制：</p>
<p>0 &lt;= 节点个数 &lt;= 1000</p>
<h2><strong>二，题解</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;递归法：即递归的去交换根节点的左右子树，直到根节点为叶子节点</strong></p>
<pre class="language-java"><code>    /**
     * 使用递归的方法，交换根节点的左子树和右子树
     * 递归出口为，根节点为叶子节点
     * @param root
     * @return
     */
    public TreeNode mirrorTree(TreeNode root) {
        TreeNode center = root;
        if(center!=null){
            TreeNode temp = center.left;
            center.left = center.right;
            center.right = temp;
            mirrorTree(center.left);
            mirrorTree(center.right);
        }
        return root;
    }</code></pre>, blogGoods=0, blogRead=0, blogCollection=0, typeName=LeetCode, blogRemark=剑指offer----之二叉树的镜像----LeetCode226, blogComment=0, blogSource=null, createdTime=2020-04-22 23:39:43, blogMonth=null, updateTime=2020-04-22 23:39:43), BlogVo(blogId=1253250557729087488, blogTitle=剑指offer-----之顺时针打印矩阵----LeetCode54, blogImage=http://121.199.34.159/group1/M00/00/01/rBD3pF6hXB2ASIQwAAAaZr2Bc1U016.jpg, blogContent=<h2><strong>一，顺时针打印矩阵</strong></h2>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<p>示例 1：</p>
<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br />输出：[1,2,3,6,9,8,7,4,5]<br />示例 2：</p>
<p>输入：matrix =&nbsp;[[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br />输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p>
<p>限制：</p>
<p>0 &lt;= matrix.length &lt;= 100<br />0 &lt;= matrix[i].length&nbsp;&lt;= 100</p>
<h2><strong>二，题解</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;模拟顺时针打印的这种循环结构：设置四个边界条件，l,r,t,b。按照从左往右，从上往下，从右往左，从下网往上的顺序依次读取矩阵的元素，并且每一次都判断边界是否相遇，直到将整个矩阵元素都加入到数组中即可。</strong></p>
<pre class="language-java"><code>    /**
     * 设置四个边界值，分别为left=0,right=matrix[0].length-1,top=0,bottom=matrix.length-1
     * 顺时针顺序即先从左到右，再从上到下，再从右向左，再从下向上，每一次执行都要判断边界值
     * @param matrix
     * @return
     */
    public static int[] spiralOrder(int[][] matrix) {
        if(matrix.length==0){
            return new int[0];
        }
        int l = 0;
        int r=matrix[0].length-1;
        int t=0;
        int b=matrix.length-1;
        int x=0;
        int[] res = new int[(r+1)*(b+1)];
        while(true){
            //从左向右
            for(int i=l;i&lt;=r;i++){
                res[x++]=matrix[t][i];
            }
            if(++t&gt;b) {
                break;
            }
            //从上向下
            for(int i=t;i&lt;=b;i++){
                res[x++] = matrix[i][r];
            }
            if(--r&lt;l){
                break;
            }
            //从右向左
            for(int i=r;i&gt;=l;i--){
                res[x++] = matrix[b][i];
            }
            if(--b&lt;t){
                break;
            }
            //从下往上
            for(int i=b;i&gt;=t;i--){
                res[x++] = matrix[i][l];
            }
            if(++l&gt;r){
                break;
            }
        }
        return res;
    }</code></pre>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>
<p>&nbsp;</p>, blogGoods=0, blogRead=0, blogCollection=0, typeName=LeetCode, blogRemark=剑指offer-----之顺时针打印矩阵----LeetCode54, blogComment=0, blogSource=null, createdTime=2020-04-23 17:13:11, blogMonth=null, updateTime=2020-04-23 17:13:11), BlogVo(blogId=1253346228108894208, blogTitle=剑指offer----之从上到下打印二叉树, blogImage=http://121.199.34.159/group1/M00/00/01/rBD3pF6htTeAUHGlAAAaZr2Bc1U102.jpg, blogContent=<h2><strong>一，从上打印二叉树-1</strong></h2>
<p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>
<p>例如:<br />给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>
<p>3<br />/ \<br />9 20<br />/ \<br />15 7<br />返回：</p>
<p>[3,9,20,15,7]</p>
<h2><strong>二，题解</strong></h2>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;BFS（广度优先搜索）：也即是二叉树的层次遍历，代码和注意事项看代码注释</strong></p>
<pre class="language-java"><code>    /**
     * 二叉树的层次遍历
     * 这里是将层次遍历的结果存储在数组中
     * 但是因为二叉树的节点个数并不知道
     * 所以不能使用数组直接进行存储，因为无法初始化数组的大小
     * 所以可以想到使用容量能自动扩充的list集合
     * 然后再根据list集合的size来初始化数组的大小
     * 并且将list元素赋值到数组中
     * @param root
     * @return
     */
    public static int[] levelOrder(TreeNode root) {
        if(root==null){
            return new int[0];
        }
        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.add(root);
        TreeNode current;
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        while(!queue.isEmpty()){
            current = queue.poll();
            list.add(current.val);
            if(current.left!=null){
                queue.add(current.left);
            }
            if(current.right!=null){
                queue.add(current.right);
            }
        }
        int[] result = new int[list.size()];
        for (int i = 0; i &lt; list.size(); i++) {
            result[i] = list.get(i);
        }
        return result;
    }</code></pre>, blogGoods=0, blogRead=0, blogCollection=0, typeName=LeetCode, blogRemark=剑指offer----之从上到下打印二叉树, blogComment=0, blogSource=null, createdTime=2020-04-23 23:33:20, blogMonth=null, updateTime=2020-04-23 23:33:20), BlogVo(blogId=1253674617332162560, blogTitle=剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169, blogImage=http://121.199.34.159/group1/M00/00/01/rBD3pF6i5v-AUh39AAAaZr2Bc1U885.jpg, blogContent=<h2><strong>一，数组中出现次数超过一半的元素---即众数</strong></h2>
<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p>示例&nbsp;1:</p>
<p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br />输出: 2</p>
<h2>二，题解</h2>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>方法有三：哈希表统计法，数组排序法，摩尔投票法</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;哈希统计法：时间复杂度O（N），空间复杂度O（N）</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 博主刚开始看到这道题的时候，首先想到的是哈希表统计法，因为博主想的是要找到众数，那么肯定得统计每个数字的出现次数，然后按照次数比较。</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 单单是想到这些，用了map集合之后发现还是不行，因为即便用map集合统计出了每个数字和其对应的出现次数之后，你会发现没有办法按照出现的次数进行比较并且得到次数最多的数字（众数</strong><strong>）</strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 然后，就又审了一遍题目，结果发现了一个本题很关键的点，（<span style="background-color: #ffcc00;">数组中有一个数字出现的次数超过数组长度的一半</span>），也就是说数组中有且仅有一个数字的出现次数会超过数组长度的一半（别笑博主笨，我是真的刚开始没反应过来）</strong></p>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 那么我为什么要把数组中的所有元素和其次数全部存放进入map集合，然后再取次数进行比较呢？我为什么不在将元素和其次数存入集合的过程中判断次数是否已经超过数组长度的一半了呢？如果超过一半了，那它肯定是众数了呀！</strong></p>
<pre class="language-java"><code>    /**
     * 思路：根据题意需要找出两个东西，一是多素元素，二是多素元素的出现次数
     * 所以我们首先想到的是采用map集合
     * 然后遍历数组，如果元素不存在与集合中，我们就将其加入map，value置为1
     * 如果元素存在于map中，则我们取出其value将其加1与数组长度的一半做比较
     * 如果大于数组长度一半，直接返回该元素即可
     * 小于数组长度一半，则将其value加1存入map覆盖原有的值即可
     *
     * @param nums
     * @return
     */
    public static int majorityElement(int[] nums) {
        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(nums.length);
        for (int num : nums) {
            if(!map.containsKey(num)){
                map.put(num,1);
            }else{
                Integer val = map.get(num);
                if(++val&gt;nums.length/2){
                    return num;
                }else{
                    map.put(num,val);
                }
            }
        }
        throw new RuntimeException("");
    }</code></pre>
<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>数组排序法：由题可知，数组众必然存在一个多数元素，且出现次数超过数组长度的一半。所以我们可以对原数组进行排序，然后取数组中间的元素即可。（我擦，我当时看到这个，就在想，好简单，这个思路，但是我为什么没想到，对，因为我没有仔细的分析题目，超过一半看见没）。既然进行排序，那么我们可以选择快排，这样时间复杂度就是O（NlogN），空间复杂度O（1）.</strong></p>
<pre class="language-java"><code>    /**
     * 数组排序法，因为多数元素的出现次数超过数组长度一半，
     * 所以我们可以先对其进行排序，采用快排，时间复杂度O（NlogN）
     * 然后取数组中点元素即可
     * @param nums
     * @return
     */
    public static int majorityElement2(int[] nums){
        quickSort(nums,0,nums.length-1);
        return nums[nums.length/2];
    }

    /**
     * 快排
     * @param nums
     * @param low
     * @param high
     */
    public static void quickSort(int[] nums,int low,int high){
        int base = nums[low];
        int L = low;
        int R = high;
        while(L&lt;R){
            //从右向左找到第一个比基准元素小的元素
            while(L&lt;R&amp;&amp;nums[R]&gt;=base){
                R--;
            }
            if(nums[R]&lt;base){
                swap(nums,L,R);
            }
            //从左向右找到第一个比基准元素大的元素
            while(L&lt;R&amp;&amp;nums[L]&lt;=base){
                L++;
            }
            if(nums[L]&gt;base){
                swap(nums,L,R);
            }
        }
        //左递归
        if(L&gt;low){
            quickSort(nums,low,L-1);
        }
        //右递归
        if(high&gt;R){
            quickSort(nums,R+1,high);
        }
    }

    public static void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }</code></pre>
<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>摩尔投票法（我将其称为大佬解法）：大概的意思就是采用正负抵消的方法，设置一个投票变量votes，初始设置为0；设置一个本题中的众数变量x，初始设置为数组首元素。然后遍历数组，判断跟设置的众数变量是否相等，如果相等将votes加一，如果不相等，则重置votes为0，且将x设置为数组下一个元素。本题众因为已经声明了肯定存在众数，所以不需要进行验证，但是如果没有声明的话，需要验证，下列代码众添加了验证：</strong></p>
<pre class="language-java"><code>    /**
     * 摩尔投票法
     * @param nums
     */
    public static int majorityElement3(int[] nums){
        int votes = 0;
        int x = nums[0];
        int count = 0;
        for (int num : nums) {
            if(votes==0){
                x = num;
            }
            votes+=(num==x)?1:-1;
        }
        //验证数组众是否存在众数
        for (int num : nums) {
            if(num==x){
                count++;
            }
        }
        return count&gt;nums.length/2?x:0;
    }</code></pre>, blogGoods=0, blogRead=0, blogCollection=0, typeName=LeetCode, blogRemark=剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169, blogComment=0, blogSource=null, createdTime=2020-04-24 21:18:14, blogMonth=null, updateTime=2020-04-24 21:18:14)], params={}, sortColumn=blog_read, sortMethod=DESC)]
2020-04-26 23:27:39.354 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 453
2020-04-26 23:27:39.356 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，集合</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，List：</strong>list是java中一种有序的集合，下有三个实现类，分别为ArrayList，Vector，LinkedList</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ArrayList：基于数组实现，增删慢，查询快，线程不安全。因为其基于数组实现，所以查询的时候可以直接根据数组的索引下标进行快速查询，但是进行增删操作的时候，需要将待增删元素后的元素全部移动，因而效率较低。且ArrayList创建时不需要分配初始大小，其空间不够的时候，会自动创建一个更大的list，然后复制数据。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Vector：基于数组实现，和ArrayList一样增删慢，查询快。但是线程安全，因为同一时间只支持一个线程对Vector进行写操作，然而因为要进行频繁的加锁和释放锁的操作，所以效率要低于ArrayList。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; LinkedList：基于双向链表实现，增删快，查询慢。因为基于链表实现，增删元素的时候，只需要改变元素的指针即可，改动较小，效率较高。然而进行查询操作的时候，需要从链表头部进行遍历，因而效率较低。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，Queue：</strong>队列，满足先进先出，种类较多。（不作详细解释）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，set：</strong>具有独一无二的特性，常用来存储无序且不重复的元素，对象相等的本质是hashcode的值相同，而如果想要比较两个对象是否相等，需要重写对象的hashcode方法和equals方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;hashset：基于hashTable实现，无序。存放的是对象的散列值，即通过hashcode计算得到的值</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;treeset：基于二叉树实现，即其中的对象按照一定的排序方式进行排列（升序，降序），每次添加对象的时候，都会进行排序，将其插入指定位置。基本的数据类型例如Integer，String等可以使用treeset默认的排序方法，而自定义数据类型需要实现compareable接口，实现compareTo方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;LinkHashSet：继承自hashset，只不过使用双向链表记录数据的顺序。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，map：</strong>一种键值对形式的集合</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;hashmap：基于数组+链表实现，增删改查操作快，但是每次遍历hashmap元素的顺序无法保证且线程不安全。如果想要其线程安全，可以使用synchronizedMap和ConcurrentHashmap，hashmap的内部是数组，数组中的每一个元素又是一个单向链表，链表中的每个元素嵌套一个Entry实例，其中包括Key，Value，Hash值，指向下一个节点的next。每次查询的时候，可以根据元素的hash值很快定位所在数组，但是定位之后需要遍历链表查找元素，因而时间复杂度为O（n），但是Java8之后对其进行了优化，将其改为了数组+链表或红黑树的结构，即当链表中的元素大于8个的时候，链表会转换为红黑树（红黑树是一种特化的二叉平衡树，因为其左右子树的深度差可以大于1），这样查询的时间复杂度就缩短到了O（logN）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ConcurrentHashmap：采用分段锁的思想进行并发操作，因而使线程安全的。由多个Segment组成，只要保证每个Segment线程安全就可以保证全局线程安全。ConcurrentHashmap的默认Segment即并发度为16，可以在初始化的时候修改，但是初始化之后不能再修改。每个Segment内部的实现和hashmap一样&middot;。Java8之后也和hashmap进行了一样的优化。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;HashTable：线程安全，即同一时刻只能有一个线程对其进行操作，并发度不如ConcurrentHashmap。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;TreeMap：基于二叉树数据结构实现，实现了SortedMap，默认按照键值的升序进行排列。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;LinkedHashMap：Hashmap的子类，只不过使用链表保存元素的插入顺序。使用迭代器遍历的时候按照插入顺序遍历。</p>\n<h2><strong>二，异常分类及处理</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;1，异常分类：</strong>Throwable是所有异常类的父类，其下有error和Exception，Error下有AwtError，ThreadDeath；Exception下有RuntimeException和CheckedException。</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</strong>对于Error类异常通常是由内部错误和资源耗尽造成的，无法在程序运行期间对其进行捕获和处理，对于这类错误我们只能记录错误的原因和终止程序。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; Exception中的RuntimeException异常（运行时异常）：这类异常是我们程序中异常处理的核心，可以在程序中进行捕获并处理。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Exception中的CheckedException异常（检查异常）：这类异常时程序中需要强制捕获的异常，通常有IO异常，SQL异常等等。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，异常处理：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>异常处理有两种方式：抛出异常和捕获异常</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;抛出异常有三种方法：throws，throw，系统自动抛出。其中throws是作用在方法上，后面跟的是可能产生的异常类。throw是作用在方法内部，后面跟的是具体的异常对象。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 捕获异常：即使用try{}catch语句进行捕获</p>\n<h2><strong>三，反射机制</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，什么叫做反射机制？</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>即在程序运行的过程中，可以获取类的属性和方法，并且可以调用任意一个类的方法。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，反射机制的使用</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 首先，获取类的class对象，有三种方式，className.getClass()，类对象.class，Class.forName(\"类路径\")，其中最后一种最为安全，性能最好。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 然后利用反射的API可以实现对类中信息的操作，例如getDeclareFields（），getDeclareMethods（），getConstroctors（）等等。反射创建类的对像有两种方法，一，class.newInstance()初始化一个类实例；二，先获取其构造器，然后利用构造器初始化一个实例。利用反射调用类的方法：先获取方法，然后调用method.invoke()执行方法。</p>\n<h2><strong>四，注解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>1，四种元注解：</strong>@Target（指定注解的使用范围），@Retention（定义注解的保留级别，有三级，SOURCE源程序中保存，CLASS文件中保存，RUNTIME运行时保存），@Documented（可以工具文档化），@Inherited（<span style=\"background-color: #ffff00;\">这个没怎么看懂</span>）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>2，注解使用示例：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>第一步，定义注解接口</p>\n<pre class=\"language-java\"><code>@Target(ElementType.FIELD)  \n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface FruitProvider {\n\n    //id\n    public int id() default  -1;\n\n    //供应商名称\n    public String name() default \"\";\n\n    //供应商地址\n    public String address() default \"\";\n\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 第二步，使用注解</p>\n<pre class=\"language-java\"><code>public class Apple {\n\n    @FruitProvider(id = 1,name = \"红富士苹果\",address = \"陕西\")\n    private String appleProvider;\n\n    public String getAppleProvider() {\n        return appleProvider;\n    }\n\n    public void setAppleProvider(String appleProvider) {\n        this.appleProvider = appleProvider;\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第三步，定义注解处理器</p>\n<pre class=\"language-java\"><code>public class FruitInfoUtil {\n    public static void getFruitInfo(Class&lt;?&gt; clazz) {\n        String strFruitProvider = \"供应商信息:\";\n        Field[] declaredFields = clazz.getDeclaredFields();\n        for (int i = 0; i &lt; declaredFields.length; i++) {\n            if (declaredFields[i].isAnnotationPresent(FruitProvider.class)) {\n                FruitProvider annotation = declaredFields[i].getAnnotation(FruitProvider.class);\n                strFruitProvider += annotation.id() + \",\" + annotation.name() + \",\" + annotation.address();\n                System.out.println(strFruitProvider);\n            }\n        }\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;第四步，主方法入口</p>\n<pre class=\"language-java\"><code>public class FruitRun {\n    public static void main(String[] args) {\n        FruitInfoUtil.getFruitInfo(Apple.class);\n    }\n}</code></pre>\n<h2><strong>五，内部类</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 1，静态内部类：</strong>即在类的内部定义的静态类，静态内部类可以访问外部了的静态变量和方法，外部也可以通过outClassName.innerClassName调用内部类</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2，成员内部类：</strong>在类的内部定义的没有用static修饰的内部类，使用方式和静态内部类一样。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>3，局部内部类：</strong>即一个类只在一个方法中使用，则完全可以将这个类定义为这个方法的内部类，即局部内部类，局部内部类可以实现真正的对外隐藏</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>4，匿名内部类：</strong>通常用于继承一个类或者实现一个接口的时候，使用new关键字定义，例如:Person person = new Student(){new Pupil(){}}</p>\n<h2><strong>六，泛型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 1，为什么要使用泛型：</strong>其根本目的是为了实现代码的复用，举个开发中常见的例子，我们需要定义返回类Result，返回类中包含状态码code，信息msg，以及数据data（任意类型），这个时候我们就需要使用泛型，因为我们返回的数据类型有各种vo，pojo类对象，list等。这时候泛型类result就可以被各种对象使用，实现代码的复用，简化开发。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>2，泛型标记和泛型限定：</strong>E表示集合中的元素，K表示键值，V表示value，N表示数值类型，T表示任意类型（包含基础类型，所有的对象类型），？（不确定的java类型）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>泛型限定：</strong>向上限定，&lt;?&nbsp; extends T&gt;，向下限定，&lt;? super&nbsp; T&gt;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; <strong>3，泛型方法：</strong>即参数类型定义为泛型类型，以便于接收不同类型的参数，做出不同的处理。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>4，泛型类：</strong>例如public class Pair&lt;T&gt;{private T data;}</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>5，泛型接口：</strong>与放泛型类类似</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>6，类型擦除：</strong>即在泛型编译的过程中，会将泛型类型替换为限定类型的操作</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>7，明确的一点：</strong>虚拟机在运行程序的过程中，内部是没有泛型的，只有普通的类和方法。</p>\n<h2><strong>7，序列化</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 序列化是为了确保对象及其状态的持久化</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>序列化的使用：</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </strong>首先，实现序列化接口java.io.Serializble</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 然后，声明序列化ID，通常private static final&nbsp; long&nbsp; serialVersionUid&nbsp; = ***</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 因为序列化是保证对象及其状态的持久化，而静态变量是不属于对象，属于类本身的，所以序列化无法保存静态变量。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果需要序列化父类变量，则父类也要实现Serializable接口</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t'ransient修饰的属性不会序列化</p>\n<h3><strong>最后，提供一张思维导图供大家学习：<a href=\"https://images-cdn.shimo.im/es83SQH0CggucT7f__thumbnail\" target=\"_blank\" rel=\"noopener\">JAVA基础</a></strong></h3>\n<p>&nbsp;</p>\n<h2>水平有限，如有错误，还望指出！</h2>","blogGoods":0,"blogId":"1248605157059497984","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHMKAcvZ8AABJTVJPTfk020.jpg","blogRead":27,"blogRemark":"面试（二）------之JAVA基础篇","blogTitle":"面试（二）------之JAVA基础篇","createdTime":"2020-04-10 13:34:02","typeName":"java面试篇","updateTime":"2020-04-20 11:53:39"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，数据库设计--表的命名规范等</strong></p>\n<p>（1），统一采用bl_开头对表进行命名</p>\n<p>（2），对于数据比较重要的表统一添加四个字段，分别为：created_time(创建时间),update_time(修改时间),version(版本号),deleted(删除字段)</p>\n<p>（3），数据库表的字段尽量都设置为NOT_NULL</p>\n<p>（4），数据库中表varchar类型字段需要设置长度的尽量设置为2<sup>n</sup>-1</p>\n<p>（5），因为博客系统分为前台展示界面和后台管理，所以对于有些表，例如bl_type（博客类型表），bl_music（音乐表）等设置了enable（启用字段）</p>\n<p><strong>二，上述第二条--四个字段的解释</strong></p>\n<p>（1），为什么要设置created_time和update_time字段：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;其一，从数据库的通用性上来说，设计这两个字段是必要的，但也需要根据业务的需要来合理添加这两个字段，因为无用的字段会浪费空间，性能，影响系统的运行。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 其二，大部分的应用都有需要根据时间进行排序的功能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 其三，当系统发生异常的时候，我们可以通过这两个字段对异常进行排查和定位。</p>\n<p>（2），为什么要设置version字段：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 1，version字段含义：字段的含义与其字面意思一样，代表版本，在这里作为乐观锁进行使用，从而保证不会出现脏数据的情况。下面解释一下什么叫乐观锁，以及乐观锁和悲观锁</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 2，乐观锁：总是假定最好的情况，即每次用户调用接口从数据库中取出数据到修改数据前的过程中，不会有其它用户对当前数据进行修改，这样在当前用户修改数据的时候，利用版本机制即判断取出的version字段和当前数据库该条数据的version字段是否相等来判断该条数据是否已经被修改，如果未修改，则予以修改（且version字段递增），如果已经修改，则提示用户更新失败。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 悲观锁：总是假定最坏的情况，即每次用户调用接口从数据库取出数据的时候，都认为该条数据会被修改，因此每次取出数据都对数据进行加锁处理，只允许当前用户进行修改，其它用户阻塞，直到当前用户修改完毕。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3，为什么使用乐观锁而不使用悲观锁：因为悲观锁比较浪费性能</p>\n<p>（3），为什么设置deleted字段：deleted字段在这里作为一个逻辑删除字段（0否1是），何为逻辑删除，即执行删除操作操作的时候，不会真正的删除数据库中的数据，而是将deleted字段设置为1即可。&nbsp;这样如果用户出现误删的操作，可以通过数据库修改该字段进行数据的恢复。</p>\n<p><strong>三，上述第三条--数据库表字段尽量设置为NOT_NULL</strong></p>\n<p>（1），数据库表字段尽量设置为NOT_NULL：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 1，有些人可能认为设置为NULL相比于NOT_NULL不是更节省空间吗？但是实际上不是这样的，设计为NULL相比于NOT_NULL要多占用一个字节的空间</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 2，设计为NOT_NULL，这样在做查询的时候能够更好的避免空指针异常，且发生该类错误的时候能够更好的进行排查</p>\n<p><strong>四，上述第四条--表varchar类型字段长度尽量设置为2<sup>n</sup>-1</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</strong>因为计算机只识别二进制，且有一定的范围，例如2<sup>8</sup>，在计算机中的范围为-128~127,因此对于varchar字段长度来说，如果设置为255，则正好是一个字节，而如果设置为256，则占用两个字节，这样会浪费计算机的内存空间，因此数据库varchar类型字段的长度最好设置为2<sup>n</sup>-1</p>\n<p><strong>五，上述第五条--对于设置enable字段的解释</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>enable字段，字面意思启用，在这里表明是否启用（0否1是），因为系统分为前台博客页面和后台管理，对于这两个不同的前端项目，后台可以通过启用字段来控制内容在前台博客页面的展示与否，与deleted字段不同的是，如果执行删除操作，那么我们只能通过手动修改数据库中的字段进行数据的恢复，且如果执行删除操作，则该数据在前台博客页面和后台管理页面都无法看见。但是如果将数据弃用（即修改enable字段值为1），则表明该数据被弃用，在前台博客页面无法显示，但是在后台管理页面可以看见，且无需通过手动修改数据库来恢复数据，可以在后台管理页面操作启用数据。</p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1247745014683947008","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dDViAcnjvAACb6PL1tzA485.jpg","blogRead":21,"blogRemark":"博客开发总结（一）-----之数据库设计篇","blogTitle":"博客开发总结（一）-----之数据库设计篇","createdTime":"2020-04-08 04:36:07","typeName":"博客开发和维护总结","updateTime":"2020-04-20 10:47:54"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2 style=\"text-align: left;\"><strong>一，JVM运行机制</strong></h2>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;jvm即java虚拟机，一共由四个部分组成，分别是类加载器子系统，运行时数据区（程序计数器，本地方法区，jvm栈，方法区，jvm堆），执行引擎（即时编译器，垃圾收集器），本地接口库。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;一个java源程序的运行先是经过编译器将其编译成字节码文件（class文件），然后通过类加载器子系统将其加载进入jvm&mdash;&mdash;&gt;程序运行过程中，运行时数据区存放程序运行过程产生的数据&mdash;&mdash;&gt;执行引擎中的垃圾收集器收集程序运行过程中创建的不再使用的对象，即时编译器将程序的字节码文件编译成机器码&mdash;&mdash;&gt;然后本地接口库利用机器码调用本地方法库中的方法，和操作系统实现交互。</p>\n<h2><strong>二，多线程</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;</strong>在多核操作系统中，jvm支持一个进程中同时并发执行多个线程，且这些线程和本地操作系统的线程相对应。当jvm中的对象初始化，内存空间分配等一系列准备工作完成之后，会调用操作系统中的接口创建一个原生线程，原生线程初始化完毕后，会调用java线程的run（）方法执行该线程，线程结束之后，jvm会释放原生线程和java线程资源。</p>\n<h2><strong>三，JVM的内存区域</strong></h2>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM的内存区域主要分为线程私有区域（程序计数器，本地方法区，JVM栈），线程共享区（方法区，JVM堆）和直接内存。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;程序计数器：线程私有区域，无内存溢出，用来记录程序运行过程中的字节码指令地址，如果是Native方法，则程序计数器为空。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM栈：线程私有区域，用来描述java程序的运行过程，java程序运行每次运行的时候，都会创建一个栈帧，方法的执行和返回对应着栈帧的入栈和出栈操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;本地方法区：线程私有区域，和JVM栈的功能一样，只不过是用来记录Native方法的运行过程。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;JVM堆：线程共享区，主要用来存放程序运行过程中产生的数据，同时也是垃圾收集器进行垃圾回收的主要区域。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;方法区：也被称为永久代，用来存放常量，静态变量，类信息等等。</p>\n<h2><strong>四，JVM的运行时内存</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>JVM的运行时内存又被称为JVM堆，因为JVM的GC算法使用的是分代收集算法，所以JVM堆按照GC标准可以分为三个区域分别为：新生代，老年代，永久代。其中新生代占1/3，老年代占2/3，永久代很少，</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;新生代：存放短生命周期，小对象的区域。新生代又分为Eden区，ServivorTo区，ServivorFrom区，区域的GC算法采用复制算法。Eden区是用来存放新创建的对象（大对象除外），ServivorTo区是用来保存MinorGC幸存下来的对象，ServivorFrom区是用来将上一次MinorGC幸存下来的对象作为下一次MinorGC的扫描对象。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;老年代：存放长生命周期的大对象，区域的GC算法采用标记整理算法</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;永久代：主要用来存放class和meta数据信息的。程序运行过程中不会进行永久代的垃圾回收，这也就导致永久代区域的数据会越来越多，最终造成内存溢出。java8之后永久代已经被元数据区取代，元数据区和永久代的功能都是一样的，但是最大的不同在于永久代区域依赖于虚拟机的内存大小，因而可以存储的class，meta信息非常有限。但是元数据区依赖的是本地操作系统，因而不会受到虚拟机内存的限制。</p>\n<h2><strong>五，垃圾回收与算法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;(1)垃圾回收：</strong>Jvm的垃圾回收判定依赖于两种方法，引用计数法和可达性分析法。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;引用计数法：即如果想要在程序中使用对象，就必须赋予一个引用，这样在对象赋予引用的时候将其引用计数加1，删除一个引用时，将对象引用计数减1，如果引用计数为0，就说明该对象已经不使用，作为垃圾。但是引用计数法存在一个缺陷，即循环引用的问题，如果两个对象相互引用，则这两个对象的引用计数永远都不会为0，造成对象无法被回收。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;可达性分析法：即先创建一些根节点对象ROOTS，然后通过这些根节点对象向下搜索，如果一个对象到任意一个ROOTS之间都没有可达路径，在经过两次标记（下文解释为什么进行两次标记），还是没有可达路径，则说明该对象可回收。</p>\n<p>&nbsp;&nbsp; &nbsp;<strong>（2）GC算法：</strong>常见的GC算法有四种，分别为标记清除算法，复制算法，标记整理算法，分代收集算法</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;标记清除算法：即在进行垃圾回收前，对所有对象进行一次标记，标记可回收的对象，然后进行清理即可。但是标记清除算法在清除回收对象之后，并不会对堆内存进行整理，这样的话如果内存中的对象大部分为小对象，清理之后就会导致没有大片连续的内存空间，即造成了内存碎片化，这样大对象存储的时候就无法找到相应的完整连续内存。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;复制算法：即将内存分为两块同等大小的区域，区域1和区域2，创建的新对象都存储在区域1中，当区域1中的内存占满之后，会对内存中的所有对象进行一次标记，标记存活的对象，将存活的对象复制到区域2，这时区域1中的对象都是可回收对象，回收区域1中的所有对象即可。但是复制算法也存在着一定的缺陷，即每次都只能使用一半的内存空间，造成了大量的内存浪费。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;标记整理算法：即结合标记清除算法和复制算法的优点，先对所有的对象进行标记，标记存活的对象，将存活的对象复制到内存的另一端，然后清除当前端的对象即可。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;分代收集算法：前面的三种算法，都无法按照对象的类型进行收集，分代收集算法正是解决这个问题，按照对象的不同类型采用不同的GC算法。以JVM的分代收集算法为例，JVM的堆内存分为新生代，老年代，永久代。新生代又分为Eden区，ServivorTo区和ServivorFrom区。新生代因为其存储生命周期短的小对象，GC比较频繁，所以采用复制算法。程序运行过程中创建的对象都存储在Eden区（大对象除外，大对象直接复制到老年代区域）。当Eden区的内存不够的时候进行MinorGC，然后将Eden区和ServivorFrom区的存活对象都复制到ServivorTo区，然后将ServivorTo区和ServivorFrom区进行交换，再次进行MinorGC。老年代因为存放的都是生命周期长的大对象，因而进行GC的不会太频繁，且清除的对象并不会太多，因而采用标记整理算法。老年代每次进行MajorGC之前都会先进行一次MinorGC，当MinorGC之后新生代的内存仍然不够的时候，将对象复制到老年代进行MajorGC。永久代区域主要回收常量，无用class等。</p>\n<h2><strong>六，JAVA中的四种引用类型</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;强引用类型<strong>：</strong>即把对象赋给一个引用变量，强引用的对象一定为可达状态，所以不会进行垃圾回收。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;软引用类型：通过SoftReference类实现，当内存不够的时候对其进行GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;弱引用类型：只有弱引用类型的对象，一定会被GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;虚引用类型：虚引用对象主要是用来跟踪对象的GC状态</p>\n<h2><strong>七，分代收集算法和分区收集算法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>分代收集算法：新生代因其存放大量短生命周期小对象，且GC频繁，所以采用复制算法。老年代因其存放长生命周期大对象，且GC不平凡，所以采用标记整理算法。永久代，回收常量，类信息等。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;分区收集算法：即将堆内存区域分为大小不同的区，可以按照不同的区进行快速垃圾回收，减少系统的停顿时间。然后再以并行的方式逐步完成整个GC。</p>\n<h2><strong>八，垃圾收集器</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>新生代区域：Serial垃圾收集器，单线程复制算法，因为单线程无需进行线程之间的交互和切换，所以效率非常高，是JVM默认的client模式下的默认垃圾回收策略，工作期间需要暂停其它所有的线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ParNew垃圾收集器，多线程复制算法，跟单线程Serial一样，是JVM默认的server模式下的垃圾回收策略，工作期间需要暂停所有其它线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Parallel Scavenge垃圾收集器：多线程复制算法，不同的是优先考虑系统吞吐量，可以利用更高效的利用CPU完成GC</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;老年代区域：Serial Old垃圾收集器，单线程标记整理算法，同新生代的Serial功能一样，只是采取的算法不同而已。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Parallel Old垃圾收集器：多线程标记整理算法，优先考虑了系统的吞吐量，其次考虑停顿时间。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CMS,多线程标记清除算法，优先考虑系统GC时的停顿时间，且过程分为四步（<span style=\"background-color: #ffff00;\">解释上文的可达性分析中的两次标记</span>，第一步：标记GC ROOTS可达对象，暂停其它工作线程；第二步：和用户线程一起工作，跟踪GC ROOTS；第三步，因为第二步用户进程没有暂停，所以有些对象状态</p>\n<p>可能发生了改变，重新进行标记；第四步，清除不可达对象）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; G1垃圾收集器，多线程标记整理算法，将内存分区，与CMS相比，一方面不会产生内存碎片，一方面，可以精确的控制系统停顿时间。</p>\n<h2><strong>九，JAVA的网络编程模型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;</strong>阻塞I/O模型：即用户线程发出I/O请求之后，内核会检查数据是否准备就绪，这时候用户线程始终处于阻塞状态等待数据准备就绪。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;非阻塞I/O模型：即用户线程不断的给内核发出I/O请求，内核接受到I/O请求之后会返回一个状态，如果数据准备就绪，就将数据复制进入用户线程，如果数据没有准备好，返回一个false，用户线程无需阻塞，可以去处理其它事情，而当数据准备好了且刚好用户线程发起I/O请求进行操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;多路复用I/O模型：多路复用I/O模型通过一个Selector线程轮询Socket的状态，如果Socket有读写事件，则进行I/O操作。此模型的优势在于可以更好的处理连接数众多但消息体不大的情况下。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;信号驱动I/O模型：即用户线程发出一个I/O请求，系统会为该请求创建一个信号函数，用户请求可继续执行其它业务逻辑，当内核数据准备就绪之后会返回给用户线程一个信号，用户线程接收到之后进行I/O操作。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;异步I/O模型：用户线程给内核发起一个asynchronous read操作，内核接收到之后，返回其请求是否成功，然后等待数据准备成功之后复制到用户线程。整个过程中请求的发起和数据读取都在内核中进行，最终发送一个信号告知用户线程I/O操作已经完成，用户直接使用数据就行。（说实话个人感</p>\n<p>觉和信号驱动很像）</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;java NIO：没怎么读懂（<span style=\"background-color: #993300;\">记得补充！</span>）</p>\n<h2><strong>十，JVM的类加载机制</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>JVM类加载分为五个阶段：加载，验证，准备，解析，初始化</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;加载：即将class文件加载到JVM中，且创建class对象，封装其数据结构。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;验证：对class文件进行验证，确保符合JVM的标准，保证JVM的安全。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;准备：即方法区中给类变量分配空间和赋初值。static修改的会在初始化阶段赋值，final修饰的会在准备阶段赋值。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;解析：即将常量池中的引用替换为直接引用</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;初始化：执行类构造器进行初始化。（因为内部流程不是很清楚，所以对于其几种不进行初始化的情况不做说明）</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;类加载器：JVM提供了三种类加载器，启动类加载器（/lib），扩展类加载器(/lib/ext)，应用程序类加载器(classpath)。还可以再应用程序类加载器自定义类加载器。</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;双亲委派机制：即当一个类接收到类加载请求的时候，不会自己进行加载，而是将其加载请求委派给其父类加载器，这样一路委派，最终加载请求都会委派到启动类加载器.启动类加载器接收到加载请求之后会去lib目录下寻找相关的class文件，若找不到，则将其加载请求再委培给子类加载器，一路委派，直到能够加载。</p>\n<h3><strong>最后，送给大家一张博主画的JVM的思维导图，以后读《深入JVM虚拟机》的时候可能会出一个JVM专题：<a href=\"https://uploader.shimo.im/f/X0MX3hLaHrevltxW.png!thumbnail\" target=\"_blank\" rel=\"noopener\">JVM思维导图</a></strong></h3>\n<p>&nbsp;</p>\n<h2>水平有限，若发现有误，还望指出！</h2>","blogGoods":0,"blogId":"1248224512563068928","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHLeALxSjAABJTVJPTfk677.jpg","blogRead":17,"blogRemark":"面试（一）------之JVM篇","blogTitle":"面试（一）------之JVM篇","createdTime":"2020-04-09 12:21:30","typeName":"java面试篇","updateTime":"2020-04-20 11:53:29"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，线程上下文切换</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong>cpu利用时间片轮询的方式来为每个任务都分配一定的时间片，任务的执行过程中保存任务的状态。任务状态的保存和在加载就叫做上下文切换。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>进程：</strong>指的是一个运行中的程序实例，一个进程中可以有多个线程，并且与进程共享同样的内存和系统资源</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong> 上下文：</strong>指的是寄存器和程序计数器保存的线程的信息</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>寄存器：</strong>指的是内存中很小但是运行速度很快的一块区域（相对于RAM外部内存）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>程序计数器：</strong>一种寄存器，用来保存当前执行指令的位置或者下一个待执行指令的位置</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>上下文切换：</strong>上下文切换指的是操作系统的内核在cpu上对进程或者线程的切换。上下文信息保存在进程控制块中（PCB）。流程如下：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;挂起当前进程，将进程的上下文信息保存在进程控制块中；</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;在进程控制块中寻找下一个任务的上下文信息。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;恢复进程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>上下文切换的原因：</strong>第一，任务正常执行完毕，调度下一个任务；第二，线程出现I/O阻塞，被挂起，cpu调度下一个任务；第三，线程等待同步锁，获取socket通知等，被挂起，cpu调度下一个任务；第四，用户调用sleep方法，让出cpu；第五，硬件中断</p>\n<h2><strong>二，JAVA阻塞队列</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>阻塞队列的是调度当前队列的线程处于阻塞状态</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 消费者阻塞：如果队列为空，则消费者线程被挂起，处于阻塞状态，当有新数据进入队列，则消费者线程被唤醒，消费数据</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 生产者阻塞：如果队列数据已满，则生产者线程挂起，处于阻塞状态，当队列有空闲位置，生产者线程被唤醒，生产数据。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞队列的主要操作：</strong>插入操作和移除（获取）操作</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>插入操作：</strong>add(e)，有空间则插入，无空间报异常；offer(e),有空间则插入，无空间返回false；offer(e,time,unit),有空间插入，无空间等待time时间，若超时返回false；put(e),有空间插入，无空间则线程挂起处于阻塞直到有空间</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>移除操作：</strong>poll(e),有值返回值，无值返回null;poll(e,time,unit),有值返回值，无值等待time时间，超时返回null;take(e),有值返回值，无值等待新数据进入再立即返回；drainTo(collection&lt;Object&gt;)批量移除，提高获取效率</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞队列的实现：</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong> ArrayBlockingQueue：</strong>基于数组的有界阻塞队列，按照先进先出顺序对元素进行排序</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>LinkedBlockingQueue：</strong>基于链表的有界阻塞队列，队头队尾采用不两个不同的锁控制数据同步，并发性高</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>PriorityBlockingQueue：</strong>基于优先级的无界队列，默认升序排列，可以自定义排序规则，根据优先级访问数据。但是有数据优先级一样的情况</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>DelayQueue：</strong>支持延时的队列，即从队列中取数据时等待一定的时间才能获取元素。可以用于缓存系统的设计，设计过期时间，也可以用来设置定时调度任务，即如果能够从队列中获取，说明到了任务的调度时间。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>SynchronousQueue</strong>：该队列是一个不存储元素的阻塞队列，每一个put操作都必须等待一个take操作的完成。吞吐量高于ArrayBlockingQueue和LinkedBlockingQueue。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>LinkedTransferQueue：</strong>基于链表的无界阻塞队列，多了transfer方法(如果消费者等待，直接将任务从生产者传递给消费者，无消费者等待，则将任务加到队尾直到被消费才返回)和tryTransfer（与transfer一致，只不过不管有没有消费者等待获取都会立即返回tryTransfer（e,time,unit）（与tryTransfer一致，只不过设置了超时时间）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>LinkedBlockingDeque：</strong>基于链表的双向阻塞队列，可以在两端同时进行读写操作，提高了队列的操作效率。</p>\n<h2><strong>三，并发关键字</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;CountDownLatch：</strong>适用于一个主线程等待子线程完成任务之后执行（原理：设置一个程序计数器，计数器的值为子线程的个数，子线程并发执行，每个子线程执行完毕后，调用CountDown方法，将其计数器的值减去1，值为0时，唤醒主线程执行）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>CyclicBarrier：</strong>即当所有线程到达一个状态共同执行。await（）方法：确保所有线程到达Barrier状态才执行；await（time,unit）：设置一个超时时间，超过这个时间，执行达到Barrier状态的线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>Semaphore：</strong>因为其限制了多线程访问资源的线程个数，所以适用于多线程并发访问有限资源的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>volatile：</strong>直接用来修饰变量，是一种比Synchronized更加轻量级的机制，用于多线程共享同一变量，可以同时对其进行读写操作。当多个线程共享变量的时候，读取变量将其从内存复制到cpu缓存中，然后线程对其操作进行修改，这样再多cpu的情况下，有可能出现线程修改原数据造成数据不一致的情况，使用volatile关键字直接将线程修改的变量存入内存，解决这个问题。</p>\n<h2><strong>四，多线程共享数据</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>多线程共享数据主要通过共享内存实现，而共享内存的可见性，有序性，原子性已经由JVM和锁解决。理想情况下我们需要解决同步和互斥的问题（<span style=\"background-color: #ffff00;\">怎么解决的有待考证！</span>）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>解决方法一：</strong>将数据抽象成一个类，将对数据的操作封装成类中的方法</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解决方法二：</strong>将Runnable对象作为一个内部类，将共享数据作为这个类的成员变量</p>\n<h2><strong>五，ConcurrentHashmap并发</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;ConcurrentHashmap使用了减小锁粒度，这里具体为分段锁的思想优化了锁，因为如果直接对hashmap进行加锁，锁太大，而且同一时刻只能有一个线程操作hashmap，并发性能较差</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;实现原理：</strong>即内部采用分段锁思想，将hashmap分为多个segment，每次读取数据的时候，对数据所在的segment进行加锁，这样只要保证每个segment线程安全，就可以保证整个hashmap线程安全</p>\n<h2><strong>六，JAVA中的线程调度</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;抢占式调度：</strong>即线程对cpu资源进行抢占，这种策略下每个线程抢占到cpu资源的概率是相等的，这样就不会一个线程阻塞造成整个系统阻塞的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>协同式调度：</strong>即一个线程使用完cpu资源之后通知cpu调度下一个任务，适用于多线程交替执行任务。因为如果一个线程阻塞可能会造成整个系统阻塞甚至崩溃</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>JAVA采用的是抢占式调度，但同时又尽可能的保证公平性（即为每个线程分配优先级不同的cpu时间片）</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>&nbsp;线程让出cpu的情况</strong>：第一，线程调用yield方法；第二，I/O阻塞，socket等待等；第三，等待同步锁；第四，正常执行完毕</p>\n<h2>七，进程调度算法</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>优先调度算法：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;先来先服务调度算法：</strong>即遵循先来先被分配cpu资源运行的原则</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>短作业调度算法：</strong>即预估作业的时间长短，优先调度时间短的任务，可能会导致长时间大任务很长时间无法被调度 &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>高优先权调度算法：即每个任务会预先被分配优先级</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;非抢占式优先调度算法：</strong>按照优先级的高低一次分配cpu资源运行</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>抢占式优先调度算法：</strong>按照优先级的高低分配cpu资源运行，但是如果任务再运行过程中有优先级更高的任务加入，则将其cpu资源临时回收分配给紧急任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>高响应比调度算法：</strong>动态调度，即作业时间短，则优先级高；等待时间长，则优先级高。前者遵循短作业调度算法，后者遵循先来先服务原则。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>时间片轮转调度算法：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;时间片轮转法：</strong>按照任务再队列中的顺序进行调度</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>多级反馈队列调度算法：</strong>即再时间片轮转法的基础上维护了就绪队列，默认第一队列优先级高，先调度第一队列的任务，如果再分配的cpu时间片内未完成则将其加入第二队列队尾，以此类推直到其执行完毕。只有第1 -（n-1）队列为空，才会调度第n队列的任务，而且当前任务执行时，如果有优先级高的任务进来，会抢占其cpu资源。</p>\n<h2><strong>八，CAS</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：</strong>即比较和交换，CAS（V,E,N）三个参数，只有当V=E的时候才会将V设置为N。如果V!=E，则说明数据已经被其它线程修改，不做任何操作</p>\n<h2><strong>九，ABA问题</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>概述：</strong>即当1线程从V中取出A时，2线程也从中取出1，修改为B，再修改为A。而1线程仍然修改成功，实际上修改过程中V的实际值已经发生改变，只不过1没有发觉。解决这种问题，常采用乐观锁的版本号机制。</p>\n<h2><strong>另外有AQS问题没怎么读懂，下次完善！</strong></h2>\n<p>&nbsp;</p>\n<h3><strong>思维导图：<a href=\"https://images-cdn.shimo.im/myFodjsaVAA3PVV7__thumbnail\" target=\"_blank\" rel=\"noopener\">并发编程（下）</a></strong></h3>\n<p>&nbsp;</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</p>","blogGoods":0,"blogId":"1249742755949817856","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHNmAPuxmAABJTVJPTfk117.jpg","blogRead":17,"blogRemark":"面试（三）------之并发编程篇（下）","blogTitle":"面试（三）------之并发编程篇（下）","createdTime":"2020-04-13 16:54:26","typeName":"java面试篇","updateTime":"2020-04-20 11:54:02"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，JAVA线程的创建方式</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong>JAVA线程的创建有四种方式，分别为，继承Thread类，实现Runable接口，实现Callable&lt;Class&gt;接口，基于线程池。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>1，继承Thread方式：创建一个类继承Thread类，创建类的实例对象，调用start方法，继而执行线程的run（）方法，代码如下：</strong></p>\n<pre class=\"language-java\"><code>public class NewThread extends Thread{\n    public static void main(String[] args) {\n        NewThread thread = new NewThread();\n        thread.start();\n    }\n    @Override\n    public void run(){\n        System.out.println(\"create  a  new thread by Thread!\");\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>2，当子类已经继承了一个类，这时候就没法再继承Thread类了，这时候就可以实现Runable接口，实例化类的线程实例，创建Thread实例传入类的实例，执行start方法，继而执行run（）方法代码如下：</strong></p>\n<p>&nbsp;</p>\n<pre class=\"language-java\"><code>public class ThreadExample2 implements Runnable {\n    public static void main(String[] args) {\n        ThreadExample2 threadExample2 = new ThreadExample2();\n        Thread thread = new Thread(threadExample2);\n        thread.start();\n    }\n    @Override\n    public void run() {\n        System.out.println(\"create a new thread by Runnable!\");\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>3，有些情况下，我们需要再一个主线程中并发多个子线程执行同一个任务，然后回收子线程的返回值整理汇总，这时候就需要实现Callable&lt;Class&gt;接口，重写其call（）方法，用于计算结果。然床创建一个线程池用于提交线程，继而执行call方法，并且创建一个Future的list用于接收子线程逻辑代码即call方法的返回，最终遍历list，得到想要的返回值，如下：</strong></p>\n<pre class=\"language-java\"><code>public class ThreadExample3 implements Callable&lt;String&gt; {\n\n    private String name;\n\n    public ThreadExample3(String name){\n        this.name = name;\n    }\n\n    @Override\n    public String call() throws Exception {\n        return name;\n    }\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        ExecutorService pool = Executors.newFixedThreadPool(3);\n        List&lt;Future&gt; list = new ArrayList&lt;&gt;();\n        for(int i=0;i&lt;3;i++){\n            ThreadExample3 threadExample3 = new ThreadExample3(i+\"\");\n            Future future =pool.submit(threadExample3);\n            System.out.println(future.get().toString()+\" is running\");\n            list.add(future);\n        }\n        pool.shutdown();\n        for (Future future : list) {\n            System.out.println(\"currentThread's result is \"+future.get().toString());\n        }\n    }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>4，基于线程池创建线程</strong></p>\n<pre class=\"language-java\"><code>public class ThreadExample4 {\n    public static void main(String[] args){\n        ExecutorService pool = Executors.newFixedThreadPool(3);\n        for(int i=0;i&lt;3;i++){\n            pool.execute(new Runnable() {\n                @Override\n                public void run() {\n                    System.out.println(\"thread  is running by FixedThreadPool\");\n                }\n            });\n        }\n        pool.shutdown();\n    }\n}</code></pre>\n<h2>二，线程池的工作原理</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong> &nbsp;1，概述：</strong>JVM根据用户提供的参数创建一定数量的线程任务，将其放入队列中，线程创建之后启动这些任务，如果线程的数量大于核心线程数量（用户设置的线程数量），则超出数量的线程排在队列中等待，当有线程任务执行完毕后，线程池调度器就会发现有可用可用线程，继而从队列中取出任务继续执行<strong>。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; </strong><strong>2，线程复用：</strong>（参见JDK源码解读，这里只做简单描述），由前可知，JVM会根据用户提供的参数创建一定数量的线程任务，且将其添加到任务队列中。JVM通过start（）方法创建一个线程之后， 会相应的为其创建一个任务队列，线程会不停的查看任务队列，如果任务队列中有任务，则调用run方法，执行，这样就达到了一次start（）创建线程，多次使用，完成线程复用的任务。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>3，线程池的核心组件和核心类（见JDK源码分类中关于线程的总结）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; </strong><strong>4，JAVA线程的工作流程：</strong>线程池刚被创建的时候，只是向系统申请一个执行线程队列和管理线程池的线程资源，当调用execute方法之后，执行下列流程：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果正在运行的线程数量小于corePoolSize（核心线程数量，即用户定义的的线程数量），则立即创建线程执行线程任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果正在运行的线程数量大于或等于corePoolSize，则将超过数量的线程加入到阻塞队列中</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在阻塞队列已满且线程数量小于MaximumPoolSize（即线程池能够容纳的最大线程数），线程池会创建非核心线程立即执行任务</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在阻塞队列已满且线程数量大于或等于MaximumPoolSize的时候，线程池会拒绝该线程任务且抛出异常</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在线程任务执行完毕之后，会将其从任务队列中移除，从队列中取出下一个线程任务执行</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 在线程处于空闲状态且空闲时间超过KeepAliveTime，且线程数量大于corePoolSize的时候，会停止该线程，这样在没有任务的时候，线程池中的线程数始终维持在corePoolSize。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，线程池的拒绝策略：</strong>分为四种，分别为AbortPolicy，CallerRunsPolicy，DiscardOldestPolicy，DiscardPolicy</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; AbortPolicy：直接抛出异常，阻止线程运行，源码如下：</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;</p>\n<pre class=\"language-java\"><code>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n            throw new RejectedExecutionException(\"Task \" + r.toString() +\n                                                 \" rejected from \" +\n                                                 e.toString());\n        }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CallerRunsPolicy：如果线程任务没有关闭，则尝试执行该线程任务，源码如下：</p>\n<pre class=\"language-java\"><code>* @param r the runnable task requested to be executed\n* @param e the executor attempting to execute this task\n*/\npublic void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n     if (!e.isShutdown()) {\n         r.run()\n     }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DiscardOldestPolicy：移除任务队列中最早进入的线程任务，执行当前任务线程，源码如下：</p>\n<pre class=\"language-java\"><code>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n       if (!e.isShutdown()) {\n           e.getQueue().poll();\n           e.execute(r);\n       }\n}</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DiscardPolicy：直接丢弃线程任务，不做任何处理</p>\n<h2><strong>三，五种常用的线程池</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;newCachedThreadPool（可缓存线程池）：</strong>当线程池创建线程的时候如果发现有可复用的线程（执行完任务，且未关闭的线程），则直接复用，如果没有则创建新线程。可缓存线程池可以高效的利用执行任务时间短的线程，提高系统的性能，且线程池中的线程如果空闲时间超过60s，则会被终止且从缓存中移除，这样可缓存线程池不会占用系统资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>newFixedThreadPool（固定大小的线程池）：</strong>即线程池中的线程是初始化固定的，当任务线程大于线程池中线程数量时，任务线程就会进入阻塞队列等待。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newScheduledThreadPool（可做任务调度的线程池）：</strong>即可以设置线程执行的停顿时间和执行周期，进行定期定时的执行某个任务。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newSingleThreadPool（单个线程的线程池）:&nbsp;</strong>即线程池中永远只有一个线程进行工作，如果下称停止或者异常，则线程池创建新的线程替代当前线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>newWorkStealingPool（足够大小的线程池）：</strong>即创建足够数量的线程的线程池，保证更快的进行运算，提高效率。</p>\n<h2><strong>四，线程的生命周期</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;线程的生命周期大致分为五个阶段：新建（new），就绪（Runnable），运行（Running），阻塞（Blocked），死亡（Dead）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;新建：</strong>即使用new创建一个线程</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>就绪：</strong>调用start方法，</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>运行：</strong>即线程获取cpu资源，执行run（）方法，进入运行状态，运行状态的线程如果调用yield（线程让步方法）或者失去cpu资源，都会导致线程重新回到就绪态；如果调用sleep方法，I/O阻塞，等待同步锁，等待通知以及suspend挂起都会导致线程进入阻塞态。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>阻塞：</strong>即线程被放入Blocked池。阻塞状态的线程如果结束了sleep方法，I/O方法返回，获取同步锁，收到通知或者resume都会导致其重新进入就绪态，与其它线程竞争cpu时间片。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>死亡：</strong>线程正常执行完run（）或者call（）方法，或者执行stop方法，或者发生异常或者错误都会导致线程死亡。（stop方法会导致锁混乱和死锁，不建议使用）</p>\n<h2><strong>五，线程的基本方法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;wait（线程等待）：</strong>会让线程进入WAITING状态，并且会释放对象的锁。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>sleep（线程睡眠）：</strong>会让线程进入睡眠，进入TIMED_WAITING状态，但是不会释放对象锁，睡眠时间到了之后，再次恢复运行状态</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>yield（线程让步）:</strong>&nbsp; 当前线程会让出其占有的cpu资源，重新回到就绪态和其它线程竞争cpu时间片</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>interrupt（线程中断）:&nbsp; </strong>中断当前线程，但是并不会导致其停止，只是改变其内部的终端标识位，在使用了thread.sleep()之后使用该方法，会导致抛出异常，且我们可以利用中断标识位进行线程的安全退出</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>join（线程加入）：</strong>即将当前线程进入阻塞态，等待下一个线程执行完毕后进入就绪态，重新竞争锁资源。通常用于主线程下面执行子线程，需要主线程阻塞，等待子线程执行完毕后返回其结果给主线程，主线程再执行的情况。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>notify（线程唤醒）/notifyAll：</strong>前者随机唤醒一个等待线程，后者全部唤醒</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>setDaemon（守护线程）:</strong>级别较低的线程，用于后台运行，服务用户用户线程，例如垃圾收集线程就是典型的守护线程。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>sleep方法和wait方法的区别：</strong>前者属于Thread，后者属于Object，前者不会释放锁资源，后者会释放锁资源</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>start方法和run方法：</strong>start方法只是创建一个线程，并没有运行，run方法时执行线程的真正代码逻辑。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>线程退出的方式：</strong>见四中最后一条</p>\n<h2><strong>六，JAVA中的锁（知识比较杂乱）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述:JAVA中的锁是为了保护数据的一致性。按照不同的标准可分为乐观锁和悲观锁，公平锁和非公平锁，共享锁和独占锁，偏向锁，轻量级锁，重量级锁，自旋锁，可重入锁。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;乐观锁：</strong>即认为每次读取数据都不会被修改，当修改操作的时候再判断当前数据是否被修改，未修改则修改，若已被修改，则返回失败状态。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>悲观锁：</strong>即认为每次读取数据都会被修改，因而每次读取数据都对其进行加锁，这样只有当前用户可以修改，其它用户阻塞等待直到当前用户修改完毕释放锁资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>自旋锁：</strong>即有些线程任务的执行很短，很快就可以释放锁资源，为了避免在这种情况下竞争线程仍然进行内核态和用户态之间的转换，因而让线程自旋（即等一会），如果有可用锁，则获取，减少了线程在用户态和内核态之间切换的时间损耗。提高了性能（优势）。当然线程自旋是占用cpu资源的，因而需要设置一个自旋的最大等待时间，如果超过此时间，则线程退出自旋模式。对于线程竞争锁资源激烈的情况，自旋有可能会导致cpu资源的损耗（劣势）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>公平锁和非公平锁：</strong>即根据线程竞争锁资源的机制判定，一般如果依据先到先得的原则，则位公平锁；如果依据就近原则，则位非公平锁。公平锁相比于非公平锁会更加耗费性能，因为要维护一个线程任务丢列，根据线程任务在队列中的顺序分配锁资源，因而不常用。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>可重入锁：</strong>又被称为递归锁，即该锁可以然后线程对其进行多次的加锁操作。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>偏向锁：</strong>当线程获取到锁的时候，用来消除线程的锁重入的开销（看起来是偏袒这个线程）。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>共享锁和独占锁：</strong>共享锁即多线程共享锁资源（典型例子，读锁）；独占锁即当前锁只能有一个线程获取，其它线程阻塞</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>轻量级锁：</strong>没有多线程竞争的前提下，减少重量级锁的使用提高性能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>重量级锁：</strong>基于操作系统的互斥量而实现的锁，会导致进程在用户态和内核态之间切换，耗费性能。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>synchronized：独占式悲观锁，可重入锁，非公平锁，重量级锁。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 作用范围：</strong>作用于成员变量和非静态方法，相当于锁住的是对象的实例，即this对象</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;作用于静态方法，相当于锁住的是class实例</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;作用域代码块，相当于锁住的代码块中的对象</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>实现原理：</strong>内部包括ContentionList（锁竞争队列），EntryList（竞争候选列表），WaitSet（等待集合），OnDeck（竞争候选者），Owner，!Owner，其中ContentionList是用来存放竞争锁资源的线程。EntryList是用来存放有资格竞争锁资源的线程。调用wait方法后放入WaitSet中，onDeck指的是同一时刻，只有一个线程竞争锁资源，Owner指的是得到锁资源的线程，!Owner指的是线程执行完毕，释放锁资源的线程。需要注意的是线程首先采用的都是自旋模式获取锁资源，如果自旋获取不到再加入ContentionList，而且Owner状态的线程并不是直接把锁资源交给onDeck状态线程，而是给它竞争锁资源的权利，因而onDeck状态的线程还需要跟自旋线程竞争锁资源。</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>ReentrantLock：独占式，可重入锁，并且可以实现公平锁和非公平锁，重量级锁。</strong></p>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;用法：</strong>lock()加锁，后跟try代码块，finally中进行释放锁unlock()</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;避免死锁的方法：</strong>响应中断（即可以根据情况中断对锁资源的请求），可轮询锁（tryLock（）即尝试获取锁，如果有可用锁则获取返回true，没有则返回。和lock（）的区别在于lock获取锁资源如果没有则一直等待直到获取到锁资源），定时所（tryLock（time,unit）即再一定时间内如果有可用锁，且线程未中断则获取锁，否则禁用当前线程。）</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>Semaphore（信号量）:</strong>机制和ReentrantLock类似</p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ReadWriteLock（读写锁）：</strong>如果系统要求支持多线程共享读，但不能多线程写，使用读锁；如果要求同一时刻只能有一个线程写，写的过程中不能读取该共享数据，则使用写锁。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; <strong>分段锁：</strong>一种思想，将数据分段加锁，例如ConcurrentHashMap</p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;死锁：</strong>即线程之间互相共享资源会导致死锁</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; <strong>锁优化：</strong>第一，减少锁的持有时间；第二：减小锁粒度，例如分段锁；第三：锁分离，例如读写锁；第四：锁粗化，放置锁粒度太小，造成频繁加锁释放锁；第五：锁消除，消除程序代码不规范而造成的乱用了锁</p>\n<p>&nbsp;</p>\n<h3><strong>并发编程（上）的思维导图送上：<a href=\"https://images-cdn.shimo.im/1UcHkyrlJyGRPYnn.png__thumbnail\" target=\"_blank\" rel=\"noopener\">并发编程（上）</a></strong></h3>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>\n<h1>水平有限，如果错误，还望指出！</h1>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;</p>","blogGoods":0,"blogId":"1249313090567143424","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHM2AQOeZAABJTVJPTfk967.jpg","blogRead":8,"blogRemark":"面试（三）------之并发编程篇（上）","blogTitle":"面试（三）------之并发编程篇（上）","createdTime":"2020-04-12 12:27:07","typeName":"java面试篇","updateTime":"2020-04-20 11:53:51"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，二分查找算法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：二分查找算法又称为折半查找算法，待查找的序列必须已经是有序的，每次取序列的中间值与查找值进行比较，若相等则返回；若中间值小于查找值，则在中间值右侧序列中进行查找；若中间值大于查找值，则在中间值左侧序列中进行查找。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现如下：</strong></p>\n<pre class=\"language-java\"><code>public static int binarySearch(int[] arr,int low,int high,int key){\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(arr[mid]==key){\n                return mid;\n            }else if(arr[mid]&lt;key){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        return -1;\n    }</code></pre>\n<h2><strong>二，冒泡排序（这里以升序为例）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：冒泡排序即对于一个无序序列，从第一个元素开始，依次比较相邻的元素，如果前一个元素大于后一个元素，则交换位置，这样一趟比较下来，就确定出最大值。直到整个序列有序为止</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现如下：</strong></p>\n<pre class=\"language-java\"><code>public static void bubbleSort(int[] arr){\n        for (int i = arr.length-1; i &gt;=0 ; i--) {\n            for (int j = 0; j &lt; i; j++) {\n                if(arr[j]&gt;arr[j+1]){\n                    swap(arr,j,j+1);\n                }\n            }\n        }\n    }\n    /**\n     * 交换元素\n     * @param arr\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] arr,int i,int j){\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }</code></pre>\n<h2>三，插入排序（升序为例）</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>概述：即默认无序序列中的第一个元素有序，随后每次排列有序序列后的一个元素，将其排列进入前面的有序序列，同时保证有序序列的有序性即可。（类似于我们打扑克牌时，每拿一张从后往前比较大小，放入正确的位置）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现如下：</strong></p>\n<pre class=\"language-java\"><code>public static void insertSort(int[] arr){\n        for (int i = 1; i &lt; arr.length; i++) {\n            for (int j = i; j &gt;=0; j--) {\n                if(arr[j]&lt;arr[j-1]){\n                    swap(arr,i,j);\n                }\n            }\n        }\n    }\n\n    /**\n     * 交换元素\n     * @param arr\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] arr,int i,int j){\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }</code></pre>\n<h2>四，快速排序（升序为例）</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>概述：在一个无序序列中，取一个基准值，通常取第一个元素为基准值。然后从最右边依次查找，找到第一个比基准值小的元素，与其交换位置；再从最左边查找，查找到第一个比基准值大的元素，与其交换位置。直到从左往右查找的索引等于从右往左查找的索引，结束一次循环，重复以上过程分别比较左右两标的序列，直到整个</strong></p>\n<p><strong>有序为止。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;JAVA代码实现如下：</strong></p>\n<pre class=\"language-java\"><code>public static void quickSort(int[] arr,int low,int high){\n        int base = arr[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //先从右往左查找第一个比基准值小的元素\n            while(R&gt;L&amp;&amp;arr[R]&gt;=base){\n                R--;\n            }\n            if(arr[R]&lt;base){\n             swap(arr,L,R);\n            }\n            //再从左往右查找第一个比基准值大的元素\n            while(R&gt;L&amp;&amp;arr[L]&lt;=base){\n                L++;\n            }\n            if(arr[L]&gt;base){\n                swap(arr,L,R);\n            }\n        }\n        //递归左右序列\n        if(L&gt;low) {\n            quickSort(arr,low,L-1);\n        }\n        if(R&lt;high) {\n            quickSort(arr,R+1,high);\n        }\n    }\n\n    /**\n     * 交换元素\n     * @param arr\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] arr,int i,int j){\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }</code></pre>\n<h2>五，希尔排序（升序为例，以初始dk为length/3+1）</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>概述：希尔排序又称增量排序，是优化的插入排序，即有一个增量dk，根据增量dk将无序序列分为若干个子序列，分别对子序列进行插入排序，每进行完一趟排序，更改增量，直到增量dk为1时，则对整个序列再进行依次插入排序。希尔排序，当增量dk大的时候，因为序列数据较少，排序较快；而当增量dk小的时候，又因为序列</strong></p>\n<p><strong>中的数据已经基本有序了，因而排序也较快。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;JAVA代码实现：为例</strong></p>\n<pre class=\"language-java\"><code>public static void sort(int[] arr){\n\n        int dk = arr.length/3+1;\n        while(dk!=1){\n            shellSort(arr,dk);\n            dk = dk/3+1;\n        }\n        if(dk==1){\n            shellSort(arr,dk);\n        }\n    }\n\n    public static void shellSort(int[] arr,int dk){\n        for (int i = dk; i &lt;arr.length ; i++) {\n            if(arr[i]&lt;arr[i-dk]){\n                swap(arr,i,i-dk);\n            }\n        }\n    }\n\n    /**\n     * 交换元素\n     * @param arr\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] arr,int i,int j){\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }</code></pre>\n<h2><strong>六，归并排序</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：归并排序采用的是典型的分治思想，即先分解，然后再归并。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n     * 先分\n     * @param arr\n     */\n    public static void sortProcess(int[] arr,int L,int R){\n        if(L==R){\n            return;\n        }\n        int mid = (L+R)/2;\n        sortProcess(arr,L,mid);\n        sortProcess(arr,mid+1,R);\n        merge(arr,L,mid,R);\n    }\n\n    /**\n     * 分治中的治\n     * @param arr\n     * @param L\n     * @param mid\n     * @param R\n     */\n    public static void merge(int[] arr,int L,int mid,int R){\n        int[] help = new int[R-L+1];\n        int p1 = L;\n        int p2 = mid+1;\n        int i =0;\n        while(p1&lt;=mid&amp;&amp;p2&lt;=R){\n            help[i++] = arr[p1]&gt;arr[p2]?arr[p2++]:arr[p1++];\n        }\n        while(p1&lt;=mid){\n            help[i++] = arr[p1++];\n        }\n        while(p2&lt;=R){\n            help[i++] = arr[p2++];\n        }\n        //将数组help复制回原数组（注意一定要有这一步，不然无法保证元素比较后的大小顺序性）\n        for (int j = 0; j &lt; help.length; j++) {\n            arr[L+j] = help[j];\n        }\n        System.out.println(Arrays.toString(arr));\n    }</code></pre>\n<h2>七，桶排序算法</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>概述：先找出无序序列中的最大值和最小值，然后根据最大值和最小值计算桶的个数并且初始化桶，然后将每个元素加入到对应的桶中，对每个桶进行排序，再整合桶中的数据即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>JAVA代码如下：</strong></p>\n<pre class=\"language-java\"><code>public static void bucketSort(int[] arr){\n\n        int k = 0;\n        //找出无序序列中的最大值和最小值\n        int max = Integer.MIN_VALUE;\n        int min = Integer.MAX_VALUE;\n        for (int i : arr) {\n            max = Math.max(max,i);\n            min = Math.min(min,i);\n        }\n\n        //根据最大值和最小值确定桶\n        int bucketNum = (max-min)/arr.length+1;\n        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = new ArrayList&lt;&gt;(bucketNum);\n        for (int i = 0; i &lt; bucketNum; i++) {\n            bucketArr.add(new ArrayList&lt;&gt;());\n        }\n\n        //遍历序列中的数据，将其分配进入不同的桶\n        for (int i=0;i&lt;arr.length;i++) {\n            int num = (arr[i]-min)/arr.length;\n            bucketArr.get(num).add(arr[i]);\n        }\n\n        //对每个桶都进行排序\n        for (ArrayList&lt;Integer&gt; bucket : bucketArr) {\n            Collections.sort(bucket);\n        }\n\n        //将桶中的数据按照顺序复制回原数组\n        for (ArrayList&lt;Integer&gt; bucket : bucketArr) {\n            for (Integer integer : bucket) {\n                arr[k++] = integer;\n            }\n        }\n    }</code></pre>\n<h2>八，基数排序（这里以高位优先为例）</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>概述：基数排序是一种优化的桶排序，但是基数排序只能排序整型数据。先要统一数据的位数，位数不够的前面添0，然后按照从低位到高位的位数顺序依据位数上数字的大小进行排序，最终得到一个有序序列。 &nbsp;</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码如下：</strong></p>\n<pre class=\"language-java\"><code>public static void radixSort(int[] arr){\n        //指数\n        int exp = 1;\n\n        //查找数组中的最大值\n        int max= Integer.MIN_VALUE;\n        for (int i : arr) {\n            max = Math.max(max,i);\n        }\n\n        //按照低位到高位的顺序依次排序\n        for (exp=1;(max/exp)&gt;0;exp*=10){\n            int[] temp = new int[arr.length];\n            //初始化桶\n            int[] buckets = new int[10];\n            //统计每个桶中数据的次数\n            for (int i = 0; i &lt; arr.length; i++) {\n                buckets[(arr[i]/exp)%10]++;\n            }\n\n            //更改buckets[i]\n            for (int i = 1; i &lt; buckets.length; i++) {\n                buckets[i]+=buckets[i-1];\n            }\n\n            //将数据存储到临时数组temp中\n            for (int i = 0; i &lt; arr.length; i++) {\n                temp[buckets[(arr[i]/exp)%10]-1] = arr[i];\n                buckets[(arr[i]/exp)%10]--;\n            }\n\n            //将临时数组的数据复制到原数组\n            System.arraycopy(temp,0,arr,0,arr.length);\n        }\n    }</code></pre>\n<h2><strong>九，其它算法（对于最短路径算法和回溯算法后面会单列出来）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;剪枝算法，最短路径算法，回溯算法</strong></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1250364779516665856","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHQyAM97iAABJTVJPTfk047.jpg","blogRead":8,"blogRemark":"面试（五）------之算法","blogTitle":"面试（五）------之算法","createdTime":"2020-04-15 10:06:09","typeName":"java面试篇","updateTime":"2020-04-25 11:53:23"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，OSI七层网络模型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;物理层：主要用于定义物理设备的标准，发送比特流</strong></p>\n<p><strong style=\"font-size: 14px;\">&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;数据链路层：主要用于对数据包中的MAC地址进行解析和封装。这一层的数据单位叫做帧</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;网络层：主要用于对数据包中的ip地址进行解析和封装，这一层的数据单位叫做数据包。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;传输层：定义传输的协议和端口，进行的数据的分段，重组和传输。TCP传输控制协议，适用于对可靠性要求高，数据量大的传输。UDP适用于对可靠性要求不高，数据量不大的传输。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;会话层：用于再传输层的基础上建立连接和管理会话。比如登录，断点续传，数据粘包和分包。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;表示层：用于对接收到的数据进行解析，将计算机识别的信息转换成人也能够识别的信息。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;应用层：构建具体应用</strong></p>\n<h2><strong>二，TCP/IP四层网络模型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：TCP/IP并不是指tcp和ip协议，而是指因特网中的TCP/IP协议簇，分为四层网络模型：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;网络接口层：用来定义主机间的连通协议</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;网络层：用于数据的传输，路由及地址的解析，确保数据能够发送到任何网络的目标上。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;传输层：使源端和目的端的相同实体能够进行通信</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;应用层：负责具体应用协议的定义</strong></p>\n<h2><strong>三，TCP三次握手/四次挥手</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：客户端和服务器之间建立连接之前需要进行三次沟通，称为&ldquo;三次握手&rdquo;；客户端和服务器之间断开连接之前，会进行四次沟通，称为&ldquo;四次挥手&rdquo;。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;三次握手：客户端发送连接请求的标识位SYN给服务器端，进入SYN-SEND状态，请求建立连接；服务器端接收到请求之后，返回一个SYN+ACK报文，进入SYN-RECV状态；客户端接收到请求之后，回应一个ACK报文，至此，三次握手完毕，客户端与服务器端之间的TCP连接已建立，可以进行数据传输。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;四次挥手：客户端和服务器端断开连接要进行四次挥手是因为TCP的关闭是半关闭造成的，即TCP连接是全双工的（即数据可以在两个方向上同时进行交换），因此想要关闭连接，就必须每个方向进行单独关闭。（客户端主动断开连接和服务器端主动断开连接），这里以客户端主动断开连接为例：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;客户端数据传输完毕之后，发送一个释放连接的标识位FIN=1给服务器端，请求断开客户端到服务器端之间的连接操作，进入FIN-WAIT-1状态；</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;服务器端接收到请求之后，返回一个ACK报文给客户端，表</strong><strong>示已经接收到其断开连接的请求，然后释放客户端到服务器端的连接，服务器端进入CLOSE-WAIT状态，客户端接收到请求后进入FIN-WAIT-2状态；</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;服务器端在将待传输到客户端的数据传输完毕之前，发出一个中断连接的标识位FIN=1给客户端，请求客户端中端服务器端到客户端的连接操作，进入进入LAST-ACK状态，等待客户端的最终确认；</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;客户端接收到服务器端的断开连接请求之后，回应一个ACK，表示接收到断开连接请求，随后等待计时器设置的时间后，断开连接。</strong></p>\n<h2><strong>四，HTTP协议</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;概述：http协议是一种无状态的协议，即客户端和服务器端不需要建立持久的连接，客户端发出请求后，服务器端接收到请求，处理数据返回应答之后，连接关闭。http协议遵循请求（Request）和应答（Response）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;传输流程：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 地址解析：通过域名系统DNS获取请求地址的协议，主机名，端口号，对象路径</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 封装HTTP数据包：根据解析出来的请求协议，主机名，端口号，对象路径和本机信息封装出HTTP数据包</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 封装TCP数据包：将HTTP数据包进一步封装成TCP数据包</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;建立TCP连接：利用三次握手协议建立客户端和服务器端的TCP连接</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 客户端发送请求：客户端发送一个请求给服务器端</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 服务器端响应：服务器端接收到客户端发送的请求之后，进行数据处理，返回响应</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;服务器关闭TCP连接：服务器返回应答之后，关闭TCP连接。如果在服务器返回的应答中加上connection：keep-alive，则返回应答后不会关闭TCP连接，下一次浏览器发送请求的时候仍然可以使用该连接（减少了响应时间和带宽资源的消耗）。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;HTTP中常见的状态码：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;20x表示成功，30x表示重定向，40x表示客户端错误，50x表示服务器错误</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;100（继续），101（切换协议），200（成功），201（created创建），202（accepted创建），203（未授权），204（无内容），205（重置内容），206（部分内容）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;300（多种选择），301（永久移动），302（临时移动），303（查看其它位置），304（未修改），305（使用代理），306（未使用），307（临时重定向），308（永久重定向）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;400（客户端请求错误），401（未授权），402（待付款），403（禁止访问），404（未发现），405（不允许使用该方法），406（无法接受），407（需要使用代理身份），408（请求超时），409（冲突），410（已失效），413（请求实体过长），414（请求地址过长），415（媒体类型不支持）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;500（内部服务器错误），501（未实现），502（网关错误），503（服务不可用），504（网关超时），505(Http版本不支持)</strong></p>\n<h2>五，HTTPS</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>概述：HTTPS是在http的基础上增加了SSL协议以保证传输数据的安全性，因为HTTP传输数据使用的明文传输，不安全。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;HTTPS加密流程：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 客户端和服务器端建立TCP连接之后，发送一个请求证书的请求</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 服务器端接收到请求之后，返回应答并且返回证书信息</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 客户端接收到证书之后，进行确认，如果确认正确，则生成密钥</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 客户端将密钥发送给服务器端，服务器端接收到之后利用私钥进行解密</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 经过上面的步骤，客户端和服务器端之间的数传传输就可以进行加密传输了</strong></p>\n<h2><strong>六，CDN原理（待补充）</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：CDN即基于分布在不同的地方的机房服务器，通过中心平台的负载均衡，内容分发和任务调度让用户就近获取所需要的内容，降低网络延时，提升用户体验。</strong></p>\n<h2><strong>七，七层负载均衡和四层负载均衡</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;四层负载均衡：即利用ip和端口号，根据负载均衡的配置和分发策略将请求分发给真实服务器</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;七层负载均衡：利用请求的URL或者主机名接受所有用户的请求，然后将其分发给真实服务器</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;区别：四层负载均衡只能根据ip和端口号进行请求的分发，但是七层负载均衡根据URL可以根据具体的请求信息进行分发，例如一个ip下面有多个具体的请求，/user,/business等。四层负载均衡将该ip或者端口号下的所有请求都分配给一台服务器进行处理，但是七层负载均衡可以根据不同的路径信息，将/user分配给一台真实</strong><strong>服务器，将/business分配给一台真实服务器。（Nginx既支持四层负载均衡，又支持七层负载均衡）</strong></p>\n<h2><strong>八，负载均衡算法</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;轮询均衡：将请求均等的分发到1-n台服务器上，用于各台服务器之间的软硬件设备没有差距的情况下。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;权重轮询均衡：即根据权重的不同，将不同数量的请求轮询分发到不同的服务器上</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;随即均衡：即将请求随机分发到服务器上</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;权重随即均衡：即根据权重的不同，将请求随机分发到服务器上</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;响应速度均衡：即根据服务器的响应速度，将请求分发到请求速度最快的服务器上</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;最少连接数均衡：即在服务器内部维护一个记录服务器处理连接数量的计数器，将请求分发到连接数最少的服务器上。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;处理能力均衡：将请求分发给内部负荷最轻的服务器</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;DNS响应均衡：不同中心机房的均衡设备接收到域名解析请求时，都进行域名解析，然后返回给客户端，客户端连接第一个返回应答的服务器，忽略其它的均衡设备。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;散列算法均衡：即通过一次性散列算法将相同参数的请求分发到一台服务器上，长期稳定的为客户端进行服务</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;IP地址散列均衡：将来自同一客户端的请求分发到同一台服务器</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;URL散列：将相同URL的请求分发到同一台服务器</strong></p>\n<h2><strong>九，Nginx的反向代理和负载均衡</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;正向代理：即客户端找代理服务器取寻找真实服务器，真实服务器并不知道客户端的ip和端口，因此可以隐藏客户端真实ip和端口</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;反向代理：即服务器找代理服务器去跟客户端打交道，在客户端眼中，代理服务器就是服务器，它并不知道真实服务器是谁</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;负载均衡：即通过Nginx，根据负载均衡的配置和分发策略将不同的请求交给不同的服务器进行处理。</strong></p>\n<p>&nbsp;</p>\n<h3><strong>思维导图：<a href=\"https://images-cdn.shimo.im/ttaA0nsU39ofHH4J__thumbnail\" target=\"_blank\" rel=\"noopener\">网络及负载均衡</a></strong></h3>\n<p>&nbsp;</p>\n<h1><strong>水平有限，如有错误，还望指出！</strong></h1>","blogGoods":0,"blogId":"1250622112591376384","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHReAPuDwAABJTVJPTfk300.jpg","blogRead":8,"blogRemark":"面试（六）------之网络与负载均衡","blogTitle":"面试（六）------之网络与负载均衡","createdTime":"2020-04-16 03:08:42","typeName":"java面试篇","updateTime":"2020-04-20 15:20:46"},{"blogCollection":0,"blogComment":0,"blogContent":"<p><strong>一，前后端分离开发优势</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp; &nbsp;1，</strong>项目开发过程中，前后端完全解耦，前端只需要负责页面的实现，只需要通过接口拿数据。后端不需要管页面的跳转，只需要负责接口的编写</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>2，</strong>前后端人员有更多的精力去负责自己的工作，前端人员可以将更多的精力投放在页面的编写，页面的美化，页面特效的制作和用户体验上；而后端人员可以将更多的精力放在接口代码的优化，sql优化，jvm调优上面</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>3，</strong>前后端分离的项目部署的时候，前端项目往往都是部署在nginx服务器上，而前后端不分离的项目往往都是部署再一台服务器上。因此前后端分离项目大大降低了服务器的负担</p>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>4，</strong>前后端不分离的项目使用模板引擎例如freemaker，thymeleaf等，前后端人员交流起来较为困难。且前端项目使用原生的DOM操作，极大的增加了前端工作人员的工作量。而前后端分离项目前端通常都是用各种ui框架，框架采用MVVM模式，极大的减轻了前端工作人员的工作量</p>\n<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>5，</strong>前后端分离开发，前端可以通过easy-mock来伪造接口数据进行测试，后端人员可以通过postman进行接口测试，开发效率大大提升。</p>","blogGoods":0,"blogId":"1247867141693128704","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dG6CAI6ipAACiM2P5LtI65.jpeg","blogRead":7,"blogRemark":"前后端分离开发的优势所在","blogTitle":"闲谈前后端分离开发","createdTime":"2020-04-08 12:41:25","typeName":"随笔","updateTime":"2020-04-20 11:48:53"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，栈及其JAVA实现</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：栈是一种先进后出的数据结构，对栈顶元素的添加，删除等操作较快，但是对于栈内的元素操作很慢</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA实现：实现需要定义栈的数据结构，写栈的入栈，出栈，获取栈顶元素的方法，如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n * 基于数组实现栈\n * @author wcj\n * @Date 2020/4/14 20:59\n * @Version 1.0\n */\npublic class StackExample&lt;E&gt; {\n\n    /**\n     * 站的深度\n     */\n    private int maxSize;\n    /**\n     * 存储数据的数组\n     */\n    private Object[] data;\n    /**\n     * 栈顶指针\n     */\n    private int top = -1;\n\n    /**\n     * 默认栈的深度为10\n     */\n    public StackExample(){\n        this(10);\n    }\n\n    /**\n     * 用户自定义栈的深度\n     * @param initialSize\n     */\n    public StackExample(int initialSize){\n        if(initialSize&gt;=0){\n            this.maxSize = initialSize;\n            this.data = new  Object[initialSize];\n            this.top = -1;\n        }else{\n            throw new RuntimeException(\"初始化栈的深度不能小于0!\");\n        }\n    }\n\n    /**\n     * 入栈操作\n     * @param e\n     * @return\n     */\n    public Boolean push(E e){\n        if(top == maxSize-1){\n            throw new RuntimeException(\"栈已满,不能入栈\");\n        }else{\n            data[++top] = e;\n        }\n        return true;\n    }\n\n    /**\n     * 出栈操作\n     * @return\n     */\n    public E pop(){\n        if(top==-1){\n            throw new RuntimeException(\"栈空，不能出栈！\");\n        }else{\n            return (E) data[top--];\n        }\n    }\n\n    /**\n     * 获取栈顶元素\n     * @return\n     */\n    public E peak(){\n        if(top==-1){\n            throw new RuntimeException(\"栈空异常！\");\n        }else{\n            return (E) data[top];\n        }\n    }  </code></pre>\n<h2><strong>二，队列极其JAVA实现</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：队列是一种先进先出的数据结构，对队头和队尾的操作简单，但是队内元素的操作复杂。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA实现：定义队列的数据结构，队列的出队，入队，获取队头元素。代码如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n * 基于数组实现队列\n * @author wcj\n * @Date 2020/4/14 21:14\n * @Version 1.0\n */\npublic class QueueExample&lt;E&gt; {\n\n    /**\n     * 队列长度\n     */\n    private int maxSize;\n    /**\n     * 存储数据数组\n     */\n    private Object[] data;\n    /**\n     * 队头指针\n     */\n    private int front;\n    /**\n     * 队尾指针\n     */\n    private int rear;\n\n    /**\n     * 默认构造器\n     */\n    public QueueExample(){\n        this(10);\n    }\n    /**\n     * 用户自定义队列长度构造器\n     * @param initialSize\n     */\n    public QueueExample(int initialSize){\n        if(initialSize&gt;=0){\n            this.maxSize = initialSize;\n            data = new Object[initialSize];\n            front = rear = 0;\n        }else{\n            throw new RuntimeException(\"初始化队列长度不能小于0！\");\n        }\n    }\n\n    /**\n     * 入队操作\n     * @param e\n     * @return\n     */\n    public Boolean add(E e){\n        if(rear == maxSize){\n            throw new RuntimeException(\"队列已满，无法入队!\");\n        }else{\n            data[rear++] = e;\n        }\n        return true;\n    }\n\n    /**\n     * 出队操作\n     * @return\n     */\n    public E poll(){\n        if(front==rear){\n            throw new RuntimeException(\"队空，无元素可出队！\");\n        }else{\n            E e = (E) data[front];\n            data[front] = null;\n            return e;\n        }\n    }\n\n    /**\n     * 获取队头元素\n     * @return\n     */\n    public E peek(){\n        if(front==rear){\n            throw new RuntimeException(\"队空，无元素可出队!\");\n        }else{\n            return (E) data[front];\n        }\n    }\n}\n</code></pre>\n<h2><strong>三，链表及其JAVA实现</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：链表是由一系列数据节点组成的数据结构，节点可以动态生成。对于元素的增加，删除操作快，查询操作慢</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;这里主要讲述几种有代表性的链表：单向链表，双向链表，双向循环链表</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;单链表的JAVA实现：数据结构定义，添加节点，删除节点，查找节点，代码如下：</strong></p>\n<pre class=\"language-java\"><code>/**\n * 单向链表\n * @author wcj\n * @Date 2020/4/14 21:32\n * @Version 1.0\n */\npublic class SingleLinkedList {\n\n    /**\n     * 链表长度\n     */\n    private int length;\n    /**\n     * 链表头节点\n     */\n    private Node head;\n\n    public SingleLinkedList(){\n        this.length = 0;\n        this.head = null;\n    }\n    /**\n     * 内部类声明每个链表节点\n     * 每个节点包括数据域和指向下一个节点的指针\n     */\n    private class Node{\n        private Object data;\n        private Node next;\n        public Node(Object data){\n            this.data = data;\n        }\n    }\n\n    /**\n     * 插入节点（这里使用头插法）\n     * @param obj\n     * @return\n     */\n    public Boolean add(Object obj){\n        Node node = new Node(obj);\n        if(length==0){\n            head = node;\n        }else{\n            node.next= head;\n            head = node;\n        }\n        length++;\n        return true;\n    }\n\n    /**\n     * 删除某个节点\n     * 先对链表进行判空处理\n     * 然后找到要删除的节点\n     * 最后进行删除\n     * @param obj\n     * @return\n     */\n    public Boolean delete(Object obj){\n        if(length==0){\n            throw new RuntimeException(\"链表为空，无节点可删除!\");\n        }else{\n            Node prev = head;\n            Node current = head;\n            //查找待删除元素\n            while(!current.data.equals(obj)){\n                if(current.next==null){\n                    return false;\n                }else{\n                    prev = current;\n                    current = current.next;\n                }\n            }\n            prev.next = current.next;\n            length--;\n        }\n        return true;\n    }\n\n    /**\n     * 获取某个元素\n     * @param obj\n     * @return\n     */\n    public Object find(Object obj){\n        if(length==0){\n            throw new RuntimeException(\"链表为空\");\n        }else{\n            Node current = head;\n            while(current.data.equals(obj)){\n                if(current.next==null){\n                    return null;\n                }else{\n                    current = current.next;\n                }\n            }\n            return current.data;\n        }\n    }\n}\n</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>双向链表的JAVA实现：定义数据结构，头插法，尾插法，删除头部节点，删除尾部节点（这里只写尾插节点和删除尾部节点），代码如下：</strong></p>\n<pre class=\"language-java\"><code>import com.sun.org.apache.xpath.internal.operations.Bool;\n\n/**\n * 单向循环链表\n * @author wcj\n * @Date 2020/4/14 22:05\n * @Version 1.0\n */\npublic class CircleLinkedList {\n\n    /**\n     * 链表长度\n     */\n    private int length;\n    /**\n     * 头节点\n     */\n    private Node head;\n    /**\n     * 尾节点\n     */\n    private Node tail;\n\n    /**\n     * 初始化构造方法\n     */\n    public CircleLinkedList(){\n        this.length = 0;\n        this.head=this.tail = null;\n    }\n\n    /**\n     * 内部类实现的链表节点\n     */\n    private class Node{\n        private Object data;\n        private Node prev;\n        private Node next;\n        public Node(Object data){\n            this.data = data;\n        }\n    }\n\n    /**\n     * 尾插节点\n     * @param obj\n     * @return\n     */\n    public Boolean addTail(Object obj){\n        Node node = new Node(obj);\n        if(length==0){\n            head = tail= node;\n            length++;\n        }else{\n            tail.next = node;\n            node.prev = tail;\n            tail = node;\n            length++;\n        }\n        return true;\n    }\n\n    /**\n     * 删除尾部节点\n     * @return\n     */\n    public Boolean delTail(){\n        Node temp = tail;\n        if(length==0){\n            throw new RuntimeException(\"链表为空!\");\n        }else{\n            tail = tail.prev;\n            tail.next = null;\n            length--;\n        }\n        return true;\n    }\n}\n</code></pre>\n<h2><strong>四，散列表</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：有一张表M，一个映射函数f(key)，如果对于任意一个key，都有一个函数指与表中的内存地址相对应，则M就为散列表，f(key)就为散列函数。散列函数存储key-value键值对形式的数据，直接生成key与表中地址值的映射，因此查询非常迅速。同时散列表也经常被用于信息安全，用于加密操作。</strong></p>\n<h2><strong>五，二叉排序树</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;概述：二叉查找树又成为二叉搜索树，二叉查找树</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;特征：根节点左边的数据小于根节点，根节点右边的数据大于根节点，且其左右子树还是二叉排序树</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;JAVA代码实现：定义数据结构，插入操作，删除操作，查找操作，代码如下：</strong></p>\n<pre class=\"language-java\"><code>package interviewFour.example4;\n\n/**\n * 二叉排序树\n * @author wcj\n * @Date 2020/4/14 17:17\n * @Version 1.0\n */\npublic class Node {\n\n    private Node root = null;\n    private int value;\n    private Node left;\n    private Node right;\n\n    public Node(){}\n\n    public Node(int value, Node left, Node right){\n        this.value = value;\n        this.left = left;\n        this.right = right;\n    }\n\n    public Node(int value){\n        this.left = null;\n        this.right = null;\n        this.value = value;\n    }\n\n    public int getValue() {\n        return value;\n    }\n\n    public void setValue(int value) {\n        this.value = value;\n    }\n\n    public Node getLeft() {\n        return left;\n    }\n\n    public void setLeft(Node left) {\n        this.left = left;\n    }\n\n    public Node getRight() {\n        return right;\n    }\n\n    public void setRight(Node right) {\n        this.right = right;\n    }\n\n    /**\n     * 插入节点\n     * @param value\n     * @return\n     */\n    public Boolean insert(int value){\n        //root代表根节点\n        Node p = root;\n        Node prev = null;\n        //创建一个节点\n        Node node = new Node(value);\n        //寻找节点的插入位置\n        while(p!=null){\n            prev = p;\n            if(value==p.getValue()){\n                return false;\n            }else if(value&lt;p.getValue()){\n                p = p.getLeft();\n            }else{\n                p = p.getRight();\n            }\n        }\n        if(root==null){\n            root = node;\n        }else if(value&lt;prev.getValue()){\n            prev.setLeft(node);\n        }else{\n            prev.setRight(node);\n        }\n        return true;\n    }\n\n    /**\n     * 删除某个节点\n     * 分为三种情况，待删除节点为叶子节点，则直接删除\n     * 待删除节点只有左子树或者右子树，则用左子树或者右子树替代当前节点位置\n     * 待删除节点即有左子树又有右子树，则寻找左子树最大节点或者右子树最小节点顶替当前节点(这里使用左子树的最大节点)\n     * @param value\n     * @return\n     */\n    public void deleteBST(int value){\n        deleteBST(root,value);\n    }\n\n    /**\n     * 递归删除左子树，或者右子树，或者根节点\n     * @param root\n     * @param value\n     * @return\n     */\n    public Boolean deleteBST(Node root,int value){\n        if(root==null){\n            return false;\n        }else{\n            if(root.getValue()==value){\n                delete(root);\n            }else if(value&lt;root.getValue()){\n                deleteBST(root.getLeft(),value);\n            }else{\n                deleteBST(root.getRight(),value);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * 分情况执行具体的删除逻辑\n     * @param node\n     * @return\n     */\n    public Boolean delete(Node node){\n        if(node.getLeft()==null){\n            node = node.getRight();\n        }else if(node.getRight()==null){\n            node = node.getLeft();\n        }else{\n            Node temp = node;\n            Node s = node;\n            //转向左子树，向右走到底\n            s = s.getLeft();\n            //寻找替换待删除节点的节点\n            while(s!=null){\n                temp = s;\n                s = s.getRight();\n            }\n            node.setValue(temp.getValue());\n            if(temp!=node){\n                node.setLeft(temp.getLeft());\n            }else{\n                node.setRight(temp.getRight());\n            }\n        }\n        return true;\n    }\n\n    /**\n     * 在二叉查找树中找到对应节点\n     * @param value\n     * @return\n     */\n    public Boolean searchBTS(int value){\n        Node node = root;\n        if(node==null){\n            throw new RuntimeException(\"无此节点！\");\n        }else{\n            if(value==node.getValue()){\n                return true;\n            }else if(value&lt;node.getValue()){\n                node = node.getLeft();\n            }else{\n                node = node.getRight();\n            }\n        }\n        return false;\n    }\n}\n</code></pre>\n<h2><strong>六，红黑树</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 概述：红黑树是一种特化的自平衡二叉排序树，即其左右子树的深度差可以超过1。（详细的插入等操作过段时间会补充）</strong></p>\n<h2><strong>七，图，位图</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;图的知识：定义，有向图/无向图，邻接矩阵/邻接表，BFS/DFS，位图的话没怎么搞清楚。</strong></p>\n<h3><strong>思维导图：<a href=\"https://images-cdn.shimo.im/YClQaLxx9e8uEb9U__thumbnail\" target=\"_blank\" rel=\"noopener\">数据结构</a></strong></h3>\n<h2>&nbsp;</h2>","blogGoods":0,"blogId":"1250068950784536576","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHQGAYlUxAABJTVJPTfk990.jpg","blogRead":7,"blogRemark":"面试（四）------之数据结构篇","blogTitle":"面试（四）------之数据结构篇","createdTime":"2020-04-14 14:30:37","typeName":"java面试篇","updateTime":"2020-04-23 22:14:43"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，分布式缓存</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;进程内缓存：对于用户信息，热点数据等信息，访问比较频繁，我们将其存放进入缓存，用户查询数据的时候直接从内存种读取，而不需要从数据库查询，既降低了数据库的负载，同时又提升了查询效率。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;分布式缓存：对于单点web应用，我们使用进程内缓存就足够了，但是对于分布式系统，数据库是部署在多个服务器上分布式数据库，缓存则是部署在多个服务器上的分布式缓存，并且缓存数据存在备份，当一个缓存服务挂掉之后，可以立即启用备份的缓存进行工作（高可用）。</strong></p>\n<h2><strong>二， redis的基本数据类型</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;String，hash，List，Set，Zset</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;基本数据类型的基本命令见redis篇：<a href=\"http://localhost:1002/info/1249588251598041088\">http://localhost:1002/info/1249588251598041088</a></strong></p>\n<h2><strong>三，redis管道</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;客户端发出一个redis命令请求之后，会监控socket，客户端处于阻塞状态，直到服务器端返回结果，客户端才可以继续发出下一个请求。且在分布式系统中，redis是部署在不同的服务器上，这样服务器之间的数据传输还会有一定的延迟，redis的性能瓶颈就是在网络延迟上 。redis管道机制，即客户端发出一个请求之</strong><strong>后，可以不等服务器端返回结果就发送下一个请求，然后批量的接收服务器端返回的结果。这样客户端批量发出请求，服务器端接</strong><strong>收到批量请</strong><strong>求之后，进行处理返回批量数据。这样提高了redis的性能。</strong></p>\n<h2><strong>四，redis事务</strong></h2>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;</strong><strong>基本命令（multi开启事务，exec执行事务，discard取消事务，watch监听某个key的变化，unwatch取消监听所有key的变化）</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;事务基本流程：客户端执行multi命令开启事务</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;客户端提交命令到事务</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;redis将客户端请求放入事务队列等待</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;服务器返回QURUD，表明命令已经进入事务</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;客户端通过exec执行事务</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;执行事务的过程中，如果有某个命令错误，则其它命令继续执行，不会回滚。</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;服务器端向客户端返回事务的执行结果</strong></p>\n<p><strong>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</strong></p>\n<h2><strong>五， redis的发布，订阅</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;发布者向频道发布消息，订阅者从频道获取消息（<span style=\"background-color: #ffcc00;\">有待补充</span>）</strong></p>\n<h2><strong>六，redis集群数据复制原理</strong></h2>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;从数据库（slave）发出数据同步请求SYNC给主数据库（master）</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;主数据库接收到从数据库的请求，进行快照，并将快照期间的命令缓存起来，生成.rdb文件</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;主数据库将.rdb文件发送给从数据库</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;从数据库接收到.rdb文件，载入文件进入本地</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;从数据库执行快照，将数据写入内存，即初始化</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;从数据库初始化完成后，主数据接收到写请求之后，会将写请求发送给从数据库，实现数据的一致性</strong></p>\n<h2><strong>七，</strong><strong>redis持久化</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;redis持久化有rdb和aof两种，rdb即采用快照的方式，每隔一定的时间，进行依次数据的快照，对于大数据集的数据处理较快，但是对于数据的完整性要求较低。aof方式是采用日志的形式，将写操作的命令都存于aof文件中，启动服务的时候直接将aof中的命令按顺序执行用以构建原始数据集，但是速度较慢，</strong><strong>且aof文件的大小要比rdb文件大。如果两种方式都开启，则启动服务的时候默认采用aof的方式进行数据恢复。</strong></p>\n<h2><strong>八， redis的集群模式及工作原理</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;主从模式：中心化，所有的写请求都发送到主数据库，读操作分发给从数据库，分担主句库的压力。但是缺陷很明显，如果主数据库宕机，则从数据库必须要阻塞等待，或者手动切换从数据库为主数据库？</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;哨兵模式：即主数据库宕机，自动选举从数据库。设置一个哨兵监视集群的运行状态，如果主数据库宕机，哨兵会依据投票机制从数据库中选举出一个主数据替换宕机的主数据库。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;集群模式：redis集群实现了redis的数据分片和数据复制能力。数据分片能够让我们对redis进行横向扩展，提升集群的吞吐量。数据复制能力，在一些节点挂掉之后，集群仍然能够对外提供服务。</strong></p>\n<h2><strong>九，redis整合springboot见redis篇</strong></h2>\n<h2><strong>十，分布式缓存设计的核心问题</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;缓存预热：用户请求数据前先将数据保存到缓存中。通常的方法是系统启动加载，定时加载</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;缓存更新：即当数据发生变化的时候，对缓存中的数据进行更改</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;缓存淘汰策略：FIFO（先进先出，即先淘汰时间长远的缓存），LRU（最近最少使用，即判断缓存最近被使用的时间，淘汰离被使用时间最远时间的缓存），LFU（最不经常使用，即在一段时间内，被使用次数最少的缓存淘汰）</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;缓存雪崩：即缓存中同一时间有大量的数据失效，导致用户请求直接访问数据库，增大数据库的负荷，导致数据库宕机甚至整个系统的崩溃。</strong><strong>&nbsp;设置随机的失效时间，缓存更新，请求加锁</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;缓存穿透：即请求一条缓存中没有的数据，则会直接访问数据库，如果同一时间大量不存在的key访问缓存，就会都去访问数据库，导致数据库宕机。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;布隆过滤器：即用户请求访问缓存之前先经过布隆过滤器，如果发现数据库和缓存中都不存在该数据，则拒绝该请求。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;cache&nbsp; null：即如果访问的数据请求返回为null，则对null值也进行缓存，只不过需要给它设置一个短暂的失效时间这样在接收到相同的请求的时候，从缓存中读取返回null，不会访问数据库</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;缓存降级：当读操作增加的时候，我们先从缓存中读取，等到数据库恢复正常再从数据库读取</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;当写操作增加的时候，我们先从写入缓存，然后再异步的写入数据库。</strong></p>\n<p>&nbsp;</p>\n<h3><strong>思维导图：<a href=\"https://images-cdn.shimo.im/uourbKTxfdENHW8g__thumbnail\" target=\"_blank\" rel=\"noopener\">分布式缓存及原理</a></strong></h3>\n<h1><strong>水平有限，如有错误，还望指出！</strong></h1>","blogGoods":0,"blogId":"1250774653945802752","blogImage":"http://121.199.34.159/group1/M00/00/00/rBD3pF6dHSyAAWJ1AABJTVJPTfk093.jpg","blogRead":7,"blogRemark":"面试（八）------之分布式缓存的原理及应用","blogTitle":"面试（八）------之分布式缓存的原理及应用","createdTime":"2020-04-16 13:14:51","typeName":"java面试篇","updateTime":"2020-04-20 17:22:08"}],"pageSize":10,"params":{},"sortColumn":"blog_read","sortMethod":"DESC","totalCount":53,"totalPage":6},"msg":"操作成功!"}
2020-04-26 23:27:44.205 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /comment/list
2020-04-26 23:27:44.205 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:27:44.205 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:27:44.206 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.CommentController.getCommentList
2020-04-26 23:27:44.206 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=null, params={}, sortColumn=null, sortMethod=ASC)]
2020-04-26 23:27:44.244 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 39
2020-04-26 23:27:44.245 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[],"pageSize":10,"params":{},"sortMethod":"ASC","totalCount":0,"totalPage":0},"msg":"操作成功!"}
2020-04-26 23:27:46.948 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /rotation-picture/list
2020-04-26 23:27:46.949 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:27:46.949 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:27:46.949 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.RotationPictureController.getRotationPictureList
2020-04-26 23:27:46.950 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:27:47.043 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 95
2020-04-26 23:27:47.043 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"createdTime":"2020-04-08 02:07:31","enable":0,"rotationId":1,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMeGALlMgAB3vNI2iaCs718.gif"},{"createdTime":"2020-04-09 13:31:10","enable":0,"rotationId":3,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PI5KAYzGaAAGfH751PIw644.jpg"},{"createdTime":"2020-04-09 13:31:20","enable":1,"rotationId":4,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PI6aAZIz1AASCO4hlpJI295.jpg"},{"createdTime":"2020-04-09 13:37:02","enable":1,"rotationId":9,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJPyAbm8fAAG9gfO8lxE28.jpeg"},{"createdTime":"2020-04-09 13:41:30","enable":1,"rotationId":10,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJgeAeG8wAAS2pjJC5QU547.jpg"},{"createdTime":"2020-04-09 13:41:38","enable":1,"rotationId":11,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhGAQFZbAAP2OOBWb6k310.jpg"},{"createdTime":"2020-04-09 13:41:50","enable":1,"rotationId":12,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhyABMZCAAG7doyXiM8109.jpg"},{"createdTime":"2020-04-09 13:41:59","enable":1,"rotationId":13,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJiWAL7BoAARW3_O3ISw651.jpg"}],"msg":"操作成功!"}
2020-04-26 23:28:00.557 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /rotation-picture/delete/1
2020-04-26 23:28:00.557 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : DELETE
2020-04-26 23:28:00.557 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:28:00.558 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.RotationPictureController.deleteRotationPicture
2020-04-26 23:28:00.558 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[1]
2020-04-26 23:28:00.699 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 142
2020-04-26 23:28:00.700 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"msg":"删除成功!"}
2020-04-26 23:28:00.842 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /rotation-picture/list
2020-04-26 23:28:00.842 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:28:00.842 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:28:00.842 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.RotationPictureController.getRotationPictureList
2020-04-26 23:28:00.842 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:28:00.932 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 90
2020-04-26 23:28:00.933 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"createdTime":"2020-04-09 13:31:10","enable":0,"rotationId":3,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PI5KAYzGaAAGfH751PIw644.jpg"},{"createdTime":"2020-04-09 13:31:20","enable":1,"rotationId":4,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PI6aAZIz1AASCO4hlpJI295.jpg"},{"createdTime":"2020-04-09 13:37:02","enable":1,"rotationId":9,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJPyAbm8fAAG9gfO8lxE28.jpeg"},{"createdTime":"2020-04-09 13:41:30","enable":1,"rotationId":10,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJgeAeG8wAAS2pjJC5QU547.jpg"},{"createdTime":"2020-04-09 13:41:38","enable":1,"rotationId":11,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhGAQFZbAAP2OOBWb6k310.jpg"},{"createdTime":"2020-04-09 13:41:50","enable":1,"rotationId":12,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhyABMZCAAG7doyXiM8109.jpg"},{"createdTime":"2020-04-09 13:41:59","enable":1,"rotationId":13,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJiWAL7BoAARW3_O3ISw651.jpg"}],"msg":"操作成功!"}
2020-04-26 23:28:04.265 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /rotation-picture/delete/3
2020-04-26 23:28:04.265 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : DELETE
2020-04-26 23:28:04.266 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:28:04.266 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.RotationPictureController.deleteRotationPicture
2020-04-26 23:28:04.266 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[3]
2020-04-26 23:28:04.403 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 138
2020-04-26 23:28:04.404 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"msg":"删除成功!"}
2020-04-26 23:28:04.549 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /rotation-picture/list
2020-04-26 23:28:04.550 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:28:04.550 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:28:04.550 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.RotationPictureController.getRotationPictureList
2020-04-26 23:28:04.551 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:28:04.641 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 92
2020-04-26 23:28:04.641 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"createdTime":"2020-04-09 13:31:20","enable":1,"rotationId":4,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PI6aAZIz1AASCO4hlpJI295.jpg"},{"createdTime":"2020-04-09 13:37:02","enable":1,"rotationId":9,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJPyAbm8fAAG9gfO8lxE28.jpeg"},{"createdTime":"2020-04-09 13:41:30","enable":1,"rotationId":10,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJgeAeG8wAAS2pjJC5QU547.jpg"},{"createdTime":"2020-04-09 13:41:38","enable":1,"rotationId":11,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhGAQFZbAAP2OOBWb6k310.jpg"},{"createdTime":"2020-04-09 13:41:50","enable":1,"rotationId":12,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhyABMZCAAG7doyXiM8109.jpg"},{"createdTime":"2020-04-09 13:41:59","enable":1,"rotationId":13,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJiWAL7BoAARW3_O3ISw651.jpg"}],"msg":"操作成功!"}
2020-04-26 23:28:19.180 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /rotation-picture/listFront
2020-04-26 23:28:19.180 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /admin/getInfo
2020-04-26 23:28:19.181 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/list
2020-04-26 23:28:19.181 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:28:19.181 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:28:19.181 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:28:19.181 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:28:19.182 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:28:19.182 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:28:19.182 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.RotationPictureController.getRotationPictureListFront
2020-04-26 23:28:19.182 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogList
2020-04-26 23:28:19.182 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:28:19.182 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.AdminController.getInfo
2020-04-26 23:28:19.182 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=15, totalPage=0, totalCount=0, list=[], params={}, sortColumn=created_time, sortMethod=DESC)]
2020-04-26 23:28:19.182 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:28:19.232 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listFront
2020-04-26 23:28:19.232 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/recommendRead
2020-04-26 23:28:19.232 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:28:19.232 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:28:19.232 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:28:19.233 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:28:19.233 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeLists
2020-04-26 23:28:19.233 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.recommendRead
2020-04-26 23:28:19.233 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:28:19.233 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:28:19.237 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/getTotal
2020-04-26 23:28:19.238 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:28:19.238 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:28:19.239 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getTotal
2020-04-26 23:28:19.239 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:28:19.335 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 155
2020-04-26 23:28:19.335 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"createdTime":"2020-04-09 13:31:20","enable":1,"rotationId":4,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PI6aAZIz1AASCO4hlpJI295.jpg"},{"createdTime":"2020-04-09 13:37:02","enable":1,"rotationId":9,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJPyAbm8fAAG9gfO8lxE28.jpeg"},{"createdTime":"2020-04-09 13:41:30","enable":1,"rotationId":10,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJgeAeG8wAAS2pjJC5QU547.jpg"},{"createdTime":"2020-04-09 13:41:38","enable":1,"rotationId":11,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhGAQFZbAAP2OOBWb6k310.jpg"},{"createdTime":"2020-04-09 13:41:50","enable":1,"rotationId":12,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhyABMZCAAG7doyXiM8109.jpg"},{"createdTime":"2020-04-09 13:41:59","enable":1,"rotationId":13,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJiWAL7BoAARW3_O3ISw651.jpg"}],"msg":"操作成功!"}
2020-04-26 23:28:19.475 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 238
2020-04-26 23:28:19.476 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":53,"msg":"操作成功!"}
2020-04-26 23:28:19.748 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 567
2020-04-26 23:28:19.750 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，0~n-1中缺失的数字</strong></h2>\n<p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>\n<p>示例 1:</p>\n<p>输入: [0,1,3]<br />输出: 2<br />示例&nbsp;2:</p>\n<p>输入: [0,1,2,3,4,5,6,7,9]<br />输出: 8</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主能想到的并且写出来的方法有：使用map存储数组中的所有元素，然后遍历0-n-1找出不在map中的元素。此种方法时间复杂度O（N），空间复杂度O（N）-----垃圾</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 统计0-n-1所有数字的数字和，再统计数组中所有数字的数字和，两和只差即为所求数字，时间复杂度O（N），空间复杂度O（1）-----垃圾</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;最优解法（二分查找法）：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;通常来说，我们使用二分查找法是查找一个存在于数组中的元素，但是本题需要求不在数组中的一个元素，因此到这很多人就会迷惑，不知道该怎么求了。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;但是我们首先要搞明白二分查找法的本质是什么：1，并不局限于仅仅查找存在于数组中的元素；2，二分查找的本质是对数组根据mid中间值在某一条件上进行二分（例如：通常的num[mid]&gt;target或者nums[mid]&lt;target进行左右切分）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;因此明白这一点，就好解决问题了。拿到这道题，使用二分，我们首先想到的应该是寻找根据mid中间值进行二分的条件</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;审题：题目中提及数组为递增数组，而且0-n-1内的n个数字有一个不在数组中，则不在的这个数字之前的数字满足nums[i]=i即元素本身等于数组下标，而之后的数字nums[i]!=i,所以这就是进行二分的条件了</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 二分查找法\n     * 算法思想：二分查找法的本质是能够有一个条件将数组根据mid中间值进行左右切分\n     * 所以我们想到二分查找法之后，首先需要做的是找出切分数组的条件\n     * 题目中给出了数组是一个递增数组，且0-n-1内的n个数字有一个不在这个长度为n-1的数组内\n     * 因此，不在的这个元素其左边元素必有数组下标值等于元素本身即nums[i]=i\n     * 而不在的这个元素的右边必有nums[i]!=i\n     * 所以根据此条件进行划分数组即可\n     * @param nums\n     * @return\n     */\n    public static int missingNumber(int[] nums) {\n        int low = 0;\n        int high = nums.length-1;\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]==mid){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        return low;\n    }</code></pre>","blogGoods":0,"blogId":"1254063045920022528","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kUM-AON88AAAaZr2Bc1U903.jpg","blogRead":0,"blogRemark":"剑指offer----0~n-1中缺失的数字","blogTitle":"剑指offer----0~n-1中缺失的数字","createdTime":"2020-04-25 23:01:44","typeName":"LeetCode","updateTime":"2020-04-25 23:01:44"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，在排序数组中查找数字I</strong></h2>\n<p>统计一个数字在排序数组中出现的次数。</p>\n<p>示例 1:</p>\n<p>输入: nums = [5,7,7,8,8,10], target = 8<br />输出: 2<br />示例&nbsp;2:</p>\n<p>输入: nums = [5,7,7,8,8,10], target = 6<br />输出: 0</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解法一：直接遍历统计，时间复杂度为O（N）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 遍历数组\n     * 找到第一个与目标元素相等的元素，res+1\n     * 然后往后找到第一个与目标元素不相等的元素,返回res即可\n     * 时间复杂度为O(N)\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static int search(int[] nums, int target) {\n        int res = 0;\n        for (int num : nums) {\n            if(num==target){\n                res++;\n            }\n        }\n        return res;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解法二：二分法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：利用二分法查找数字在排序数组中的左边界Left和右边界Right.如下，如果要寻找数组中的8，则其左边界为left=2,有边界right=5.所以出现次数为right-left-1.时间复杂度为O（logN）</strong></p>\n<table style=\"width: 20%; border-collapse: collapse; margin-left: auto; margin-right: auto;\" border=\"1\" cellpadding=\"5\">\n<tbody>\n<tr>\n<td style=\"width: 16.6667%;\">5</td>\n<td style=\"width: 16.6667%;\">7</td>\n<td style=\"width: 16.6667%;\">7</td>\n<td style=\"width: 16.6667%;\">8</td>\n<td style=\"width: 16.6667%;\">8</td>\n<td style=\"width: 16.6667%;\">10</td>\n</tr>\n</tbody>\n</table>\n<pre class=\"language-java\"><code>    /**\n     * 二分查找法\n     * 时间复杂度为O（logN）\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static int search2(int[] nums, int target){\n        int low = 0;\n        int high = nums.length-1;\n        int left,right;\n        left = right = 0;\n        //一次二分\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]&lt;=target){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        right = low;\n\n        low = 0;\n        high = nums.length -1;\n        //二次二分\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]&lt;target){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        left = high;\n        return right -left -1;\n    }</code></pre>","blogGoods":0,"blogId":"1254055163115724800","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kSXiAYRyFAAAaZr2Bc1U379.jpg","blogRead":0,"blogRemark":"剑指offer----在排序数组中查找数字I----LeetCode34","blogTitle":"剑指offer----在排序数组中查找数字I----LeetCode34","createdTime":"2020-04-25 22:30:24","typeName":"LeetCode","updateTime":"2020-04-25 22:30:24"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，两个链表的第一个公共节点</strong></h2>\n<p><strong><img src=\"https://images-cdn.shimo.im/Wd1NC8pveQYp9iIL.png__thumbnail\" alt=\"示例图\" width=\"742\" height=\"241\" /></strong></p>\n<p><strong>这是我从官方截下的一张图，也是有些人疑惑的地方，因为官方这张图给出的公共节点为8，而大多数人看到这张图，认为公共节点应该是1.</strong></p>\n<p><strong>但是实际上这里的公共节点不仅要节点的value相等，同时还需要节点的地址相等。从图中可以看出两个1节点虽然值相等，但是地址却不同，因而不是公共节点</strong></p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解法一：双指针</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：初始化两个指针p1=headA,p2=headB</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;分别遍历两个链表，求出两个链表的长度l1,l2</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;然后重置p1,p2指针指向头节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;让长链表的指针先走多的步数（l1-l2或者l2-l1）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;然后让两个指针同时走，直到两者相遇，即找到公共节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解疑：弄清楚第一个value相等的节点和指针相遇的节点，这两种节点是不同的，指针相遇的节点，不仅包含value相等，同时地址也相等。（如图中的8）；而第一个value相等的节点则可能并不在同一个地址，因此不一定是公共节点</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法\n     * @param headA\n     * @param headB\n     * @return\n     */\n    public static ListNode getIntersectionNode2(ListNode headA, ListNode headB){\n        ListNode p1 =headA;\n        ListNode p2 = headB;\n        int l1 = 0;\n        int l2 = 0;\n        //计算链表1的长度\n        while(p1!=null){\n            l1++;\n            p1 = p1.next;\n        }\n        //计算链表2的长度\n        while(p2!=null){\n            l2++;\n            p2 = p2.next;\n        }\n        p1 = headA;\n        p2 = headB;\n        //让长链表指针先走长的步数\n        if(l1&gt;l2){\n            for (int i = 0; i &lt; l1-l2; i++) {\n                p1 = p1.next;\n            }\n        }else{\n            for (int i = 0; i &lt; l2-l1; i++) {\n                p2 = p2.next;\n            }\n        }\n        //然后让两个指针同时走，直到相遇\n        while(p1!=p2){\n            p1 = p1.next;\n            p2 = p2.next;\n        }\n        return p1;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;解法二（大神解法）：丘比特相遇法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;利用两个指针p1=headA,p2=headB,让两个指针同时走，</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果p1先走到底，就将p1置为headB，</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果p2,先走到底，就将p2置为headA,</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;当两个指针相遇的时候，他们就相爱了（当然是找到公共节点了）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法p1=headA,p2=headB\n     * 思想是：两个节点同时从各自的链表出发\n     * p1走到末尾时，回到headB的头部\n     * p2走到末尾时，回到headA的头部\n     * 两个指针相遇的时候，即使要找的公共节点\n     * @param headA\n     * @param headB\n     * @return\n     */\n    public static ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode p1 = headA;\n        ListNode p2 = headB;\n        while(p1!=p2){\n            p1 = (p1==null)?headB:p1.next;\n            p2 = (p2==null)?headA:p2.next;\n        }\n        return p1;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1253992797703364608","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kD2OADD3mAAAaZr2Bc1U709.jpg","blogRead":0,"blogRemark":"剑指offer----之两个链表的第一个公共节点----LeetCode160","blogTitle":"剑指offer----之两个链表的第一个公共节点----LeetCode160","createdTime":"2020-04-25 18:22:35","typeName":"LeetCode","updateTime":"2020-04-25 18:22:35"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，第一个只出现一次的字符</strong></h2>\n<p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。</p>\n<p>示例:</p>\n<p>s = \"abaccdeff\"<br />返回 \"b\"</p>\n<p>s = \"\" <br />返回 \" \"</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主现在发现，做一道算法题的时候，最重要的一步就是读题，审题，在草稿纸上写下自己的思路（当然那种望眼欲穿的大佬除外）。然后才开始动笔，对于IT人来说，真的，多将时间花费在思考上面，而不是无意义的重复搬砖。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;题目分析：看到这道题，抓住两个关键字：第一个，只出现一次。什么意思呢，例如\"abaccdeff\"，其中只出现一次的字符有'b','d','e'三个，然后在三个字符中第一个出现在字符串中的是'b'，因此本题的答案是'b'.</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法分析：根据题目分析，我们最直观的解法应该是，先找出字符串中只出现一次的字符，然后再找出只出现一次字符中，第一个在字符串中出现的。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;所以我们需要做两件事，一是统计字符串中各个字符的出现次数，并且记录；二，统计完毕后，找出第一个出现次数为1的字符，返回即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;因此我们既要存字符，还要存字符对应的出现次数，所以理所当然我们选择map集合。当然对于本题而言，因为求第一个出现一次的字符，所以我们更好的是可以使用LinkedHashMap。这样免去最后的一次遍历字符串</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;下面提供两种解法：三种解法都是使用map集合，但是略有不同</strong></p>\n<p><strong>LinkedHashMap：（这是博主写的，代码冗余，这里用来和大神的写法做比较，警醒自己）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 用LinkedHashMap\n     * 思想：遍历字符串，如果map为空或者map中不含当前字符，则将其存入map\n     * 如果map中已经含有当前字符，则从map中移除\n     * 最终map中只剩出现一次的字符\n     * 返货map中的第一个即可\n     * @param s\n     * @return\n     */\n    public static char firstUniqChar(String s) {\n        Map&lt;Character,Integer&gt;map = new LinkedHashMap&lt;&gt;();\n        for (int i = 0; i &lt; s.length(); i++) {\n            char ch = s.charAt(i);\n            if(map.isEmpty()||!map.containsKey(ch)){\n                map.put(ch,1);\n            }else{\n                Integer val = map.get(ch);\n                map.put(ch,++val);\n            }\n        }\n        //返回map中第一个元素即可\n        Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entries = map.entrySet();\n        for (Map.Entry&lt;Character, Integer&gt; entry : entries) {\n            if(entry.getValue()==1){\n                return entry.getKey();\n            }\n        }\n        return ' ';\n    }</code></pre>\n<p><strong>HashMap（大神解法）：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 哈希表法\n     * @param s\n     * @return\n     */\n    public char firstUniqChar2(String s) {\n        Map&lt;Character,Boolean&gt; map = new HashMap&lt;&gt;();\n        char[] chars = s.toCharArray();\n        for (char ch : chars) {\n            map.put(ch,!map.containsKey(ch));\n        }\n        for (char ch : chars) {\n            if(map.get(ch)){\n                return ch;\n            }\n        }\n        return ' ';\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;分析：首先，这里提供了两种解法，一种为LinkedHashMap，一种为HashMap，这两种解法的不同之处就在于最后获取值的时候，LinkedHashMap获取最终值是遍历LinkedHashMap的entrySet，但是HashMap获取最终值是遍历原字符串。因而当数据庞大的时候，显然使用LinkedHashMap性能更高。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;然后，再分析一下这两种解法不另外一个不同之处，没错！就是大神的解法中使用map存放key对应的value值是Boolean型！（<span style=\"background-color: #ffcc00;\">这个真的是神一般的存在</span>），既省去了计算次数的麻烦，同时最后取的时候也不需要判断次数。wc！同一种解法，为什么天差地别！</strong></p>","blogGoods":0,"blogId":"1253956468789600256","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6j7Y6ACrySAAAaZr2Bc1U825.jpg","blogRead":0,"blogRemark":"剑指offer----第一次只出现一次的字符","blogTitle":"剑指offer----第一次只出现一次的字符","createdTime":"2020-04-25 15:58:14","typeName":"LeetCode","updateTime":"2020-04-25 15:58:14"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，连续子数组的最大和</strong></h2>\n<p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>\n<p>要求时间复杂度为O(n)。</p>\n<p>示例1:</p>\n<p>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br />输出: 6<br />解释:&nbsp;连续子数组&nbsp;[4,-1,2,1] 的和最大，为&nbsp;6。</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;看到这道题，最简单的想法肯定是求出所有连续子数组的值，然后进行比较，找出最大的即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;但是随后会想到既然要找出所有的子数组，那么我们可以使用分治的思想，因为分治的分过程即可以得到所有子序列</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;随后，再深一步，既然可以分治的思想，分的过程即是递归的过程，而且子数组的最大值依赖与前一子数组，所以可以想到使用动态规划</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：设dp[i]为以nums[i]为结尾的最大子数组和，初始值dp[0] = nums[0]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;遍历数组，如果dp[i-1]&gt;=0。则说明前面的最大子数组对当前子数组有增益效果，所以dp[i] = dp[i-1]+nums[i]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果dp[i-1]&lt;0。说明前面的最大子数组对当前子数组有夫负效果，还不如nums[i]本身，所以dp[i]=nums[i]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主的这样的写法：时间复杂度为O（N），空间复杂度也为O（N），但是实际上不需要使用dp数组，使用nums原数组就行，所以可以减小空间复杂度为O（1）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 动态规划\n     * 算法思想：因为求的是连续子数组的最大和\n     * 所以我们可以设dp[i]为以nums[i]结尾的最大连续子数组\n     * 如果dp[i]&lt;=nums[i],dp[i]=nums[i]\n     * 如果dp[i]&gt;nums[i],则dp[i]=dp[i]+nums[i]\n     * @param nums\n     * @return\n     */\n    public static int maxSubArray(int[] nums) {\n        int[] dp  = new int[nums.length];\n        dp[0] = nums[0];\n        int res = nums[0];\n        for (int i = 1; i &lt; nums.length; i++) {\n            if(dp[i-1]&lt;0){\n                dp[i] = nums[i];\n            }else{\n                dp[i] = dp[i-1]+nums[i];\n            }\n            res = Math.max(res,dp[i]);\n        }\n        return res;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1253938714590175232","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6j3QSACLxRAAAaZr2Bc1U017.jpg","blogRead":0,"blogRemark":"剑指offer---连续子数组的最大和---LeetCode53","blogTitle":"剑指offer---连续子数组的最大和---LeetCode53","createdTime":"2020-04-25 14:47:41","typeName":"LeetCode","updateTime":"2020-04-25 14:47:41"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，最小的k个数</strong></h2>\n<p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>\n<p>示例 1：</p>\n<p>输入：arr = [3,2,1], k = 2<br />输出：[1,2] 或者 [2,1]<br />示例 2：</p>\n<p>输入：arr = [0,1,2,1], k = 1<br />输出：[0]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;1,可以采用快排的思想，将原数组按照升序排序，然后取出前k个数即可，时间复杂度为O（NlogN）。但是其实跟API中的sort方法好像差别不大</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 对原数组升序排序，然后取前k个元素\n     * @param arr\n     * @param k\n     * @return\n     */\n    public static int[] getLeastNumbers(int[] arr, int k) {\n        quickSort(arr,0,arr.length-1);\n        int[] result = new int[k];\n        for (int i = 0; i &lt; k; i++) {\n            result[i] = arr[i];\n        }\n        return result;\n    }\n\n    /**\n     * 快排\n     * @param nums\n     * @param low\n     * @param high\n     */\n    public static void quickSort(int[] nums,int low,int high){\n        int base = nums[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //先从右向左找到第一个小于基准元素的元素\n            while(L&lt;R&amp;&amp;nums[R]&gt;=base){\n                R--;\n            }\n            if(nums[R]&lt;base){\n                swap(nums,L,R);\n            }\n            //再从左向右找到第一个大于基准元素的元素\n            while(L&lt;R&amp;&amp;nums[L]&lt;=base){\n                L++;\n            }\n            if(nums[L]&gt;base){\n                swap(nums,L,R);\n            }\n        }\n        //左递归\n        if(L&gt;low){\n            quickSort(nums,low,L-1);\n        }\n        //右递归\n        if(high&gt;R){\n            quickSort(nums,R+1,high);\n        }\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>2，堆排序：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;先讲解一下堆排序：堆排序是一种完全二叉树的结构，常见的存在两种堆结构，小根堆（即满足arr[2i+1]&gt;=arr[i]&amp;&amp;arr[2i+2]&gt;=arr[i]），大根堆（即满足arr[2i+1]&lt;=arr[i]&amp;&amp;arr[2i+2]&lt;=arr[i]）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;基本算法思想：第一步，初始化堆，即堆初始化为大根堆或者小根堆（这里我们简称调整堆）；第二步，将堆顶元素与堆的末尾元素进行交换，然后重新调整堆。在java中堆通常用来实现优先级队列PriorityQueue(默认的采用小根堆，若想使用大根堆，需要在创建时实现comparator)</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;使用情况：这里以java中的优先级队列为例，堆的使用情况不能按照堆名断章取义，例如小根堆实际上是将元素升序存放，因为在算法第二步中将堆顶元素与末尾元素进行交换，然后重新调整，交换的堆顶元素为最小元素，也是最先从堆中进入队列的。所以小根堆适用于TOPk大的算法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;相反的，大根堆适用于TOPk小的算法，下面分别给出小根堆和大根堆的算法：</strong></p>\n<p><strong>小根堆：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 堆排序---小根堆\n     * @param nums\n     */\n    public static void HeapSort(int[] nums){\n        //先初始化堆\n        for (int i = nums.length/2-1; i &gt;=0 ; i--) {\n            adjustHeap(nums,i,nums.length);\n        }\n        //交换堆顶与末尾节点+重新调整为小根堆\n        for (int i = nums.length-1; i &gt;0; i--) {\n            //先交换\n            swap(nums,0,i);\n            //再调整\n            adjustHeap(nums,0,i);\n        }\n    }\n\n    /**\n     * 调整为小根堆\n     * @param nums\n     * @param i\n     * @param length\n     */\n    public static void adjustHeap(int[] nums,int i,int length){\n        int temp = nums[i];\n        for (int j = 2*i+1; j &lt; length; j=2*j+1) {\n            //找出左右节点中的最小值\n            if(j+1&lt;length&amp;&amp;nums[j]&gt;nums[j+1]){\n                j++;\n            }\n            if(nums[j]&lt;temp){\n                nums[i] = nums[j];\n                i = j;\n            }\n        }\n        nums[i] = temp;\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p><strong>大根堆：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 堆排序---大根堆\n     * @param nums\n     */\n    public static void heapSort(int[] nums){\n\n        //初始化堆的过程\n        for (int i = nums.length/2-1; i &gt;=0; i--) {\n            adjustHeap(nums,i,nums.length);\n        }\n        //调整+交换堆顶和末尾的元素\n        for (int i = nums.length-1; i &gt;0; i--) {\n            //先交换，再重新调整\n            swap(nums,0,i);\n            adjustHeap(nums,0,i);\n        }\n    }\n\n    /**\n     * 调整大顶堆的过程\n     * @param nums\n     * @param i\n     * @param length\n     */\n    public static void adjustHeap(int[] nums,int i,int length){\n        int temp = nums[i];\n        for (int j = 2*i+1; j &lt; length; j=2*j+1) {\n            //找出左右节点中的最大值\n            if(j+1&lt;length&amp;&amp;nums[j]&lt;nums[j+1]){\n                j++;\n            }\n            if(nums[j]&gt;temp){\n                nums[i] = nums[j];\n                i = j;\n            }\n        }\n        nums[i] = temp;\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>本题利用大根堆解法，且使用java中自带的优先级队列PriorityQueue：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用堆数据结构，java中的优先级队列对应着最小堆\n     * 实现其comparator即可\n     * @param arr\n     * @param k\n     * @return\n     */\n    public static int[] getLeastNumbers2(int[] arr, int k){\n        Queue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(k,(v1,v2)-&gt;v2-v1);\n        for (int i : arr) {\n            if(heap.isEmpty()||heap.size()&lt;k||i&lt;heap.peek()){\n                heap.offer(i);\n            }\n            if(heap.size()&gt;k){\n                heap.poll();\n            }\n        }\n        int[] result = new int[k];\n        int j = 0;\n        for (Integer val : heap) {\n            result[j++] = val;\n        }\n        return result;\n    }</code></pre>","blogGoods":0,"blogId":"1253874832811089920","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6joYWAF3oqAAAaZr2Bc1U671.jpg","blogRead":2,"blogRemark":"剑指offer----之最小的k个数","blogTitle":"剑指offer----之最小的k个数","createdTime":"2020-04-25 10:33:50","typeName":"LeetCode","updateTime":"2020-04-25 11:53:15"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，数组中出现次数超过一半的元素---即众数</strong></h2>\n<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>\n<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>\n<p>示例&nbsp;1:</p>\n<p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br />输出: 2</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>方法有三：哈希表统计法，数组排序法，摩尔投票法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;哈希统计法：时间复杂度O（N），空间复杂度O（N）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 博主刚开始看到这道题的时候，首先想到的是哈希表统计法，因为博主想的是要找到众数，那么肯定得统计每个数字的出现次数，然后按照次数比较。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 单单是想到这些，用了map集合之后发现还是不行，因为即便用map集合统计出了每个数字和其对应的出现次数之后，你会发现没有办法按照出现的次数进行比较并且得到次数最多的数字（众数</strong><strong>）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 然后，就又审了一遍题目，结果发现了一个本题很关键的点，（<span style=\"background-color: #ffcc00;\">数组中有一个数字出现的次数超过数组长度的一半</span>），也就是说数组中有且仅有一个数字的出现次数会超过数组长度的一半（别笑博主笨，我是真的刚开始没反应过来）</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 那么我为什么要把数组中的所有元素和其次数全部存放进入map集合，然后再取次数进行比较呢？我为什么不在将元素和其次数存入集合的过程中判断次数是否已经超过数组长度的一半了呢？如果超过一半了，那它肯定是众数了呀！</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 思路：根据题意需要找出两个东西，一是多素元素，二是多素元素的出现次数\n     * 所以我们首先想到的是采用map集合\n     * 然后遍历数组，如果元素不存在与集合中，我们就将其加入map，value置为1\n     * 如果元素存在于map中，则我们取出其value将其加1与数组长度的一半做比较\n     * 如果大于数组长度一半，直接返回该元素即可\n     * 小于数组长度一半，则将其value加1存入map覆盖原有的值即可\n     *\n     * @param nums\n     * @return\n     */\n    public static int majorityElement(int[] nums) {\n        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(nums.length);\n        for (int num : nums) {\n            if(!map.containsKey(num)){\n                map.put(num,1);\n            }else{\n                Integer val = map.get(num);\n                if(++val&gt;nums.length/2){\n                    return num;\n                }else{\n                    map.put(num,val);\n                }\n            }\n        }\n        throw new RuntimeException(\"\");\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>数组排序法：由题可知，数组众必然存在一个多数元素，且出现次数超过数组长度的一半。所以我们可以对原数组进行排序，然后取数组中间的元素即可。（我擦，我当时看到这个，就在想，好简单，这个思路，但是我为什么没想到，对，因为我没有仔细的分析题目，超过一半看见没）。既然进行排序，那么我们可以选择快排，这样时间复杂度就是O（NlogN），空间复杂度O（1）.</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 数组排序法，因为多数元素的出现次数超过数组长度一半，\n     * 所以我们可以先对其进行排序，采用快排，时间复杂度O（NlogN）\n     * 然后取数组中点元素即可\n     * @param nums\n     * @return\n     */\n    public static int majorityElement2(int[] nums){\n        quickSort(nums,0,nums.length-1);\n        return nums[nums.length/2];\n    }\n\n    /**\n     * 快排\n     * @param nums\n     * @param low\n     * @param high\n     */\n    public static void quickSort(int[] nums,int low,int high){\n        int base = nums[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //从右向左找到第一个比基准元素小的元素\n            while(L&lt;R&amp;&amp;nums[R]&gt;=base){\n                R--;\n            }\n            if(nums[R]&lt;base){\n                swap(nums,L,R);\n            }\n            //从左向右找到第一个比基准元素大的元素\n            while(L&lt;R&amp;&amp;nums[L]&lt;=base){\n                L++;\n            }\n            if(nums[L]&gt;base){\n                swap(nums,L,R);\n            }\n        }\n        //左递归\n        if(L&gt;low){\n            quickSort(nums,low,L-1);\n        }\n        //右递归\n        if(high&gt;R){\n            quickSort(nums,R+1,high);\n        }\n    }\n\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>摩尔投票法（我将其称为大佬解法）：大概的意思就是采用正负抵消的方法，设置一个投票变量votes，初始设置为0；设置一个本题中的众数变量x，初始设置为数组首元素。然后遍历数组，判断跟设置的众数变量是否相等，如果相等将votes加一，如果不相等，则重置votes为0，且将x设置为数组下一个元素。本题众因为已经声明了肯定存在众数，所以不需要进行验证，但是如果没有声明的话，需要验证，下列代码众添加了验证：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 摩尔投票法\n     * @param nums\n     */\n    public static int majorityElement3(int[] nums){\n        int votes = 0;\n        int x = nums[0];\n        int count = 0;\n        for (int num : nums) {\n            if(votes==0){\n                x = num;\n            }\n            votes+=(num==x)?1:-1;\n        }\n        //验证数组众是否存在众数\n        for (int num : nums) {\n            if(num==x){\n                count++;\n            }\n        }\n        return count&gt;nums.length/2?x:0;\n    }</code></pre>","blogGoods":0,"blogId":"1253674617332162560","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6i5v-AUh39AAAaZr2Bc1U885.jpg","blogRead":0,"blogRemark":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","blogTitle":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","createdTime":"2020-04-24 21:18:14","typeName":"LeetCode","updateTime":"2020-04-24 21:18:14"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，从上到下打印二叉树-2</strong></h2>\n<p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>\n<p>例如:<br />给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>\n<p>3<br />/ \\<br />9 20<br />/ \\<br />15 7<br />返回其层次遍历结果：</p>\n<p>[<br />[3],<br />[9,20],<br />[15,7]<br />]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;BFS（广度优先搜索）：层次遍历</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * BFS\n     * @param root\n     * @return\n     */\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {\n        if (root == null) {\n            return new ArrayList&lt;&gt;(0);\n        }\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();\n        TreeNode current;\n        while (!queue.isEmpty()) {\n            List&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();\n            for (int i = queue.size(); i &gt; 0; i--) {\n                current = queue.poll();\n                arrayList.add(current.val);\n                if (current.left != null) {\n                    queue.add(current.left);\n                }\n                if (current.right != null) {\n                    queue.add(current.right);\n                }\n            }\n            list.add(arrayList);\n        }\n        return list;\n    }</code></pre>","blogGoods":0,"blogId":"1253350612905598976","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6huUyATZJ_AAAaZr2Bc1U363.jpg","blogRead":1,"blogRemark":"剑指offer----之从上到下打印二叉树----LeetCode102","blogTitle":"剑指offer----之从上到下打印二叉树----LeetCode102","createdTime":"2020-04-23 23:50:45","typeName":"LeetCode","updateTime":"2020-04-23 23:50:57"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，从上打印二叉树-1</strong></h2>\n<p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>\n<p>例如:<br />给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>\n<p>3<br />/ \\<br />9 20<br />/ \\<br />15 7<br />返回：</p>\n<p>[3,9,20,15,7]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;BFS（广度优先搜索）：也即是二叉树的层次遍历，代码和注意事项看代码注释</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 二叉树的层次遍历\n     * 这里是将层次遍历的结果存储在数组中\n     * 但是因为二叉树的节点个数并不知道\n     * 所以不能使用数组直接进行存储，因为无法初始化数组的大小\n     * 所以可以想到使用容量能自动扩充的list集合\n     * 然后再根据list集合的size来初始化数组的大小\n     * 并且将list元素赋值到数组中\n     * @param root\n     * @return\n     */\n    public static int[] levelOrder(TreeNode root) {\n        if(root==null){\n            return new int[0];\n        }\n        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n        TreeNode current;\n        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n        while(!queue.isEmpty()){\n            current = queue.poll();\n            list.add(current.val);\n            if(current.left!=null){\n                queue.add(current.left);\n            }\n            if(current.right!=null){\n                queue.add(current.right);\n            }\n        }\n        int[] result = new int[list.size()];\n        for (int i = 0; i &lt; list.size(); i++) {\n            result[i] = list.get(i);\n        }\n        return result;\n    }</code></pre>","blogGoods":0,"blogId":"1253346228108894208","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6htTeAUHGlAAAaZr2Bc1U102.jpg","blogRead":0,"blogRemark":"剑指offer----之从上到下打印二叉树","blogTitle":"剑指offer----之从上到下打印二叉树","createdTime":"2020-04-23 23:33:20","typeName":"LeetCode","updateTime":"2020-04-23 23:33:20"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，包含min函数的栈</strong></h2>\n<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>\n<p>&nbsp;</p>\n<p>示例:</p>\n<p>MinStack minStack = new MinStack();<br />minStack.push(-2);<br />minStack.push(0);<br />minStack.push(-3);<br />minStack.min(); --&gt; 返回 -3.<br />minStack.pop();<br />minStack.top(); --&gt; 返回 0.<br />minStack.min(); --&gt; 返回 -2.</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>&nbsp;辅助栈法：即初始化两个栈A,B</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;A栈用于实现基本的push(),pop(),top()的正常逻辑</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;B栈用来存放A栈中的非严格降序元素（这个我也理解不了，看代码就知道是存放什么的啦），代码中的方法注释很清楚</strong></p>\n<pre class=\"language-java\"><code>public class MinStack {\n    /** initialize your data structure here. */\n    Stack&lt;Integer&gt; A,B;\n\n    public MinStack() {\n        A = new Stack&lt;&gt;();\n        B = new Stack&lt;&gt;();\n    }\n\n    /**\n     * 入栈操作，元素先入A栈\n     * 如果B栈为空或者B栈的栈顶元素大于待入栈元素，则B栈也执行入栈操作\n     * @param x\n     */\n    public void push(int x) {\n        A.add(x);\n        if(B.isEmpty()||B.peek()&gt;=x){\n            B.add(x);\n        }\n    }\n\n    /**\n     * 这段代码优点巧妙\n     * 注意这里使用的A.pop()而不是A.peek()\n     * 所以这里实际上是分为两种情况的\n     * 第一种：当A的栈顶元素不为当前栈中的最小元素，即不等于栈B的栈顶元素\n     *         则只进行栈A的出栈操作，即A.pop()\n     * 第二种：当A的栈顶元素为当前栈中的最小元素，即等于栈B的栈顶元素\n     *        则不仅要A.pop(),而且为了保证A,B栈中最小元素的同步性\n     *        B栈也要执行出栈操作\n     */\n    public void pop() {\n        if(A.pop().equals(B.peek())){\n            B.pop();\n        }\n    }\n\n    /**\n     * 正常获取A的栈顶元素\n     * @return\n     */\n    public int top() {\n        return A.peek();\n    }\n\n    /**\n     * 获取A栈的最小元素，即B栈的栈顶元素\n     * @return\n     */\n    public int min() {\n        return B.peek();\n    }\n}</code></pre>","blogGoods":0,"blogId":"1253331349566234624","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hp12AMy2MAAAaZr2Bc1U568.jpg","blogRead":4,"blogRemark":"剑指offer----之包含min函数的栈---LeetCode155","blogTitle":"剑指offer----之包含min函数的栈---LeetCode155","createdTime":"2020-04-23 22:34:13","typeName":"LeetCode","updateTime":"2020-04-23 23:50:51"},{"blogCollection":0,"blogComment":0,"blogContent":"<h3><strong>晚上九点多，坐在床上，面前摆放着电脑，屏幕显示的是LeetCode中的《剑指offer》的题解</strong></h3>\n<h3><strong>此时的我毫无睡意，当然，这并不是因为解出一道题的喜悦冲淡了我的睡意</strong></h3>\n<h3><strong>相反的，这是一种难以言明的心情，包含着对自己无知的羞愧，也包含着别人面对如此无知的自己也能给出耐心回应的感动</strong></h3>\n<h3><strong>人有时或许就是这样，刻意的举动会让人心生防备，但是无意的善举却能温润人心</strong></h3>\n<h3><strong>别人无意的一个回答，一个小举动，一句肯定的话</strong></h3>\n<h3><strong>殊不知却能为对方赋予无穷无尽的能量</strong></h3>\n<h3><strong>将这一天的疲惫和劳累都消除</strong></h3>\n<h3><strong>赠人玫瑰，手有余香</strong></h3>\n<h3><strong>我一直抱着这样的一种心态，或许我无法做到赠人玫瑰，但是我会尽量将自己的善意展现给别人</strong></h3>\n<h3><strong>也许他刚刚好正处于某个难关，而你又刚刚好是他难关之初的引导者</strong></h3>\n<h3><strong>一句话，或许对于你来说只是人生中微不足道的几秒钟</strong></h3>\n<h3><strong>而对他来说，或许可能是多年之后回忆起来也能嘴角上扬的美好岁月</strong></h3>\n<h3><strong>想起前段时间一部剧里面的话，在这里也送给屏幕前的你：愿你永怀善意，清澈明朗</strong></h3>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1253326423486144512","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hosWANYd2AAHQzo49lBU641.jpg","blogRead":3,"blogRemark":"2020-4-23有感","blogTitle":"2020-4-23有感","createdTime":"2020-04-23 22:14:38","typeName":"随心日记","updateTime":"2020-04-25 21:22:30"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，顺时针打印矩阵</strong></h2>\n<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>\n<p>示例 1：</p>\n<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br />输出：[1,2,3,6,9,8,7,4,5]<br />示例 2：</p>\n<p>输入：matrix =&nbsp;[[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br />输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p>\n<p>限制：</p>\n<p>0 &lt;= matrix.length &lt;= 100<br />0 &lt;= matrix[i].length&nbsp;&lt;= 100</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;模拟顺时针打印的这种循环结构：设置四个边界条件，l,r,t,b。按照从左往右，从上往下，从右往左，从下网往上的顺序依次读取矩阵的元素，并且每一次都判断边界是否相遇，直到将整个矩阵元素都加入到数组中即可。</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 设置四个边界值，分别为left=0,right=matrix[0].length-1,top=0,bottom=matrix.length-1\n     * 顺时针顺序即先从左到右，再从上到下，再从右向左，再从下向上，每一次执行都要判断边界值\n     * @param matrix\n     * @return\n     */\n    public static int[] spiralOrder(int[][] matrix) {\n        if(matrix.length==0){\n            return new int[0];\n        }\n        int l = 0;\n        int r=matrix[0].length-1;\n        int t=0;\n        int b=matrix.length-1;\n        int x=0;\n        int[] res = new int[(r+1)*(b+1)];\n        while(true){\n            //从左向右\n            for(int i=l;i&lt;=r;i++){\n                res[x++]=matrix[t][i];\n            }\n            if(++t&gt;b) {\n                break;\n            }\n            //从上向下\n            for(int i=t;i&lt;=b;i++){\n                res[x++] = matrix[i][r];\n            }\n            if(--r&lt;l){\n                break;\n            }\n            //从右向左\n            for(int i=r;i&gt;=l;i--){\n                res[x++] = matrix[b][i];\n            }\n            if(--b&lt;t){\n                break;\n            }\n            //从下往上\n            for(int i=b;i&gt;=t;i--){\n                res[x++] = matrix[i][l];\n            }\n            if(++l&gt;r){\n                break;\n            }\n        }\n        return res;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1253250557729087488","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hXB2ASIQwAAAaZr2Bc1U016.jpg","blogRead":0,"blogRemark":"剑指offer-----之顺时针打印矩阵----LeetCode54","blogTitle":"剑指offer-----之顺时针打印矩阵----LeetCode54","createdTime":"2020-04-23 17:13:11","typeName":"LeetCode","updateTime":"2020-04-23 17:13:11"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，对称的二叉树</strong></h2>\n<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>\n<p>例如，二叉树&nbsp;[1,2,2,3,4,4,3] 是对称的。</p>\n<p>&nbsp; &nbsp; 1<br />&nbsp; &nbsp;/ \\<br />&nbsp; 2 &nbsp; 2<br />&nbsp;/ \\ / \\<br />3 &nbsp;4 4 &nbsp;3<br />但是下面这个&nbsp;[1,2,2,null,3,null,3] 则不是镜像对称的:</p>\n<p>&nbsp; &nbsp; 1<br />&nbsp; &nbsp;/ \\<br />&nbsp; 2 &nbsp; 2<br />&nbsp; &nbsp;\\ &nbsp; \\<br />&nbsp; &nbsp;3 &nbsp; &nbsp;3</p>\n<p>示例 1：</p>\n<p>输入：root = [1,2,2,3,4,4,3]<br />输出：true<br />示例 2：</p>\n<p>输入：root = [1,2,2,null,3,null,3]<br />输出：false</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>递归法：从对称的二叉树中我们可以找到如下规律</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果一个二叉树是对称的，则每一个节点的左右子树也是对称的,因此是递归的</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 设L = root.left，R=root.right，则满足L.left.val = R.right.val;L.right.val=R.left.val;</strong></p>\n<pre class=\"language-java\"><code>public boolean isSymmetric(TreeNode root) {\n        return  root==null?true:recur(root.left,root.right);\n    }\n    public boolean recur(TreeNode L,TreeNode R){\n        if(L==null&amp;&amp;R==null){\n            return true;\n        }\n        if(L==null||R==null||L.val!=R.val){\n            return false;\n        }\n        return recur(L.left,R.right)&amp;&amp;recur(L.right,R.left);\n    }</code></pre>","blogGoods":0,"blogId":"1252992659794968576","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6ga--AKQdvAAAaZr2Bc1U862.jpg","blogRead":1,"blogRemark":"剑指offer----之对称的二叉树----LeetCode101","blogTitle":"剑指offer----之对称的二叉树----LeetCode101","createdTime":"2020-04-23 00:08:23","typeName":"LeetCode","updateTime":"2020-04-23 00:12:33"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，二叉树镜像</strong></h2>\n<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>\n<p>例如输入：</p>\n<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; 2 &nbsp; &nbsp; 7<br />&nbsp;/ \\ &nbsp; / \\<br />1 &nbsp; 3 6 &nbsp; 9<br />镜像输出：</p>\n<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; 7 &nbsp; &nbsp; 2<br />&nbsp;/ \\ &nbsp; / \\<br />9 &nbsp; 6 3&nbsp; &nbsp;1</p>\n<p>示例 1：</p>\n<p>输入：root = [4,2,7,1,3,6,9]<br />输出：[4,7,2,9,6,3,1]</p>\n<p>限制：</p>\n<p>0 &lt;= 节点个数 &lt;= 1000</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;递归法：即递归的去交换根节点的左右子树，直到根节点为叶子节点</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用递归的方法，交换根节点的左子树和右子树\n     * 递归出口为，根节点为叶子节点\n     * @param root\n     * @return\n     */\n    public TreeNode mirrorTree(TreeNode root) {\n        TreeNode center = root;\n        if(center!=null){\n            TreeNode temp = center.left;\n            center.left = center.right;\n            center.right = temp;\n            mirrorTree(center.left);\n            mirrorTree(center.right);\n        }\n        return root;\n    }</code></pre>","blogGoods":0,"blogId":"1252985443281027072","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6gZTWABF55AAAaZr2Bc1U678.jpg","blogRead":0,"blogRemark":"剑指offer----之二叉树的镜像----LeetCode226","blogTitle":"剑指offer----之二叉树的镜像----LeetCode226","createdTime":"2020-04-22 23:39:43","typeName":"LeetCode","updateTime":"2020-04-22 23:39:43"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，合并两个有序链表</strong></h2>\n<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>\n<p>示例1：</p>\n<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br />输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br />限制：</p>\n<p>0 &lt;= 链表长度 &lt;= 1000</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>伪头节点法：即创建一个伪头节点head和一个用于辅助的节点cur</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法：如果l1.val&lt;=l2.val,就让cur指向l1，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l1指向其next</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果l1.val&gt;l2.val,就让cur指向l2，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l2指向其next</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;直到l1和l2有一个为空为止，让cur指向剩余的一个非空链表即可，若两个链表的长度为M,N则时间复杂度为O(M+N)</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用四节点，一个伪头节点，一个当前节点cur，已经链表的两个节点l1,l2\n     * 每次比较l1,l2节点的val大小，将小的节点连接到当前节点cur上即可\n     * 直到l1,l2有一个空，则将剩余的一个非空链表连接到cur尾部即可\n     * @param l1\n     * @param l2\n     * @return\n     */\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode head;\n        ListNode cur;\n        head = cur = new ListNode(0);\n        while(l1!=null&amp;&amp;l2!=null){\n            if(l1.val&lt;=l2.val){\n                cur.next = l1;\n                cur = cur.next;\n                l1 = l1.next;\n            }else{\n                cur.next = l2;\n                cur = cur.next;\n                l2 = l2.next;\n            }\n        }\n        if(l1!=null){\n            cur.next = l1;\n        }\n        if(l2!=null){\n            cur.next = l2;\n        }\n        return head.next;\n    }</code></pre>","blogGoods":0,"blogId":"1252980258446000128","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6gYGWAe-MZAAAaZr2Bc1U550.jpg","blogRead":0,"blogRemark":"剑指offer----之合并有序链表---LeetCode21","blogTitle":"剑指offer----之合并有序链表---LeetCode21","createdTime":"2020-04-22 23:19:06","typeName":"LeetCode","updateTime":"2020-04-22 23:19:06"}],"pageSize":15,"params":{},"sortColumn":"created_time","sortMethod":"DESC","totalCount":53,"totalPage":4},"msg":"操作成功!"}
2020-04-26 23:28:19.991 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /music/listFront
2020-04-26 23:28:19.991 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:28:19.992 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:28:19.993 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.MusicController.getMusicList
2020-04-26 23:28:19.993 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:28:20.148 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /link/list
2020-04-26 23:28:20.149 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:28:20.149 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:28:20.149 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.LinkController.getLinkList
2020-04-26 23:28:20.149 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:28:20.152 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 161
2020-04-26 23:28:20.153 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"artist":"周深","cover":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMh2AFeEFAAAZaWcYmAM180.jpg","id":1,"lrc":"[00:00.37]周深 - 直破穹苍 (《斗破苍穹》动画第三季主题曲)\n[00:02.79]作词：冥凰\n[00:03.86]作曲：李建衡\n[00:05.19]编曲：崔博源、李建衡\n[00:07.13]人声录制：徐威@上海V-Studio\n[00:09.23]监唱：徐威@上海V-Studio\n[00:11.38]混音：周天澈@Studio21A\n[00:24.13]有没有想过 穿越这片沙漠\n[00:32.21]前方是什么\n[00:35.16]是就此陨落\n[00:37.97]还是抓牢命运脉搏\n[00:45.38]他曾经 爱过 恨过 痛过\n[00:51.07]直到望见远处那抹焰火\n[00:56.73]也许这 是祸 是过 是错\n[01:02.41]仍不害怕 去烧灼\n[01:08.50]管那六合八荒 斗一场\n[01:14.06]焰分噬浪谁能抗\n[01:19.28]漫却这漫漫险关 莫登攀\n[01:24.88]他欲乘风 直破穹苍\n[01:43.04]太多的纠葛 太多悲欢离合\n[01:51.39]要人太执着\n[01:54.21]该如何选择\n[01:57.02]才能看清是非漩涡\n[02:04.58]他曾经 哭过 泪过 笑过\n[02:10.16]直到紧握手心那抹焰火\n[02:15.77]走遍这 荒山 大漠 湖泊\n[02:21.49]仍不退缩 去冲破\n[02:27.44]管那龙潭虎穴 斗一场\n[02:32.72]生死福祸也跌宕\n[02:38.28]漫却他太多如果 都过往\n[02:43.86]还来惊诧 满堂\n[02:50.00]管那六合八荒 斗一场\n[02:55.22]焰分噬浪谁能抗\n[03:00.85]漫却这漫漫险关 莫登攀\n[03:06.51]他欲乘风 直破穹苍","name":"直破苍穹","url":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMlWAC1FrAr8ypaThmW479.flac"},{"artist":"冷鸢","cover":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMnWAa32EAABwmk6a5Cs834.jpg","id":2,"lrc":"你是信的开头诗的内容\n童话的结尾\n你是理所当然的奇迹\n你是月色真美\n你是圣诞老人送给我\n好孩子的礼物\n你是三千美丽世界里\n我的一瓢水\n所以让我再靠近一点点\n因为你太温暖\n我会再变得坚强一点点\n因为你太柔软\n交换无名指金色的契约\n给彼此岁月\n说好从今以后都牵着手\n因为要走很远\n你是我万水千山的冒险\n要找的标记点\n你是分割我人生的线\n又将它们相连\n你是前世千次的回眸\n虔诚牵的手\n你是其余所有的一切\n是我的世界\n所以请你再闪亮一点点\n尽管我太平凡\n我会再变得柔软一点点\n因为你太敏感\n交换无名指金色的契约\n给彼此岁月\n说好从今以后都牵着手\n不管要走多远\n让我再靠近一点点\n因为你太温暖\n我会再变得坚强一点点\n因为你太柔软\n交换无名指金色的契约\n给彼此岁月\n说好从今以后都牵着手\n因为要走很远","name":"勾指起誓","url":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMomAGXdvAHZQ_9pwL9c866.mp3"}],"msg":"操作成功!"}
2020-04-26 23:28:20.289 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 141
2020-04-26 23:28:20.290 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"createdTime":"2020-04-08 02:11:26","linkId":1,"linkName":"百度","linkUrl":"www.baidu.com","updateTime":"2020-04-08 02:11:26","version":1},{"createdTime":"2020-04-18 21:39:52","linkId":2,"linkName":"CSDN","linkUrl":"https://www.csdn.net/","updateTime":"2020-04-18 21:39:52","version":1}],"msg":"操作成功!"}
2020-04-26 23:28:20.357 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 1177
2020-04-26 23:28:20.357 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"header":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMSKACehsAACHOzTvceE295.jpg","id":1,"name":"小屋","signature":"时光好不经用，转眼已是半生","username":"admin"},"msg":"操作成功!"}
2020-04-26 23:28:20.428 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 1196
2020-04-26 23:28:20.429 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1248605157059497984","blogRead":27,"blogTitle":"面试（二）------之JAVA基础篇","createdTime":"2020-04-10 13:34:02","typeName":"java面试篇"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1247745014683947008","blogRead":21,"blogTitle":"博客开发总结（一）-----之数据库设计篇","createdTime":"2020-04-08 04:36:07","typeName":"博客开发和维护总结"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1248224512563068928","blogRead":17,"blogTitle":"面试（一）------之JVM篇","createdTime":"2020-04-09 12:21:30","typeName":"java面试篇"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1249742755949817856","blogRead":17,"blogTitle":"面试（三）------之并发编程篇（下）","createdTime":"2020-04-13 16:54:26","typeName":"java面试篇"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1250622112591376384","blogRead":8,"blogTitle":"面试（六）------之网络与负载均衡","createdTime":"2020-04-16 03:08:42","typeName":"java面试篇"}],"msg":"操作成功!"}
2020-04-26 23:28:20.499 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 1268
2020-04-26 23:28:20.500 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":1,"typeName":"Linux"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":2,"typeName":"Docker"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"SpringBoot"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":4,"typeName":"Mybatis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":5,"typeName":"爬虫"},{"deleted":0,"enable":1,"typeBlogCount":4,"typeId":6,"typeName":"博客开发和维护总结"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":7,"typeName":"CSS"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"JavaScript"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Vue"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":10,"typeName":"随笔"},{"deleted":0,"enable":1,"typeBlogCount":16,"typeId":11,"typeName":"java面试篇"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":13,"typeName":"JDK源码阅读"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":14,"typeName":"redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":15,"typeName":"MongoDB"},{"deleted":0,"enable":1,"typeBlogCount":28,"typeId":16,"typeName":"LeetCode"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":17,"typeName":"随心日记"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":18,"typeName":"计算机网络"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":19,"typeName":"操作系统"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":20,"typeName":"数据结构"}],"msg":"操作成功!"}
2020-04-26 23:28:34.086 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /user/login
2020-04-26 23:28:34.088 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:28:34.088 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:28:34.088 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.UserController.login
2020-04-26 23:28:34.088 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[User(userId=null, username=admin, password=123456, name=null, sex=null, header=null, nickname=null, userEmail=null, createdTime=null, updateTime=null, version=null, deleted=null)]
2020-04-26 23:28:34.188 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 102
2020-04-26 23:28:34.189 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"user":{"header":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NWkaAJPVvAANwwcjPp-g88.jpeg","name":"","nickname":"小屋","password":"","sex":1,"userEmail":"570857634@qq.com","userId":1,"username":"admin"},"token":"40CB82BDD0C6A552A4BE107B0AF48B21"},"msg":"操作成功!"}
2020-04-26 23:28:34.625 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /rotation-picture/listFront
2020-04-26 23:28:34.626 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:28:34.627 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:28:34.627 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.RotationPictureController.getRotationPictureListFront
2020-04-26 23:28:34.627 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:28:34.717 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 92
2020-04-26 23:28:34.718 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"createdTime":"2020-04-09 13:31:20","enable":1,"rotationId":4,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PI6aAZIz1AASCO4hlpJI295.jpg"},{"createdTime":"2020-04-09 13:37:02","enable":1,"rotationId":9,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJPyAbm8fAAG9gfO8lxE28.jpeg"},{"createdTime":"2020-04-09 13:41:30","enable":1,"rotationId":10,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJgeAeG8wAAS2pjJC5QU547.jpg"},{"createdTime":"2020-04-09 13:41:38","enable":1,"rotationId":11,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhGAQFZbAAP2OOBWb6k310.jpg"},{"createdTime":"2020-04-09 13:41:50","enable":1,"rotationId":12,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhyABMZCAAG7doyXiM8109.jpg"},{"createdTime":"2020-04-09 13:41:59","enable":1,"rotationId":13,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJiWAL7BoAARW3_O3ISw651.jpg"}],"msg":"操作成功!"}
2020-04-26 23:28:34.934 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/list
2020-04-26 23:28:34.934 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /admin/getInfo
2020-04-26 23:28:34.934 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:28:34.934 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:28:34.935 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:28:34.935 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:28:34.935 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogList
2020-04-26 23:28:34.935 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.AdminController.getInfo
2020-04-26 23:28:34.935 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=15, totalPage=0, totalCount=0, list=[], params={}, sortColumn=created_time, sortMethod=DESC)]
2020-04-26 23:28:34.935 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:28:34.942 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/getTotal
2020-04-26 23:28:34.942 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/recommendRead
2020-04-26 23:28:34.942 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listFront
2020-04-26 23:28:34.943 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:28:34.943 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:28:34.943 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:28:34.943 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:28:34.943 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:28:34.943 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:28:34.943 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getTotal
2020-04-26 23:28:34.943 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeLists
2020-04-26 23:28:34.943 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.recommendRead
2020-04-26 23:28:34.943 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:28:34.943 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:28:34.943 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:28:35.263 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 321
2020-04-26 23:28:35.263 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 329
2020-04-26 23:28:35.263 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":53,"msg":"操作成功!"}
2020-04-26 23:28:35.263 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"header":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMSKACehsAACHOzTvceE295.jpg","id":1,"name":"小屋","signature":"时光好不经用，转眼已是半生","username":"admin"},"msg":"操作成功!"}
2020-04-26 23:28:35.353 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 411
2020-04-26 23:28:35.353 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":1,"typeName":"Linux"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":2,"typeName":"Docker"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"SpringBoot"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":4,"typeName":"Mybatis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":5,"typeName":"爬虫"},{"deleted":0,"enable":1,"typeBlogCount":4,"typeId":6,"typeName":"博客开发和维护总结"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":7,"typeName":"CSS"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"JavaScript"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Vue"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":10,"typeName":"随笔"},{"deleted":0,"enable":1,"typeBlogCount":16,"typeId":11,"typeName":"java面试篇"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":13,"typeName":"JDK源码阅读"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":14,"typeName":"redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":15,"typeName":"MongoDB"},{"deleted":0,"enable":1,"typeBlogCount":28,"typeId":16,"typeName":"LeetCode"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":17,"typeName":"随心日记"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":18,"typeName":"计算机网络"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":19,"typeName":"操作系统"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":20,"typeName":"数据结构"}],"msg":"操作成功!"}
2020-04-26 23:28:35.359 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 417
2020-04-26 23:28:35.360 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1248605157059497984","blogRead":27,"blogTitle":"面试（二）------之JAVA基础篇","createdTime":"2020-04-10 13:34:02","typeName":"java面试篇"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1247745014683947008","blogRead":21,"blogTitle":"博客开发总结（一）-----之数据库设计篇","createdTime":"2020-04-08 04:36:07","typeName":"博客开发和维护总结"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1248224512563068928","blogRead":17,"blogTitle":"面试（一）------之JVM篇","createdTime":"2020-04-09 12:21:30","typeName":"java面试篇"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1249742755949817856","blogRead":17,"blogTitle":"面试（三）------之并发编程篇（下）","createdTime":"2020-04-13 16:54:26","typeName":"java面试篇"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1250622112591376384","blogRead":8,"blogTitle":"面试（六）------之网络与负载均衡","createdTime":"2020-04-16 03:08:42","typeName":"java面试篇"}],"msg":"操作成功!"}
2020-04-26 23:28:35.554 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 620
2020-04-26 23:28:35.557 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，0~n-1中缺失的数字</strong></h2>\n<p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>\n<p>示例 1:</p>\n<p>输入: [0,1,3]<br />输出: 2<br />示例&nbsp;2:</p>\n<p>输入: [0,1,2,3,4,5,6,7,9]<br />输出: 8</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主能想到的并且写出来的方法有：使用map存储数组中的所有元素，然后遍历0-n-1找出不在map中的元素。此种方法时间复杂度O（N），空间复杂度O（N）-----垃圾</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 统计0-n-1所有数字的数字和，再统计数组中所有数字的数字和，两和只差即为所求数字，时间复杂度O（N），空间复杂度O（1）-----垃圾</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;最优解法（二分查找法）：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;通常来说，我们使用二分查找法是查找一个存在于数组中的元素，但是本题需要求不在数组中的一个元素，因此到这很多人就会迷惑，不知道该怎么求了。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;但是我们首先要搞明白二分查找法的本质是什么：1，并不局限于仅仅查找存在于数组中的元素；2，二分查找的本质是对数组根据mid中间值在某一条件上进行二分（例如：通常的num[mid]&gt;target或者nums[mid]&lt;target进行左右切分）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;因此明白这一点，就好解决问题了。拿到这道题，使用二分，我们首先想到的应该是寻找根据mid中间值进行二分的条件</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;审题：题目中提及数组为递增数组，而且0-n-1内的n个数字有一个不在数组中，则不在的这个数字之前的数字满足nums[i]=i即元素本身等于数组下标，而之后的数字nums[i]!=i,所以这就是进行二分的条件了</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 二分查找法\n     * 算法思想：二分查找法的本质是能够有一个条件将数组根据mid中间值进行左右切分\n     * 所以我们想到二分查找法之后，首先需要做的是找出切分数组的条件\n     * 题目中给出了数组是一个递增数组，且0-n-1内的n个数字有一个不在这个长度为n-1的数组内\n     * 因此，不在的这个元素其左边元素必有数组下标值等于元素本身即nums[i]=i\n     * 而不在的这个元素的右边必有nums[i]!=i\n     * 所以根据此条件进行划分数组即可\n     * @param nums\n     * @return\n     */\n    public static int missingNumber(int[] nums) {\n        int low = 0;\n        int high = nums.length-1;\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]==mid){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        return low;\n    }</code></pre>","blogGoods":0,"blogId":"1254063045920022528","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kUM-AON88AAAaZr2Bc1U903.jpg","blogRead":0,"blogRemark":"剑指offer----0~n-1中缺失的数字","blogTitle":"剑指offer----0~n-1中缺失的数字","createdTime":"2020-04-25 23:01:44","typeName":"LeetCode","updateTime":"2020-04-25 23:01:44"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，在排序数组中查找数字I</strong></h2>\n<p>统计一个数字在排序数组中出现的次数。</p>\n<p>示例 1:</p>\n<p>输入: nums = [5,7,7,8,8,10], target = 8<br />输出: 2<br />示例&nbsp;2:</p>\n<p>输入: nums = [5,7,7,8,8,10], target = 6<br />输出: 0</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解法一：直接遍历统计，时间复杂度为O（N）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 遍历数组\n     * 找到第一个与目标元素相等的元素，res+1\n     * 然后往后找到第一个与目标元素不相等的元素,返回res即可\n     * 时间复杂度为O(N)\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static int search(int[] nums, int target) {\n        int res = 0;\n        for (int num : nums) {\n            if(num==target){\n                res++;\n            }\n        }\n        return res;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解法二：二分法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：利用二分法查找数字在排序数组中的左边界Left和右边界Right.如下，如果要寻找数组中的8，则其左边界为left=2,有边界right=5.所以出现次数为right-left-1.时间复杂度为O（logN）</strong></p>\n<table style=\"width: 20%; border-collapse: collapse; margin-left: auto; margin-right: auto;\" border=\"1\" cellpadding=\"5\">\n<tbody>\n<tr>\n<td style=\"width: 16.6667%;\">5</td>\n<td style=\"width: 16.6667%;\">7</td>\n<td style=\"width: 16.6667%;\">7</td>\n<td style=\"width: 16.6667%;\">8</td>\n<td style=\"width: 16.6667%;\">8</td>\n<td style=\"width: 16.6667%;\">10</td>\n</tr>\n</tbody>\n</table>\n<pre class=\"language-java\"><code>    /**\n     * 二分查找法\n     * 时间复杂度为O（logN）\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static int search2(int[] nums, int target){\n        int low = 0;\n        int high = nums.length-1;\n        int left,right;\n        left = right = 0;\n        //一次二分\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]&lt;=target){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        right = low;\n\n        low = 0;\n        high = nums.length -1;\n        //二次二分\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]&lt;target){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        left = high;\n        return right -left -1;\n    }</code></pre>","blogGoods":0,"blogId":"1254055163115724800","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kSXiAYRyFAAAaZr2Bc1U379.jpg","blogRead":0,"blogRemark":"剑指offer----在排序数组中查找数字I----LeetCode34","blogTitle":"剑指offer----在排序数组中查找数字I----LeetCode34","createdTime":"2020-04-25 22:30:24","typeName":"LeetCode","updateTime":"2020-04-25 22:30:24"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，两个链表的第一个公共节点</strong></h2>\n<p><strong><img src=\"https://images-cdn.shimo.im/Wd1NC8pveQYp9iIL.png__thumbnail\" alt=\"示例图\" width=\"742\" height=\"241\" /></strong></p>\n<p><strong>这是我从官方截下的一张图，也是有些人疑惑的地方，因为官方这张图给出的公共节点为8，而大多数人看到这张图，认为公共节点应该是1.</strong></p>\n<p><strong>但是实际上这里的公共节点不仅要节点的value相等，同时还需要节点的地址相等。从图中可以看出两个1节点虽然值相等，但是地址却不同，因而不是公共节点</strong></p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解法一：双指针</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：初始化两个指针p1=headA,p2=headB</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;分别遍历两个链表，求出两个链表的长度l1,l2</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;然后重置p1,p2指针指向头节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;让长链表的指针先走多的步数（l1-l2或者l2-l1）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;然后让两个指针同时走，直到两者相遇，即找到公共节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解疑：弄清楚第一个value相等的节点和指针相遇的节点，这两种节点是不同的，指针相遇的节点，不仅包含value相等，同时地址也相等。（如图中的8）；而第一个value相等的节点则可能并不在同一个地址，因此不一定是公共节点</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法\n     * @param headA\n     * @param headB\n     * @return\n     */\n    public static ListNode getIntersectionNode2(ListNode headA, ListNode headB){\n        ListNode p1 =headA;\n        ListNode p2 = headB;\n        int l1 = 0;\n        int l2 = 0;\n        //计算链表1的长度\n        while(p1!=null){\n            l1++;\n            p1 = p1.next;\n        }\n        //计算链表2的长度\n        while(p2!=null){\n            l2++;\n            p2 = p2.next;\n        }\n        p1 = headA;\n        p2 = headB;\n        //让长链表指针先走长的步数\n        if(l1&gt;l2){\n            for (int i = 0; i &lt; l1-l2; i++) {\n                p1 = p1.next;\n            }\n        }else{\n            for (int i = 0; i &lt; l2-l1; i++) {\n                p2 = p2.next;\n            }\n        }\n        //然后让两个指针同时走，直到相遇\n        while(p1!=p2){\n            p1 = p1.next;\n            p2 = p2.next;\n        }\n        return p1;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;解法二（大神解法）：丘比特相遇法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;利用两个指针p1=headA,p2=headB,让两个指针同时走，</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果p1先走到底，就将p1置为headB，</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果p2,先走到底，就将p2置为headA,</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;当两个指针相遇的时候，他们就相爱了（当然是找到公共节点了）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法p1=headA,p2=headB\n     * 思想是：两个节点同时从各自的链表出发\n     * p1走到末尾时，回到headB的头部\n     * p2走到末尾时，回到headA的头部\n     * 两个指针相遇的时候，即使要找的公共节点\n     * @param headA\n     * @param headB\n     * @return\n     */\n    public static ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode p1 = headA;\n        ListNode p2 = headB;\n        while(p1!=p2){\n            p1 = (p1==null)?headB:p1.next;\n            p2 = (p2==null)?headA:p2.next;\n        }\n        return p1;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1253992797703364608","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kD2OADD3mAAAaZr2Bc1U709.jpg","blogRead":0,"blogRemark":"剑指offer----之两个链表的第一个公共节点----LeetCode160","blogTitle":"剑指offer----之两个链表的第一个公共节点----LeetCode160","createdTime":"2020-04-25 18:22:35","typeName":"LeetCode","updateTime":"2020-04-25 18:22:35"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，第一个只出现一次的字符</strong></h2>\n<p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。</p>\n<p>示例:</p>\n<p>s = \"abaccdeff\"<br />返回 \"b\"</p>\n<p>s = \"\" <br />返回 \" \"</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主现在发现，做一道算法题的时候，最重要的一步就是读题，审题，在草稿纸上写下自己的思路（当然那种望眼欲穿的大佬除外）。然后才开始动笔，对于IT人来说，真的，多将时间花费在思考上面，而不是无意义的重复搬砖。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;题目分析：看到这道题，抓住两个关键字：第一个，只出现一次。什么意思呢，例如\"abaccdeff\"，其中只出现一次的字符有'b','d','e'三个，然后在三个字符中第一个出现在字符串中的是'b'，因此本题的答案是'b'.</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法分析：根据题目分析，我们最直观的解法应该是，先找出字符串中只出现一次的字符，然后再找出只出现一次字符中，第一个在字符串中出现的。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;所以我们需要做两件事，一是统计字符串中各个字符的出现次数，并且记录；二，统计完毕后，找出第一个出现次数为1的字符，返回即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;因此我们既要存字符，还要存字符对应的出现次数，所以理所当然我们选择map集合。当然对于本题而言，因为求第一个出现一次的字符，所以我们更好的是可以使用LinkedHashMap。这样免去最后的一次遍历字符串</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;下面提供两种解法：三种解法都是使用map集合，但是略有不同</strong></p>\n<p><strong>LinkedHashMap：（这是博主写的，代码冗余，这里用来和大神的写法做比较，警醒自己）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 用LinkedHashMap\n     * 思想：遍历字符串，如果map为空或者map中不含当前字符，则将其存入map\n     * 如果map中已经含有当前字符，则从map中移除\n     * 最终map中只剩出现一次的字符\n     * 返货map中的第一个即可\n     * @param s\n     * @return\n     */\n    public static char firstUniqChar(String s) {\n        Map&lt;Character,Integer&gt;map = new LinkedHashMap&lt;&gt;();\n        for (int i = 0; i &lt; s.length(); i++) {\n            char ch = s.charAt(i);\n            if(map.isEmpty()||!map.containsKey(ch)){\n                map.put(ch,1);\n            }else{\n                Integer val = map.get(ch);\n                map.put(ch,++val);\n            }\n        }\n        //返回map中第一个元素即可\n        Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entries = map.entrySet();\n        for (Map.Entry&lt;Character, Integer&gt; entry : entries) {\n            if(entry.getValue()==1){\n                return entry.getKey();\n            }\n        }\n        return ' ';\n    }</code></pre>\n<p><strong>HashMap（大神解法）：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 哈希表法\n     * @param s\n     * @return\n     */\n    public char firstUniqChar2(String s) {\n        Map&lt;Character,Boolean&gt; map = new HashMap&lt;&gt;();\n        char[] chars = s.toCharArray();\n        for (char ch : chars) {\n            map.put(ch,!map.containsKey(ch));\n        }\n        for (char ch : chars) {\n            if(map.get(ch)){\n                return ch;\n            }\n        }\n        return ' ';\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;分析：首先，这里提供了两种解法，一种为LinkedHashMap，一种为HashMap，这两种解法的不同之处就在于最后获取值的时候，LinkedHashMap获取最终值是遍历LinkedHashMap的entrySet，但是HashMap获取最终值是遍历原字符串。因而当数据庞大的时候，显然使用LinkedHashMap性能更高。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;然后，再分析一下这两种解法不另外一个不同之处，没错！就是大神的解法中使用map存放key对应的value值是Boolean型！（<span style=\"background-color: #ffcc00;\">这个真的是神一般的存在</span>），既省去了计算次数的麻烦，同时最后取的时候也不需要判断次数。wc！同一种解法，为什么天差地别！</strong></p>","blogGoods":0,"blogId":"1253956468789600256","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6j7Y6ACrySAAAaZr2Bc1U825.jpg","blogRead":0,"blogRemark":"剑指offer----第一次只出现一次的字符","blogTitle":"剑指offer----第一次只出现一次的字符","createdTime":"2020-04-25 15:58:14","typeName":"LeetCode","updateTime":"2020-04-25 15:58:14"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，连续子数组的最大和</strong></h2>\n<p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>\n<p>要求时间复杂度为O(n)。</p>\n<p>示例1:</p>\n<p>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br />输出: 6<br />解释:&nbsp;连续子数组&nbsp;[4,-1,2,1] 的和最大，为&nbsp;6。</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;看到这道题，最简单的想法肯定是求出所有连续子数组的值，然后进行比较，找出最大的即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;但是随后会想到既然要找出所有的子数组，那么我们可以使用分治的思想，因为分治的分过程即可以得到所有子序列</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;随后，再深一步，既然可以分治的思想，分的过程即是递归的过程，而且子数组的最大值依赖与前一子数组，所以可以想到使用动态规划</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：设dp[i]为以nums[i]为结尾的最大子数组和，初始值dp[0] = nums[0]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;遍历数组，如果dp[i-1]&gt;=0。则说明前面的最大子数组对当前子数组有增益效果，所以dp[i] = dp[i-1]+nums[i]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果dp[i-1]&lt;0。说明前面的最大子数组对当前子数组有夫负效果，还不如nums[i]本身，所以dp[i]=nums[i]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主的这样的写法：时间复杂度为O（N），空间复杂度也为O（N），但是实际上不需要使用dp数组，使用nums原数组就行，所以可以减小空间复杂度为O（1）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 动态规划\n     * 算法思想：因为求的是连续子数组的最大和\n     * 所以我们可以设dp[i]为以nums[i]结尾的最大连续子数组\n     * 如果dp[i]&lt;=nums[i],dp[i]=nums[i]\n     * 如果dp[i]&gt;nums[i],则dp[i]=dp[i]+nums[i]\n     * @param nums\n     * @return\n     */\n    public static int maxSubArray(int[] nums) {\n        int[] dp  = new int[nums.length];\n        dp[0] = nums[0];\n        int res = nums[0];\n        for (int i = 1; i &lt; nums.length; i++) {\n            if(dp[i-1]&lt;0){\n                dp[i] = nums[i];\n            }else{\n                dp[i] = dp[i-1]+nums[i];\n            }\n            res = Math.max(res,dp[i]);\n        }\n        return res;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1253938714590175232","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6j3QSACLxRAAAaZr2Bc1U017.jpg","blogRead":0,"blogRemark":"剑指offer---连续子数组的最大和---LeetCode53","blogTitle":"剑指offer---连续子数组的最大和---LeetCode53","createdTime":"2020-04-25 14:47:41","typeName":"LeetCode","updateTime":"2020-04-25 14:47:41"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，最小的k个数</strong></h2>\n<p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>\n<p>示例 1：</p>\n<p>输入：arr = [3,2,1], k = 2<br />输出：[1,2] 或者 [2,1]<br />示例 2：</p>\n<p>输入：arr = [0,1,2,1], k = 1<br />输出：[0]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;1,可以采用快排的思想，将原数组按照升序排序，然后取出前k个数即可，时间复杂度为O（NlogN）。但是其实跟API中的sort方法好像差别不大</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 对原数组升序排序，然后取前k个元素\n     * @param arr\n     * @param k\n     * @return\n     */\n    public static int[] getLeastNumbers(int[] arr, int k) {\n        quickSort(arr,0,arr.length-1);\n        int[] result = new int[k];\n        for (int i = 0; i &lt; k; i++) {\n            result[i] = arr[i];\n        }\n        return result;\n    }\n\n    /**\n     * 快排\n     * @param nums\n     * @param low\n     * @param high\n     */\n    public static void quickSort(int[] nums,int low,int high){\n        int base = nums[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //先从右向左找到第一个小于基准元素的元素\n            while(L&lt;R&amp;&amp;nums[R]&gt;=base){\n                R--;\n            }\n            if(nums[R]&lt;base){\n                swap(nums,L,R);\n            }\n            //再从左向右找到第一个大于基准元素的元素\n            while(L&lt;R&amp;&amp;nums[L]&lt;=base){\n                L++;\n            }\n            if(nums[L]&gt;base){\n                swap(nums,L,R);\n            }\n        }\n        //左递归\n        if(L&gt;low){\n            quickSort(nums,low,L-1);\n        }\n        //右递归\n        if(high&gt;R){\n            quickSort(nums,R+1,high);\n        }\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>2，堆排序：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;先讲解一下堆排序：堆排序是一种完全二叉树的结构，常见的存在两种堆结构，小根堆（即满足arr[2i+1]&gt;=arr[i]&amp;&amp;arr[2i+2]&gt;=arr[i]），大根堆（即满足arr[2i+1]&lt;=arr[i]&amp;&amp;arr[2i+2]&lt;=arr[i]）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;基本算法思想：第一步，初始化堆，即堆初始化为大根堆或者小根堆（这里我们简称调整堆）；第二步，将堆顶元素与堆的末尾元素进行交换，然后重新调整堆。在java中堆通常用来实现优先级队列PriorityQueue(默认的采用小根堆，若想使用大根堆，需要在创建时实现comparator)</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;使用情况：这里以java中的优先级队列为例，堆的使用情况不能按照堆名断章取义，例如小根堆实际上是将元素升序存放，因为在算法第二步中将堆顶元素与末尾元素进行交换，然后重新调整，交换的堆顶元素为最小元素，也是最先从堆中进入队列的。所以小根堆适用于TOPk大的算法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;相反的，大根堆适用于TOPk小的算法，下面分别给出小根堆和大根堆的算法：</strong></p>\n<p><strong>小根堆：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 堆排序---小根堆\n     * @param nums\n     */\n    public static void HeapSort(int[] nums){\n        //先初始化堆\n        for (int i = nums.length/2-1; i &gt;=0 ; i--) {\n            adjustHeap(nums,i,nums.length);\n        }\n        //交换堆顶与末尾节点+重新调整为小根堆\n        for (int i = nums.length-1; i &gt;0; i--) {\n            //先交换\n            swap(nums,0,i);\n            //再调整\n            adjustHeap(nums,0,i);\n        }\n    }\n\n    /**\n     * 调整为小根堆\n     * @param nums\n     * @param i\n     * @param length\n     */\n    public static void adjustHeap(int[] nums,int i,int length){\n        int temp = nums[i];\n        for (int j = 2*i+1; j &lt; length; j=2*j+1) {\n            //找出左右节点中的最小值\n            if(j+1&lt;length&amp;&amp;nums[j]&gt;nums[j+1]){\n                j++;\n            }\n            if(nums[j]&lt;temp){\n                nums[i] = nums[j];\n                i = j;\n            }\n        }\n        nums[i] = temp;\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p><strong>大根堆：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 堆排序---大根堆\n     * @param nums\n     */\n    public static void heapSort(int[] nums){\n\n        //初始化堆的过程\n        for (int i = nums.length/2-1; i &gt;=0; i--) {\n            adjustHeap(nums,i,nums.length);\n        }\n        //调整+交换堆顶和末尾的元素\n        for (int i = nums.length-1; i &gt;0; i--) {\n            //先交换，再重新调整\n            swap(nums,0,i);\n            adjustHeap(nums,0,i);\n        }\n    }\n\n    /**\n     * 调整大顶堆的过程\n     * @param nums\n     * @param i\n     * @param length\n     */\n    public static void adjustHeap(int[] nums,int i,int length){\n        int temp = nums[i];\n        for (int j = 2*i+1; j &lt; length; j=2*j+1) {\n            //找出左右节点中的最大值\n            if(j+1&lt;length&amp;&amp;nums[j]&lt;nums[j+1]){\n                j++;\n            }\n            if(nums[j]&gt;temp){\n                nums[i] = nums[j];\n                i = j;\n            }\n        }\n        nums[i] = temp;\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>本题利用大根堆解法，且使用java中自带的优先级队列PriorityQueue：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用堆数据结构，java中的优先级队列对应着最小堆\n     * 实现其comparator即可\n     * @param arr\n     * @param k\n     * @return\n     */\n    public static int[] getLeastNumbers2(int[] arr, int k){\n        Queue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(k,(v1,v2)-&gt;v2-v1);\n        for (int i : arr) {\n            if(heap.isEmpty()||heap.size()&lt;k||i&lt;heap.peek()){\n                heap.offer(i);\n            }\n            if(heap.size()&gt;k){\n                heap.poll();\n            }\n        }\n        int[] result = new int[k];\n        int j = 0;\n        for (Integer val : heap) {\n            result[j++] = val;\n        }\n        return result;\n    }</code></pre>","blogGoods":0,"blogId":"1253874832811089920","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6joYWAF3oqAAAaZr2Bc1U671.jpg","blogRead":2,"blogRemark":"剑指offer----之最小的k个数","blogTitle":"剑指offer----之最小的k个数","createdTime":"2020-04-25 10:33:50","typeName":"LeetCode","updateTime":"2020-04-25 11:53:15"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，数组中出现次数超过一半的元素---即众数</strong></h2>\n<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>\n<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>\n<p>示例&nbsp;1:</p>\n<p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br />输出: 2</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>方法有三：哈希表统计法，数组排序法，摩尔投票法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;哈希统计法：时间复杂度O（N），空间复杂度O（N）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 博主刚开始看到这道题的时候，首先想到的是哈希表统计法，因为博主想的是要找到众数，那么肯定得统计每个数字的出现次数，然后按照次数比较。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 单单是想到这些，用了map集合之后发现还是不行，因为即便用map集合统计出了每个数字和其对应的出现次数之后，你会发现没有办法按照出现的次数进行比较并且得到次数最多的数字（众数</strong><strong>）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 然后，就又审了一遍题目，结果发现了一个本题很关键的点，（<span style=\"background-color: #ffcc00;\">数组中有一个数字出现的次数超过数组长度的一半</span>），也就是说数组中有且仅有一个数字的出现次数会超过数组长度的一半（别笑博主笨，我是真的刚开始没反应过来）</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 那么我为什么要把数组中的所有元素和其次数全部存放进入map集合，然后再取次数进行比较呢？我为什么不在将元素和其次数存入集合的过程中判断次数是否已经超过数组长度的一半了呢？如果超过一半了，那它肯定是众数了呀！</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 思路：根据题意需要找出两个东西，一是多素元素，二是多素元素的出现次数\n     * 所以我们首先想到的是采用map集合\n     * 然后遍历数组，如果元素不存在与集合中，我们就将其加入map，value置为1\n     * 如果元素存在于map中，则我们取出其value将其加1与数组长度的一半做比较\n     * 如果大于数组长度一半，直接返回该元素即可\n     * 小于数组长度一半，则将其value加1存入map覆盖原有的值即可\n     *\n     * @param nums\n     * @return\n     */\n    public static int majorityElement(int[] nums) {\n        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(nums.length);\n        for (int num : nums) {\n            if(!map.containsKey(num)){\n                map.put(num,1);\n            }else{\n                Integer val = map.get(num);\n                if(++val&gt;nums.length/2){\n                    return num;\n                }else{\n                    map.put(num,val);\n                }\n            }\n        }\n        throw new RuntimeException(\"\");\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>数组排序法：由题可知，数组众必然存在一个多数元素，且出现次数超过数组长度的一半。所以我们可以对原数组进行排序，然后取数组中间的元素即可。（我擦，我当时看到这个，就在想，好简单，这个思路，但是我为什么没想到，对，因为我没有仔细的分析题目，超过一半看见没）。既然进行排序，那么我们可以选择快排，这样时间复杂度就是O（NlogN），空间复杂度O（1）.</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 数组排序法，因为多数元素的出现次数超过数组长度一半，\n     * 所以我们可以先对其进行排序，采用快排，时间复杂度O（NlogN）\n     * 然后取数组中点元素即可\n     * @param nums\n     * @return\n     */\n    public static int majorityElement2(int[] nums){\n        quickSort(nums,0,nums.length-1);\n        return nums[nums.length/2];\n    }\n\n    /**\n     * 快排\n     * @param nums\n     * @param low\n     * @param high\n     */\n    public static void quickSort(int[] nums,int low,int high){\n        int base = nums[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //从右向左找到第一个比基准元素小的元素\n            while(L&lt;R&amp;&amp;nums[R]&gt;=base){\n                R--;\n            }\n            if(nums[R]&lt;base){\n                swap(nums,L,R);\n            }\n            //从左向右找到第一个比基准元素大的元素\n            while(L&lt;R&amp;&amp;nums[L]&lt;=base){\n                L++;\n            }\n            if(nums[L]&gt;base){\n                swap(nums,L,R);\n            }\n        }\n        //左递归\n        if(L&gt;low){\n            quickSort(nums,low,L-1);\n        }\n        //右递归\n        if(high&gt;R){\n            quickSort(nums,R+1,high);\n        }\n    }\n\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>摩尔投票法（我将其称为大佬解法）：大概的意思就是采用正负抵消的方法，设置一个投票变量votes，初始设置为0；设置一个本题中的众数变量x，初始设置为数组首元素。然后遍历数组，判断跟设置的众数变量是否相等，如果相等将votes加一，如果不相等，则重置votes为0，且将x设置为数组下一个元素。本题众因为已经声明了肯定存在众数，所以不需要进行验证，但是如果没有声明的话，需要验证，下列代码众添加了验证：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 摩尔投票法\n     * @param nums\n     */\n    public static int majorityElement3(int[] nums){\n        int votes = 0;\n        int x = nums[0];\n        int count = 0;\n        for (int num : nums) {\n            if(votes==0){\n                x = num;\n            }\n            votes+=(num==x)?1:-1;\n        }\n        //验证数组众是否存在众数\n        for (int num : nums) {\n            if(num==x){\n                count++;\n            }\n        }\n        return count&gt;nums.length/2?x:0;\n    }</code></pre>","blogGoods":0,"blogId":"1253674617332162560","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6i5v-AUh39AAAaZr2Bc1U885.jpg","blogRead":0,"blogRemark":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","blogTitle":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","createdTime":"2020-04-24 21:18:14","typeName":"LeetCode","updateTime":"2020-04-24 21:18:14"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，从上到下打印二叉树-2</strong></h2>\n<p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>\n<p>例如:<br />给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>\n<p>3<br />/ \\<br />9 20<br />/ \\<br />15 7<br />返回其层次遍历结果：</p>\n<p>[<br />[3],<br />[9,20],<br />[15,7]<br />]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;BFS（广度优先搜索）：层次遍历</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * BFS\n     * @param root\n     * @return\n     */\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {\n        if (root == null) {\n            return new ArrayList&lt;&gt;(0);\n        }\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();\n        TreeNode current;\n        while (!queue.isEmpty()) {\n            List&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();\n            for (int i = queue.size(); i &gt; 0; i--) {\n                current = queue.poll();\n                arrayList.add(current.val);\n                if (current.left != null) {\n                    queue.add(current.left);\n                }\n                if (current.right != null) {\n                    queue.add(current.right);\n                }\n            }\n            list.add(arrayList);\n        }\n        return list;\n    }</code></pre>","blogGoods":0,"blogId":"1253350612905598976","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6huUyATZJ_AAAaZr2Bc1U363.jpg","blogRead":1,"blogRemark":"剑指offer----之从上到下打印二叉树----LeetCode102","blogTitle":"剑指offer----之从上到下打印二叉树----LeetCode102","createdTime":"2020-04-23 23:50:45","typeName":"LeetCode","updateTime":"2020-04-23 23:50:57"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，从上打印二叉树-1</strong></h2>\n<p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>\n<p>例如:<br />给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>\n<p>3<br />/ \\<br />9 20<br />/ \\<br />15 7<br />返回：</p>\n<p>[3,9,20,15,7]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;BFS（广度优先搜索）：也即是二叉树的层次遍历，代码和注意事项看代码注释</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 二叉树的层次遍历\n     * 这里是将层次遍历的结果存储在数组中\n     * 但是因为二叉树的节点个数并不知道\n     * 所以不能使用数组直接进行存储，因为无法初始化数组的大小\n     * 所以可以想到使用容量能自动扩充的list集合\n     * 然后再根据list集合的size来初始化数组的大小\n     * 并且将list元素赋值到数组中\n     * @param root\n     * @return\n     */\n    public static int[] levelOrder(TreeNode root) {\n        if(root==null){\n            return new int[0];\n        }\n        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n        TreeNode current;\n        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n        while(!queue.isEmpty()){\n            current = queue.poll();\n            list.add(current.val);\n            if(current.left!=null){\n                queue.add(current.left);\n            }\n            if(current.right!=null){\n                queue.add(current.right);\n            }\n        }\n        int[] result = new int[list.size()];\n        for (int i = 0; i &lt; list.size(); i++) {\n            result[i] = list.get(i);\n        }\n        return result;\n    }</code></pre>","blogGoods":0,"blogId":"1253346228108894208","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6htTeAUHGlAAAaZr2Bc1U102.jpg","blogRead":0,"blogRemark":"剑指offer----之从上到下打印二叉树","blogTitle":"剑指offer----之从上到下打印二叉树","createdTime":"2020-04-23 23:33:20","typeName":"LeetCode","updateTime":"2020-04-23 23:33:20"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，包含min函数的栈</strong></h2>\n<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>\n<p>&nbsp;</p>\n<p>示例:</p>\n<p>MinStack minStack = new MinStack();<br />minStack.push(-2);<br />minStack.push(0);<br />minStack.push(-3);<br />minStack.min(); --&gt; 返回 -3.<br />minStack.pop();<br />minStack.top(); --&gt; 返回 0.<br />minStack.min(); --&gt; 返回 -2.</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>&nbsp;辅助栈法：即初始化两个栈A,B</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;A栈用于实现基本的push(),pop(),top()的正常逻辑</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;B栈用来存放A栈中的非严格降序元素（这个我也理解不了，看代码就知道是存放什么的啦），代码中的方法注释很清楚</strong></p>\n<pre class=\"language-java\"><code>public class MinStack {\n    /** initialize your data structure here. */\n    Stack&lt;Integer&gt; A,B;\n\n    public MinStack() {\n        A = new Stack&lt;&gt;();\n        B = new Stack&lt;&gt;();\n    }\n\n    /**\n     * 入栈操作，元素先入A栈\n     * 如果B栈为空或者B栈的栈顶元素大于待入栈元素，则B栈也执行入栈操作\n     * @param x\n     */\n    public void push(int x) {\n        A.add(x);\n        if(B.isEmpty()||B.peek()&gt;=x){\n            B.add(x);\n        }\n    }\n\n    /**\n     * 这段代码优点巧妙\n     * 注意这里使用的A.pop()而不是A.peek()\n     * 所以这里实际上是分为两种情况的\n     * 第一种：当A的栈顶元素不为当前栈中的最小元素，即不等于栈B的栈顶元素\n     *         则只进行栈A的出栈操作，即A.pop()\n     * 第二种：当A的栈顶元素为当前栈中的最小元素，即等于栈B的栈顶元素\n     *        则不仅要A.pop(),而且为了保证A,B栈中最小元素的同步性\n     *        B栈也要执行出栈操作\n     */\n    public void pop() {\n        if(A.pop().equals(B.peek())){\n            B.pop();\n        }\n    }\n\n    /**\n     * 正常获取A的栈顶元素\n     * @return\n     */\n    public int top() {\n        return A.peek();\n    }\n\n    /**\n     * 获取A栈的最小元素，即B栈的栈顶元素\n     * @return\n     */\n    public int min() {\n        return B.peek();\n    }\n}</code></pre>","blogGoods":0,"blogId":"1253331349566234624","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hp12AMy2MAAAaZr2Bc1U568.jpg","blogRead":4,"blogRemark":"剑指offer----之包含min函数的栈---LeetCode155","blogTitle":"剑指offer----之包含min函数的栈---LeetCode155","createdTime":"2020-04-23 22:34:13","typeName":"LeetCode","updateTime":"2020-04-23 23:50:51"},{"blogCollection":0,"blogComment":0,"blogContent":"<h3><strong>晚上九点多，坐在床上，面前摆放着电脑，屏幕显示的是LeetCode中的《剑指offer》的题解</strong></h3>\n<h3><strong>此时的我毫无睡意，当然，这并不是因为解出一道题的喜悦冲淡了我的睡意</strong></h3>\n<h3><strong>相反的，这是一种难以言明的心情，包含着对自己无知的羞愧，也包含着别人面对如此无知的自己也能给出耐心回应的感动</strong></h3>\n<h3><strong>人有时或许就是这样，刻意的举动会让人心生防备，但是无意的善举却能温润人心</strong></h3>\n<h3><strong>别人无意的一个回答，一个小举动，一句肯定的话</strong></h3>\n<h3><strong>殊不知却能为对方赋予无穷无尽的能量</strong></h3>\n<h3><strong>将这一天的疲惫和劳累都消除</strong></h3>\n<h3><strong>赠人玫瑰，手有余香</strong></h3>\n<h3><strong>我一直抱着这样的一种心态，或许我无法做到赠人玫瑰，但是我会尽量将自己的善意展现给别人</strong></h3>\n<h3><strong>也许他刚刚好正处于某个难关，而你又刚刚好是他难关之初的引导者</strong></h3>\n<h3><strong>一句话，或许对于你来说只是人生中微不足道的几秒钟</strong></h3>\n<h3><strong>而对他来说，或许可能是多年之后回忆起来也能嘴角上扬的美好岁月</strong></h3>\n<h3><strong>想起前段时间一部剧里面的话，在这里也送给屏幕前的你：愿你永怀善意，清澈明朗</strong></h3>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1253326423486144512","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hosWANYd2AAHQzo49lBU641.jpg","blogRead":3,"blogRemark":"2020-4-23有感","blogTitle":"2020-4-23有感","createdTime":"2020-04-23 22:14:38","typeName":"随心日记","updateTime":"2020-04-25 21:22:30"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，顺时针打印矩阵</strong></h2>\n<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>\n<p>示例 1：</p>\n<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br />输出：[1,2,3,6,9,8,7,4,5]<br />示例 2：</p>\n<p>输入：matrix =&nbsp;[[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br />输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p>\n<p>限制：</p>\n<p>0 &lt;= matrix.length &lt;= 100<br />0 &lt;= matrix[i].length&nbsp;&lt;= 100</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;模拟顺时针打印的这种循环结构：设置四个边界条件，l,r,t,b。按照从左往右，从上往下，从右往左，从下网往上的顺序依次读取矩阵的元素，并且每一次都判断边界是否相遇，直到将整个矩阵元素都加入到数组中即可。</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 设置四个边界值，分别为left=0,right=matrix[0].length-1,top=0,bottom=matrix.length-1\n     * 顺时针顺序即先从左到右，再从上到下，再从右向左，再从下向上，每一次执行都要判断边界值\n     * @param matrix\n     * @return\n     */\n    public static int[] spiralOrder(int[][] matrix) {\n        if(matrix.length==0){\n            return new int[0];\n        }\n        int l = 0;\n        int r=matrix[0].length-1;\n        int t=0;\n        int b=matrix.length-1;\n        int x=0;\n        int[] res = new int[(r+1)*(b+1)];\n        while(true){\n            //从左向右\n            for(int i=l;i&lt;=r;i++){\n                res[x++]=matrix[t][i];\n            }\n            if(++t&gt;b) {\n                break;\n            }\n            //从上向下\n            for(int i=t;i&lt;=b;i++){\n                res[x++] = matrix[i][r];\n            }\n            if(--r&lt;l){\n                break;\n            }\n            //从右向左\n            for(int i=r;i&gt;=l;i--){\n                res[x++] = matrix[b][i];\n            }\n            if(--b&lt;t){\n                break;\n            }\n            //从下往上\n            for(int i=b;i&gt;=t;i--){\n                res[x++] = matrix[i][l];\n            }\n            if(++l&gt;r){\n                break;\n            }\n        }\n        return res;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1253250557729087488","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hXB2ASIQwAAAaZr2Bc1U016.jpg","blogRead":0,"blogRemark":"剑指offer-----之顺时针打印矩阵----LeetCode54","blogTitle":"剑指offer-----之顺时针打印矩阵----LeetCode54","createdTime":"2020-04-23 17:13:11","typeName":"LeetCode","updateTime":"2020-04-23 17:13:11"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，对称的二叉树</strong></h2>\n<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>\n<p>例如，二叉树&nbsp;[1,2,2,3,4,4,3] 是对称的。</p>\n<p>&nbsp; &nbsp; 1<br />&nbsp; &nbsp;/ \\<br />&nbsp; 2 &nbsp; 2<br />&nbsp;/ \\ / \\<br />3 &nbsp;4 4 &nbsp;3<br />但是下面这个&nbsp;[1,2,2,null,3,null,3] 则不是镜像对称的:</p>\n<p>&nbsp; &nbsp; 1<br />&nbsp; &nbsp;/ \\<br />&nbsp; 2 &nbsp; 2<br />&nbsp; &nbsp;\\ &nbsp; \\<br />&nbsp; &nbsp;3 &nbsp; &nbsp;3</p>\n<p>示例 1：</p>\n<p>输入：root = [1,2,2,3,4,4,3]<br />输出：true<br />示例 2：</p>\n<p>输入：root = [1,2,2,null,3,null,3]<br />输出：false</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>递归法：从对称的二叉树中我们可以找到如下规律</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果一个二叉树是对称的，则每一个节点的左右子树也是对称的,因此是递归的</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 设L = root.left，R=root.right，则满足L.left.val = R.right.val;L.right.val=R.left.val;</strong></p>\n<pre class=\"language-java\"><code>public boolean isSymmetric(TreeNode root) {\n        return  root==null?true:recur(root.left,root.right);\n    }\n    public boolean recur(TreeNode L,TreeNode R){\n        if(L==null&amp;&amp;R==null){\n            return true;\n        }\n        if(L==null||R==null||L.val!=R.val){\n            return false;\n        }\n        return recur(L.left,R.right)&amp;&amp;recur(L.right,R.left);\n    }</code></pre>","blogGoods":0,"blogId":"1252992659794968576","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6ga--AKQdvAAAaZr2Bc1U862.jpg","blogRead":1,"blogRemark":"剑指offer----之对称的二叉树----LeetCode101","blogTitle":"剑指offer----之对称的二叉树----LeetCode101","createdTime":"2020-04-23 00:08:23","typeName":"LeetCode","updateTime":"2020-04-23 00:12:33"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，二叉树镜像</strong></h2>\n<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>\n<p>例如输入：</p>\n<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; 2 &nbsp; &nbsp; 7<br />&nbsp;/ \\ &nbsp; / \\<br />1 &nbsp; 3 6 &nbsp; 9<br />镜像输出：</p>\n<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; 7 &nbsp; &nbsp; 2<br />&nbsp;/ \\ &nbsp; / \\<br />9 &nbsp; 6 3&nbsp; &nbsp;1</p>\n<p>示例 1：</p>\n<p>输入：root = [4,2,7,1,3,6,9]<br />输出：[4,7,2,9,6,3,1]</p>\n<p>限制：</p>\n<p>0 &lt;= 节点个数 &lt;= 1000</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;递归法：即递归的去交换根节点的左右子树，直到根节点为叶子节点</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用递归的方法，交换根节点的左子树和右子树\n     * 递归出口为，根节点为叶子节点\n     * @param root\n     * @return\n     */\n    public TreeNode mirrorTree(TreeNode root) {\n        TreeNode center = root;\n        if(center!=null){\n            TreeNode temp = center.left;\n            center.left = center.right;\n            center.right = temp;\n            mirrorTree(center.left);\n            mirrorTree(center.right);\n        }\n        return root;\n    }</code></pre>","blogGoods":0,"blogId":"1252985443281027072","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6gZTWABF55AAAaZr2Bc1U678.jpg","blogRead":0,"blogRemark":"剑指offer----之二叉树的镜像----LeetCode226","blogTitle":"剑指offer----之二叉树的镜像----LeetCode226","createdTime":"2020-04-22 23:39:43","typeName":"LeetCode","updateTime":"2020-04-22 23:39:43"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，合并两个有序链表</strong></h2>\n<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>\n<p>示例1：</p>\n<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br />输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br />限制：</p>\n<p>0 &lt;= 链表长度 &lt;= 1000</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>伪头节点法：即创建一个伪头节点head和一个用于辅助的节点cur</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法：如果l1.val&lt;=l2.val,就让cur指向l1，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l1指向其next</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果l1.val&gt;l2.val,就让cur指向l2，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l2指向其next</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;直到l1和l2有一个为空为止，让cur指向剩余的一个非空链表即可，若两个链表的长度为M,N则时间复杂度为O(M+N)</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用四节点，一个伪头节点，一个当前节点cur，已经链表的两个节点l1,l2\n     * 每次比较l1,l2节点的val大小，将小的节点连接到当前节点cur上即可\n     * 直到l1,l2有一个空，则将剩余的一个非空链表连接到cur尾部即可\n     * @param l1\n     * @param l2\n     * @return\n     */\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode head;\n        ListNode cur;\n        head = cur = new ListNode(0);\n        while(l1!=null&amp;&amp;l2!=null){\n            if(l1.val&lt;=l2.val){\n                cur.next = l1;\n                cur = cur.next;\n                l1 = l1.next;\n            }else{\n                cur.next = l2;\n                cur = cur.next;\n                l2 = l2.next;\n            }\n        }\n        if(l1!=null){\n            cur.next = l1;\n        }\n        if(l2!=null){\n            cur.next = l2;\n        }\n        return head.next;\n    }</code></pre>","blogGoods":0,"blogId":"1252980258446000128","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6gYGWAe-MZAAAaZr2Bc1U550.jpg","blogRead":0,"blogRemark":"剑指offer----之合并有序链表---LeetCode21","blogTitle":"剑指offer----之合并有序链表---LeetCode21","createdTime":"2020-04-22 23:19:06","typeName":"LeetCode","updateTime":"2020-04-22 23:19:06"}],"pageSize":15,"params":{},"sortColumn":"created_time","sortMethod":"DESC","totalCount":53,"totalPage":4},"msg":"操作成功!"}
2020-04-26 23:28:35.613 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /music/listFront
2020-04-26 23:28:35.613 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:28:35.613 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:28:35.613 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.MusicController.getMusicList
2020-04-26 23:28:35.614 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:28:35.744 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /link/list
2020-04-26 23:28:35.744 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:28:35.745 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:28:35.745 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.LinkController.getLinkList
2020-04-26 23:28:35.745 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:28:35.970 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 357
2020-04-26 23:28:35.971 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"artist":"周深","cover":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMh2AFeEFAAAZaWcYmAM180.jpg","id":1,"lrc":"[00:00.37]周深 - 直破穹苍 (《斗破苍穹》动画第三季主题曲)\n[00:02.79]作词：冥凰\n[00:03.86]作曲：李建衡\n[00:05.19]编曲：崔博源、李建衡\n[00:07.13]人声录制：徐威@上海V-Studio\n[00:09.23]监唱：徐威@上海V-Studio\n[00:11.38]混音：周天澈@Studio21A\n[00:24.13]有没有想过 穿越这片沙漠\n[00:32.21]前方是什么\n[00:35.16]是就此陨落\n[00:37.97]还是抓牢命运脉搏\n[00:45.38]他曾经 爱过 恨过 痛过\n[00:51.07]直到望见远处那抹焰火\n[00:56.73]也许这 是祸 是过 是错\n[01:02.41]仍不害怕 去烧灼\n[01:08.50]管那六合八荒 斗一场\n[01:14.06]焰分噬浪谁能抗\n[01:19.28]漫却这漫漫险关 莫登攀\n[01:24.88]他欲乘风 直破穹苍\n[01:43.04]太多的纠葛 太多悲欢离合\n[01:51.39]要人太执着\n[01:54.21]该如何选择\n[01:57.02]才能看清是非漩涡\n[02:04.58]他曾经 哭过 泪过 笑过\n[02:10.16]直到紧握手心那抹焰火\n[02:15.77]走遍这 荒山 大漠 湖泊\n[02:21.49]仍不退缩 去冲破\n[02:27.44]管那龙潭虎穴 斗一场\n[02:32.72]生死福祸也跌宕\n[02:38.28]漫却他太多如果 都过往\n[02:43.86]还来惊诧 满堂\n[02:50.00]管那六合八荒 斗一场\n[02:55.22]焰分噬浪谁能抗\n[03:00.85]漫却这漫漫险关 莫登攀\n[03:06.51]他欲乘风 直破穹苍","name":"直破苍穹","url":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMlWAC1FrAr8ypaThmW479.flac"},{"artist":"冷鸢","cover":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMnWAa32EAABwmk6a5Cs834.jpg","id":2,"lrc":"你是信的开头诗的内容\n童话的结尾\n你是理所当然的奇迹\n你是月色真美\n你是圣诞老人送给我\n好孩子的礼物\n你是三千美丽世界里\n我的一瓢水\n所以让我再靠近一点点\n因为你太温暖\n我会再变得坚强一点点\n因为你太柔软\n交换无名指金色的契约\n给彼此岁月\n说好从今以后都牵着手\n因为要走很远\n你是我万水千山的冒险\n要找的标记点\n你是分割我人生的线\n又将它们相连\n你是前世千次的回眸\n虔诚牵的手\n你是其余所有的一切\n是我的世界\n所以请你再闪亮一点点\n尽管我太平凡\n我会再变得柔软一点点\n因为你太敏感\n交换无名指金色的契约\n给彼此岁月\n说好从今以后都牵着手\n不管要走多远\n让我再靠近一点点\n因为你太温暖\n我会再变得坚强一点点\n因为你太柔软\n交换无名指金色的契约\n给彼此岁月\n说好从今以后都牵着手\n因为要走很远","name":"勾指起誓","url":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMomAGXdvAHZQ_9pwL9c866.mp3"}],"msg":"操作成功!"}
2020-04-26 23:28:36.032 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 288
2020-04-26 23:28:36.032 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"createdTime":"2020-04-08 02:11:26","linkId":1,"linkName":"百度","linkUrl":"www.baidu.com","updateTime":"2020-04-08 02:11:26","version":1},{"createdTime":"2020-04-18 21:39:52","linkId":2,"linkName":"CSDN","linkUrl":"https://www.csdn.net/","updateTime":"2020-04-18 21:39:52","version":1}],"msg":"操作成功!"}
2020-04-26 23:28:45.626 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/list
2020-04-26 23:28:45.626 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:28:45.627 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:28:45.627 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogList
2020-04-26 23:28:45.627 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=15, totalPage=0, totalCount=0, list=null, params={blogTitle=LeetCode}, sortColumn=created_time, sortMethod=DESC)]
2020-04-26 23:28:46.086 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 460
2020-04-26 23:28:46.087 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，在排序数组中查找数字I</strong></h2>\n<p>统计一个数字在排序数组中出现的次数。</p>\n<p>示例 1:</p>\n<p>输入: nums = [5,7,7,8,8,10], target = 8<br />输出: 2<br />示例&nbsp;2:</p>\n<p>输入: nums = [5,7,7,8,8,10], target = 6<br />输出: 0</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解法一：直接遍历统计，时间复杂度为O（N）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 遍历数组\n     * 找到第一个与目标元素相等的元素，res+1\n     * 然后往后找到第一个与目标元素不相等的元素,返回res即可\n     * 时间复杂度为O(N)\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static int search(int[] nums, int target) {\n        int res = 0;\n        for (int num : nums) {\n            if(num==target){\n                res++;\n            }\n        }\n        return res;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解法二：二分法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：利用二分法查找数字在排序数组中的左边界Left和右边界Right.如下，如果要寻找数组中的8，则其左边界为left=2,有边界right=5.所以出现次数为right-left-1.时间复杂度为O（logN）</strong></p>\n<table style=\"width: 20%; border-collapse: collapse; margin-left: auto; margin-right: auto;\" border=\"1\" cellpadding=\"5\">\n<tbody>\n<tr>\n<td style=\"width: 16.6667%;\">5</td>\n<td style=\"width: 16.6667%;\">7</td>\n<td style=\"width: 16.6667%;\">7</td>\n<td style=\"width: 16.6667%;\">8</td>\n<td style=\"width: 16.6667%;\">8</td>\n<td style=\"width: 16.6667%;\">10</td>\n</tr>\n</tbody>\n</table>\n<pre class=\"language-java\"><code>    /**\n     * 二分查找法\n     * 时间复杂度为O（logN）\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static int search2(int[] nums, int target){\n        int low = 0;\n        int high = nums.length-1;\n        int left,right;\n        left = right = 0;\n        //一次二分\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]&lt;=target){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        right = low;\n\n        low = 0;\n        high = nums.length -1;\n        //二次二分\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]&lt;target){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        left = high;\n        return right -left -1;\n    }</code></pre>","blogGoods":0,"blogId":"1254055163115724800","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kSXiAYRyFAAAaZr2Bc1U379.jpg","blogRead":0,"blogRemark":"剑指offer----在排序数组中查找数字I----LeetCode34","blogTitle":"剑指offer----在排序数组中查找数字I----LeetCode34","createdTime":"2020-04-25 22:30:24","typeName":"LeetCode","updateTime":"2020-04-25 22:30:24"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，两个链表的第一个公共节点</strong></h2>\n<p><strong><img src=\"https://images-cdn.shimo.im/Wd1NC8pveQYp9iIL.png__thumbnail\" alt=\"示例图\" width=\"742\" height=\"241\" /></strong></p>\n<p><strong>这是我从官方截下的一张图，也是有些人疑惑的地方，因为官方这张图给出的公共节点为8，而大多数人看到这张图，认为公共节点应该是1.</strong></p>\n<p><strong>但是实际上这里的公共节点不仅要节点的value相等，同时还需要节点的地址相等。从图中可以看出两个1节点虽然值相等，但是地址却不同，因而不是公共节点</strong></p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解法一：双指针</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：初始化两个指针p1=headA,p2=headB</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;分别遍历两个链表，求出两个链表的长度l1,l2</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;然后重置p1,p2指针指向头节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;让长链表的指针先走多的步数（l1-l2或者l2-l1）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;然后让两个指针同时走，直到两者相遇，即找到公共节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解疑：弄清楚第一个value相等的节点和指针相遇的节点，这两种节点是不同的，指针相遇的节点，不仅包含value相等，同时地址也相等。（如图中的8）；而第一个value相等的节点则可能并不在同一个地址，因此不一定是公共节点</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法\n     * @param headA\n     * @param headB\n     * @return\n     */\n    public static ListNode getIntersectionNode2(ListNode headA, ListNode headB){\n        ListNode p1 =headA;\n        ListNode p2 = headB;\n        int l1 = 0;\n        int l2 = 0;\n        //计算链表1的长度\n        while(p1!=null){\n            l1++;\n            p1 = p1.next;\n        }\n        //计算链表2的长度\n        while(p2!=null){\n            l2++;\n            p2 = p2.next;\n        }\n        p1 = headA;\n        p2 = headB;\n        //让长链表指针先走长的步数\n        if(l1&gt;l2){\n            for (int i = 0; i &lt; l1-l2; i++) {\n                p1 = p1.next;\n            }\n        }else{\n            for (int i = 0; i &lt; l2-l1; i++) {\n                p2 = p2.next;\n            }\n        }\n        //然后让两个指针同时走，直到相遇\n        while(p1!=p2){\n            p1 = p1.next;\n            p2 = p2.next;\n        }\n        return p1;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;解法二（大神解法）：丘比特相遇法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;利用两个指针p1=headA,p2=headB,让两个指针同时走，</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果p1先走到底，就将p1置为headB，</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果p2,先走到底，就将p2置为headA,</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;当两个指针相遇的时候，他们就相爱了（当然是找到公共节点了）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法p1=headA,p2=headB\n     * 思想是：两个节点同时从各自的链表出发\n     * p1走到末尾时，回到headB的头部\n     * p2走到末尾时，回到headA的头部\n     * 两个指针相遇的时候，即使要找的公共节点\n     * @param headA\n     * @param headB\n     * @return\n     */\n    public static ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode p1 = headA;\n        ListNode p2 = headB;\n        while(p1!=p2){\n            p1 = (p1==null)?headB:p1.next;\n            p2 = (p2==null)?headA:p2.next;\n        }\n        return p1;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1253992797703364608","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kD2OADD3mAAAaZr2Bc1U709.jpg","blogRead":0,"blogRemark":"剑指offer----之两个链表的第一个公共节点----LeetCode160","blogTitle":"剑指offer----之两个链表的第一个公共节点----LeetCode160","createdTime":"2020-04-25 18:22:35","typeName":"LeetCode","updateTime":"2020-04-25 18:22:35"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，连续子数组的最大和</strong></h2>\n<p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>\n<p>要求时间复杂度为O(n)。</p>\n<p>示例1:</p>\n<p>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br />输出: 6<br />解释:&nbsp;连续子数组&nbsp;[4,-1,2,1] 的和最大，为&nbsp;6。</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;看到这道题，最简单的想法肯定是求出所有连续子数组的值，然后进行比较，找出最大的即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;但是随后会想到既然要找出所有的子数组，那么我们可以使用分治的思想，因为分治的分过程即可以得到所有子序列</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;随后，再深一步，既然可以分治的思想，分的过程即是递归的过程，而且子数组的最大值依赖与前一子数组，所以可以想到使用动态规划</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：设dp[i]为以nums[i]为结尾的最大子数组和，初始值dp[0] = nums[0]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;遍历数组，如果dp[i-1]&gt;=0。则说明前面的最大子数组对当前子数组有增益效果，所以dp[i] = dp[i-1]+nums[i]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果dp[i-1]&lt;0。说明前面的最大子数组对当前子数组有夫负效果，还不如nums[i]本身，所以dp[i]=nums[i]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主的这样的写法：时间复杂度为O（N），空间复杂度也为O（N），但是实际上不需要使用dp数组，使用nums原数组就行，所以可以减小空间复杂度为O（1）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 动态规划\n     * 算法思想：因为求的是连续子数组的最大和\n     * 所以我们可以设dp[i]为以nums[i]结尾的最大连续子数组\n     * 如果dp[i]&lt;=nums[i],dp[i]=nums[i]\n     * 如果dp[i]&gt;nums[i],则dp[i]=dp[i]+nums[i]\n     * @param nums\n     * @return\n     */\n    public static int maxSubArray(int[] nums) {\n        int[] dp  = new int[nums.length];\n        dp[0] = nums[0];\n        int res = nums[0];\n        for (int i = 1; i &lt; nums.length; i++) {\n            if(dp[i-1]&lt;0){\n                dp[i] = nums[i];\n            }else{\n                dp[i] = dp[i-1]+nums[i];\n            }\n            res = Math.max(res,dp[i]);\n        }\n        return res;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1253938714590175232","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6j3QSACLxRAAAaZr2Bc1U017.jpg","blogRead":0,"blogRemark":"剑指offer---连续子数组的最大和---LeetCode53","blogTitle":"剑指offer---连续子数组的最大和---LeetCode53","createdTime":"2020-04-25 14:47:41","typeName":"LeetCode","updateTime":"2020-04-25 14:47:41"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，数组中出现次数超过一半的元素---即众数</strong></h2>\n<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>\n<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>\n<p>示例&nbsp;1:</p>\n<p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br />输出: 2</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>方法有三：哈希表统计法，数组排序法，摩尔投票法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;哈希统计法：时间复杂度O（N），空间复杂度O（N）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 博主刚开始看到这道题的时候，首先想到的是哈希表统计法，因为博主想的是要找到众数，那么肯定得统计每个数字的出现次数，然后按照次数比较。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 单单是想到这些，用了map集合之后发现还是不行，因为即便用map集合统计出了每个数字和其对应的出现次数之后，你会发现没有办法按照出现的次数进行比较并且得到次数最多的数字（众数</strong><strong>）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 然后，就又审了一遍题目，结果发现了一个本题很关键的点，（<span style=\"background-color: #ffcc00;\">数组中有一个数字出现的次数超过数组长度的一半</span>），也就是说数组中有且仅有一个数字的出现次数会超过数组长度的一半（别笑博主笨，我是真的刚开始没反应过来）</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 那么我为什么要把数组中的所有元素和其次数全部存放进入map集合，然后再取次数进行比较呢？我为什么不在将元素和其次数存入集合的过程中判断次数是否已经超过数组长度的一半了呢？如果超过一半了，那它肯定是众数了呀！</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 思路：根据题意需要找出两个东西，一是多素元素，二是多素元素的出现次数\n     * 所以我们首先想到的是采用map集合\n     * 然后遍历数组，如果元素不存在与集合中，我们就将其加入map，value置为1\n     * 如果元素存在于map中，则我们取出其value将其加1与数组长度的一半做比较\n     * 如果大于数组长度一半，直接返回该元素即可\n     * 小于数组长度一半，则将其value加1存入map覆盖原有的值即可\n     *\n     * @param nums\n     * @return\n     */\n    public static int majorityElement(int[] nums) {\n        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(nums.length);\n        for (int num : nums) {\n            if(!map.containsKey(num)){\n                map.put(num,1);\n            }else{\n                Integer val = map.get(num);\n                if(++val&gt;nums.length/2){\n                    return num;\n                }else{\n                    map.put(num,val);\n                }\n            }\n        }\n        throw new RuntimeException(\"\");\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>数组排序法：由题可知，数组众必然存在一个多数元素，且出现次数超过数组长度的一半。所以我们可以对原数组进行排序，然后取数组中间的元素即可。（我擦，我当时看到这个，就在想，好简单，这个思路，但是我为什么没想到，对，因为我没有仔细的分析题目，超过一半看见没）。既然进行排序，那么我们可以选择快排，这样时间复杂度就是O（NlogN），空间复杂度O（1）.</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 数组排序法，因为多数元素的出现次数超过数组长度一半，\n     * 所以我们可以先对其进行排序，采用快排，时间复杂度O（NlogN）\n     * 然后取数组中点元素即可\n     * @param nums\n     * @return\n     */\n    public static int majorityElement2(int[] nums){\n        quickSort(nums,0,nums.length-1);\n        return nums[nums.length/2];\n    }\n\n    /**\n     * 快排\n     * @param nums\n     * @param low\n     * @param high\n     */\n    public static void quickSort(int[] nums,int low,int high){\n        int base = nums[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //从右向左找到第一个比基准元素小的元素\n            while(L&lt;R&amp;&amp;nums[R]&gt;=base){\n                R--;\n            }\n            if(nums[R]&lt;base){\n                swap(nums,L,R);\n            }\n            //从左向右找到第一个比基准元素大的元素\n            while(L&lt;R&amp;&amp;nums[L]&lt;=base){\n                L++;\n            }\n            if(nums[L]&gt;base){\n                swap(nums,L,R);\n            }\n        }\n        //左递归\n        if(L&gt;low){\n            quickSort(nums,low,L-1);\n        }\n        //右递归\n        if(high&gt;R){\n            quickSort(nums,R+1,high);\n        }\n    }\n\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>摩尔投票法（我将其称为大佬解法）：大概的意思就是采用正负抵消的方法，设置一个投票变量votes，初始设置为0；设置一个本题中的众数变量x，初始设置为数组首元素。然后遍历数组，判断跟设置的众数变量是否相等，如果相等将votes加一，如果不相等，则重置votes为0，且将x设置为数组下一个元素。本题众因为已经声明了肯定存在众数，所以不需要进行验证，但是如果没有声明的话，需要验证，下列代码众添加了验证：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 摩尔投票法\n     * @param nums\n     */\n    public static int majorityElement3(int[] nums){\n        int votes = 0;\n        int x = nums[0];\n        int count = 0;\n        for (int num : nums) {\n            if(votes==0){\n                x = num;\n            }\n            votes+=(num==x)?1:-1;\n        }\n        //验证数组众是否存在众数\n        for (int num : nums) {\n            if(num==x){\n                count++;\n            }\n        }\n        return count&gt;nums.length/2?x:0;\n    }</code></pre>","blogGoods":0,"blogId":"1253674617332162560","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6i5v-AUh39AAAaZr2Bc1U885.jpg","blogRead":0,"blogRemark":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","blogTitle":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","createdTime":"2020-04-24 21:18:14","typeName":"LeetCode","updateTime":"2020-04-24 21:18:14"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，从上到下打印二叉树-2</strong></h2>\n<p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>\n<p>例如:<br />给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>\n<p>3<br />/ \\<br />9 20<br />/ \\<br />15 7<br />返回其层次遍历结果：</p>\n<p>[<br />[3],<br />[9,20],<br />[15,7]<br />]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;BFS（广度优先搜索）：层次遍历</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * BFS\n     * @param root\n     * @return\n     */\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {\n        if (root == null) {\n            return new ArrayList&lt;&gt;(0);\n        }\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();\n        TreeNode current;\n        while (!queue.isEmpty()) {\n            List&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();\n            for (int i = queue.size(); i &gt; 0; i--) {\n                current = queue.poll();\n                arrayList.add(current.val);\n                if (current.left != null) {\n                    queue.add(current.left);\n                }\n                if (current.right != null) {\n                    queue.add(current.right);\n                }\n            }\n            list.add(arrayList);\n        }\n        return list;\n    }</code></pre>","blogGoods":0,"blogId":"1253350612905598976","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6huUyATZJ_AAAaZr2Bc1U363.jpg","blogRead":1,"blogRemark":"剑指offer----之从上到下打印二叉树----LeetCode102","blogTitle":"剑指offer----之从上到下打印二叉树----LeetCode102","createdTime":"2020-04-23 23:50:45","typeName":"LeetCode","updateTime":"2020-04-23 23:50:57"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，包含min函数的栈</strong></h2>\n<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>\n<p>&nbsp;</p>\n<p>示例:</p>\n<p>MinStack minStack = new MinStack();<br />minStack.push(-2);<br />minStack.push(0);<br />minStack.push(-3);<br />minStack.min(); --&gt; 返回 -3.<br />minStack.pop();<br />minStack.top(); --&gt; 返回 0.<br />minStack.min(); --&gt; 返回 -2.</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>&nbsp;辅助栈法：即初始化两个栈A,B</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;A栈用于实现基本的push(),pop(),top()的正常逻辑</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;B栈用来存放A栈中的非严格降序元素（这个我也理解不了，看代码就知道是存放什么的啦），代码中的方法注释很清楚</strong></p>\n<pre class=\"language-java\"><code>public class MinStack {\n    /** initialize your data structure here. */\n    Stack&lt;Integer&gt; A,B;\n\n    public MinStack() {\n        A = new Stack&lt;&gt;();\n        B = new Stack&lt;&gt;();\n    }\n\n    /**\n     * 入栈操作，元素先入A栈\n     * 如果B栈为空或者B栈的栈顶元素大于待入栈元素，则B栈也执行入栈操作\n     * @param x\n     */\n    public void push(int x) {\n        A.add(x);\n        if(B.isEmpty()||B.peek()&gt;=x){\n            B.add(x);\n        }\n    }\n\n    /**\n     * 这段代码优点巧妙\n     * 注意这里使用的A.pop()而不是A.peek()\n     * 所以这里实际上是分为两种情况的\n     * 第一种：当A的栈顶元素不为当前栈中的最小元素，即不等于栈B的栈顶元素\n     *         则只进行栈A的出栈操作，即A.pop()\n     * 第二种：当A的栈顶元素为当前栈中的最小元素，即等于栈B的栈顶元素\n     *        则不仅要A.pop(),而且为了保证A,B栈中最小元素的同步性\n     *        B栈也要执行出栈操作\n     */\n    public void pop() {\n        if(A.pop().equals(B.peek())){\n            B.pop();\n        }\n    }\n\n    /**\n     * 正常获取A的栈顶元素\n     * @return\n     */\n    public int top() {\n        return A.peek();\n    }\n\n    /**\n     * 获取A栈的最小元素，即B栈的栈顶元素\n     * @return\n     */\n    public int min() {\n        return B.peek();\n    }\n}</code></pre>","blogGoods":0,"blogId":"1253331349566234624","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hp12AMy2MAAAaZr2Bc1U568.jpg","blogRead":4,"blogRemark":"剑指offer----之包含min函数的栈---LeetCode155","blogTitle":"剑指offer----之包含min函数的栈---LeetCode155","createdTime":"2020-04-23 22:34:13","typeName":"LeetCode","updateTime":"2020-04-23 23:50:51"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，顺时针打印矩阵</strong></h2>\n<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>\n<p>示例 1：</p>\n<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br />输出：[1,2,3,6,9,8,7,4,5]<br />示例 2：</p>\n<p>输入：matrix =&nbsp;[[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br />输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p>\n<p>限制：</p>\n<p>0 &lt;= matrix.length &lt;= 100<br />0 &lt;= matrix[i].length&nbsp;&lt;= 100</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;模拟顺时针打印的这种循环结构：设置四个边界条件，l,r,t,b。按照从左往右，从上往下，从右往左，从下网往上的顺序依次读取矩阵的元素，并且每一次都判断边界是否相遇，直到将整个矩阵元素都加入到数组中即可。</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 设置四个边界值，分别为left=0,right=matrix[0].length-1,top=0,bottom=matrix.length-1\n     * 顺时针顺序即先从左到右，再从上到下，再从右向左，再从下向上，每一次执行都要判断边界值\n     * @param matrix\n     * @return\n     */\n    public static int[] spiralOrder(int[][] matrix) {\n        if(matrix.length==0){\n            return new int[0];\n        }\n        int l = 0;\n        int r=matrix[0].length-1;\n        int t=0;\n        int b=matrix.length-1;\n        int x=0;\n        int[] res = new int[(r+1)*(b+1)];\n        while(true){\n            //从左向右\n            for(int i=l;i&lt;=r;i++){\n                res[x++]=matrix[t][i];\n            }\n            if(++t&gt;b) {\n                break;\n            }\n            //从上向下\n            for(int i=t;i&lt;=b;i++){\n                res[x++] = matrix[i][r];\n            }\n            if(--r&lt;l){\n                break;\n            }\n            //从右向左\n            for(int i=r;i&gt;=l;i--){\n                res[x++] = matrix[b][i];\n            }\n            if(--b&lt;t){\n                break;\n            }\n            //从下往上\n            for(int i=b;i&gt;=t;i--){\n                res[x++] = matrix[i][l];\n            }\n            if(++l&gt;r){\n                break;\n            }\n        }\n        return res;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1253250557729087488","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hXB2ASIQwAAAaZr2Bc1U016.jpg","blogRead":0,"blogRemark":"剑指offer-----之顺时针打印矩阵----LeetCode54","blogTitle":"剑指offer-----之顺时针打印矩阵----LeetCode54","createdTime":"2020-04-23 17:13:11","typeName":"LeetCode","updateTime":"2020-04-23 17:13:11"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，对称的二叉树</strong></h2>\n<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>\n<p>例如，二叉树&nbsp;[1,2,2,3,4,4,3] 是对称的。</p>\n<p>&nbsp; &nbsp; 1<br />&nbsp; &nbsp;/ \\<br />&nbsp; 2 &nbsp; 2<br />&nbsp;/ \\ / \\<br />3 &nbsp;4 4 &nbsp;3<br />但是下面这个&nbsp;[1,2,2,null,3,null,3] 则不是镜像对称的:</p>\n<p>&nbsp; &nbsp; 1<br />&nbsp; &nbsp;/ \\<br />&nbsp; 2 &nbsp; 2<br />&nbsp; &nbsp;\\ &nbsp; \\<br />&nbsp; &nbsp;3 &nbsp; &nbsp;3</p>\n<p>示例 1：</p>\n<p>输入：root = [1,2,2,3,4,4,3]<br />输出：true<br />示例 2：</p>\n<p>输入：root = [1,2,2,null,3,null,3]<br />输出：false</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>递归法：从对称的二叉树中我们可以找到如下规律</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果一个二叉树是对称的，则每一个节点的左右子树也是对称的,因此是递归的</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 设L = root.left，R=root.right，则满足L.left.val = R.right.val;L.right.val=R.left.val;</strong></p>\n<pre class=\"language-java\"><code>public boolean isSymmetric(TreeNode root) {\n        return  root==null?true:recur(root.left,root.right);\n    }\n    public boolean recur(TreeNode L,TreeNode R){\n        if(L==null&amp;&amp;R==null){\n            return true;\n        }\n        if(L==null||R==null||L.val!=R.val){\n            return false;\n        }\n        return recur(L.left,R.right)&amp;&amp;recur(L.right,R.left);\n    }</code></pre>","blogGoods":0,"blogId":"1252992659794968576","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6ga--AKQdvAAAaZr2Bc1U862.jpg","blogRead":1,"blogRemark":"剑指offer----之对称的二叉树----LeetCode101","blogTitle":"剑指offer----之对称的二叉树----LeetCode101","createdTime":"2020-04-23 00:08:23","typeName":"LeetCode","updateTime":"2020-04-23 00:12:33"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，二叉树镜像</strong></h2>\n<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>\n<p>例如输入：</p>\n<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; 2 &nbsp; &nbsp; 7<br />&nbsp;/ \\ &nbsp; / \\<br />1 &nbsp; 3 6 &nbsp; 9<br />镜像输出：</p>\n<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; 7 &nbsp; &nbsp; 2<br />&nbsp;/ \\ &nbsp; / \\<br />9 &nbsp; 6 3&nbsp; &nbsp;1</p>\n<p>示例 1：</p>\n<p>输入：root = [4,2,7,1,3,6,9]<br />输出：[4,7,2,9,6,3,1]</p>\n<p>限制：</p>\n<p>0 &lt;= 节点个数 &lt;= 1000</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;递归法：即递归的去交换根节点的左右子树，直到根节点为叶子节点</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用递归的方法，交换根节点的左子树和右子树\n     * 递归出口为，根节点为叶子节点\n     * @param root\n     * @return\n     */\n    public TreeNode mirrorTree(TreeNode root) {\n        TreeNode center = root;\n        if(center!=null){\n            TreeNode temp = center.left;\n            center.left = center.right;\n            center.right = temp;\n            mirrorTree(center.left);\n            mirrorTree(center.right);\n        }\n        return root;\n    }</code></pre>","blogGoods":0,"blogId":"1252985443281027072","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6gZTWABF55AAAaZr2Bc1U678.jpg","blogRead":0,"blogRemark":"剑指offer----之二叉树的镜像----LeetCode226","blogTitle":"剑指offer----之二叉树的镜像----LeetCode226","createdTime":"2020-04-22 23:39:43","typeName":"LeetCode","updateTime":"2020-04-22 23:39:43"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，合并两个有序链表</strong></h2>\n<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>\n<p>示例1：</p>\n<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br />输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br />限制：</p>\n<p>0 &lt;= 链表长度 &lt;= 1000</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>伪头节点法：即创建一个伪头节点head和一个用于辅助的节点cur</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法：如果l1.val&lt;=l2.val,就让cur指向l1，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l1指向其next</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果l1.val&gt;l2.val,就让cur指向l2，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l2指向其next</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;直到l1和l2有一个为空为止，让cur指向剩余的一个非空链表即可，若两个链表的长度为M,N则时间复杂度为O(M+N)</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用四节点，一个伪头节点，一个当前节点cur，已经链表的两个节点l1,l2\n     * 每次比较l1,l2节点的val大小，将小的节点连接到当前节点cur上即可\n     * 直到l1,l2有一个空，则将剩余的一个非空链表连接到cur尾部即可\n     * @param l1\n     * @param l2\n     * @return\n     */\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode head;\n        ListNode cur;\n        head = cur = new ListNode(0);\n        while(l1!=null&amp;&amp;l2!=null){\n            if(l1.val&lt;=l2.val){\n                cur.next = l1;\n                cur = cur.next;\n                l1 = l1.next;\n            }else{\n                cur.next = l2;\n                cur = cur.next;\n                l2 = l2.next;\n            }\n        }\n        if(l1!=null){\n            cur.next = l1;\n        }\n        if(l2!=null){\n            cur.next = l2;\n        }\n        return head.next;\n    }</code></pre>","blogGoods":0,"blogId":"1252980258446000128","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6gYGWAe-MZAAAaZr2Bc1U550.jpg","blogRead":0,"blogRemark":"剑指offer----之合并有序链表---LeetCode21","blogTitle":"剑指offer----之合并有序链表---LeetCode21","createdTime":"2020-04-22 23:19:06","typeName":"LeetCode","updateTime":"2020-04-22 23:19:06"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，反转链表</strong></h2>\n<p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>\n<p>示例:</p>\n<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br />输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>\n<p>限制：</p>\n<p>0 &lt;= 节点个数 &lt;= 5000</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;双指针法：初始化两个指针p1,p2，p1指向null;p2指向头节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;使用临时节点存放p2.next;将p2.next =p1;p1=p2;p2=临时节点即可</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法\n     * 初始化两个指针p1,p2,p1=head;p2=head.next\n     * 先将头节点的next置为null\n     * 然后使用一个辅助指针临时存储p2.next；再将p2.next=p1;p1=p2;p2=临时指针；直到p2.next==null\n     * @param head\n     * @return\n     */\n    public ListNode reverseList2(ListNode head){\n        ListNode p1 = null;\n        ListNode p2 = head;\n        while(p2!=null){\n            ListNode help = p2.next;\n            p2.next=p1;\n            p1 = p2;\n            p2 = help;\n        }\n        return p1;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>递归法：想想这道题，反转！！！是不是跟栈的结构很相似，先进后出（是的，没错，博主刚开始做这道题，第一时间想的就是用栈的特性，但是WTF，我真的栈给它实现了一遍，后来看到递归解法我哭了，递归的本质不就是栈吗？我为什么要这么愚蠢，手动实现一遍递归的内部过程？？？？<img src=\"https://cdn.jsdelivr.net/npm/tinymce-all-in-one@4.9.3/plugins/emoticons/img/smiley-cry.gif\" alt=\"cry\" /><img src=\"https://cdn.jsdelivr.net/npm/tinymce-all-in-one@4.9.3/plugins/emoticons/img/smiley-cry.gif\" alt=\"cry\" />）。好了，不扯了，直接上正题：递归到最后的一个节点，用ret接收，然后将其前一个节点的next.next指向本身，然后再将前一个节点的next指向null即可。</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 既然可以用栈，当然可以用递归\n     * 因为递归操作的本质就是栈的入栈出栈操作\n     * @param head\n     * @return\n     */\n    public ListNode reverseList3(ListNode head){\n        if(head==null||head.next==null){\n            return head;\n        }\n        ListNode ret = reverseList3(head.next);\n        head.next.next = head;\n        head.next = null;\n        return ret;\n    }</code></pre>\n<p>&nbsp;</p>\n<h3><strong>最后，附上博主的垃圾栈代码给大家瞅瞅，望诸君共勉，告诫自己，时刻保持清醒！！</strong></h3>\n<pre class=\"language-java\"><code>    /**\n     * 一看到反转立马想到栈的特性：先进后出\n     * 可以加一个中间栈，遍历链表将每个元素放入栈中\n     * 然后再出栈，构成一个新链表即可，但是时间复杂度为O(N),空间复杂度也为O（N）,较为复杂\n     * @param head\n     * @return\n     */\n    public ListNode reverseList(ListNode head) {\n        if(head==null){\n            return head;\n        }\n        Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;();\n        int count = 0;\n        while(head.next!=null){\n            stack.push(head);\n            head = head.next;\n            count++;\n        }\n        //创建辅助节点，便于输出最后的链表\n        ListNode help = null;\n        help = head;\n        while(!stack.isEmpty()){\n            head.next = stack.pop();\n            head = head.next;\n            count--;\n            if(count==0){\n                head.next = null;\n            }\n        }\n        return help;\n    }</code></pre>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1252636594674872320","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6fIEiAab3fAAAaZr2Bc1U212.jpg","blogRead":1,"blogRemark":"剑指offer----之反转链表----LeetCode206","blogTitle":"剑指offer----之反转链表----LeetCode206","createdTime":"2020-04-22 00:33:31","typeName":"LeetCode","updateTime":"2020-04-22 00:33:38"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，二进制中1的个数</strong></h2>\n<p>请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9&nbsp;表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>\n<p>示例 1：</p>\n<p>输入：00000000000000000000000000001011<br />输出：3<br />解释：输入的二进制串 00000000000000000000000000001011&nbsp;中，共有三位为 '1'。<br />示例 2：</p>\n<p>输入：00000000000000000000000010000000<br />输出：1<br />解释：输入的二进制串 00000000000000000000000010000000&nbsp;中，共有一位为 '1'。<br />示例 3：</p>\n<p>输入：11111111111111111111111111111101<br />输出：31<br />解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。</p>\n<p><strong>刚开始看到题目的时候，感觉题目是不是有问题，不是要求输入一个整数，判断整数转换为二进制数中的1的位数吗？然后就想当然的在转换过程中计算1的个数，结果一提交，reject（我擦）。看了解析之后才明白为什么俺们都是人，脑袋里装的东西差距能嫩么大呢！！！！！</strong></p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;利用位运算：即每次将二进制数的最后一位&amp;1，如果结果为1，则说明最后一位为1，计数器加1；如果不为1，则不做任何操作；每次操作之后，将原数字向右无符号移位1位，相当于缩小一倍，即去掉最后一位，在二进制数左前面添加一个0.直到n为0截至，时间复杂度即二进制数最高位1的位数，</strong><strong>即<span style=\"background-color: #ffcc00;\">O（log2N）</span>.解法如下：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用位运算，每次判断二进制数的最右边一位，如果&amp;1为1则表明该位为1，计数器加1\n     * 如果&amp;1不为1，不做操作\n     * 每次运算结束，都要将原数字无符号右移一位，缩小一倍，相当于将最后一位去掉，在左前面补上一个0\n     * 时间复杂度位（Log2n）即是二进制数最高位1的位数\n     * @param n\n     * @return\n     */\n    public static int hammingWeight2(int n){\n        int count = 0;\n        while(n!=0){\n            count+=(n&amp;1);\n            n&gt;&gt;&gt;=1;\n        }\n        return count;\n    }</code></pre>\n<p>&nbsp;</p>\n<p>&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<strong>巧用n&amp;(n-1)：没错，就是在看了这个解法之后，就像玩联盟的时候发现自己跟大神玩的完全不是一个游戏一样。现在我也是这种心理，我们是同一个物种吗？我们做的是一道题吗？小朋友，你是否有很多？号。现在我们看看大神的解法：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 巧用n&amp;(n-1),每次消去n的最右边一个1，直到n为0\n     * @param n\n     * @return\n     */\n    public static int hammingWeight3(int n){\n        int count = 0;\n        while(n!=0){\n            count++;\n            n&amp;=(n-1);\n        }\n        return count;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>设二进制数中1的个数为M,则该种解法的时间复杂度就为<span style=\"background-color: #ffcc00;\">O（M）</span></strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;现在具体分析一下：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;设n为10101000，则(n-1)就为101000111，到这里好好看看这两个数字，是不是优点感觉了！</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;然后n&amp;(n-1)=10100000,你发现了什么？是不是二进制数n的最右边的1被消除了！对，没错，就是这样，你再多来几次！我擦，什么人，脑子装的机器码吗？还能这么玩？好了，剩下的就不说了，自己体会吧。</strong></p>","blogGoods":0,"blogId":"1252518351972872192","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6esjKAQsixAAAaZr2Bc1U878.jpg","blogRead":1,"blogRemark":"LeetCode191---之二进制数中1的个数","blogTitle":"LeetCode191---之二进制数中1的个数","createdTime":"2020-04-21 16:43:40","typeName":"LeetCode","updateTime":"2020-04-21 16:45:38"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，旋转数组的最小数字</strong></h2>\n<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组&nbsp;[3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。&nbsp;&nbsp;</p>\n<p>示例 1：</p>\n<p>输入：[3,4,5,1,2]<br />输出：1<br />示例 2：</p>\n<p>输入：[2,2,2,0,1]<br />输出：0</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;暴力环循法：即遍历一遍数组，遍历的过程种如果发现当前元素小于前面的元素，则返回当前元素；否则返回数组第一个元素。时间复杂度为O（N）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 遍历数组，按照升序规则查找需要进行交换的元素，输出后面的一个较小元素即可，时间复杂度为O（n)\n     * @param numbers\n     * @return\n     */\n    public static int minArrays(int[] numbers){\n        for(int i=1;i&lt;numbers.length;i++){\n            if(numbers[i]&lt;numbers[i-1]){\n                return numbers[i];\n            }\n        }\n        return numbers[0];\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>利用二分查找法的特性：该题是二分查找的变版，前后两个递增数组，仍然可以使用二分查找，只是具体的逻辑不同。时间复杂度为O（N），当然特别情况下会退化到O（logN）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 二分查找\n     * @param numbers\n     * @return\n     */\n    public static int minArray(int[] numbers){\n        int i=0;\n        int j=numbers.length-1;\n        while(i&lt;j){\n            int m = (i+j)/2;\n            if(numbers[m]&gt;numbers[j]){\n                i = m+1;\n            }else if(numbers[m]&lt;numbers[j]){\n                j = m;\n            }else{\n                j--;\n            }\n        }\n        return numbers[i];\n    }</code></pre>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1252503447316475904","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6epFCAFjmsAAAaZr2Bc1U324.jpg","blogRead":0,"blogRemark":"LeetCode154----之旋转数组的最小值","blogTitle":"LeetCode154----之旋转数组的最小值","createdTime":"2020-04-21 15:44:26","typeName":"LeetCode","updateTime":"2020-04-21 23:17:51"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，青蛙跳台阶</strong></h2>\n<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n&nbsp;级的台阶总共有多少种跳法。</p>\n<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>\n<p>示例 1：</p>\n<p>输入：n = 2<br />输出：2<br />示例 2：</p>\n<p>输入：n = 7<br />输出：21<br />提示：</p>\n<p>0 &lt;= n &lt;= 100</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>分析：因为青蛙只有两种跳法，要么跳一级，要么跳两级。我们设上一个n级台阶的跳法为f(n)种，则对于最后一步只有两种情况：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;当最后一步跳1级台阶时，前面则跳了(n-1)级台阶，跳法为f(n-1)</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;当最后一步跳2级台阶时，前面则跳了（n-2）级台阶，跳法为f(n-2),</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;所以f(n) = f(n-1)+f(n-2)</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;解法一：递归求解，递归出口为f(1)=1,f(2)=2;递归体为f(n)=f(n-1)+f(n-2),但是递归的时间复杂度为指数级，且计算了太多重复数据</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 青蛙跳台阶递归解法\n     *\n     * @param n\n     * @return\n     */\n    public static int jump(int n) {\n        if (n == 1) {\n            return 1;\n        } else if (n == 2) {\n            return 2;\n        } else {\n            int result = jump(n - 1) + jump(n - 2);\n            return result % 1000000007;\n        }\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>解法二：动态规划，因为可以分解为子问题，且子问题的求解依赖于前面求解过的子问题，而且递归存在重复计算的问题。所以可使用动态规划，如下：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 青蛙跳台阶动态规划解法\n     *\n     * @param n\n     * @return\n     */\n    public static int jump2(int n) {\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        dp[1] = 1;\n        for (int i = 2; i &lt;= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n            dp[i] = dp[i] % 1000000007;\n        }\n        return dp[n];\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>官方解法：动态规划，但是用三个变量存储子问题的值，依次交替前进，空间复杂度降为O(1)</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 动态规划解决青蛙跳台阶\n     * @param n\n     * @return\n     */\n    public static int jump3(int n){\n        int a=1,b=1,sum;\n        for(int i=0;i&lt;n;i++){\n            sum = (a+b)%1000000007;\n            a = b;\n            b = sum;\n        }\n        return a;\n    }</code></pre>\n<p>&nbsp;</p>\n<h2><strong>该题和斐波那契数列问题基本一致，只是初始值存在差别。</strong></h2>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1252439650715316224","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6eaOaAXbVhAAAaZr2Bc1U560.jpg","blogRead":0,"blogRemark":"LeetCode70----青蛙跳台阶","blogTitle":"LeetCode70----青蛙跳台阶","createdTime":"2020-04-21 11:30:56","typeName":"LeetCode","updateTime":"2020-04-21 23:17:38"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，斐波那契数列</strong></h2>\n<p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</p>\n<p>F(0) = 0,&nbsp; &nbsp;F(1)&nbsp;= 1<br />F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br />斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>\n<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>\n<p>示例 1：</p>\n<p>输入：n = 2<br />输出：1<br />示例 2：</p>\n<p>输入：n = 5<br />输出：5</p>\n<p>提示：</p>\n<p>0 &lt;= n &lt;= 100</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;一般情况下，遇到斐波那契数列，可能首先想到的就是递归解决，时间复杂度为O（2^n），嗯，这个时间复杂度，和没用算法没啥区别。如下：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 递归解决斐波那契数列第n项问题\n     * @param n\n     * @return\n     */\n    public static int findFibonacci2(int n){\n        if(n==0){\n            return 0;\n        }else if(n==1){\n            return 1;\n        }else{\n            int result = findFibonacci2(n-1)+findFibonacci2(n-2);\n            return result%1000000007;\n        }\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>动态规划：因为本题求解的问题可以分解为子问题，并且子问题会出现重复，所以采用动态规划更优。这里，博主使用的动态规划还没有到最优解的情况，因为使用数组，空间复杂度为O（n）,但是实际上可以将空间复杂度降为O（1）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;动态规划的一般解题思路（参照此题，大神勿喷）：（1）找出转台转移方程，即根据1-（n-1）项推导出第n项；（2）使用一个数组存储子状态，这也是动态规划优化时间复杂度的主要途径；</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * dp求斐波那契数列的第n项\n     *\n     * @param n\n     * @return\n     */\n    public static int findFibonacci(int n) {\n        if(n==0||n==1){\n            return n;\n        }\n        int[] dp = new int[n+1];\n        dp[0] = 0;\n        dp[1] = 1;\n\n        for(int i = 2;i&lt;=n;i++){\n            dp[i] = dp[i-1]+dp[i-2];\n            dp[i] = dp[i]%1000000007;\n        }\n        return dp[n];\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>下面贴一下官方的超神解答：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 时间复杂度为O（n）,空间复杂度O（1)动态规划\n     * @param n\n     * @return\n     */\n    public static int findFibonacci3(int n){\n        int a=0,b=1,sum;\n        for(int i=0;i&lt;n;i++){\n            sum = (a+b)%1000000007;\n            a = b;\n            b = sum;\n        }\n        return a;\n    }</code></pre>\n<p>&nbsp;</p>\n<h2><strong>关于动态规划，待博主深入学习之后，再做总结</strong></h2>","blogGoods":0,"blogId":"1252423800151093248","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6eWiCADg7OAAAaZr2Bc1U759.jpg","blogRead":0,"blogRemark":"LeetCode509----斐波那契数列","blogTitle":"LeetCode509----斐波那契数列","createdTime":"2020-04-21 10:27:57","typeName":"LeetCode","updateTime":"2020-04-21 10:34:11"}],"pageSize":15,"params":{"blogTitle":"LeetCode"},"sortColumn":"created_time","sortMethod":"DESC","totalCount":16,"totalPage":2},"msg":"操作成功!"}
2020-04-26 23:28:53.556 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /rotation-picture/listFront
2020-04-26 23:28:53.557 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:28:53.557 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:28:53.557 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.RotationPictureController.getRotationPictureListFront
2020-04-26 23:28:53.557 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:28:53.652 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 96
2020-04-26 23:28:53.653 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"createdTime":"2020-04-09 13:31:20","enable":1,"rotationId":4,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PI6aAZIz1AASCO4hlpJI295.jpg"},{"createdTime":"2020-04-09 13:37:02","enable":1,"rotationId":9,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJPyAbm8fAAG9gfO8lxE28.jpeg"},{"createdTime":"2020-04-09 13:41:30","enable":1,"rotationId":10,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJgeAeG8wAAS2pjJC5QU547.jpg"},{"createdTime":"2020-04-09 13:41:38","enable":1,"rotationId":11,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhGAQFZbAAP2OOBWb6k310.jpg"},{"createdTime":"2020-04-09 13:41:50","enable":1,"rotationId":12,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhyABMZCAAG7doyXiM8109.jpg"},{"createdTime":"2020-04-09 13:41:59","enable":1,"rotationId":13,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJiWAL7BoAARW3_O3ISw651.jpg"}],"msg":"操作成功!"}
2020-04-26 23:28:53.871 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/list
2020-04-26 23:28:53.871 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:28:53.871 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:28:53.872 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogList
2020-04-26 23:28:53.872 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=15, totalPage=0, totalCount=0, list=[], params={}, sortColumn=created_time, sortMethod=DESC)]
2020-04-26 23:28:54.338 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 467
2020-04-26 23:28:54.339 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，0~n-1中缺失的数字</strong></h2>\n<p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>\n<p>示例 1:</p>\n<p>输入: [0,1,3]<br />输出: 2<br />示例&nbsp;2:</p>\n<p>输入: [0,1,2,3,4,5,6,7,9]<br />输出: 8</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主能想到的并且写出来的方法有：使用map存储数组中的所有元素，然后遍历0-n-1找出不在map中的元素。此种方法时间复杂度O（N），空间复杂度O（N）-----垃圾</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 统计0-n-1所有数字的数字和，再统计数组中所有数字的数字和，两和只差即为所求数字，时间复杂度O（N），空间复杂度O（1）-----垃圾</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;最优解法（二分查找法）：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;通常来说，我们使用二分查找法是查找一个存在于数组中的元素，但是本题需要求不在数组中的一个元素，因此到这很多人就会迷惑，不知道该怎么求了。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;但是我们首先要搞明白二分查找法的本质是什么：1，并不局限于仅仅查找存在于数组中的元素；2，二分查找的本质是对数组根据mid中间值在某一条件上进行二分（例如：通常的num[mid]&gt;target或者nums[mid]&lt;target进行左右切分）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;因此明白这一点，就好解决问题了。拿到这道题，使用二分，我们首先想到的应该是寻找根据mid中间值进行二分的条件</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;审题：题目中提及数组为递增数组，而且0-n-1内的n个数字有一个不在数组中，则不在的这个数字之前的数字满足nums[i]=i即元素本身等于数组下标，而之后的数字nums[i]!=i,所以这就是进行二分的条件了</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 二分查找法\n     * 算法思想：二分查找法的本质是能够有一个条件将数组根据mid中间值进行左右切分\n     * 所以我们想到二分查找法之后，首先需要做的是找出切分数组的条件\n     * 题目中给出了数组是一个递增数组，且0-n-1内的n个数字有一个不在这个长度为n-1的数组内\n     * 因此，不在的这个元素其左边元素必有数组下标值等于元素本身即nums[i]=i\n     * 而不在的这个元素的右边必有nums[i]!=i\n     * 所以根据此条件进行划分数组即可\n     * @param nums\n     * @return\n     */\n    public static int missingNumber(int[] nums) {\n        int low = 0;\n        int high = nums.length-1;\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]==mid){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        return low;\n    }</code></pre>","blogGoods":0,"blogId":"1254063045920022528","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kUM-AON88AAAaZr2Bc1U903.jpg","blogRead":0,"blogRemark":"剑指offer----0~n-1中缺失的数字","blogTitle":"剑指offer----0~n-1中缺失的数字","createdTime":"2020-04-25 23:01:44","typeName":"LeetCode","updateTime":"2020-04-25 23:01:44"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，在排序数组中查找数字I</strong></h2>\n<p>统计一个数字在排序数组中出现的次数。</p>\n<p>示例 1:</p>\n<p>输入: nums = [5,7,7,8,8,10], target = 8<br />输出: 2<br />示例&nbsp;2:</p>\n<p>输入: nums = [5,7,7,8,8,10], target = 6<br />输出: 0</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解法一：直接遍历统计，时间复杂度为O（N）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 遍历数组\n     * 找到第一个与目标元素相等的元素，res+1\n     * 然后往后找到第一个与目标元素不相等的元素,返回res即可\n     * 时间复杂度为O(N)\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static int search(int[] nums, int target) {\n        int res = 0;\n        for (int num : nums) {\n            if(num==target){\n                res++;\n            }\n        }\n        return res;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解法二：二分法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：利用二分法查找数字在排序数组中的左边界Left和右边界Right.如下，如果要寻找数组中的8，则其左边界为left=2,有边界right=5.所以出现次数为right-left-1.时间复杂度为O（logN）</strong></p>\n<table style=\"width: 20%; border-collapse: collapse; margin-left: auto; margin-right: auto;\" border=\"1\" cellpadding=\"5\">\n<tbody>\n<tr>\n<td style=\"width: 16.6667%;\">5</td>\n<td style=\"width: 16.6667%;\">7</td>\n<td style=\"width: 16.6667%;\">7</td>\n<td style=\"width: 16.6667%;\">8</td>\n<td style=\"width: 16.6667%;\">8</td>\n<td style=\"width: 16.6667%;\">10</td>\n</tr>\n</tbody>\n</table>\n<pre class=\"language-java\"><code>    /**\n     * 二分查找法\n     * 时间复杂度为O（logN）\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static int search2(int[] nums, int target){\n        int low = 0;\n        int high = nums.length-1;\n        int left,right;\n        left = right = 0;\n        //一次二分\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]&lt;=target){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        right = low;\n\n        low = 0;\n        high = nums.length -1;\n        //二次二分\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]&lt;target){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        left = high;\n        return right -left -1;\n    }</code></pre>","blogGoods":0,"blogId":"1254055163115724800","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kSXiAYRyFAAAaZr2Bc1U379.jpg","blogRead":0,"blogRemark":"剑指offer----在排序数组中查找数字I----LeetCode34","blogTitle":"剑指offer----在排序数组中查找数字I----LeetCode34","createdTime":"2020-04-25 22:30:24","typeName":"LeetCode","updateTime":"2020-04-25 22:30:24"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，两个链表的第一个公共节点</strong></h2>\n<p><strong><img src=\"https://images-cdn.shimo.im/Wd1NC8pveQYp9iIL.png__thumbnail\" alt=\"示例图\" width=\"742\" height=\"241\" /></strong></p>\n<p><strong>这是我从官方截下的一张图，也是有些人疑惑的地方，因为官方这张图给出的公共节点为8，而大多数人看到这张图，认为公共节点应该是1.</strong></p>\n<p><strong>但是实际上这里的公共节点不仅要节点的value相等，同时还需要节点的地址相等。从图中可以看出两个1节点虽然值相等，但是地址却不同，因而不是公共节点</strong></p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解法一：双指针</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：初始化两个指针p1=headA,p2=headB</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;分别遍历两个链表，求出两个链表的长度l1,l2</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;然后重置p1,p2指针指向头节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;让长链表的指针先走多的步数（l1-l2或者l2-l1）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;然后让两个指针同时走，直到两者相遇，即找到公共节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解疑：弄清楚第一个value相等的节点和指针相遇的节点，这两种节点是不同的，指针相遇的节点，不仅包含value相等，同时地址也相等。（如图中的8）；而第一个value相等的节点则可能并不在同一个地址，因此不一定是公共节点</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法\n     * @param headA\n     * @param headB\n     * @return\n     */\n    public static ListNode getIntersectionNode2(ListNode headA, ListNode headB){\n        ListNode p1 =headA;\n        ListNode p2 = headB;\n        int l1 = 0;\n        int l2 = 0;\n        //计算链表1的长度\n        while(p1!=null){\n            l1++;\n            p1 = p1.next;\n        }\n        //计算链表2的长度\n        while(p2!=null){\n            l2++;\n            p2 = p2.next;\n        }\n        p1 = headA;\n        p2 = headB;\n        //让长链表指针先走长的步数\n        if(l1&gt;l2){\n            for (int i = 0; i &lt; l1-l2; i++) {\n                p1 = p1.next;\n            }\n        }else{\n            for (int i = 0; i &lt; l2-l1; i++) {\n                p2 = p2.next;\n            }\n        }\n        //然后让两个指针同时走，直到相遇\n        while(p1!=p2){\n            p1 = p1.next;\n            p2 = p2.next;\n        }\n        return p1;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;解法二（大神解法）：丘比特相遇法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;利用两个指针p1=headA,p2=headB,让两个指针同时走，</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果p1先走到底，就将p1置为headB，</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果p2,先走到底，就将p2置为headA,</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;当两个指针相遇的时候，他们就相爱了（当然是找到公共节点了）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法p1=headA,p2=headB\n     * 思想是：两个节点同时从各自的链表出发\n     * p1走到末尾时，回到headB的头部\n     * p2走到末尾时，回到headA的头部\n     * 两个指针相遇的时候，即使要找的公共节点\n     * @param headA\n     * @param headB\n     * @return\n     */\n    public static ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode p1 = headA;\n        ListNode p2 = headB;\n        while(p1!=p2){\n            p1 = (p1==null)?headB:p1.next;\n            p2 = (p2==null)?headA:p2.next;\n        }\n        return p1;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1253992797703364608","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kD2OADD3mAAAaZr2Bc1U709.jpg","blogRead":0,"blogRemark":"剑指offer----之两个链表的第一个公共节点----LeetCode160","blogTitle":"剑指offer----之两个链表的第一个公共节点----LeetCode160","createdTime":"2020-04-25 18:22:35","typeName":"LeetCode","updateTime":"2020-04-25 18:22:35"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，第一个只出现一次的字符</strong></h2>\n<p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。</p>\n<p>示例:</p>\n<p>s = \"abaccdeff\"<br />返回 \"b\"</p>\n<p>s = \"\" <br />返回 \" \"</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主现在发现，做一道算法题的时候，最重要的一步就是读题，审题，在草稿纸上写下自己的思路（当然那种望眼欲穿的大佬除外）。然后才开始动笔，对于IT人来说，真的，多将时间花费在思考上面，而不是无意义的重复搬砖。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;题目分析：看到这道题，抓住两个关键字：第一个，只出现一次。什么意思呢，例如\"abaccdeff\"，其中只出现一次的字符有'b','d','e'三个，然后在三个字符中第一个出现在字符串中的是'b'，因此本题的答案是'b'.</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法分析：根据题目分析，我们最直观的解法应该是，先找出字符串中只出现一次的字符，然后再找出只出现一次字符中，第一个在字符串中出现的。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;所以我们需要做两件事，一是统计字符串中各个字符的出现次数，并且记录；二，统计完毕后，找出第一个出现次数为1的字符，返回即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;因此我们既要存字符，还要存字符对应的出现次数，所以理所当然我们选择map集合。当然对于本题而言，因为求第一个出现一次的字符，所以我们更好的是可以使用LinkedHashMap。这样免去最后的一次遍历字符串</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;下面提供两种解法：三种解法都是使用map集合，但是略有不同</strong></p>\n<p><strong>LinkedHashMap：（这是博主写的，代码冗余，这里用来和大神的写法做比较，警醒自己）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 用LinkedHashMap\n     * 思想：遍历字符串，如果map为空或者map中不含当前字符，则将其存入map\n     * 如果map中已经含有当前字符，则从map中移除\n     * 最终map中只剩出现一次的字符\n     * 返货map中的第一个即可\n     * @param s\n     * @return\n     */\n    public static char firstUniqChar(String s) {\n        Map&lt;Character,Integer&gt;map = new LinkedHashMap&lt;&gt;();\n        for (int i = 0; i &lt; s.length(); i++) {\n            char ch = s.charAt(i);\n            if(map.isEmpty()||!map.containsKey(ch)){\n                map.put(ch,1);\n            }else{\n                Integer val = map.get(ch);\n                map.put(ch,++val);\n            }\n        }\n        //返回map中第一个元素即可\n        Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entries = map.entrySet();\n        for (Map.Entry&lt;Character, Integer&gt; entry : entries) {\n            if(entry.getValue()==1){\n                return entry.getKey();\n            }\n        }\n        return ' ';\n    }</code></pre>\n<p><strong>HashMap（大神解法）：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 哈希表法\n     * @param s\n     * @return\n     */\n    public char firstUniqChar2(String s) {\n        Map&lt;Character,Boolean&gt; map = new HashMap&lt;&gt;();\n        char[] chars = s.toCharArray();\n        for (char ch : chars) {\n            map.put(ch,!map.containsKey(ch));\n        }\n        for (char ch : chars) {\n            if(map.get(ch)){\n                return ch;\n            }\n        }\n        return ' ';\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;分析：首先，这里提供了两种解法，一种为LinkedHashMap，一种为HashMap，这两种解法的不同之处就在于最后获取值的时候，LinkedHashMap获取最终值是遍历LinkedHashMap的entrySet，但是HashMap获取最终值是遍历原字符串。因而当数据庞大的时候，显然使用LinkedHashMap性能更高。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;然后，再分析一下这两种解法不另外一个不同之处，没错！就是大神的解法中使用map存放key对应的value值是Boolean型！（<span style=\"background-color: #ffcc00;\">这个真的是神一般的存在</span>），既省去了计算次数的麻烦，同时最后取的时候也不需要判断次数。wc！同一种解法，为什么天差地别！</strong></p>","blogGoods":0,"blogId":"1253956468789600256","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6j7Y6ACrySAAAaZr2Bc1U825.jpg","blogRead":0,"blogRemark":"剑指offer----第一次只出现一次的字符","blogTitle":"剑指offer----第一次只出现一次的字符","createdTime":"2020-04-25 15:58:14","typeName":"LeetCode","updateTime":"2020-04-25 15:58:14"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，连续子数组的最大和</strong></h2>\n<p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>\n<p>要求时间复杂度为O(n)。</p>\n<p>示例1:</p>\n<p>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br />输出: 6<br />解释:&nbsp;连续子数组&nbsp;[4,-1,2,1] 的和最大，为&nbsp;6。</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;看到这道题，最简单的想法肯定是求出所有连续子数组的值，然后进行比较，找出最大的即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;但是随后会想到既然要找出所有的子数组，那么我们可以使用分治的思想，因为分治的分过程即可以得到所有子序列</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;随后，再深一步，既然可以分治的思想，分的过程即是递归的过程，而且子数组的最大值依赖与前一子数组，所以可以想到使用动态规划</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：设dp[i]为以nums[i]为结尾的最大子数组和，初始值dp[0] = nums[0]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;遍历数组，如果dp[i-1]&gt;=0。则说明前面的最大子数组对当前子数组有增益效果，所以dp[i] = dp[i-1]+nums[i]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果dp[i-1]&lt;0。说明前面的最大子数组对当前子数组有夫负效果，还不如nums[i]本身，所以dp[i]=nums[i]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主的这样的写法：时间复杂度为O（N），空间复杂度也为O（N），但是实际上不需要使用dp数组，使用nums原数组就行，所以可以减小空间复杂度为O（1）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 动态规划\n     * 算法思想：因为求的是连续子数组的最大和\n     * 所以我们可以设dp[i]为以nums[i]结尾的最大连续子数组\n     * 如果dp[i]&lt;=nums[i],dp[i]=nums[i]\n     * 如果dp[i]&gt;nums[i],则dp[i]=dp[i]+nums[i]\n     * @param nums\n     * @return\n     */\n    public static int maxSubArray(int[] nums) {\n        int[] dp  = new int[nums.length];\n        dp[0] = nums[0];\n        int res = nums[0];\n        for (int i = 1; i &lt; nums.length; i++) {\n            if(dp[i-1]&lt;0){\n                dp[i] = nums[i];\n            }else{\n                dp[i] = dp[i-1]+nums[i];\n            }\n            res = Math.max(res,dp[i]);\n        }\n        return res;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1253938714590175232","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6j3QSACLxRAAAaZr2Bc1U017.jpg","blogRead":0,"blogRemark":"剑指offer---连续子数组的最大和---LeetCode53","blogTitle":"剑指offer---连续子数组的最大和---LeetCode53","createdTime":"2020-04-25 14:47:41","typeName":"LeetCode","updateTime":"2020-04-25 14:47:41"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，最小的k个数</strong></h2>\n<p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>\n<p>示例 1：</p>\n<p>输入：arr = [3,2,1], k = 2<br />输出：[1,2] 或者 [2,1]<br />示例 2：</p>\n<p>输入：arr = [0,1,2,1], k = 1<br />输出：[0]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;1,可以采用快排的思想，将原数组按照升序排序，然后取出前k个数即可，时间复杂度为O（NlogN）。但是其实跟API中的sort方法好像差别不大</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 对原数组升序排序，然后取前k个元素\n     * @param arr\n     * @param k\n     * @return\n     */\n    public static int[] getLeastNumbers(int[] arr, int k) {\n        quickSort(arr,0,arr.length-1);\n        int[] result = new int[k];\n        for (int i = 0; i &lt; k; i++) {\n            result[i] = arr[i];\n        }\n        return result;\n    }\n\n    /**\n     * 快排\n     * @param nums\n     * @param low\n     * @param high\n     */\n    public static void quickSort(int[] nums,int low,int high){\n        int base = nums[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //先从右向左找到第一个小于基准元素的元素\n            while(L&lt;R&amp;&amp;nums[R]&gt;=base){\n                R--;\n            }\n            if(nums[R]&lt;base){\n                swap(nums,L,R);\n            }\n            //再从左向右找到第一个大于基准元素的元素\n            while(L&lt;R&amp;&amp;nums[L]&lt;=base){\n                L++;\n            }\n            if(nums[L]&gt;base){\n                swap(nums,L,R);\n            }\n        }\n        //左递归\n        if(L&gt;low){\n            quickSort(nums,low,L-1);\n        }\n        //右递归\n        if(high&gt;R){\n            quickSort(nums,R+1,high);\n        }\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>2，堆排序：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;先讲解一下堆排序：堆排序是一种完全二叉树的结构，常见的存在两种堆结构，小根堆（即满足arr[2i+1]&gt;=arr[i]&amp;&amp;arr[2i+2]&gt;=arr[i]），大根堆（即满足arr[2i+1]&lt;=arr[i]&amp;&amp;arr[2i+2]&lt;=arr[i]）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;基本算法思想：第一步，初始化堆，即堆初始化为大根堆或者小根堆（这里我们简称调整堆）；第二步，将堆顶元素与堆的末尾元素进行交换，然后重新调整堆。在java中堆通常用来实现优先级队列PriorityQueue(默认的采用小根堆，若想使用大根堆，需要在创建时实现comparator)</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;使用情况：这里以java中的优先级队列为例，堆的使用情况不能按照堆名断章取义，例如小根堆实际上是将元素升序存放，因为在算法第二步中将堆顶元素与末尾元素进行交换，然后重新调整，交换的堆顶元素为最小元素，也是最先从堆中进入队列的。所以小根堆适用于TOPk大的算法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;相反的，大根堆适用于TOPk小的算法，下面分别给出小根堆和大根堆的算法：</strong></p>\n<p><strong>小根堆：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 堆排序---小根堆\n     * @param nums\n     */\n    public static void HeapSort(int[] nums){\n        //先初始化堆\n        for (int i = nums.length/2-1; i &gt;=0 ; i--) {\n            adjustHeap(nums,i,nums.length);\n        }\n        //交换堆顶与末尾节点+重新调整为小根堆\n        for (int i = nums.length-1; i &gt;0; i--) {\n            //先交换\n            swap(nums,0,i);\n            //再调整\n            adjustHeap(nums,0,i);\n        }\n    }\n\n    /**\n     * 调整为小根堆\n     * @param nums\n     * @param i\n     * @param length\n     */\n    public static void adjustHeap(int[] nums,int i,int length){\n        int temp = nums[i];\n        for (int j = 2*i+1; j &lt; length; j=2*j+1) {\n            //找出左右节点中的最小值\n            if(j+1&lt;length&amp;&amp;nums[j]&gt;nums[j+1]){\n                j++;\n            }\n            if(nums[j]&lt;temp){\n                nums[i] = nums[j];\n                i = j;\n            }\n        }\n        nums[i] = temp;\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p><strong>大根堆：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 堆排序---大根堆\n     * @param nums\n     */\n    public static void heapSort(int[] nums){\n\n        //初始化堆的过程\n        for (int i = nums.length/2-1; i &gt;=0; i--) {\n            adjustHeap(nums,i,nums.length);\n        }\n        //调整+交换堆顶和末尾的元素\n        for (int i = nums.length-1; i &gt;0; i--) {\n            //先交换，再重新调整\n            swap(nums,0,i);\n            adjustHeap(nums,0,i);\n        }\n    }\n\n    /**\n     * 调整大顶堆的过程\n     * @param nums\n     * @param i\n     * @param length\n     */\n    public static void adjustHeap(int[] nums,int i,int length){\n        int temp = nums[i];\n        for (int j = 2*i+1; j &lt; length; j=2*j+1) {\n            //找出左右节点中的最大值\n            if(j+1&lt;length&amp;&amp;nums[j]&lt;nums[j+1]){\n                j++;\n            }\n            if(nums[j]&gt;temp){\n                nums[i] = nums[j];\n                i = j;\n            }\n        }\n        nums[i] = temp;\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>本题利用大根堆解法，且使用java中自带的优先级队列PriorityQueue：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用堆数据结构，java中的优先级队列对应着最小堆\n     * 实现其comparator即可\n     * @param arr\n     * @param k\n     * @return\n     */\n    public static int[] getLeastNumbers2(int[] arr, int k){\n        Queue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(k,(v1,v2)-&gt;v2-v1);\n        for (int i : arr) {\n            if(heap.isEmpty()||heap.size()&lt;k||i&lt;heap.peek()){\n                heap.offer(i);\n            }\n            if(heap.size()&gt;k){\n                heap.poll();\n            }\n        }\n        int[] result = new int[k];\n        int j = 0;\n        for (Integer val : heap) {\n            result[j++] = val;\n        }\n        return result;\n    }</code></pre>","blogGoods":0,"blogId":"1253874832811089920","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6joYWAF3oqAAAaZr2Bc1U671.jpg","blogRead":2,"blogRemark":"剑指offer----之最小的k个数","blogTitle":"剑指offer----之最小的k个数","createdTime":"2020-04-25 10:33:50","typeName":"LeetCode","updateTime":"2020-04-25 11:53:15"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，数组中出现次数超过一半的元素---即众数</strong></h2>\n<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>\n<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>\n<p>示例&nbsp;1:</p>\n<p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br />输出: 2</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>方法有三：哈希表统计法，数组排序法，摩尔投票法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;哈希统计法：时间复杂度O（N），空间复杂度O（N）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 博主刚开始看到这道题的时候，首先想到的是哈希表统计法，因为博主想的是要找到众数，那么肯定得统计每个数字的出现次数，然后按照次数比较。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 单单是想到这些，用了map集合之后发现还是不行，因为即便用map集合统计出了每个数字和其对应的出现次数之后，你会发现没有办法按照出现的次数进行比较并且得到次数最多的数字（众数</strong><strong>）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 然后，就又审了一遍题目，结果发现了一个本题很关键的点，（<span style=\"background-color: #ffcc00;\">数组中有一个数字出现的次数超过数组长度的一半</span>），也就是说数组中有且仅有一个数字的出现次数会超过数组长度的一半（别笑博主笨，我是真的刚开始没反应过来）</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 那么我为什么要把数组中的所有元素和其次数全部存放进入map集合，然后再取次数进行比较呢？我为什么不在将元素和其次数存入集合的过程中判断次数是否已经超过数组长度的一半了呢？如果超过一半了，那它肯定是众数了呀！</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 思路：根据题意需要找出两个东西，一是多素元素，二是多素元素的出现次数\n     * 所以我们首先想到的是采用map集合\n     * 然后遍历数组，如果元素不存在与集合中，我们就将其加入map，value置为1\n     * 如果元素存在于map中，则我们取出其value将其加1与数组长度的一半做比较\n     * 如果大于数组长度一半，直接返回该元素即可\n     * 小于数组长度一半，则将其value加1存入map覆盖原有的值即可\n     *\n     * @param nums\n     * @return\n     */\n    public static int majorityElement(int[] nums) {\n        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(nums.length);\n        for (int num : nums) {\n            if(!map.containsKey(num)){\n                map.put(num,1);\n            }else{\n                Integer val = map.get(num);\n                if(++val&gt;nums.length/2){\n                    return num;\n                }else{\n                    map.put(num,val);\n                }\n            }\n        }\n        throw new RuntimeException(\"\");\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>数组排序法：由题可知，数组众必然存在一个多数元素，且出现次数超过数组长度的一半。所以我们可以对原数组进行排序，然后取数组中间的元素即可。（我擦，我当时看到这个，就在想，好简单，这个思路，但是我为什么没想到，对，因为我没有仔细的分析题目，超过一半看见没）。既然进行排序，那么我们可以选择快排，这样时间复杂度就是O（NlogN），空间复杂度O（1）.</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 数组排序法，因为多数元素的出现次数超过数组长度一半，\n     * 所以我们可以先对其进行排序，采用快排，时间复杂度O（NlogN）\n     * 然后取数组中点元素即可\n     * @param nums\n     * @return\n     */\n    public static int majorityElement2(int[] nums){\n        quickSort(nums,0,nums.length-1);\n        return nums[nums.length/2];\n    }\n\n    /**\n     * 快排\n     * @param nums\n     * @param low\n     * @param high\n     */\n    public static void quickSort(int[] nums,int low,int high){\n        int base = nums[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //从右向左找到第一个比基准元素小的元素\n            while(L&lt;R&amp;&amp;nums[R]&gt;=base){\n                R--;\n            }\n            if(nums[R]&lt;base){\n                swap(nums,L,R);\n            }\n            //从左向右找到第一个比基准元素大的元素\n            while(L&lt;R&amp;&amp;nums[L]&lt;=base){\n                L++;\n            }\n            if(nums[L]&gt;base){\n                swap(nums,L,R);\n            }\n        }\n        //左递归\n        if(L&gt;low){\n            quickSort(nums,low,L-1);\n        }\n        //右递归\n        if(high&gt;R){\n            quickSort(nums,R+1,high);\n        }\n    }\n\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>摩尔投票法（我将其称为大佬解法）：大概的意思就是采用正负抵消的方法，设置一个投票变量votes，初始设置为0；设置一个本题中的众数变量x，初始设置为数组首元素。然后遍历数组，判断跟设置的众数变量是否相等，如果相等将votes加一，如果不相等，则重置votes为0，且将x设置为数组下一个元素。本题众因为已经声明了肯定存在众数，所以不需要进行验证，但是如果没有声明的话，需要验证，下列代码众添加了验证：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 摩尔投票法\n     * @param nums\n     */\n    public static int majorityElement3(int[] nums){\n        int votes = 0;\n        int x = nums[0];\n        int count = 0;\n        for (int num : nums) {\n            if(votes==0){\n                x = num;\n            }\n            votes+=(num==x)?1:-1;\n        }\n        //验证数组众是否存在众数\n        for (int num : nums) {\n            if(num==x){\n                count++;\n            }\n        }\n        return count&gt;nums.length/2?x:0;\n    }</code></pre>","blogGoods":0,"blogId":"1253674617332162560","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6i5v-AUh39AAAaZr2Bc1U885.jpg","blogRead":0,"blogRemark":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","blogTitle":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","createdTime":"2020-04-24 21:18:14","typeName":"LeetCode","updateTime":"2020-04-24 21:18:14"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，从上到下打印二叉树-2</strong></h2>\n<p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>\n<p>例如:<br />给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>\n<p>3<br />/ \\<br />9 20<br />/ \\<br />15 7<br />返回其层次遍历结果：</p>\n<p>[<br />[3],<br />[9,20],<br />[15,7]<br />]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;BFS（广度优先搜索）：层次遍历</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * BFS\n     * @param root\n     * @return\n     */\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {\n        if (root == null) {\n            return new ArrayList&lt;&gt;(0);\n        }\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();\n        TreeNode current;\n        while (!queue.isEmpty()) {\n            List&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();\n            for (int i = queue.size(); i &gt; 0; i--) {\n                current = queue.poll();\n                arrayList.add(current.val);\n                if (current.left != null) {\n                    queue.add(current.left);\n                }\n                if (current.right != null) {\n                    queue.add(current.right);\n                }\n            }\n            list.add(arrayList);\n        }\n        return list;\n    }</code></pre>","blogGoods":0,"blogId":"1253350612905598976","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6huUyATZJ_AAAaZr2Bc1U363.jpg","blogRead":1,"blogRemark":"剑指offer----之从上到下打印二叉树----LeetCode102","blogTitle":"剑指offer----之从上到下打印二叉树----LeetCode102","createdTime":"2020-04-23 23:50:45","typeName":"LeetCode","updateTime":"2020-04-23 23:50:57"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，从上打印二叉树-1</strong></h2>\n<p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>\n<p>例如:<br />给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>\n<p>3<br />/ \\<br />9 20<br />/ \\<br />15 7<br />返回：</p>\n<p>[3,9,20,15,7]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;BFS（广度优先搜索）：也即是二叉树的层次遍历，代码和注意事项看代码注释</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 二叉树的层次遍历\n     * 这里是将层次遍历的结果存储在数组中\n     * 但是因为二叉树的节点个数并不知道\n     * 所以不能使用数组直接进行存储，因为无法初始化数组的大小\n     * 所以可以想到使用容量能自动扩充的list集合\n     * 然后再根据list集合的size来初始化数组的大小\n     * 并且将list元素赋值到数组中\n     * @param root\n     * @return\n     */\n    public static int[] levelOrder(TreeNode root) {\n        if(root==null){\n            return new int[0];\n        }\n        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n        TreeNode current;\n        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n        while(!queue.isEmpty()){\n            current = queue.poll();\n            list.add(current.val);\n            if(current.left!=null){\n                queue.add(current.left);\n            }\n            if(current.right!=null){\n                queue.add(current.right);\n            }\n        }\n        int[] result = new int[list.size()];\n        for (int i = 0; i &lt; list.size(); i++) {\n            result[i] = list.get(i);\n        }\n        return result;\n    }</code></pre>","blogGoods":0,"blogId":"1253346228108894208","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6htTeAUHGlAAAaZr2Bc1U102.jpg","blogRead":0,"blogRemark":"剑指offer----之从上到下打印二叉树","blogTitle":"剑指offer----之从上到下打印二叉树","createdTime":"2020-04-23 23:33:20","typeName":"LeetCode","updateTime":"2020-04-23 23:33:20"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，包含min函数的栈</strong></h2>\n<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>\n<p>&nbsp;</p>\n<p>示例:</p>\n<p>MinStack minStack = new MinStack();<br />minStack.push(-2);<br />minStack.push(0);<br />minStack.push(-3);<br />minStack.min(); --&gt; 返回 -3.<br />minStack.pop();<br />minStack.top(); --&gt; 返回 0.<br />minStack.min(); --&gt; 返回 -2.</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>&nbsp;辅助栈法：即初始化两个栈A,B</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;A栈用于实现基本的push(),pop(),top()的正常逻辑</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;B栈用来存放A栈中的非严格降序元素（这个我也理解不了，看代码就知道是存放什么的啦），代码中的方法注释很清楚</strong></p>\n<pre class=\"language-java\"><code>public class MinStack {\n    /** initialize your data structure here. */\n    Stack&lt;Integer&gt; A,B;\n\n    public MinStack() {\n        A = new Stack&lt;&gt;();\n        B = new Stack&lt;&gt;();\n    }\n\n    /**\n     * 入栈操作，元素先入A栈\n     * 如果B栈为空或者B栈的栈顶元素大于待入栈元素，则B栈也执行入栈操作\n     * @param x\n     */\n    public void push(int x) {\n        A.add(x);\n        if(B.isEmpty()||B.peek()&gt;=x){\n            B.add(x);\n        }\n    }\n\n    /**\n     * 这段代码优点巧妙\n     * 注意这里使用的A.pop()而不是A.peek()\n     * 所以这里实际上是分为两种情况的\n     * 第一种：当A的栈顶元素不为当前栈中的最小元素，即不等于栈B的栈顶元素\n     *         则只进行栈A的出栈操作，即A.pop()\n     * 第二种：当A的栈顶元素为当前栈中的最小元素，即等于栈B的栈顶元素\n     *        则不仅要A.pop(),而且为了保证A,B栈中最小元素的同步性\n     *        B栈也要执行出栈操作\n     */\n    public void pop() {\n        if(A.pop().equals(B.peek())){\n            B.pop();\n        }\n    }\n\n    /**\n     * 正常获取A的栈顶元素\n     * @return\n     */\n    public int top() {\n        return A.peek();\n    }\n\n    /**\n     * 获取A栈的最小元素，即B栈的栈顶元素\n     * @return\n     */\n    public int min() {\n        return B.peek();\n    }\n}</code></pre>","blogGoods":0,"blogId":"1253331349566234624","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hp12AMy2MAAAaZr2Bc1U568.jpg","blogRead":4,"blogRemark":"剑指offer----之包含min函数的栈---LeetCode155","blogTitle":"剑指offer----之包含min函数的栈---LeetCode155","createdTime":"2020-04-23 22:34:13","typeName":"LeetCode","updateTime":"2020-04-23 23:50:51"},{"blogCollection":0,"blogComment":0,"blogContent":"<h3><strong>晚上九点多，坐在床上，面前摆放着电脑，屏幕显示的是LeetCode中的《剑指offer》的题解</strong></h3>\n<h3><strong>此时的我毫无睡意，当然，这并不是因为解出一道题的喜悦冲淡了我的睡意</strong></h3>\n<h3><strong>相反的，这是一种难以言明的心情，包含着对自己无知的羞愧，也包含着别人面对如此无知的自己也能给出耐心回应的感动</strong></h3>\n<h3><strong>人有时或许就是这样，刻意的举动会让人心生防备，但是无意的善举却能温润人心</strong></h3>\n<h3><strong>别人无意的一个回答，一个小举动，一句肯定的话</strong></h3>\n<h3><strong>殊不知却能为对方赋予无穷无尽的能量</strong></h3>\n<h3><strong>将这一天的疲惫和劳累都消除</strong></h3>\n<h3><strong>赠人玫瑰，手有余香</strong></h3>\n<h3><strong>我一直抱着这样的一种心态，或许我无法做到赠人玫瑰，但是我会尽量将自己的善意展现给别人</strong></h3>\n<h3><strong>也许他刚刚好正处于某个难关，而你又刚刚好是他难关之初的引导者</strong></h3>\n<h3><strong>一句话，或许对于你来说只是人生中微不足道的几秒钟</strong></h3>\n<h3><strong>而对他来说，或许可能是多年之后回忆起来也能嘴角上扬的美好岁月</strong></h3>\n<h3><strong>想起前段时间一部剧里面的话，在这里也送给屏幕前的你：愿你永怀善意，清澈明朗</strong></h3>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1253326423486144512","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hosWANYd2AAHQzo49lBU641.jpg","blogRead":3,"blogRemark":"2020-4-23有感","blogTitle":"2020-4-23有感","createdTime":"2020-04-23 22:14:38","typeName":"随心日记","updateTime":"2020-04-25 21:22:30"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，顺时针打印矩阵</strong></h2>\n<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>\n<p>示例 1：</p>\n<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br />输出：[1,2,3,6,9,8,7,4,5]<br />示例 2：</p>\n<p>输入：matrix =&nbsp;[[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br />输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p>\n<p>限制：</p>\n<p>0 &lt;= matrix.length &lt;= 100<br />0 &lt;= matrix[i].length&nbsp;&lt;= 100</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;模拟顺时针打印的这种循环结构：设置四个边界条件，l,r,t,b。按照从左往右，从上往下，从右往左，从下网往上的顺序依次读取矩阵的元素，并且每一次都判断边界是否相遇，直到将整个矩阵元素都加入到数组中即可。</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 设置四个边界值，分别为left=0,right=matrix[0].length-1,top=0,bottom=matrix.length-1\n     * 顺时针顺序即先从左到右，再从上到下，再从右向左，再从下向上，每一次执行都要判断边界值\n     * @param matrix\n     * @return\n     */\n    public static int[] spiralOrder(int[][] matrix) {\n        if(matrix.length==0){\n            return new int[0];\n        }\n        int l = 0;\n        int r=matrix[0].length-1;\n        int t=0;\n        int b=matrix.length-1;\n        int x=0;\n        int[] res = new int[(r+1)*(b+1)];\n        while(true){\n            //从左向右\n            for(int i=l;i&lt;=r;i++){\n                res[x++]=matrix[t][i];\n            }\n            if(++t&gt;b) {\n                break;\n            }\n            //从上向下\n            for(int i=t;i&lt;=b;i++){\n                res[x++] = matrix[i][r];\n            }\n            if(--r&lt;l){\n                break;\n            }\n            //从右向左\n            for(int i=r;i&gt;=l;i--){\n                res[x++] = matrix[b][i];\n            }\n            if(--b&lt;t){\n                break;\n            }\n            //从下往上\n            for(int i=b;i&gt;=t;i--){\n                res[x++] = matrix[i][l];\n            }\n            if(++l&gt;r){\n                break;\n            }\n        }\n        return res;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1253250557729087488","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hXB2ASIQwAAAaZr2Bc1U016.jpg","blogRead":0,"blogRemark":"剑指offer-----之顺时针打印矩阵----LeetCode54","blogTitle":"剑指offer-----之顺时针打印矩阵----LeetCode54","createdTime":"2020-04-23 17:13:11","typeName":"LeetCode","updateTime":"2020-04-23 17:13:11"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，对称的二叉树</strong></h2>\n<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>\n<p>例如，二叉树&nbsp;[1,2,2,3,4,4,3] 是对称的。</p>\n<p>&nbsp; &nbsp; 1<br />&nbsp; &nbsp;/ \\<br />&nbsp; 2 &nbsp; 2<br />&nbsp;/ \\ / \\<br />3 &nbsp;4 4 &nbsp;3<br />但是下面这个&nbsp;[1,2,2,null,3,null,3] 则不是镜像对称的:</p>\n<p>&nbsp; &nbsp; 1<br />&nbsp; &nbsp;/ \\<br />&nbsp; 2 &nbsp; 2<br />&nbsp; &nbsp;\\ &nbsp; \\<br />&nbsp; &nbsp;3 &nbsp; &nbsp;3</p>\n<p>示例 1：</p>\n<p>输入：root = [1,2,2,3,4,4,3]<br />输出：true<br />示例 2：</p>\n<p>输入：root = [1,2,2,null,3,null,3]<br />输出：false</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>递归法：从对称的二叉树中我们可以找到如下规律</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果一个二叉树是对称的，则每一个节点的左右子树也是对称的,因此是递归的</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 设L = root.left，R=root.right，则满足L.left.val = R.right.val;L.right.val=R.left.val;</strong></p>\n<pre class=\"language-java\"><code>public boolean isSymmetric(TreeNode root) {\n        return  root==null?true:recur(root.left,root.right);\n    }\n    public boolean recur(TreeNode L,TreeNode R){\n        if(L==null&amp;&amp;R==null){\n            return true;\n        }\n        if(L==null||R==null||L.val!=R.val){\n            return false;\n        }\n        return recur(L.left,R.right)&amp;&amp;recur(L.right,R.left);\n    }</code></pre>","blogGoods":0,"blogId":"1252992659794968576","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6ga--AKQdvAAAaZr2Bc1U862.jpg","blogRead":1,"blogRemark":"剑指offer----之对称的二叉树----LeetCode101","blogTitle":"剑指offer----之对称的二叉树----LeetCode101","createdTime":"2020-04-23 00:08:23","typeName":"LeetCode","updateTime":"2020-04-23 00:12:33"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，二叉树镜像</strong></h2>\n<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>\n<p>例如输入：</p>\n<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; 2 &nbsp; &nbsp; 7<br />&nbsp;/ \\ &nbsp; / \\<br />1 &nbsp; 3 6 &nbsp; 9<br />镜像输出：</p>\n<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; 7 &nbsp; &nbsp; 2<br />&nbsp;/ \\ &nbsp; / \\<br />9 &nbsp; 6 3&nbsp; &nbsp;1</p>\n<p>示例 1：</p>\n<p>输入：root = [4,2,7,1,3,6,9]<br />输出：[4,7,2,9,6,3,1]</p>\n<p>限制：</p>\n<p>0 &lt;= 节点个数 &lt;= 1000</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;递归法：即递归的去交换根节点的左右子树，直到根节点为叶子节点</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用递归的方法，交换根节点的左子树和右子树\n     * 递归出口为，根节点为叶子节点\n     * @param root\n     * @return\n     */\n    public TreeNode mirrorTree(TreeNode root) {\n        TreeNode center = root;\n        if(center!=null){\n            TreeNode temp = center.left;\n            center.left = center.right;\n            center.right = temp;\n            mirrorTree(center.left);\n            mirrorTree(center.right);\n        }\n        return root;\n    }</code></pre>","blogGoods":0,"blogId":"1252985443281027072","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6gZTWABF55AAAaZr2Bc1U678.jpg","blogRead":0,"blogRemark":"剑指offer----之二叉树的镜像----LeetCode226","blogTitle":"剑指offer----之二叉树的镜像----LeetCode226","createdTime":"2020-04-22 23:39:43","typeName":"LeetCode","updateTime":"2020-04-22 23:39:43"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，合并两个有序链表</strong></h2>\n<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>\n<p>示例1：</p>\n<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br />输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br />限制：</p>\n<p>0 &lt;= 链表长度 &lt;= 1000</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>伪头节点法：即创建一个伪头节点head和一个用于辅助的节点cur</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法：如果l1.val&lt;=l2.val,就让cur指向l1，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l1指向其next</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果l1.val&gt;l2.val,就让cur指向l2，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l2指向其next</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;直到l1和l2有一个为空为止，让cur指向剩余的一个非空链表即可，若两个链表的长度为M,N则时间复杂度为O(M+N)</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用四节点，一个伪头节点，一个当前节点cur，已经链表的两个节点l1,l2\n     * 每次比较l1,l2节点的val大小，将小的节点连接到当前节点cur上即可\n     * 直到l1,l2有一个空，则将剩余的一个非空链表连接到cur尾部即可\n     * @param l1\n     * @param l2\n     * @return\n     */\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode head;\n        ListNode cur;\n        head = cur = new ListNode(0);\n        while(l1!=null&amp;&amp;l2!=null){\n            if(l1.val&lt;=l2.val){\n                cur.next = l1;\n                cur = cur.next;\n                l1 = l1.next;\n            }else{\n                cur.next = l2;\n                cur = cur.next;\n                l2 = l2.next;\n            }\n        }\n        if(l1!=null){\n            cur.next = l1;\n        }\n        if(l2!=null){\n            cur.next = l2;\n        }\n        return head.next;\n    }</code></pre>","blogGoods":0,"blogId":"1252980258446000128","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6gYGWAe-MZAAAaZr2Bc1U550.jpg","blogRead":0,"blogRemark":"剑指offer----之合并有序链表---LeetCode21","blogTitle":"剑指offer----之合并有序链表---LeetCode21","createdTime":"2020-04-22 23:19:06","typeName":"LeetCode","updateTime":"2020-04-22 23:19:06"}],"pageSize":15,"params":{},"sortColumn":"created_time","sortMethod":"DESC","totalCount":53,"totalPage":4},"msg":"操作成功!"}
2020-04-26 23:28:56.917 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/list
2020-04-26 23:28:56.918 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:28:56.919 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:28:56.919 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogList
2020-04-26 23:28:56.919 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=15, totalPage=0, totalCount=0, list=null, params={blogTitle=LeetCode}, sortColumn=created_time, sortMethod=DESC)]
2020-04-26 23:28:57.329 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 412
2020-04-26 23:28:57.330 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，在排序数组中查找数字I</strong></h2>\n<p>统计一个数字在排序数组中出现的次数。</p>\n<p>示例 1:</p>\n<p>输入: nums = [5,7,7,8,8,10], target = 8<br />输出: 2<br />示例&nbsp;2:</p>\n<p>输入: nums = [5,7,7,8,8,10], target = 6<br />输出: 0</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解法一：直接遍历统计，时间复杂度为O（N）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 遍历数组\n     * 找到第一个与目标元素相等的元素，res+1\n     * 然后往后找到第一个与目标元素不相等的元素,返回res即可\n     * 时间复杂度为O(N)\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static int search(int[] nums, int target) {\n        int res = 0;\n        for (int num : nums) {\n            if(num==target){\n                res++;\n            }\n        }\n        return res;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解法二：二分法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：利用二分法查找数字在排序数组中的左边界Left和右边界Right.如下，如果要寻找数组中的8，则其左边界为left=2,有边界right=5.所以出现次数为right-left-1.时间复杂度为O（logN）</strong></p>\n<table style=\"width: 20%; border-collapse: collapse; margin-left: auto; margin-right: auto;\" border=\"1\" cellpadding=\"5\">\n<tbody>\n<tr>\n<td style=\"width: 16.6667%;\">5</td>\n<td style=\"width: 16.6667%;\">7</td>\n<td style=\"width: 16.6667%;\">7</td>\n<td style=\"width: 16.6667%;\">8</td>\n<td style=\"width: 16.6667%;\">8</td>\n<td style=\"width: 16.6667%;\">10</td>\n</tr>\n</tbody>\n</table>\n<pre class=\"language-java\"><code>    /**\n     * 二分查找法\n     * 时间复杂度为O（logN）\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static int search2(int[] nums, int target){\n        int low = 0;\n        int high = nums.length-1;\n        int left,right;\n        left = right = 0;\n        //一次二分\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]&lt;=target){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        right = low;\n\n        low = 0;\n        high = nums.length -1;\n        //二次二分\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]&lt;target){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        left = high;\n        return right -left -1;\n    }</code></pre>","blogGoods":0,"blogId":"1254055163115724800","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kSXiAYRyFAAAaZr2Bc1U379.jpg","blogRead":0,"blogRemark":"剑指offer----在排序数组中查找数字I----LeetCode34","blogTitle":"剑指offer----在排序数组中查找数字I----LeetCode34","createdTime":"2020-04-25 22:30:24","typeName":"LeetCode","updateTime":"2020-04-25 22:30:24"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，两个链表的第一个公共节点</strong></h2>\n<p><strong><img src=\"https://images-cdn.shimo.im/Wd1NC8pveQYp9iIL.png__thumbnail\" alt=\"示例图\" width=\"742\" height=\"241\" /></strong></p>\n<p><strong>这是我从官方截下的一张图，也是有些人疑惑的地方，因为官方这张图给出的公共节点为8，而大多数人看到这张图，认为公共节点应该是1.</strong></p>\n<p><strong>但是实际上这里的公共节点不仅要节点的value相等，同时还需要节点的地址相等。从图中可以看出两个1节点虽然值相等，但是地址却不同，因而不是公共节点</strong></p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解法一：双指针</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：初始化两个指针p1=headA,p2=headB</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;分别遍历两个链表，求出两个链表的长度l1,l2</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;然后重置p1,p2指针指向头节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;让长链表的指针先走多的步数（l1-l2或者l2-l1）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;然后让两个指针同时走，直到两者相遇，即找到公共节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解疑：弄清楚第一个value相等的节点和指针相遇的节点，这两种节点是不同的，指针相遇的节点，不仅包含value相等，同时地址也相等。（如图中的8）；而第一个value相等的节点则可能并不在同一个地址，因此不一定是公共节点</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法\n     * @param headA\n     * @param headB\n     * @return\n     */\n    public static ListNode getIntersectionNode2(ListNode headA, ListNode headB){\n        ListNode p1 =headA;\n        ListNode p2 = headB;\n        int l1 = 0;\n        int l2 = 0;\n        //计算链表1的长度\n        while(p1!=null){\n            l1++;\n            p1 = p1.next;\n        }\n        //计算链表2的长度\n        while(p2!=null){\n            l2++;\n            p2 = p2.next;\n        }\n        p1 = headA;\n        p2 = headB;\n        //让长链表指针先走长的步数\n        if(l1&gt;l2){\n            for (int i = 0; i &lt; l1-l2; i++) {\n                p1 = p1.next;\n            }\n        }else{\n            for (int i = 0; i &lt; l2-l1; i++) {\n                p2 = p2.next;\n            }\n        }\n        //然后让两个指针同时走，直到相遇\n        while(p1!=p2){\n            p1 = p1.next;\n            p2 = p2.next;\n        }\n        return p1;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;解法二（大神解法）：丘比特相遇法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;利用两个指针p1=headA,p2=headB,让两个指针同时走，</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果p1先走到底，就将p1置为headB，</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果p2,先走到底，就将p2置为headA,</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;当两个指针相遇的时候，他们就相爱了（当然是找到公共节点了）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法p1=headA,p2=headB\n     * 思想是：两个节点同时从各自的链表出发\n     * p1走到末尾时，回到headB的头部\n     * p2走到末尾时，回到headA的头部\n     * 两个指针相遇的时候，即使要找的公共节点\n     * @param headA\n     * @param headB\n     * @return\n     */\n    public static ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode p1 = headA;\n        ListNode p2 = headB;\n        while(p1!=p2){\n            p1 = (p1==null)?headB:p1.next;\n            p2 = (p2==null)?headA:p2.next;\n        }\n        return p1;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1253992797703364608","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kD2OADD3mAAAaZr2Bc1U709.jpg","blogRead":0,"blogRemark":"剑指offer----之两个链表的第一个公共节点----LeetCode160","blogTitle":"剑指offer----之两个链表的第一个公共节点----LeetCode160","createdTime":"2020-04-25 18:22:35","typeName":"LeetCode","updateTime":"2020-04-25 18:22:35"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，连续子数组的最大和</strong></h2>\n<p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>\n<p>要求时间复杂度为O(n)。</p>\n<p>示例1:</p>\n<p>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br />输出: 6<br />解释:&nbsp;连续子数组&nbsp;[4,-1,2,1] 的和最大，为&nbsp;6。</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;看到这道题，最简单的想法肯定是求出所有连续子数组的值，然后进行比较，找出最大的即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;但是随后会想到既然要找出所有的子数组，那么我们可以使用分治的思想，因为分治的分过程即可以得到所有子序列</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;随后，再深一步，既然可以分治的思想，分的过程即是递归的过程，而且子数组的最大值依赖与前一子数组，所以可以想到使用动态规划</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：设dp[i]为以nums[i]为结尾的最大子数组和，初始值dp[0] = nums[0]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;遍历数组，如果dp[i-1]&gt;=0。则说明前面的最大子数组对当前子数组有增益效果，所以dp[i] = dp[i-1]+nums[i]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果dp[i-1]&lt;0。说明前面的最大子数组对当前子数组有夫负效果，还不如nums[i]本身，所以dp[i]=nums[i]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主的这样的写法：时间复杂度为O（N），空间复杂度也为O（N），但是实际上不需要使用dp数组，使用nums原数组就行，所以可以减小空间复杂度为O（1）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 动态规划\n     * 算法思想：因为求的是连续子数组的最大和\n     * 所以我们可以设dp[i]为以nums[i]结尾的最大连续子数组\n     * 如果dp[i]&lt;=nums[i],dp[i]=nums[i]\n     * 如果dp[i]&gt;nums[i],则dp[i]=dp[i]+nums[i]\n     * @param nums\n     * @return\n     */\n    public static int maxSubArray(int[] nums) {\n        int[] dp  = new int[nums.length];\n        dp[0] = nums[0];\n        int res = nums[0];\n        for (int i = 1; i &lt; nums.length; i++) {\n            if(dp[i-1]&lt;0){\n                dp[i] = nums[i];\n            }else{\n                dp[i] = dp[i-1]+nums[i];\n            }\n            res = Math.max(res,dp[i]);\n        }\n        return res;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1253938714590175232","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6j3QSACLxRAAAaZr2Bc1U017.jpg","blogRead":0,"blogRemark":"剑指offer---连续子数组的最大和---LeetCode53","blogTitle":"剑指offer---连续子数组的最大和---LeetCode53","createdTime":"2020-04-25 14:47:41","typeName":"LeetCode","updateTime":"2020-04-25 14:47:41"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，数组中出现次数超过一半的元素---即众数</strong></h2>\n<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>\n<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>\n<p>示例&nbsp;1:</p>\n<p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br />输出: 2</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>方法有三：哈希表统计法，数组排序法，摩尔投票法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;哈希统计法：时间复杂度O（N），空间复杂度O（N）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 博主刚开始看到这道题的时候，首先想到的是哈希表统计法，因为博主想的是要找到众数，那么肯定得统计每个数字的出现次数，然后按照次数比较。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 单单是想到这些，用了map集合之后发现还是不行，因为即便用map集合统计出了每个数字和其对应的出现次数之后，你会发现没有办法按照出现的次数进行比较并且得到次数最多的数字（众数</strong><strong>）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 然后，就又审了一遍题目，结果发现了一个本题很关键的点，（<span style=\"background-color: #ffcc00;\">数组中有一个数字出现的次数超过数组长度的一半</span>），也就是说数组中有且仅有一个数字的出现次数会超过数组长度的一半（别笑博主笨，我是真的刚开始没反应过来）</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 那么我为什么要把数组中的所有元素和其次数全部存放进入map集合，然后再取次数进行比较呢？我为什么不在将元素和其次数存入集合的过程中判断次数是否已经超过数组长度的一半了呢？如果超过一半了，那它肯定是众数了呀！</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 思路：根据题意需要找出两个东西，一是多素元素，二是多素元素的出现次数\n     * 所以我们首先想到的是采用map集合\n     * 然后遍历数组，如果元素不存在与集合中，我们就将其加入map，value置为1\n     * 如果元素存在于map中，则我们取出其value将其加1与数组长度的一半做比较\n     * 如果大于数组长度一半，直接返回该元素即可\n     * 小于数组长度一半，则将其value加1存入map覆盖原有的值即可\n     *\n     * @param nums\n     * @return\n     */\n    public static int majorityElement(int[] nums) {\n        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(nums.length);\n        for (int num : nums) {\n            if(!map.containsKey(num)){\n                map.put(num,1);\n            }else{\n                Integer val = map.get(num);\n                if(++val&gt;nums.length/2){\n                    return num;\n                }else{\n                    map.put(num,val);\n                }\n            }\n        }\n        throw new RuntimeException(\"\");\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>数组排序法：由题可知，数组众必然存在一个多数元素，且出现次数超过数组长度的一半。所以我们可以对原数组进行排序，然后取数组中间的元素即可。（我擦，我当时看到这个，就在想，好简单，这个思路，但是我为什么没想到，对，因为我没有仔细的分析题目，超过一半看见没）。既然进行排序，那么我们可以选择快排，这样时间复杂度就是O（NlogN），空间复杂度O（1）.</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 数组排序法，因为多数元素的出现次数超过数组长度一半，\n     * 所以我们可以先对其进行排序，采用快排，时间复杂度O（NlogN）\n     * 然后取数组中点元素即可\n     * @param nums\n     * @return\n     */\n    public static int majorityElement2(int[] nums){\n        quickSort(nums,0,nums.length-1);\n        return nums[nums.length/2];\n    }\n\n    /**\n     * 快排\n     * @param nums\n     * @param low\n     * @param high\n     */\n    public static void quickSort(int[] nums,int low,int high){\n        int base = nums[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //从右向左找到第一个比基准元素小的元素\n            while(L&lt;R&amp;&amp;nums[R]&gt;=base){\n                R--;\n            }\n            if(nums[R]&lt;base){\n                swap(nums,L,R);\n            }\n            //从左向右找到第一个比基准元素大的元素\n            while(L&lt;R&amp;&amp;nums[L]&lt;=base){\n                L++;\n            }\n            if(nums[L]&gt;base){\n                swap(nums,L,R);\n            }\n        }\n        //左递归\n        if(L&gt;low){\n            quickSort(nums,low,L-1);\n        }\n        //右递归\n        if(high&gt;R){\n            quickSort(nums,R+1,high);\n        }\n    }\n\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>摩尔投票法（我将其称为大佬解法）：大概的意思就是采用正负抵消的方法，设置一个投票变量votes，初始设置为0；设置一个本题中的众数变量x，初始设置为数组首元素。然后遍历数组，判断跟设置的众数变量是否相等，如果相等将votes加一，如果不相等，则重置votes为0，且将x设置为数组下一个元素。本题众因为已经声明了肯定存在众数，所以不需要进行验证，但是如果没有声明的话，需要验证，下列代码众添加了验证：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 摩尔投票法\n     * @param nums\n     */\n    public static int majorityElement3(int[] nums){\n        int votes = 0;\n        int x = nums[0];\n        int count = 0;\n        for (int num : nums) {\n            if(votes==0){\n                x = num;\n            }\n            votes+=(num==x)?1:-1;\n        }\n        //验证数组众是否存在众数\n        for (int num : nums) {\n            if(num==x){\n                count++;\n            }\n        }\n        return count&gt;nums.length/2?x:0;\n    }</code></pre>","blogGoods":0,"blogId":"1253674617332162560","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6i5v-AUh39AAAaZr2Bc1U885.jpg","blogRead":0,"blogRemark":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","blogTitle":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","createdTime":"2020-04-24 21:18:14","typeName":"LeetCode","updateTime":"2020-04-24 21:18:14"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，从上到下打印二叉树-2</strong></h2>\n<p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>\n<p>例如:<br />给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>\n<p>3<br />/ \\<br />9 20<br />/ \\<br />15 7<br />返回其层次遍历结果：</p>\n<p>[<br />[3],<br />[9,20],<br />[15,7]<br />]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;BFS（广度优先搜索）：层次遍历</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * BFS\n     * @param root\n     * @return\n     */\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {\n        if (root == null) {\n            return new ArrayList&lt;&gt;(0);\n        }\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();\n        TreeNode current;\n        while (!queue.isEmpty()) {\n            List&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();\n            for (int i = queue.size(); i &gt; 0; i--) {\n                current = queue.poll();\n                arrayList.add(current.val);\n                if (current.left != null) {\n                    queue.add(current.left);\n                }\n                if (current.right != null) {\n                    queue.add(current.right);\n                }\n            }\n            list.add(arrayList);\n        }\n        return list;\n    }</code></pre>","blogGoods":0,"blogId":"1253350612905598976","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6huUyATZJ_AAAaZr2Bc1U363.jpg","blogRead":1,"blogRemark":"剑指offer----之从上到下打印二叉树----LeetCode102","blogTitle":"剑指offer----之从上到下打印二叉树----LeetCode102","createdTime":"2020-04-23 23:50:45","typeName":"LeetCode","updateTime":"2020-04-23 23:50:57"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，包含min函数的栈</strong></h2>\n<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>\n<p>&nbsp;</p>\n<p>示例:</p>\n<p>MinStack minStack = new MinStack();<br />minStack.push(-2);<br />minStack.push(0);<br />minStack.push(-3);<br />minStack.min(); --&gt; 返回 -3.<br />minStack.pop();<br />minStack.top(); --&gt; 返回 0.<br />minStack.min(); --&gt; 返回 -2.</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>&nbsp;辅助栈法：即初始化两个栈A,B</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;A栈用于实现基本的push(),pop(),top()的正常逻辑</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;B栈用来存放A栈中的非严格降序元素（这个我也理解不了，看代码就知道是存放什么的啦），代码中的方法注释很清楚</strong></p>\n<pre class=\"language-java\"><code>public class MinStack {\n    /** initialize your data structure here. */\n    Stack&lt;Integer&gt; A,B;\n\n    public MinStack() {\n        A = new Stack&lt;&gt;();\n        B = new Stack&lt;&gt;();\n    }\n\n    /**\n     * 入栈操作，元素先入A栈\n     * 如果B栈为空或者B栈的栈顶元素大于待入栈元素，则B栈也执行入栈操作\n     * @param x\n     */\n    public void push(int x) {\n        A.add(x);\n        if(B.isEmpty()||B.peek()&gt;=x){\n            B.add(x);\n        }\n    }\n\n    /**\n     * 这段代码优点巧妙\n     * 注意这里使用的A.pop()而不是A.peek()\n     * 所以这里实际上是分为两种情况的\n     * 第一种：当A的栈顶元素不为当前栈中的最小元素，即不等于栈B的栈顶元素\n     *         则只进行栈A的出栈操作，即A.pop()\n     * 第二种：当A的栈顶元素为当前栈中的最小元素，即等于栈B的栈顶元素\n     *        则不仅要A.pop(),而且为了保证A,B栈中最小元素的同步性\n     *        B栈也要执行出栈操作\n     */\n    public void pop() {\n        if(A.pop().equals(B.peek())){\n            B.pop();\n        }\n    }\n\n    /**\n     * 正常获取A的栈顶元素\n     * @return\n     */\n    public int top() {\n        return A.peek();\n    }\n\n    /**\n     * 获取A栈的最小元素，即B栈的栈顶元素\n     * @return\n     */\n    public int min() {\n        return B.peek();\n    }\n}</code></pre>","blogGoods":0,"blogId":"1253331349566234624","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hp12AMy2MAAAaZr2Bc1U568.jpg","blogRead":4,"blogRemark":"剑指offer----之包含min函数的栈---LeetCode155","blogTitle":"剑指offer----之包含min函数的栈---LeetCode155","createdTime":"2020-04-23 22:34:13","typeName":"LeetCode","updateTime":"2020-04-23 23:50:51"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，顺时针打印矩阵</strong></h2>\n<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>\n<p>示例 1：</p>\n<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br />输出：[1,2,3,6,9,8,7,4,5]<br />示例 2：</p>\n<p>输入：matrix =&nbsp;[[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br />输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p>\n<p>限制：</p>\n<p>0 &lt;= matrix.length &lt;= 100<br />0 &lt;= matrix[i].length&nbsp;&lt;= 100</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;模拟顺时针打印的这种循环结构：设置四个边界条件，l,r,t,b。按照从左往右，从上往下，从右往左，从下网往上的顺序依次读取矩阵的元素，并且每一次都判断边界是否相遇，直到将整个矩阵元素都加入到数组中即可。</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 设置四个边界值，分别为left=0,right=matrix[0].length-1,top=0,bottom=matrix.length-1\n     * 顺时针顺序即先从左到右，再从上到下，再从右向左，再从下向上，每一次执行都要判断边界值\n     * @param matrix\n     * @return\n     */\n    public static int[] spiralOrder(int[][] matrix) {\n        if(matrix.length==0){\n            return new int[0];\n        }\n        int l = 0;\n        int r=matrix[0].length-1;\n        int t=0;\n        int b=matrix.length-1;\n        int x=0;\n        int[] res = new int[(r+1)*(b+1)];\n        while(true){\n            //从左向右\n            for(int i=l;i&lt;=r;i++){\n                res[x++]=matrix[t][i];\n            }\n            if(++t&gt;b) {\n                break;\n            }\n            //从上向下\n            for(int i=t;i&lt;=b;i++){\n                res[x++] = matrix[i][r];\n            }\n            if(--r&lt;l){\n                break;\n            }\n            //从右向左\n            for(int i=r;i&gt;=l;i--){\n                res[x++] = matrix[b][i];\n            }\n            if(--b&lt;t){\n                break;\n            }\n            //从下往上\n            for(int i=b;i&gt;=t;i--){\n                res[x++] = matrix[i][l];\n            }\n            if(++l&gt;r){\n                break;\n            }\n        }\n        return res;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1253250557729087488","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hXB2ASIQwAAAaZr2Bc1U016.jpg","blogRead":0,"blogRemark":"剑指offer-----之顺时针打印矩阵----LeetCode54","blogTitle":"剑指offer-----之顺时针打印矩阵----LeetCode54","createdTime":"2020-04-23 17:13:11","typeName":"LeetCode","updateTime":"2020-04-23 17:13:11"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，对称的二叉树</strong></h2>\n<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>\n<p>例如，二叉树&nbsp;[1,2,2,3,4,4,3] 是对称的。</p>\n<p>&nbsp; &nbsp; 1<br />&nbsp; &nbsp;/ \\<br />&nbsp; 2 &nbsp; 2<br />&nbsp;/ \\ / \\<br />3 &nbsp;4 4 &nbsp;3<br />但是下面这个&nbsp;[1,2,2,null,3,null,3] 则不是镜像对称的:</p>\n<p>&nbsp; &nbsp; 1<br />&nbsp; &nbsp;/ \\<br />&nbsp; 2 &nbsp; 2<br />&nbsp; &nbsp;\\ &nbsp; \\<br />&nbsp; &nbsp;3 &nbsp; &nbsp;3</p>\n<p>示例 1：</p>\n<p>输入：root = [1,2,2,3,4,4,3]<br />输出：true<br />示例 2：</p>\n<p>输入：root = [1,2,2,null,3,null,3]<br />输出：false</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>递归法：从对称的二叉树中我们可以找到如下规律</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果一个二叉树是对称的，则每一个节点的左右子树也是对称的,因此是递归的</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 设L = root.left，R=root.right，则满足L.left.val = R.right.val;L.right.val=R.left.val;</strong></p>\n<pre class=\"language-java\"><code>public boolean isSymmetric(TreeNode root) {\n        return  root==null?true:recur(root.left,root.right);\n    }\n    public boolean recur(TreeNode L,TreeNode R){\n        if(L==null&amp;&amp;R==null){\n            return true;\n        }\n        if(L==null||R==null||L.val!=R.val){\n            return false;\n        }\n        return recur(L.left,R.right)&amp;&amp;recur(L.right,R.left);\n    }</code></pre>","blogGoods":0,"blogId":"1252992659794968576","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6ga--AKQdvAAAaZr2Bc1U862.jpg","blogRead":1,"blogRemark":"剑指offer----之对称的二叉树----LeetCode101","blogTitle":"剑指offer----之对称的二叉树----LeetCode101","createdTime":"2020-04-23 00:08:23","typeName":"LeetCode","updateTime":"2020-04-23 00:12:33"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，二叉树镜像</strong></h2>\n<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>\n<p>例如输入：</p>\n<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; 2 &nbsp; &nbsp; 7<br />&nbsp;/ \\ &nbsp; / \\<br />1 &nbsp; 3 6 &nbsp; 9<br />镜像输出：</p>\n<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; 7 &nbsp; &nbsp; 2<br />&nbsp;/ \\ &nbsp; / \\<br />9 &nbsp; 6 3&nbsp; &nbsp;1</p>\n<p>示例 1：</p>\n<p>输入：root = [4,2,7,1,3,6,9]<br />输出：[4,7,2,9,6,3,1]</p>\n<p>限制：</p>\n<p>0 &lt;= 节点个数 &lt;= 1000</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;递归法：即递归的去交换根节点的左右子树，直到根节点为叶子节点</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用递归的方法，交换根节点的左子树和右子树\n     * 递归出口为，根节点为叶子节点\n     * @param root\n     * @return\n     */\n    public TreeNode mirrorTree(TreeNode root) {\n        TreeNode center = root;\n        if(center!=null){\n            TreeNode temp = center.left;\n            center.left = center.right;\n            center.right = temp;\n            mirrorTree(center.left);\n            mirrorTree(center.right);\n        }\n        return root;\n    }</code></pre>","blogGoods":0,"blogId":"1252985443281027072","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6gZTWABF55AAAaZr2Bc1U678.jpg","blogRead":0,"blogRemark":"剑指offer----之二叉树的镜像----LeetCode226","blogTitle":"剑指offer----之二叉树的镜像----LeetCode226","createdTime":"2020-04-22 23:39:43","typeName":"LeetCode","updateTime":"2020-04-22 23:39:43"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，合并两个有序链表</strong></h2>\n<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>\n<p>示例1：</p>\n<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br />输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br />限制：</p>\n<p>0 &lt;= 链表长度 &lt;= 1000</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>伪头节点法：即创建一个伪头节点head和一个用于辅助的节点cur</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法：如果l1.val&lt;=l2.val,就让cur指向l1，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l1指向其next</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果l1.val&gt;l2.val,就让cur指向l2，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l2指向其next</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;直到l1和l2有一个为空为止，让cur指向剩余的一个非空链表即可，若两个链表的长度为M,N则时间复杂度为O(M+N)</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用四节点，一个伪头节点，一个当前节点cur，已经链表的两个节点l1,l2\n     * 每次比较l1,l2节点的val大小，将小的节点连接到当前节点cur上即可\n     * 直到l1,l2有一个空，则将剩余的一个非空链表连接到cur尾部即可\n     * @param l1\n     * @param l2\n     * @return\n     */\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode head;\n        ListNode cur;\n        head = cur = new ListNode(0);\n        while(l1!=null&amp;&amp;l2!=null){\n            if(l1.val&lt;=l2.val){\n                cur.next = l1;\n                cur = cur.next;\n                l1 = l1.next;\n            }else{\n                cur.next = l2;\n                cur = cur.next;\n                l2 = l2.next;\n            }\n        }\n        if(l1!=null){\n            cur.next = l1;\n        }\n        if(l2!=null){\n            cur.next = l2;\n        }\n        return head.next;\n    }</code></pre>","blogGoods":0,"blogId":"1252980258446000128","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6gYGWAe-MZAAAaZr2Bc1U550.jpg","blogRead":0,"blogRemark":"剑指offer----之合并有序链表---LeetCode21","blogTitle":"剑指offer----之合并有序链表---LeetCode21","createdTime":"2020-04-22 23:19:06","typeName":"LeetCode","updateTime":"2020-04-22 23:19:06"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，反转链表</strong></h2>\n<p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>\n<p>示例:</p>\n<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br />输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>\n<p>限制：</p>\n<p>0 &lt;= 节点个数 &lt;= 5000</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;双指针法：初始化两个指针p1,p2，p1指向null;p2指向头节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;使用临时节点存放p2.next;将p2.next =p1;p1=p2;p2=临时节点即可</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法\n     * 初始化两个指针p1,p2,p1=head;p2=head.next\n     * 先将头节点的next置为null\n     * 然后使用一个辅助指针临时存储p2.next；再将p2.next=p1;p1=p2;p2=临时指针；直到p2.next==null\n     * @param head\n     * @return\n     */\n    public ListNode reverseList2(ListNode head){\n        ListNode p1 = null;\n        ListNode p2 = head;\n        while(p2!=null){\n            ListNode help = p2.next;\n            p2.next=p1;\n            p1 = p2;\n            p2 = help;\n        }\n        return p1;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>递归法：想想这道题，反转！！！是不是跟栈的结构很相似，先进后出（是的，没错，博主刚开始做这道题，第一时间想的就是用栈的特性，但是WTF，我真的栈给它实现了一遍，后来看到递归解法我哭了，递归的本质不就是栈吗？我为什么要这么愚蠢，手动实现一遍递归的内部过程？？？？<img src=\"https://cdn.jsdelivr.net/npm/tinymce-all-in-one@4.9.3/plugins/emoticons/img/smiley-cry.gif\" alt=\"cry\" /><img src=\"https://cdn.jsdelivr.net/npm/tinymce-all-in-one@4.9.3/plugins/emoticons/img/smiley-cry.gif\" alt=\"cry\" />）。好了，不扯了，直接上正题：递归到最后的一个节点，用ret接收，然后将其前一个节点的next.next指向本身，然后再将前一个节点的next指向null即可。</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 既然可以用栈，当然可以用递归\n     * 因为递归操作的本质就是栈的入栈出栈操作\n     * @param head\n     * @return\n     */\n    public ListNode reverseList3(ListNode head){\n        if(head==null||head.next==null){\n            return head;\n        }\n        ListNode ret = reverseList3(head.next);\n        head.next.next = head;\n        head.next = null;\n        return ret;\n    }</code></pre>\n<p>&nbsp;</p>\n<h3><strong>最后，附上博主的垃圾栈代码给大家瞅瞅，望诸君共勉，告诫自己，时刻保持清醒！！</strong></h3>\n<pre class=\"language-java\"><code>    /**\n     * 一看到反转立马想到栈的特性：先进后出\n     * 可以加一个中间栈，遍历链表将每个元素放入栈中\n     * 然后再出栈，构成一个新链表即可，但是时间复杂度为O(N),空间复杂度也为O（N）,较为复杂\n     * @param head\n     * @return\n     */\n    public ListNode reverseList(ListNode head) {\n        if(head==null){\n            return head;\n        }\n        Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;();\n        int count = 0;\n        while(head.next!=null){\n            stack.push(head);\n            head = head.next;\n            count++;\n        }\n        //创建辅助节点，便于输出最后的链表\n        ListNode help = null;\n        help = head;\n        while(!stack.isEmpty()){\n            head.next = stack.pop();\n            head = head.next;\n            count--;\n            if(count==0){\n                head.next = null;\n            }\n        }\n        return help;\n    }</code></pre>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1252636594674872320","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6fIEiAab3fAAAaZr2Bc1U212.jpg","blogRead":1,"blogRemark":"剑指offer----之反转链表----LeetCode206","blogTitle":"剑指offer----之反转链表----LeetCode206","createdTime":"2020-04-22 00:33:31","typeName":"LeetCode","updateTime":"2020-04-22 00:33:38"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，二进制中1的个数</strong></h2>\n<p>请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9&nbsp;表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>\n<p>示例 1：</p>\n<p>输入：00000000000000000000000000001011<br />输出：3<br />解释：输入的二进制串 00000000000000000000000000001011&nbsp;中，共有三位为 '1'。<br />示例 2：</p>\n<p>输入：00000000000000000000000010000000<br />输出：1<br />解释：输入的二进制串 00000000000000000000000010000000&nbsp;中，共有一位为 '1'。<br />示例 3：</p>\n<p>输入：11111111111111111111111111111101<br />输出：31<br />解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。</p>\n<p><strong>刚开始看到题目的时候，感觉题目是不是有问题，不是要求输入一个整数，判断整数转换为二进制数中的1的位数吗？然后就想当然的在转换过程中计算1的个数，结果一提交，reject（我擦）。看了解析之后才明白为什么俺们都是人，脑袋里装的东西差距能嫩么大呢！！！！！</strong></p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;利用位运算：即每次将二进制数的最后一位&amp;1，如果结果为1，则说明最后一位为1，计数器加1；如果不为1，则不做任何操作；每次操作之后，将原数字向右无符号移位1位，相当于缩小一倍，即去掉最后一位，在二进制数左前面添加一个0.直到n为0截至，时间复杂度即二进制数最高位1的位数，</strong><strong>即<span style=\"background-color: #ffcc00;\">O（log2N）</span>.解法如下：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用位运算，每次判断二进制数的最右边一位，如果&amp;1为1则表明该位为1，计数器加1\n     * 如果&amp;1不为1，不做操作\n     * 每次运算结束，都要将原数字无符号右移一位，缩小一倍，相当于将最后一位去掉，在左前面补上一个0\n     * 时间复杂度位（Log2n）即是二进制数最高位1的位数\n     * @param n\n     * @return\n     */\n    public static int hammingWeight2(int n){\n        int count = 0;\n        while(n!=0){\n            count+=(n&amp;1);\n            n&gt;&gt;&gt;=1;\n        }\n        return count;\n    }</code></pre>\n<p>&nbsp;</p>\n<p>&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<strong>巧用n&amp;(n-1)：没错，就是在看了这个解法之后，就像玩联盟的时候发现自己跟大神玩的完全不是一个游戏一样。现在我也是这种心理，我们是同一个物种吗？我们做的是一道题吗？小朋友，你是否有很多？号。现在我们看看大神的解法：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 巧用n&amp;(n-1),每次消去n的最右边一个1，直到n为0\n     * @param n\n     * @return\n     */\n    public static int hammingWeight3(int n){\n        int count = 0;\n        while(n!=0){\n            count++;\n            n&amp;=(n-1);\n        }\n        return count;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>设二进制数中1的个数为M,则该种解法的时间复杂度就为<span style=\"background-color: #ffcc00;\">O（M）</span></strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;现在具体分析一下：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;设n为10101000，则(n-1)就为101000111，到这里好好看看这两个数字，是不是优点感觉了！</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;然后n&amp;(n-1)=10100000,你发现了什么？是不是二进制数n的最右边的1被消除了！对，没错，就是这样，你再多来几次！我擦，什么人，脑子装的机器码吗？还能这么玩？好了，剩下的就不说了，自己体会吧。</strong></p>","blogGoods":0,"blogId":"1252518351972872192","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6esjKAQsixAAAaZr2Bc1U878.jpg","blogRead":1,"blogRemark":"LeetCode191---之二进制数中1的个数","blogTitle":"LeetCode191---之二进制数中1的个数","createdTime":"2020-04-21 16:43:40","typeName":"LeetCode","updateTime":"2020-04-21 16:45:38"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，旋转数组的最小数字</strong></h2>\n<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组&nbsp;[3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。&nbsp;&nbsp;</p>\n<p>示例 1：</p>\n<p>输入：[3,4,5,1,2]<br />输出：1<br />示例 2：</p>\n<p>输入：[2,2,2,0,1]<br />输出：0</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;暴力环循法：即遍历一遍数组，遍历的过程种如果发现当前元素小于前面的元素，则返回当前元素；否则返回数组第一个元素。时间复杂度为O（N）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 遍历数组，按照升序规则查找需要进行交换的元素，输出后面的一个较小元素即可，时间复杂度为O（n)\n     * @param numbers\n     * @return\n     */\n    public static int minArrays(int[] numbers){\n        for(int i=1;i&lt;numbers.length;i++){\n            if(numbers[i]&lt;numbers[i-1]){\n                return numbers[i];\n            }\n        }\n        return numbers[0];\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>利用二分查找法的特性：该题是二分查找的变版，前后两个递增数组，仍然可以使用二分查找，只是具体的逻辑不同。时间复杂度为O（N），当然特别情况下会退化到O（logN）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 二分查找\n     * @param numbers\n     * @return\n     */\n    public static int minArray(int[] numbers){\n        int i=0;\n        int j=numbers.length-1;\n        while(i&lt;j){\n            int m = (i+j)/2;\n            if(numbers[m]&gt;numbers[j]){\n                i = m+1;\n            }else if(numbers[m]&lt;numbers[j]){\n                j = m;\n            }else{\n                j--;\n            }\n        }\n        return numbers[i];\n    }</code></pre>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1252503447316475904","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6epFCAFjmsAAAaZr2Bc1U324.jpg","blogRead":0,"blogRemark":"LeetCode154----之旋转数组的最小值","blogTitle":"LeetCode154----之旋转数组的最小值","createdTime":"2020-04-21 15:44:26","typeName":"LeetCode","updateTime":"2020-04-21 23:17:51"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，青蛙跳台阶</strong></h2>\n<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n&nbsp;级的台阶总共有多少种跳法。</p>\n<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>\n<p>示例 1：</p>\n<p>输入：n = 2<br />输出：2<br />示例 2：</p>\n<p>输入：n = 7<br />输出：21<br />提示：</p>\n<p>0 &lt;= n &lt;= 100</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>分析：因为青蛙只有两种跳法，要么跳一级，要么跳两级。我们设上一个n级台阶的跳法为f(n)种，则对于最后一步只有两种情况：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;当最后一步跳1级台阶时，前面则跳了(n-1)级台阶，跳法为f(n-1)</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;当最后一步跳2级台阶时，前面则跳了（n-2）级台阶，跳法为f(n-2),</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;所以f(n) = f(n-1)+f(n-2)</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;解法一：递归求解，递归出口为f(1)=1,f(2)=2;递归体为f(n)=f(n-1)+f(n-2),但是递归的时间复杂度为指数级，且计算了太多重复数据</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 青蛙跳台阶递归解法\n     *\n     * @param n\n     * @return\n     */\n    public static int jump(int n) {\n        if (n == 1) {\n            return 1;\n        } else if (n == 2) {\n            return 2;\n        } else {\n            int result = jump(n - 1) + jump(n - 2);\n            return result % 1000000007;\n        }\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>解法二：动态规划，因为可以分解为子问题，且子问题的求解依赖于前面求解过的子问题，而且递归存在重复计算的问题。所以可使用动态规划，如下：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 青蛙跳台阶动态规划解法\n     *\n     * @param n\n     * @return\n     */\n    public static int jump2(int n) {\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        dp[1] = 1;\n        for (int i = 2; i &lt;= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n            dp[i] = dp[i] % 1000000007;\n        }\n        return dp[n];\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>官方解法：动态规划，但是用三个变量存储子问题的值，依次交替前进，空间复杂度降为O(1)</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 动态规划解决青蛙跳台阶\n     * @param n\n     * @return\n     */\n    public static int jump3(int n){\n        int a=1,b=1,sum;\n        for(int i=0;i&lt;n;i++){\n            sum = (a+b)%1000000007;\n            a = b;\n            b = sum;\n        }\n        return a;\n    }</code></pre>\n<p>&nbsp;</p>\n<h2><strong>该题和斐波那契数列问题基本一致，只是初始值存在差别。</strong></h2>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1252439650715316224","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6eaOaAXbVhAAAaZr2Bc1U560.jpg","blogRead":0,"blogRemark":"LeetCode70----青蛙跳台阶","blogTitle":"LeetCode70----青蛙跳台阶","createdTime":"2020-04-21 11:30:56","typeName":"LeetCode","updateTime":"2020-04-21 23:17:38"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，斐波那契数列</strong></h2>\n<p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</p>\n<p>F(0) = 0,&nbsp; &nbsp;F(1)&nbsp;= 1<br />F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br />斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>\n<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>\n<p>示例 1：</p>\n<p>输入：n = 2<br />输出：1<br />示例 2：</p>\n<p>输入：n = 5<br />输出：5</p>\n<p>提示：</p>\n<p>0 &lt;= n &lt;= 100</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;一般情况下，遇到斐波那契数列，可能首先想到的就是递归解决，时间复杂度为O（2^n），嗯，这个时间复杂度，和没用算法没啥区别。如下：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 递归解决斐波那契数列第n项问题\n     * @param n\n     * @return\n     */\n    public static int findFibonacci2(int n){\n        if(n==0){\n            return 0;\n        }else if(n==1){\n            return 1;\n        }else{\n            int result = findFibonacci2(n-1)+findFibonacci2(n-2);\n            return result%1000000007;\n        }\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>动态规划：因为本题求解的问题可以分解为子问题，并且子问题会出现重复，所以采用动态规划更优。这里，博主使用的动态规划还没有到最优解的情况，因为使用数组，空间复杂度为O（n）,但是实际上可以将空间复杂度降为O（1）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;动态规划的一般解题思路（参照此题，大神勿喷）：（1）找出转台转移方程，即根据1-（n-1）项推导出第n项；（2）使用一个数组存储子状态，这也是动态规划优化时间复杂度的主要途径；</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * dp求斐波那契数列的第n项\n     *\n     * @param n\n     * @return\n     */\n    public static int findFibonacci(int n) {\n        if(n==0||n==1){\n            return n;\n        }\n        int[] dp = new int[n+1];\n        dp[0] = 0;\n        dp[1] = 1;\n\n        for(int i = 2;i&lt;=n;i++){\n            dp[i] = dp[i-1]+dp[i-2];\n            dp[i] = dp[i]%1000000007;\n        }\n        return dp[n];\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>下面贴一下官方的超神解答：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 时间复杂度为O（n）,空间复杂度O（1)动态规划\n     * @param n\n     * @return\n     */\n    public static int findFibonacci3(int n){\n        int a=0,b=1,sum;\n        for(int i=0;i&lt;n;i++){\n            sum = (a+b)%1000000007;\n            a = b;\n            b = sum;\n        }\n        return a;\n    }</code></pre>\n<p>&nbsp;</p>\n<h2><strong>关于动态规划，待博主深入学习之后，再做总结</strong></h2>","blogGoods":0,"blogId":"1252423800151093248","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6eWiCADg7OAAAaZr2Bc1U759.jpg","blogRead":0,"blogRemark":"LeetCode509----斐波那契数列","blogTitle":"LeetCode509----斐波那契数列","createdTime":"2020-04-21 10:27:57","typeName":"LeetCode","updateTime":"2020-04-21 10:34:11"}],"pageSize":15,"params":{"blogTitle":"LeetCode"},"sortColumn":"created_time","sortMethod":"DESC","totalCount":16,"totalPage":2},"msg":"操作成功!"}
2020-04-26 23:29:06.086 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /rotation-picture/listFront
2020-04-26 23:29:06.087 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:29:06.087 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:29:06.087 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.RotationPictureController.getRotationPictureListFront
2020-04-26 23:29:06.087 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:29:06.097 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/list
2020-04-26 23:29:06.098 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:29:06.098 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:29:06.098 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogList
2020-04-26 23:29:06.098 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=15, totalPage=0, totalCount=0, list=[], params={}, sortColumn=created_time, sortMethod=DESC)]
2020-04-26 23:29:06.188 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 102
2020-04-26 23:29:06.188 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"createdTime":"2020-04-09 13:31:20","enable":1,"rotationId":4,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PI6aAZIz1AASCO4hlpJI295.jpg"},{"createdTime":"2020-04-09 13:37:02","enable":1,"rotationId":9,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJPyAbm8fAAG9gfO8lxE28.jpeg"},{"createdTime":"2020-04-09 13:41:30","enable":1,"rotationId":10,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJgeAeG8wAAS2pjJC5QU547.jpg"},{"createdTime":"2020-04-09 13:41:38","enable":1,"rotationId":11,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhGAQFZbAAP2OOBWb6k310.jpg"},{"createdTime":"2020-04-09 13:41:50","enable":1,"rotationId":12,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhyABMZCAAG7doyXiM8109.jpg"},{"createdTime":"2020-04-09 13:41:59","enable":1,"rotationId":13,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJiWAL7BoAARW3_O3ISw651.jpg"}],"msg":"操作成功!"}
2020-04-26 23:29:06.671 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 574
2020-04-26 23:29:06.672 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，0~n-1中缺失的数字</strong></h2>\n<p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>\n<p>示例 1:</p>\n<p>输入: [0,1,3]<br />输出: 2<br />示例&nbsp;2:</p>\n<p>输入: [0,1,2,3,4,5,6,7,9]<br />输出: 8</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主能想到的并且写出来的方法有：使用map存储数组中的所有元素，然后遍历0-n-1找出不在map中的元素。此种方法时间复杂度O（N），空间复杂度O（N）-----垃圾</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 统计0-n-1所有数字的数字和，再统计数组中所有数字的数字和，两和只差即为所求数字，时间复杂度O（N），空间复杂度O（1）-----垃圾</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;最优解法（二分查找法）：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;通常来说，我们使用二分查找法是查找一个存在于数组中的元素，但是本题需要求不在数组中的一个元素，因此到这很多人就会迷惑，不知道该怎么求了。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;但是我们首先要搞明白二分查找法的本质是什么：1，并不局限于仅仅查找存在于数组中的元素；2，二分查找的本质是对数组根据mid中间值在某一条件上进行二分（例如：通常的num[mid]&gt;target或者nums[mid]&lt;target进行左右切分）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;因此明白这一点，就好解决问题了。拿到这道题，使用二分，我们首先想到的应该是寻找根据mid中间值进行二分的条件</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;审题：题目中提及数组为递增数组，而且0-n-1内的n个数字有一个不在数组中，则不在的这个数字之前的数字满足nums[i]=i即元素本身等于数组下标，而之后的数字nums[i]!=i,所以这就是进行二分的条件了</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 二分查找法\n     * 算法思想：二分查找法的本质是能够有一个条件将数组根据mid中间值进行左右切分\n     * 所以我们想到二分查找法之后，首先需要做的是找出切分数组的条件\n     * 题目中给出了数组是一个递增数组，且0-n-1内的n个数字有一个不在这个长度为n-1的数组内\n     * 因此，不在的这个元素其左边元素必有数组下标值等于元素本身即nums[i]=i\n     * 而不在的这个元素的右边必有nums[i]!=i\n     * 所以根据此条件进行划分数组即可\n     * @param nums\n     * @return\n     */\n    public static int missingNumber(int[] nums) {\n        int low = 0;\n        int high = nums.length-1;\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]==mid){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        return low;\n    }</code></pre>","blogGoods":0,"blogId":"1254063045920022528","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kUM-AON88AAAaZr2Bc1U903.jpg","blogRead":0,"blogRemark":"剑指offer----0~n-1中缺失的数字","blogTitle":"剑指offer----0~n-1中缺失的数字","createdTime":"2020-04-25 23:01:44","typeName":"LeetCode","updateTime":"2020-04-25 23:01:44"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，在排序数组中查找数字I</strong></h2>\n<p>统计一个数字在排序数组中出现的次数。</p>\n<p>示例 1:</p>\n<p>输入: nums = [5,7,7,8,8,10], target = 8<br />输出: 2<br />示例&nbsp;2:</p>\n<p>输入: nums = [5,7,7,8,8,10], target = 6<br />输出: 0</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解法一：直接遍历统计，时间复杂度为O（N）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 遍历数组\n     * 找到第一个与目标元素相等的元素，res+1\n     * 然后往后找到第一个与目标元素不相等的元素,返回res即可\n     * 时间复杂度为O(N)\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static int search(int[] nums, int target) {\n        int res = 0;\n        for (int num : nums) {\n            if(num==target){\n                res++;\n            }\n        }\n        return res;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解法二：二分法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：利用二分法查找数字在排序数组中的左边界Left和右边界Right.如下，如果要寻找数组中的8，则其左边界为left=2,有边界right=5.所以出现次数为right-left-1.时间复杂度为O（logN）</strong></p>\n<table style=\"width: 20%; border-collapse: collapse; margin-left: auto; margin-right: auto;\" border=\"1\" cellpadding=\"5\">\n<tbody>\n<tr>\n<td style=\"width: 16.6667%;\">5</td>\n<td style=\"width: 16.6667%;\">7</td>\n<td style=\"width: 16.6667%;\">7</td>\n<td style=\"width: 16.6667%;\">8</td>\n<td style=\"width: 16.6667%;\">8</td>\n<td style=\"width: 16.6667%;\">10</td>\n</tr>\n</tbody>\n</table>\n<pre class=\"language-java\"><code>    /**\n     * 二分查找法\n     * 时间复杂度为O（logN）\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static int search2(int[] nums, int target){\n        int low = 0;\n        int high = nums.length-1;\n        int left,right;\n        left = right = 0;\n        //一次二分\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]&lt;=target){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        right = low;\n\n        low = 0;\n        high = nums.length -1;\n        //二次二分\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]&lt;target){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        left = high;\n        return right -left -1;\n    }</code></pre>","blogGoods":0,"blogId":"1254055163115724800","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kSXiAYRyFAAAaZr2Bc1U379.jpg","blogRead":0,"blogRemark":"剑指offer----在排序数组中查找数字I----LeetCode34","blogTitle":"剑指offer----在排序数组中查找数字I----LeetCode34","createdTime":"2020-04-25 22:30:24","typeName":"LeetCode","updateTime":"2020-04-25 22:30:24"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，两个链表的第一个公共节点</strong></h2>\n<p><strong><img src=\"https://images-cdn.shimo.im/Wd1NC8pveQYp9iIL.png__thumbnail\" alt=\"示例图\" width=\"742\" height=\"241\" /></strong></p>\n<p><strong>这是我从官方截下的一张图，也是有些人疑惑的地方，因为官方这张图给出的公共节点为8，而大多数人看到这张图，认为公共节点应该是1.</strong></p>\n<p><strong>但是实际上这里的公共节点不仅要节点的value相等，同时还需要节点的地址相等。从图中可以看出两个1节点虽然值相等，但是地址却不同，因而不是公共节点</strong></p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解法一：双指针</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：初始化两个指针p1=headA,p2=headB</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;分别遍历两个链表，求出两个链表的长度l1,l2</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;然后重置p1,p2指针指向头节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;让长链表的指针先走多的步数（l1-l2或者l2-l1）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;然后让两个指针同时走，直到两者相遇，即找到公共节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解疑：弄清楚第一个value相等的节点和指针相遇的节点，这两种节点是不同的，指针相遇的节点，不仅包含value相等，同时地址也相等。（如图中的8）；而第一个value相等的节点则可能并不在同一个地址，因此不一定是公共节点</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法\n     * @param headA\n     * @param headB\n     * @return\n     */\n    public static ListNode getIntersectionNode2(ListNode headA, ListNode headB){\n        ListNode p1 =headA;\n        ListNode p2 = headB;\n        int l1 = 0;\n        int l2 = 0;\n        //计算链表1的长度\n        while(p1!=null){\n            l1++;\n            p1 = p1.next;\n        }\n        //计算链表2的长度\n        while(p2!=null){\n            l2++;\n            p2 = p2.next;\n        }\n        p1 = headA;\n        p2 = headB;\n        //让长链表指针先走长的步数\n        if(l1&gt;l2){\n            for (int i = 0; i &lt; l1-l2; i++) {\n                p1 = p1.next;\n            }\n        }else{\n            for (int i = 0; i &lt; l2-l1; i++) {\n                p2 = p2.next;\n            }\n        }\n        //然后让两个指针同时走，直到相遇\n        while(p1!=p2){\n            p1 = p1.next;\n            p2 = p2.next;\n        }\n        return p1;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;解法二（大神解法）：丘比特相遇法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;利用两个指针p1=headA,p2=headB,让两个指针同时走，</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果p1先走到底，就将p1置为headB，</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果p2,先走到底，就将p2置为headA,</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;当两个指针相遇的时候，他们就相爱了（当然是找到公共节点了）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法p1=headA,p2=headB\n     * 思想是：两个节点同时从各自的链表出发\n     * p1走到末尾时，回到headB的头部\n     * p2走到末尾时，回到headA的头部\n     * 两个指针相遇的时候，即使要找的公共节点\n     * @param headA\n     * @param headB\n     * @return\n     */\n    public static ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode p1 = headA;\n        ListNode p2 = headB;\n        while(p1!=p2){\n            p1 = (p1==null)?headB:p1.next;\n            p2 = (p2==null)?headA:p2.next;\n        }\n        return p1;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1253992797703364608","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kD2OADD3mAAAaZr2Bc1U709.jpg","blogRead":0,"blogRemark":"剑指offer----之两个链表的第一个公共节点----LeetCode160","blogTitle":"剑指offer----之两个链表的第一个公共节点----LeetCode160","createdTime":"2020-04-25 18:22:35","typeName":"LeetCode","updateTime":"2020-04-25 18:22:35"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，第一个只出现一次的字符</strong></h2>\n<p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。</p>\n<p>示例:</p>\n<p>s = \"abaccdeff\"<br />返回 \"b\"</p>\n<p>s = \"\" <br />返回 \" \"</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主现在发现，做一道算法题的时候，最重要的一步就是读题，审题，在草稿纸上写下自己的思路（当然那种望眼欲穿的大佬除外）。然后才开始动笔，对于IT人来说，真的，多将时间花费在思考上面，而不是无意义的重复搬砖。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;题目分析：看到这道题，抓住两个关键字：第一个，只出现一次。什么意思呢，例如\"abaccdeff\"，其中只出现一次的字符有'b','d','e'三个，然后在三个字符中第一个出现在字符串中的是'b'，因此本题的答案是'b'.</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法分析：根据题目分析，我们最直观的解法应该是，先找出字符串中只出现一次的字符，然后再找出只出现一次字符中，第一个在字符串中出现的。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;所以我们需要做两件事，一是统计字符串中各个字符的出现次数，并且记录；二，统计完毕后，找出第一个出现次数为1的字符，返回即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;因此我们既要存字符，还要存字符对应的出现次数，所以理所当然我们选择map集合。当然对于本题而言，因为求第一个出现一次的字符，所以我们更好的是可以使用LinkedHashMap。这样免去最后的一次遍历字符串</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;下面提供两种解法：三种解法都是使用map集合，但是略有不同</strong></p>\n<p><strong>LinkedHashMap：（这是博主写的，代码冗余，这里用来和大神的写法做比较，警醒自己）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 用LinkedHashMap\n     * 思想：遍历字符串，如果map为空或者map中不含当前字符，则将其存入map\n     * 如果map中已经含有当前字符，则从map中移除\n     * 最终map中只剩出现一次的字符\n     * 返货map中的第一个即可\n     * @param s\n     * @return\n     */\n    public static char firstUniqChar(String s) {\n        Map&lt;Character,Integer&gt;map = new LinkedHashMap&lt;&gt;();\n        for (int i = 0; i &lt; s.length(); i++) {\n            char ch = s.charAt(i);\n            if(map.isEmpty()||!map.containsKey(ch)){\n                map.put(ch,1);\n            }else{\n                Integer val = map.get(ch);\n                map.put(ch,++val);\n            }\n        }\n        //返回map中第一个元素即可\n        Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entries = map.entrySet();\n        for (Map.Entry&lt;Character, Integer&gt; entry : entries) {\n            if(entry.getValue()==1){\n                return entry.getKey();\n            }\n        }\n        return ' ';\n    }</code></pre>\n<p><strong>HashMap（大神解法）：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 哈希表法\n     * @param s\n     * @return\n     */\n    public char firstUniqChar2(String s) {\n        Map&lt;Character,Boolean&gt; map = new HashMap&lt;&gt;();\n        char[] chars = s.toCharArray();\n        for (char ch : chars) {\n            map.put(ch,!map.containsKey(ch));\n        }\n        for (char ch : chars) {\n            if(map.get(ch)){\n                return ch;\n            }\n        }\n        return ' ';\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;分析：首先，这里提供了两种解法，一种为LinkedHashMap，一种为HashMap，这两种解法的不同之处就在于最后获取值的时候，LinkedHashMap获取最终值是遍历LinkedHashMap的entrySet，但是HashMap获取最终值是遍历原字符串。因而当数据庞大的时候，显然使用LinkedHashMap性能更高。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;然后，再分析一下这两种解法不另外一个不同之处，没错！就是大神的解法中使用map存放key对应的value值是Boolean型！（<span style=\"background-color: #ffcc00;\">这个真的是神一般的存在</span>），既省去了计算次数的麻烦，同时最后取的时候也不需要判断次数。wc！同一种解法，为什么天差地别！</strong></p>","blogGoods":0,"blogId":"1253956468789600256","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6j7Y6ACrySAAAaZr2Bc1U825.jpg","blogRead":0,"blogRemark":"剑指offer----第一次只出现一次的字符","blogTitle":"剑指offer----第一次只出现一次的字符","createdTime":"2020-04-25 15:58:14","typeName":"LeetCode","updateTime":"2020-04-25 15:58:14"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，连续子数组的最大和</strong></h2>\n<p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>\n<p>要求时间复杂度为O(n)。</p>\n<p>示例1:</p>\n<p>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br />输出: 6<br />解释:&nbsp;连续子数组&nbsp;[4,-1,2,1] 的和最大，为&nbsp;6。</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;看到这道题，最简单的想法肯定是求出所有连续子数组的值，然后进行比较，找出最大的即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;但是随后会想到既然要找出所有的子数组，那么我们可以使用分治的思想，因为分治的分过程即可以得到所有子序列</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;随后，再深一步，既然可以分治的思想，分的过程即是递归的过程，而且子数组的最大值依赖与前一子数组，所以可以想到使用动态规划</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：设dp[i]为以nums[i]为结尾的最大子数组和，初始值dp[0] = nums[0]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;遍历数组，如果dp[i-1]&gt;=0。则说明前面的最大子数组对当前子数组有增益效果，所以dp[i] = dp[i-1]+nums[i]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果dp[i-1]&lt;0。说明前面的最大子数组对当前子数组有夫负效果，还不如nums[i]本身，所以dp[i]=nums[i]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主的这样的写法：时间复杂度为O（N），空间复杂度也为O（N），但是实际上不需要使用dp数组，使用nums原数组就行，所以可以减小空间复杂度为O（1）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 动态规划\n     * 算法思想：因为求的是连续子数组的最大和\n     * 所以我们可以设dp[i]为以nums[i]结尾的最大连续子数组\n     * 如果dp[i]&lt;=nums[i],dp[i]=nums[i]\n     * 如果dp[i]&gt;nums[i],则dp[i]=dp[i]+nums[i]\n     * @param nums\n     * @return\n     */\n    public static int maxSubArray(int[] nums) {\n        int[] dp  = new int[nums.length];\n        dp[0] = nums[0];\n        int res = nums[0];\n        for (int i = 1; i &lt; nums.length; i++) {\n            if(dp[i-1]&lt;0){\n                dp[i] = nums[i];\n            }else{\n                dp[i] = dp[i-1]+nums[i];\n            }\n            res = Math.max(res,dp[i]);\n        }\n        return res;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1253938714590175232","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6j3QSACLxRAAAaZr2Bc1U017.jpg","blogRead":0,"blogRemark":"剑指offer---连续子数组的最大和---LeetCode53","blogTitle":"剑指offer---连续子数组的最大和---LeetCode53","createdTime":"2020-04-25 14:47:41","typeName":"LeetCode","updateTime":"2020-04-25 14:47:41"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，最小的k个数</strong></h2>\n<p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>\n<p>示例 1：</p>\n<p>输入：arr = [3,2,1], k = 2<br />输出：[1,2] 或者 [2,1]<br />示例 2：</p>\n<p>输入：arr = [0,1,2,1], k = 1<br />输出：[0]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;1,可以采用快排的思想，将原数组按照升序排序，然后取出前k个数即可，时间复杂度为O（NlogN）。但是其实跟API中的sort方法好像差别不大</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 对原数组升序排序，然后取前k个元素\n     * @param arr\n     * @param k\n     * @return\n     */\n    public static int[] getLeastNumbers(int[] arr, int k) {\n        quickSort(arr,0,arr.length-1);\n        int[] result = new int[k];\n        for (int i = 0; i &lt; k; i++) {\n            result[i] = arr[i];\n        }\n        return result;\n    }\n\n    /**\n     * 快排\n     * @param nums\n     * @param low\n     * @param high\n     */\n    public static void quickSort(int[] nums,int low,int high){\n        int base = nums[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //先从右向左找到第一个小于基准元素的元素\n            while(L&lt;R&amp;&amp;nums[R]&gt;=base){\n                R--;\n            }\n            if(nums[R]&lt;base){\n                swap(nums,L,R);\n            }\n            //再从左向右找到第一个大于基准元素的元素\n            while(L&lt;R&amp;&amp;nums[L]&lt;=base){\n                L++;\n            }\n            if(nums[L]&gt;base){\n                swap(nums,L,R);\n            }\n        }\n        //左递归\n        if(L&gt;low){\n            quickSort(nums,low,L-1);\n        }\n        //右递归\n        if(high&gt;R){\n            quickSort(nums,R+1,high);\n        }\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>2，堆排序：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;先讲解一下堆排序：堆排序是一种完全二叉树的结构，常见的存在两种堆结构，小根堆（即满足arr[2i+1]&gt;=arr[i]&amp;&amp;arr[2i+2]&gt;=arr[i]），大根堆（即满足arr[2i+1]&lt;=arr[i]&amp;&amp;arr[2i+2]&lt;=arr[i]）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;基本算法思想：第一步，初始化堆，即堆初始化为大根堆或者小根堆（这里我们简称调整堆）；第二步，将堆顶元素与堆的末尾元素进行交换，然后重新调整堆。在java中堆通常用来实现优先级队列PriorityQueue(默认的采用小根堆，若想使用大根堆，需要在创建时实现comparator)</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;使用情况：这里以java中的优先级队列为例，堆的使用情况不能按照堆名断章取义，例如小根堆实际上是将元素升序存放，因为在算法第二步中将堆顶元素与末尾元素进行交换，然后重新调整，交换的堆顶元素为最小元素，也是最先从堆中进入队列的。所以小根堆适用于TOPk大的算法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;相反的，大根堆适用于TOPk小的算法，下面分别给出小根堆和大根堆的算法：</strong></p>\n<p><strong>小根堆：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 堆排序---小根堆\n     * @param nums\n     */\n    public static void HeapSort(int[] nums){\n        //先初始化堆\n        for (int i = nums.length/2-1; i &gt;=0 ; i--) {\n            adjustHeap(nums,i,nums.length);\n        }\n        //交换堆顶与末尾节点+重新调整为小根堆\n        for (int i = nums.length-1; i &gt;0; i--) {\n            //先交换\n            swap(nums,0,i);\n            //再调整\n            adjustHeap(nums,0,i);\n        }\n    }\n\n    /**\n     * 调整为小根堆\n     * @param nums\n     * @param i\n     * @param length\n     */\n    public static void adjustHeap(int[] nums,int i,int length){\n        int temp = nums[i];\n        for (int j = 2*i+1; j &lt; length; j=2*j+1) {\n            //找出左右节点中的最小值\n            if(j+1&lt;length&amp;&amp;nums[j]&gt;nums[j+1]){\n                j++;\n            }\n            if(nums[j]&lt;temp){\n                nums[i] = nums[j];\n                i = j;\n            }\n        }\n        nums[i] = temp;\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p><strong>大根堆：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 堆排序---大根堆\n     * @param nums\n     */\n    public static void heapSort(int[] nums){\n\n        //初始化堆的过程\n        for (int i = nums.length/2-1; i &gt;=0; i--) {\n            adjustHeap(nums,i,nums.length);\n        }\n        //调整+交换堆顶和末尾的元素\n        for (int i = nums.length-1; i &gt;0; i--) {\n            //先交换，再重新调整\n            swap(nums,0,i);\n            adjustHeap(nums,0,i);\n        }\n    }\n\n    /**\n     * 调整大顶堆的过程\n     * @param nums\n     * @param i\n     * @param length\n     */\n    public static void adjustHeap(int[] nums,int i,int length){\n        int temp = nums[i];\n        for (int j = 2*i+1; j &lt; length; j=2*j+1) {\n            //找出左右节点中的最大值\n            if(j+1&lt;length&amp;&amp;nums[j]&lt;nums[j+1]){\n                j++;\n            }\n            if(nums[j]&gt;temp){\n                nums[i] = nums[j];\n                i = j;\n            }\n        }\n        nums[i] = temp;\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>本题利用大根堆解法，且使用java中自带的优先级队列PriorityQueue：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用堆数据结构，java中的优先级队列对应着最小堆\n     * 实现其comparator即可\n     * @param arr\n     * @param k\n     * @return\n     */\n    public static int[] getLeastNumbers2(int[] arr, int k){\n        Queue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(k,(v1,v2)-&gt;v2-v1);\n        for (int i : arr) {\n            if(heap.isEmpty()||heap.size()&lt;k||i&lt;heap.peek()){\n                heap.offer(i);\n            }\n            if(heap.size()&gt;k){\n                heap.poll();\n            }\n        }\n        int[] result = new int[k];\n        int j = 0;\n        for (Integer val : heap) {\n            result[j++] = val;\n        }\n        return result;\n    }</code></pre>","blogGoods":0,"blogId":"1253874832811089920","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6joYWAF3oqAAAaZr2Bc1U671.jpg","blogRead":2,"blogRemark":"剑指offer----之最小的k个数","blogTitle":"剑指offer----之最小的k个数","createdTime":"2020-04-25 10:33:50","typeName":"LeetCode","updateTime":"2020-04-25 11:53:15"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，数组中出现次数超过一半的元素---即众数</strong></h2>\n<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>\n<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>\n<p>示例&nbsp;1:</p>\n<p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br />输出: 2</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>方法有三：哈希表统计法，数组排序法，摩尔投票法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;哈希统计法：时间复杂度O（N），空间复杂度O（N）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 博主刚开始看到这道题的时候，首先想到的是哈希表统计法，因为博主想的是要找到众数，那么肯定得统计每个数字的出现次数，然后按照次数比较。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 单单是想到这些，用了map集合之后发现还是不行，因为即便用map集合统计出了每个数字和其对应的出现次数之后，你会发现没有办法按照出现的次数进行比较并且得到次数最多的数字（众数</strong><strong>）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 然后，就又审了一遍题目，结果发现了一个本题很关键的点，（<span style=\"background-color: #ffcc00;\">数组中有一个数字出现的次数超过数组长度的一半</span>），也就是说数组中有且仅有一个数字的出现次数会超过数组长度的一半（别笑博主笨，我是真的刚开始没反应过来）</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 那么我为什么要把数组中的所有元素和其次数全部存放进入map集合，然后再取次数进行比较呢？我为什么不在将元素和其次数存入集合的过程中判断次数是否已经超过数组长度的一半了呢？如果超过一半了，那它肯定是众数了呀！</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 思路：根据题意需要找出两个东西，一是多素元素，二是多素元素的出现次数\n     * 所以我们首先想到的是采用map集合\n     * 然后遍历数组，如果元素不存在与集合中，我们就将其加入map，value置为1\n     * 如果元素存在于map中，则我们取出其value将其加1与数组长度的一半做比较\n     * 如果大于数组长度一半，直接返回该元素即可\n     * 小于数组长度一半，则将其value加1存入map覆盖原有的值即可\n     *\n     * @param nums\n     * @return\n     */\n    public static int majorityElement(int[] nums) {\n        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(nums.length);\n        for (int num : nums) {\n            if(!map.containsKey(num)){\n                map.put(num,1);\n            }else{\n                Integer val = map.get(num);\n                if(++val&gt;nums.length/2){\n                    return num;\n                }else{\n                    map.put(num,val);\n                }\n            }\n        }\n        throw new RuntimeException(\"\");\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>数组排序法：由题可知，数组众必然存在一个多数元素，且出现次数超过数组长度的一半。所以我们可以对原数组进行排序，然后取数组中间的元素即可。（我擦，我当时看到这个，就在想，好简单，这个思路，但是我为什么没想到，对，因为我没有仔细的分析题目，超过一半看见没）。既然进行排序，那么我们可以选择快排，这样时间复杂度就是O（NlogN），空间复杂度O（1）.</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 数组排序法，因为多数元素的出现次数超过数组长度一半，\n     * 所以我们可以先对其进行排序，采用快排，时间复杂度O（NlogN）\n     * 然后取数组中点元素即可\n     * @param nums\n     * @return\n     */\n    public static int majorityElement2(int[] nums){\n        quickSort(nums,0,nums.length-1);\n        return nums[nums.length/2];\n    }\n\n    /**\n     * 快排\n     * @param nums\n     * @param low\n     * @param high\n     */\n    public static void quickSort(int[] nums,int low,int high){\n        int base = nums[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //从右向左找到第一个比基准元素小的元素\n            while(L&lt;R&amp;&amp;nums[R]&gt;=base){\n                R--;\n            }\n            if(nums[R]&lt;base){\n                swap(nums,L,R);\n            }\n            //从左向右找到第一个比基准元素大的元素\n            while(L&lt;R&amp;&amp;nums[L]&lt;=base){\n                L++;\n            }\n            if(nums[L]&gt;base){\n                swap(nums,L,R);\n            }\n        }\n        //左递归\n        if(L&gt;low){\n            quickSort(nums,low,L-1);\n        }\n        //右递归\n        if(high&gt;R){\n            quickSort(nums,R+1,high);\n        }\n    }\n\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>摩尔投票法（我将其称为大佬解法）：大概的意思就是采用正负抵消的方法，设置一个投票变量votes，初始设置为0；设置一个本题中的众数变量x，初始设置为数组首元素。然后遍历数组，判断跟设置的众数变量是否相等，如果相等将votes加一，如果不相等，则重置votes为0，且将x设置为数组下一个元素。本题众因为已经声明了肯定存在众数，所以不需要进行验证，但是如果没有声明的话，需要验证，下列代码众添加了验证：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 摩尔投票法\n     * @param nums\n     */\n    public static int majorityElement3(int[] nums){\n        int votes = 0;\n        int x = nums[0];\n        int count = 0;\n        for (int num : nums) {\n            if(votes==0){\n                x = num;\n            }\n            votes+=(num==x)?1:-1;\n        }\n        //验证数组众是否存在众数\n        for (int num : nums) {\n            if(num==x){\n                count++;\n            }\n        }\n        return count&gt;nums.length/2?x:0;\n    }</code></pre>","blogGoods":0,"blogId":"1253674617332162560","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6i5v-AUh39AAAaZr2Bc1U885.jpg","blogRead":0,"blogRemark":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","blogTitle":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","createdTime":"2020-04-24 21:18:14","typeName":"LeetCode","updateTime":"2020-04-24 21:18:14"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，从上到下打印二叉树-2</strong></h2>\n<p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>\n<p>例如:<br />给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>\n<p>3<br />/ \\<br />9 20<br />/ \\<br />15 7<br />返回其层次遍历结果：</p>\n<p>[<br />[3],<br />[9,20],<br />[15,7]<br />]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;BFS（广度优先搜索）：层次遍历</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * BFS\n     * @param root\n     * @return\n     */\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {\n        if (root == null) {\n            return new ArrayList&lt;&gt;(0);\n        }\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();\n        TreeNode current;\n        while (!queue.isEmpty()) {\n            List&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();\n            for (int i = queue.size(); i &gt; 0; i--) {\n                current = queue.poll();\n                arrayList.add(current.val);\n                if (current.left != null) {\n                    queue.add(current.left);\n                }\n                if (current.right != null) {\n                    queue.add(current.right);\n                }\n            }\n            list.add(arrayList);\n        }\n        return list;\n    }</code></pre>","blogGoods":0,"blogId":"1253350612905598976","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6huUyATZJ_AAAaZr2Bc1U363.jpg","blogRead":1,"blogRemark":"剑指offer----之从上到下打印二叉树----LeetCode102","blogTitle":"剑指offer----之从上到下打印二叉树----LeetCode102","createdTime":"2020-04-23 23:50:45","typeName":"LeetCode","updateTime":"2020-04-23 23:50:57"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，从上打印二叉树-1</strong></h2>\n<p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>\n<p>例如:<br />给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>\n<p>3<br />/ \\<br />9 20<br />/ \\<br />15 7<br />返回：</p>\n<p>[3,9,20,15,7]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;BFS（广度优先搜索）：也即是二叉树的层次遍历，代码和注意事项看代码注释</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 二叉树的层次遍历\n     * 这里是将层次遍历的结果存储在数组中\n     * 但是因为二叉树的节点个数并不知道\n     * 所以不能使用数组直接进行存储，因为无法初始化数组的大小\n     * 所以可以想到使用容量能自动扩充的list集合\n     * 然后再根据list集合的size来初始化数组的大小\n     * 并且将list元素赋值到数组中\n     * @param root\n     * @return\n     */\n    public static int[] levelOrder(TreeNode root) {\n        if(root==null){\n            return new int[0];\n        }\n        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n        TreeNode current;\n        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n        while(!queue.isEmpty()){\n            current = queue.poll();\n            list.add(current.val);\n            if(current.left!=null){\n                queue.add(current.left);\n            }\n            if(current.right!=null){\n                queue.add(current.right);\n            }\n        }\n        int[] result = new int[list.size()];\n        for (int i = 0; i &lt; list.size(); i++) {\n            result[i] = list.get(i);\n        }\n        return result;\n    }</code></pre>","blogGoods":0,"blogId":"1253346228108894208","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6htTeAUHGlAAAaZr2Bc1U102.jpg","blogRead":0,"blogRemark":"剑指offer----之从上到下打印二叉树","blogTitle":"剑指offer----之从上到下打印二叉树","createdTime":"2020-04-23 23:33:20","typeName":"LeetCode","updateTime":"2020-04-23 23:33:20"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，包含min函数的栈</strong></h2>\n<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>\n<p>&nbsp;</p>\n<p>示例:</p>\n<p>MinStack minStack = new MinStack();<br />minStack.push(-2);<br />minStack.push(0);<br />minStack.push(-3);<br />minStack.min(); --&gt; 返回 -3.<br />minStack.pop();<br />minStack.top(); --&gt; 返回 0.<br />minStack.min(); --&gt; 返回 -2.</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>&nbsp;辅助栈法：即初始化两个栈A,B</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;A栈用于实现基本的push(),pop(),top()的正常逻辑</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;B栈用来存放A栈中的非严格降序元素（这个我也理解不了，看代码就知道是存放什么的啦），代码中的方法注释很清楚</strong></p>\n<pre class=\"language-java\"><code>public class MinStack {\n    /** initialize your data structure here. */\n    Stack&lt;Integer&gt; A,B;\n\n    public MinStack() {\n        A = new Stack&lt;&gt;();\n        B = new Stack&lt;&gt;();\n    }\n\n    /**\n     * 入栈操作，元素先入A栈\n     * 如果B栈为空或者B栈的栈顶元素大于待入栈元素，则B栈也执行入栈操作\n     * @param x\n     */\n    public void push(int x) {\n        A.add(x);\n        if(B.isEmpty()||B.peek()&gt;=x){\n            B.add(x);\n        }\n    }\n\n    /**\n     * 这段代码优点巧妙\n     * 注意这里使用的A.pop()而不是A.peek()\n     * 所以这里实际上是分为两种情况的\n     * 第一种：当A的栈顶元素不为当前栈中的最小元素，即不等于栈B的栈顶元素\n     *         则只进行栈A的出栈操作，即A.pop()\n     * 第二种：当A的栈顶元素为当前栈中的最小元素，即等于栈B的栈顶元素\n     *        则不仅要A.pop(),而且为了保证A,B栈中最小元素的同步性\n     *        B栈也要执行出栈操作\n     */\n    public void pop() {\n        if(A.pop().equals(B.peek())){\n            B.pop();\n        }\n    }\n\n    /**\n     * 正常获取A的栈顶元素\n     * @return\n     */\n    public int top() {\n        return A.peek();\n    }\n\n    /**\n     * 获取A栈的最小元素，即B栈的栈顶元素\n     * @return\n     */\n    public int min() {\n        return B.peek();\n    }\n}</code></pre>","blogGoods":0,"blogId":"1253331349566234624","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hp12AMy2MAAAaZr2Bc1U568.jpg","blogRead":4,"blogRemark":"剑指offer----之包含min函数的栈---LeetCode155","blogTitle":"剑指offer----之包含min函数的栈---LeetCode155","createdTime":"2020-04-23 22:34:13","typeName":"LeetCode","updateTime":"2020-04-23 23:50:51"},{"blogCollection":0,"blogComment":0,"blogContent":"<h3><strong>晚上九点多，坐在床上，面前摆放着电脑，屏幕显示的是LeetCode中的《剑指offer》的题解</strong></h3>\n<h3><strong>此时的我毫无睡意，当然，这并不是因为解出一道题的喜悦冲淡了我的睡意</strong></h3>\n<h3><strong>相反的，这是一种难以言明的心情，包含着对自己无知的羞愧，也包含着别人面对如此无知的自己也能给出耐心回应的感动</strong></h3>\n<h3><strong>人有时或许就是这样，刻意的举动会让人心生防备，但是无意的善举却能温润人心</strong></h3>\n<h3><strong>别人无意的一个回答，一个小举动，一句肯定的话</strong></h3>\n<h3><strong>殊不知却能为对方赋予无穷无尽的能量</strong></h3>\n<h3><strong>将这一天的疲惫和劳累都消除</strong></h3>\n<h3><strong>赠人玫瑰，手有余香</strong></h3>\n<h3><strong>我一直抱着这样的一种心态，或许我无法做到赠人玫瑰，但是我会尽量将自己的善意展现给别人</strong></h3>\n<h3><strong>也许他刚刚好正处于某个难关，而你又刚刚好是他难关之初的引导者</strong></h3>\n<h3><strong>一句话，或许对于你来说只是人生中微不足道的几秒钟</strong></h3>\n<h3><strong>而对他来说，或许可能是多年之后回忆起来也能嘴角上扬的美好岁月</strong></h3>\n<h3><strong>想起前段时间一部剧里面的话，在这里也送给屏幕前的你：愿你永怀善意，清澈明朗</strong></h3>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1253326423486144512","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hosWANYd2AAHQzo49lBU641.jpg","blogRead":3,"blogRemark":"2020-4-23有感","blogTitle":"2020-4-23有感","createdTime":"2020-04-23 22:14:38","typeName":"随心日记","updateTime":"2020-04-25 21:22:30"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，顺时针打印矩阵</strong></h2>\n<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>\n<p>示例 1：</p>\n<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br />输出：[1,2,3,6,9,8,7,4,5]<br />示例 2：</p>\n<p>输入：matrix =&nbsp;[[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br />输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p>\n<p>限制：</p>\n<p>0 &lt;= matrix.length &lt;= 100<br />0 &lt;= matrix[i].length&nbsp;&lt;= 100</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;模拟顺时针打印的这种循环结构：设置四个边界条件，l,r,t,b。按照从左往右，从上往下，从右往左，从下网往上的顺序依次读取矩阵的元素，并且每一次都判断边界是否相遇，直到将整个矩阵元素都加入到数组中即可。</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 设置四个边界值，分别为left=0,right=matrix[0].length-1,top=0,bottom=matrix.length-1\n     * 顺时针顺序即先从左到右，再从上到下，再从右向左，再从下向上，每一次执行都要判断边界值\n     * @param matrix\n     * @return\n     */\n    public static int[] spiralOrder(int[][] matrix) {\n        if(matrix.length==0){\n            return new int[0];\n        }\n        int l = 0;\n        int r=matrix[0].length-1;\n        int t=0;\n        int b=matrix.length-1;\n        int x=0;\n        int[] res = new int[(r+1)*(b+1)];\n        while(true){\n            //从左向右\n            for(int i=l;i&lt;=r;i++){\n                res[x++]=matrix[t][i];\n            }\n            if(++t&gt;b) {\n                break;\n            }\n            //从上向下\n            for(int i=t;i&lt;=b;i++){\n                res[x++] = matrix[i][r];\n            }\n            if(--r&lt;l){\n                break;\n            }\n            //从右向左\n            for(int i=r;i&gt;=l;i--){\n                res[x++] = matrix[b][i];\n            }\n            if(--b&lt;t){\n                break;\n            }\n            //从下往上\n            for(int i=b;i&gt;=t;i--){\n                res[x++] = matrix[i][l];\n            }\n            if(++l&gt;r){\n                break;\n            }\n        }\n        return res;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1253250557729087488","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hXB2ASIQwAAAaZr2Bc1U016.jpg","blogRead":0,"blogRemark":"剑指offer-----之顺时针打印矩阵----LeetCode54","blogTitle":"剑指offer-----之顺时针打印矩阵----LeetCode54","createdTime":"2020-04-23 17:13:11","typeName":"LeetCode","updateTime":"2020-04-23 17:13:11"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，对称的二叉树</strong></h2>\n<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>\n<p>例如，二叉树&nbsp;[1,2,2,3,4,4,3] 是对称的。</p>\n<p>&nbsp; &nbsp; 1<br />&nbsp; &nbsp;/ \\<br />&nbsp; 2 &nbsp; 2<br />&nbsp;/ \\ / \\<br />3 &nbsp;4 4 &nbsp;3<br />但是下面这个&nbsp;[1,2,2,null,3,null,3] 则不是镜像对称的:</p>\n<p>&nbsp; &nbsp; 1<br />&nbsp; &nbsp;/ \\<br />&nbsp; 2 &nbsp; 2<br />&nbsp; &nbsp;\\ &nbsp; \\<br />&nbsp; &nbsp;3 &nbsp; &nbsp;3</p>\n<p>示例 1：</p>\n<p>输入：root = [1,2,2,3,4,4,3]<br />输出：true<br />示例 2：</p>\n<p>输入：root = [1,2,2,null,3,null,3]<br />输出：false</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>递归法：从对称的二叉树中我们可以找到如下规律</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果一个二叉树是对称的，则每一个节点的左右子树也是对称的,因此是递归的</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 设L = root.left，R=root.right，则满足L.left.val = R.right.val;L.right.val=R.left.val;</strong></p>\n<pre class=\"language-java\"><code>public boolean isSymmetric(TreeNode root) {\n        return  root==null?true:recur(root.left,root.right);\n    }\n    public boolean recur(TreeNode L,TreeNode R){\n        if(L==null&amp;&amp;R==null){\n            return true;\n        }\n        if(L==null||R==null||L.val!=R.val){\n            return false;\n        }\n        return recur(L.left,R.right)&amp;&amp;recur(L.right,R.left);\n    }</code></pre>","blogGoods":0,"blogId":"1252992659794968576","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6ga--AKQdvAAAaZr2Bc1U862.jpg","blogRead":1,"blogRemark":"剑指offer----之对称的二叉树----LeetCode101","blogTitle":"剑指offer----之对称的二叉树----LeetCode101","createdTime":"2020-04-23 00:08:23","typeName":"LeetCode","updateTime":"2020-04-23 00:12:33"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，二叉树镜像</strong></h2>\n<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>\n<p>例如输入：</p>\n<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; 2 &nbsp; &nbsp; 7<br />&nbsp;/ \\ &nbsp; / \\<br />1 &nbsp; 3 6 &nbsp; 9<br />镜像输出：</p>\n<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; 7 &nbsp; &nbsp; 2<br />&nbsp;/ \\ &nbsp; / \\<br />9 &nbsp; 6 3&nbsp; &nbsp;1</p>\n<p>示例 1：</p>\n<p>输入：root = [4,2,7,1,3,6,9]<br />输出：[4,7,2,9,6,3,1]</p>\n<p>限制：</p>\n<p>0 &lt;= 节点个数 &lt;= 1000</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;递归法：即递归的去交换根节点的左右子树，直到根节点为叶子节点</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用递归的方法，交换根节点的左子树和右子树\n     * 递归出口为，根节点为叶子节点\n     * @param root\n     * @return\n     */\n    public TreeNode mirrorTree(TreeNode root) {\n        TreeNode center = root;\n        if(center!=null){\n            TreeNode temp = center.left;\n            center.left = center.right;\n            center.right = temp;\n            mirrorTree(center.left);\n            mirrorTree(center.right);\n        }\n        return root;\n    }</code></pre>","blogGoods":0,"blogId":"1252985443281027072","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6gZTWABF55AAAaZr2Bc1U678.jpg","blogRead":0,"blogRemark":"剑指offer----之二叉树的镜像----LeetCode226","blogTitle":"剑指offer----之二叉树的镜像----LeetCode226","createdTime":"2020-04-22 23:39:43","typeName":"LeetCode","updateTime":"2020-04-22 23:39:43"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，合并两个有序链表</strong></h2>\n<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>\n<p>示例1：</p>\n<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br />输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br />限制：</p>\n<p>0 &lt;= 链表长度 &lt;= 1000</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>伪头节点法：即创建一个伪头节点head和一个用于辅助的节点cur</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法：如果l1.val&lt;=l2.val,就让cur指向l1，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l1指向其next</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果l1.val&gt;l2.val,就让cur指向l2，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l2指向其next</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;直到l1和l2有一个为空为止，让cur指向剩余的一个非空链表即可，若两个链表的长度为M,N则时间复杂度为O(M+N)</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用四节点，一个伪头节点，一个当前节点cur，已经链表的两个节点l1,l2\n     * 每次比较l1,l2节点的val大小，将小的节点连接到当前节点cur上即可\n     * 直到l1,l2有一个空，则将剩余的一个非空链表连接到cur尾部即可\n     * @param l1\n     * @param l2\n     * @return\n     */\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode head;\n        ListNode cur;\n        head = cur = new ListNode(0);\n        while(l1!=null&amp;&amp;l2!=null){\n            if(l1.val&lt;=l2.val){\n                cur.next = l1;\n                cur = cur.next;\n                l1 = l1.next;\n            }else{\n                cur.next = l2;\n                cur = cur.next;\n                l2 = l2.next;\n            }\n        }\n        if(l1!=null){\n            cur.next = l1;\n        }\n        if(l2!=null){\n            cur.next = l2;\n        }\n        return head.next;\n    }</code></pre>","blogGoods":0,"blogId":"1252980258446000128","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6gYGWAe-MZAAAaZr2Bc1U550.jpg","blogRead":0,"blogRemark":"剑指offer----之合并有序链表---LeetCode21","blogTitle":"剑指offer----之合并有序链表---LeetCode21","createdTime":"2020-04-22 23:19:06","typeName":"LeetCode","updateTime":"2020-04-22 23:19:06"}],"pageSize":15,"params":{},"sortColumn":"created_time","sortMethod":"DESC","totalCount":53,"totalPage":4},"msg":"操作成功!"}
2020-04-26 23:29:07.720 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/getTimeLine
2020-04-26 23:29:07.721 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:29:07.721 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:29:07.722 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getTimeLine
2020-04-26 23:29:07.722 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:29:07.816 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 96
2020-04-26 23:29:07.819 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"blogVoList":[{"blogId":"1254063045920022528","blogMonth":"2020-04","blogTitle":"剑指offer----0~n-1中缺失的数字","createdTime":"2020-04-25 23:01:44"},{"blogId":"1254055163115724800","blogMonth":"2020-04","blogTitle":"剑指offer----在排序数组中查找数字I----LeetCode34","createdTime":"2020-04-25 22:30:24"},{"blogId":"1253992797703364608","blogMonth":"2020-04","blogTitle":"剑指offer----之两个链表的第一个公共节点----LeetCode160","createdTime":"2020-04-25 18:22:35"},{"blogId":"1253956468789600256","blogMonth":"2020-04","blogTitle":"剑指offer----第一次只出现一次的字符","createdTime":"2020-04-25 15:58:14"},{"blogId":"1253938714590175232","blogMonth":"2020-04","blogTitle":"剑指offer---连续子数组的最大和---LeetCode53","createdTime":"2020-04-25 14:47:41"},{"blogId":"1253874832811089920","blogMonth":"2020-04","blogTitle":"剑指offer----之最小的k个数","createdTime":"2020-04-25 10:33:50"},{"blogId":"1253674617332162560","blogMonth":"2020-04","blogTitle":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","createdTime":"2020-04-24 21:18:14"},{"blogId":"1253350612905598976","blogMonth":"2020-04","blogTitle":"剑指offer----之从上到下打印二叉树----LeetCode102","createdTime":"2020-04-23 23:50:45"},{"blogId":"1253346228108894208","blogMonth":"2020-04","blogTitle":"剑指offer----之从上到下打印二叉树","createdTime":"2020-04-23 23:33:20"},{"blogId":"1253331349566234624","blogMonth":"2020-04","blogTitle":"剑指offer----之包含min函数的栈---LeetCode155","createdTime":"2020-04-23 22:34:13"},{"blogId":"1253326423486144512","blogMonth":"2020-04","blogTitle":"2020-4-23有感","createdTime":"2020-04-23 22:14:38"},{"blogId":"1253250557729087488","blogMonth":"2020-04","blogTitle":"剑指offer-----之顺时针打印矩阵----LeetCode54","createdTime":"2020-04-23 17:13:11"},{"blogId":"1252992659794968576","blogMonth":"2020-04","blogTitle":"剑指offer----之对称的二叉树----LeetCode101","createdTime":"2020-04-23 00:08:23"},{"blogId":"1252985443281027072","blogMonth":"2020-04","blogTitle":"剑指offer----之二叉树的镜像----LeetCode226","createdTime":"2020-04-22 23:39:43"},{"blogId":"1252980258446000128","blogMonth":"2020-04","blogTitle":"剑指offer----之合并有序链表---LeetCode21","createdTime":"2020-04-22 23:19:06"},{"blogId":"1252636594674872320","blogMonth":"2020-04","blogTitle":"剑指offer----之反转链表----LeetCode206","createdTime":"2020-04-22 00:33:31"},{"blogId":"1252621660096311296","blogMonth":"2020-04","blogTitle":"剑指offer----之链表中的到数第k个节点","createdTime":"2020-04-21 23:34:10"},{"blogId":"1252617033468620800","blogMonth":"2020-04","blogTitle":"剑指offer----之调整数组顺序使奇数在前，偶数在后","createdTime":"2020-04-21 23:15:47"},{"blogId":"1252610331612557312","blogMonth":"2020-04","blogTitle":"剑指offer----之删除链表的节点","createdTime":"2020-04-21 22:49:09"},{"blogId":"1252604581645398016","blogMonth":"2020-04","blogTitle":"剑指offer----之打印从1到最大的n位数","createdTime":"2020-04-21 22:26:18"},{"blogId":"1252518351972872192","blogMonth":"2020-04","blogTitle":"LeetCode191---之二进制数中1的个数","createdTime":"2020-04-21 16:43:40"},{"blogId":"1252503447316475904","blogMonth":"2020-04","blogTitle":"LeetCode154----之旋转数组的最小值","createdTime":"2020-04-21 15:44:26"},{"blogId":"1252439650715316224","blogMonth":"2020-04","blogTitle":"LeetCode70----青蛙跳台阶","createdTime":"2020-04-21 11:30:56"},{"blogId":"1252423800151093248","blogMonth":"2020-04","blogTitle":"LeetCode509----斐波那契数列","createdTime":"2020-04-21 10:27:57"},{"blogId":"1252270516845203456","blogMonth":"2020-04","blogTitle":"剑指offer--用两个栈实现队列","createdTime":"2020-04-21 00:18:51"},{"blogId":"1252264352052989952","blogMonth":"2020-04","blogTitle":"剑指offer----之从尾到头打印链表","createdTime":"2020-04-20 23:54:22"},{"blogId":"1252257654055686144","blogMonth":"2020-04","blogTitle":"剑指offer----之替换空格","createdTime":"2020-04-20 23:27:45"},{"blogId":"1252250357355040768","blogMonth":"2020-04","blogTitle":"LeetCode240","createdTime":"2020-04-20 22:58:45"},{"blogId":"1252230734534463488","blogMonth":"2020-04","blogTitle":"剑指Offer----之寻找数组中的重复数字","createdTime":"2020-04-20 21:40:47"},{"blogId":"1251888137978793984","blogMonth":"2020-04","blogTitle":"标签云无法实现连续点击切换Bug","createdTime":"2020-04-19 22:59:26"},{"blogId":"1251457803692810240","blogMonth":"2020-04","blogTitle":"面试（九）-----之设计模式（观察者模式）","createdTime":"2020-04-18 18:29:26"},{"blogId":"1251436080364814336","blogMonth":"2020-04","blogTitle":"面试（九）------之设计模式（代理模式）","createdTime":"2020-04-18 17:03:07"},{"blogId":"1251428943714615296","blogMonth":"2020-04","blogTitle":"面试（九）------之设计模式（装饰者模式）","createdTime":"2020-04-18 16:34:45"},{"blogId":"1251421326858551296","blogMonth":"2020-04","blogTitle":"面试（九）-----之设计模式（适配器模式）","createdTime":"2020-04-18 16:04:29"},{"blogId":"1251376301936246784","blogMonth":"2020-04","blogTitle":"面试（九）-----之设计模式（建造者模式）","createdTime":"2020-04-18 13:05:35"},{"blogId":"1251342530616786944","blogMonth":"2020-04","blogTitle":"面试（九）-----之设计模式（单例模式）","createdTime":"2020-04-18 10:51:23"},{"blogId":"1251186933548199936","blogMonth":"2020-04","blogTitle":"粒子特效覆盖分页按钮点击Bug","createdTime":"2020-04-18 00:33:06"},{"blogId":"1251175051101745152","blogMonth":"2020-04","blogTitle":"面试（九）------之设计模式（工厂模式）","createdTime":"2020-04-17 23:45:53"},{"blogId":"1250802898447667200","blogMonth":"2020-04","blogTitle":"项目中的时区问题","createdTime":"2020-04-16 23:07:05"},{"blogId":"1250774653945802752","blogMonth":"2020-04","blogTitle":"面试（八）------之分布式缓存的原理及应用","createdTime":"2020-04-16 13:14:51"},{"blogId":"1250704122190073856","blogMonth":"2020-04","blogTitle":"面试（七）-----数据库及分布式事务","createdTime":"2020-04-16 08:34:35"},{"blogId":"1250622112591376384","blogMonth":"2020-04","blogTitle":"面试（六）------之网络与负载均衡","createdTime":"2020-04-16 03:08:42"},{"blogId":"1250364779516665856","blogMonth":"2020-04","blogTitle":"面试（五）------之算法","createdTime":"2020-04-15 10:06:09"},{"blogId":"1250068950784536576","blogMonth":"2020-04","blogTitle":"面试（四）------之数据结构篇","createdTime":"2020-04-14 14:30:37"},{"blogId":"1249742755949817856","blogMonth":"2020-04","blogTitle":"面试（三）------之并发编程篇（下）","createdTime":"2020-04-13 16:54:26"},{"blogId":"1249588251598041088","blogMonth":"2020-04","blogTitle":"redis基础（一）","createdTime":"2020-04-13 06:40:30"},{"blogId":"1249313090567143424","blogMonth":"2020-04","blogTitle":"面试（三）------之并发编程篇（上）","createdTime":"2020-04-12 12:27:07"},{"blogId":"1248605157059497984","blogMonth":"2020-04","blogTitle":"面试（二）------之JAVA基础篇","createdTime":"2020-04-10 13:34:02"},{"blogId":"1248500061625745408","blogMonth":"2020-04","blogTitle":"Linux基本命令","createdTime":"2020-04-10 06:36:25"},{"blogId":"1248224512563068928","blogMonth":"2020-04","blogTitle":"面试（一）------之JVM篇","createdTime":"2020-04-09 12:21:30"},{"blogId":"1248135765829918720","blogMonth":"2020-04","blogTitle":"CSS----之flex弹性布局","createdTime":"2020-04-09 06:28:51"},{"blogId":"1247867141693128704","blogMonth":"2020-04","blogTitle":"闲谈前后端分离开发","createdTime":"2020-04-08 12:41:25"},{"blogId":"1247745014683947008","blogMonth":"2020-04","blogTitle":"博客开发总结（一）-----之数据库设计篇","createdTime":"2020-04-08 04:36:07"}],"month":"2020-04"}],"msg":"操作成功!"}
2020-04-26 23:29:27.378 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /rotation-picture/listFront
2020-04-26 23:29:27.379 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:29:27.379 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:29:27.379 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.RotationPictureController.getRotationPictureListFront
2020-04-26 23:29:27.379 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:29:27.380 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/list
2020-04-26 23:29:27.381 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:29:27.381 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:29:27.381 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogList
2020-04-26 23:29:27.381 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=15, totalPage=0, totalCount=0, list=[], params={}, sortColumn=created_time, sortMethod=DESC)]
2020-04-26 23:29:27.470 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 92
2020-04-26 23:29:27.470 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"createdTime":"2020-04-09 13:31:20","enable":1,"rotationId":4,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PI6aAZIz1AASCO4hlpJI295.jpg"},{"createdTime":"2020-04-09 13:37:02","enable":1,"rotationId":9,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJPyAbm8fAAG9gfO8lxE28.jpeg"},{"createdTime":"2020-04-09 13:41:30","enable":1,"rotationId":10,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJgeAeG8wAAS2pjJC5QU547.jpg"},{"createdTime":"2020-04-09 13:41:38","enable":1,"rotationId":11,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhGAQFZbAAP2OOBWb6k310.jpg"},{"createdTime":"2020-04-09 13:41:50","enable":1,"rotationId":12,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhyABMZCAAG7doyXiM8109.jpg"},{"createdTime":"2020-04-09 13:41:59","enable":1,"rotationId":13,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJiWAL7BoAARW3_O3ISw651.jpg"}],"msg":"操作成功!"}
2020-04-26 23:29:27.790 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 410
2020-04-26 23:29:27.791 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，0~n-1中缺失的数字</strong></h2>\n<p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>\n<p>示例 1:</p>\n<p>输入: [0,1,3]<br />输出: 2<br />示例&nbsp;2:</p>\n<p>输入: [0,1,2,3,4,5,6,7,9]<br />输出: 8</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主能想到的并且写出来的方法有：使用map存储数组中的所有元素，然后遍历0-n-1找出不在map中的元素。此种方法时间复杂度O（N），空间复杂度O（N）-----垃圾</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 统计0-n-1所有数字的数字和，再统计数组中所有数字的数字和，两和只差即为所求数字，时间复杂度O（N），空间复杂度O（1）-----垃圾</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;最优解法（二分查找法）：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;通常来说，我们使用二分查找法是查找一个存在于数组中的元素，但是本题需要求不在数组中的一个元素，因此到这很多人就会迷惑，不知道该怎么求了。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;但是我们首先要搞明白二分查找法的本质是什么：1，并不局限于仅仅查找存在于数组中的元素；2，二分查找的本质是对数组根据mid中间值在某一条件上进行二分（例如：通常的num[mid]&gt;target或者nums[mid]&lt;target进行左右切分）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;因此明白这一点，就好解决问题了。拿到这道题，使用二分，我们首先想到的应该是寻找根据mid中间值进行二分的条件</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;审题：题目中提及数组为递增数组，而且0-n-1内的n个数字有一个不在数组中，则不在的这个数字之前的数字满足nums[i]=i即元素本身等于数组下标，而之后的数字nums[i]!=i,所以这就是进行二分的条件了</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 二分查找法\n     * 算法思想：二分查找法的本质是能够有一个条件将数组根据mid中间值进行左右切分\n     * 所以我们想到二分查找法之后，首先需要做的是找出切分数组的条件\n     * 题目中给出了数组是一个递增数组，且0-n-1内的n个数字有一个不在这个长度为n-1的数组内\n     * 因此，不在的这个元素其左边元素必有数组下标值等于元素本身即nums[i]=i\n     * 而不在的这个元素的右边必有nums[i]!=i\n     * 所以根据此条件进行划分数组即可\n     * @param nums\n     * @return\n     */\n    public static int missingNumber(int[] nums) {\n        int low = 0;\n        int high = nums.length-1;\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]==mid){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        return low;\n    }</code></pre>","blogGoods":0,"blogId":"1254063045920022528","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kUM-AON88AAAaZr2Bc1U903.jpg","blogRead":0,"blogRemark":"剑指offer----0~n-1中缺失的数字","blogTitle":"剑指offer----0~n-1中缺失的数字","createdTime":"2020-04-25 23:01:44","typeName":"LeetCode","updateTime":"2020-04-25 23:01:44"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，在排序数组中查找数字I</strong></h2>\n<p>统计一个数字在排序数组中出现的次数。</p>\n<p>示例 1:</p>\n<p>输入: nums = [5,7,7,8,8,10], target = 8<br />输出: 2<br />示例&nbsp;2:</p>\n<p>输入: nums = [5,7,7,8,8,10], target = 6<br />输出: 0</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解法一：直接遍历统计，时间复杂度为O（N）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 遍历数组\n     * 找到第一个与目标元素相等的元素，res+1\n     * 然后往后找到第一个与目标元素不相等的元素,返回res即可\n     * 时间复杂度为O(N)\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static int search(int[] nums, int target) {\n        int res = 0;\n        for (int num : nums) {\n            if(num==target){\n                res++;\n            }\n        }\n        return res;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解法二：二分法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：利用二分法查找数字在排序数组中的左边界Left和右边界Right.如下，如果要寻找数组中的8，则其左边界为left=2,有边界right=5.所以出现次数为right-left-1.时间复杂度为O（logN）</strong></p>\n<table style=\"width: 20%; border-collapse: collapse; margin-left: auto; margin-right: auto;\" border=\"1\" cellpadding=\"5\">\n<tbody>\n<tr>\n<td style=\"width: 16.6667%;\">5</td>\n<td style=\"width: 16.6667%;\">7</td>\n<td style=\"width: 16.6667%;\">7</td>\n<td style=\"width: 16.6667%;\">8</td>\n<td style=\"width: 16.6667%;\">8</td>\n<td style=\"width: 16.6667%;\">10</td>\n</tr>\n</tbody>\n</table>\n<pre class=\"language-java\"><code>    /**\n     * 二分查找法\n     * 时间复杂度为O（logN）\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static int search2(int[] nums, int target){\n        int low = 0;\n        int high = nums.length-1;\n        int left,right;\n        left = right = 0;\n        //一次二分\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]&lt;=target){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        right = low;\n\n        low = 0;\n        high = nums.length -1;\n        //二次二分\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]&lt;target){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        left = high;\n        return right -left -1;\n    }</code></pre>","blogGoods":0,"blogId":"1254055163115724800","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kSXiAYRyFAAAaZr2Bc1U379.jpg","blogRead":0,"blogRemark":"剑指offer----在排序数组中查找数字I----LeetCode34","blogTitle":"剑指offer----在排序数组中查找数字I----LeetCode34","createdTime":"2020-04-25 22:30:24","typeName":"LeetCode","updateTime":"2020-04-25 22:30:24"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，两个链表的第一个公共节点</strong></h2>\n<p><strong><img src=\"https://images-cdn.shimo.im/Wd1NC8pveQYp9iIL.png__thumbnail\" alt=\"示例图\" width=\"742\" height=\"241\" /></strong></p>\n<p><strong>这是我从官方截下的一张图，也是有些人疑惑的地方，因为官方这张图给出的公共节点为8，而大多数人看到这张图，认为公共节点应该是1.</strong></p>\n<p><strong>但是实际上这里的公共节点不仅要节点的value相等，同时还需要节点的地址相等。从图中可以看出两个1节点虽然值相等，但是地址却不同，因而不是公共节点</strong></p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解法一：双指针</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：初始化两个指针p1=headA,p2=headB</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;分别遍历两个链表，求出两个链表的长度l1,l2</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;然后重置p1,p2指针指向头节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;让长链表的指针先走多的步数（l1-l2或者l2-l1）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;然后让两个指针同时走，直到两者相遇，即找到公共节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解疑：弄清楚第一个value相等的节点和指针相遇的节点，这两种节点是不同的，指针相遇的节点，不仅包含value相等，同时地址也相等。（如图中的8）；而第一个value相等的节点则可能并不在同一个地址，因此不一定是公共节点</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法\n     * @param headA\n     * @param headB\n     * @return\n     */\n    public static ListNode getIntersectionNode2(ListNode headA, ListNode headB){\n        ListNode p1 =headA;\n        ListNode p2 = headB;\n        int l1 = 0;\n        int l2 = 0;\n        //计算链表1的长度\n        while(p1!=null){\n            l1++;\n            p1 = p1.next;\n        }\n        //计算链表2的长度\n        while(p2!=null){\n            l2++;\n            p2 = p2.next;\n        }\n        p1 = headA;\n        p2 = headB;\n        //让长链表指针先走长的步数\n        if(l1&gt;l2){\n            for (int i = 0; i &lt; l1-l2; i++) {\n                p1 = p1.next;\n            }\n        }else{\n            for (int i = 0; i &lt; l2-l1; i++) {\n                p2 = p2.next;\n            }\n        }\n        //然后让两个指针同时走，直到相遇\n        while(p1!=p2){\n            p1 = p1.next;\n            p2 = p2.next;\n        }\n        return p1;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;解法二（大神解法）：丘比特相遇法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;利用两个指针p1=headA,p2=headB,让两个指针同时走，</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果p1先走到底，就将p1置为headB，</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果p2,先走到底，就将p2置为headA,</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;当两个指针相遇的时候，他们就相爱了（当然是找到公共节点了）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法p1=headA,p2=headB\n     * 思想是：两个节点同时从各自的链表出发\n     * p1走到末尾时，回到headB的头部\n     * p2走到末尾时，回到headA的头部\n     * 两个指针相遇的时候，即使要找的公共节点\n     * @param headA\n     * @param headB\n     * @return\n     */\n    public static ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode p1 = headA;\n        ListNode p2 = headB;\n        while(p1!=p2){\n            p1 = (p1==null)?headB:p1.next;\n            p2 = (p2==null)?headA:p2.next;\n        }\n        return p1;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1253992797703364608","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kD2OADD3mAAAaZr2Bc1U709.jpg","blogRead":0,"blogRemark":"剑指offer----之两个链表的第一个公共节点----LeetCode160","blogTitle":"剑指offer----之两个链表的第一个公共节点----LeetCode160","createdTime":"2020-04-25 18:22:35","typeName":"LeetCode","updateTime":"2020-04-25 18:22:35"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，第一个只出现一次的字符</strong></h2>\n<p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。</p>\n<p>示例:</p>\n<p>s = \"abaccdeff\"<br />返回 \"b\"</p>\n<p>s = \"\" <br />返回 \" \"</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主现在发现，做一道算法题的时候，最重要的一步就是读题，审题，在草稿纸上写下自己的思路（当然那种望眼欲穿的大佬除外）。然后才开始动笔，对于IT人来说，真的，多将时间花费在思考上面，而不是无意义的重复搬砖。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;题目分析：看到这道题，抓住两个关键字：第一个，只出现一次。什么意思呢，例如\"abaccdeff\"，其中只出现一次的字符有'b','d','e'三个，然后在三个字符中第一个出现在字符串中的是'b'，因此本题的答案是'b'.</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法分析：根据题目分析，我们最直观的解法应该是，先找出字符串中只出现一次的字符，然后再找出只出现一次字符中，第一个在字符串中出现的。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;所以我们需要做两件事，一是统计字符串中各个字符的出现次数，并且记录；二，统计完毕后，找出第一个出现次数为1的字符，返回即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;因此我们既要存字符，还要存字符对应的出现次数，所以理所当然我们选择map集合。当然对于本题而言，因为求第一个出现一次的字符，所以我们更好的是可以使用LinkedHashMap。这样免去最后的一次遍历字符串</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;下面提供两种解法：三种解法都是使用map集合，但是略有不同</strong></p>\n<p><strong>LinkedHashMap：（这是博主写的，代码冗余，这里用来和大神的写法做比较，警醒自己）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 用LinkedHashMap\n     * 思想：遍历字符串，如果map为空或者map中不含当前字符，则将其存入map\n     * 如果map中已经含有当前字符，则从map中移除\n     * 最终map中只剩出现一次的字符\n     * 返货map中的第一个即可\n     * @param s\n     * @return\n     */\n    public static char firstUniqChar(String s) {\n        Map&lt;Character,Integer&gt;map = new LinkedHashMap&lt;&gt;();\n        for (int i = 0; i &lt; s.length(); i++) {\n            char ch = s.charAt(i);\n            if(map.isEmpty()||!map.containsKey(ch)){\n                map.put(ch,1);\n            }else{\n                Integer val = map.get(ch);\n                map.put(ch,++val);\n            }\n        }\n        //返回map中第一个元素即可\n        Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entries = map.entrySet();\n        for (Map.Entry&lt;Character, Integer&gt; entry : entries) {\n            if(entry.getValue()==1){\n                return entry.getKey();\n            }\n        }\n        return ' ';\n    }</code></pre>\n<p><strong>HashMap（大神解法）：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 哈希表法\n     * @param s\n     * @return\n     */\n    public char firstUniqChar2(String s) {\n        Map&lt;Character,Boolean&gt; map = new HashMap&lt;&gt;();\n        char[] chars = s.toCharArray();\n        for (char ch : chars) {\n            map.put(ch,!map.containsKey(ch));\n        }\n        for (char ch : chars) {\n            if(map.get(ch)){\n                return ch;\n            }\n        }\n        return ' ';\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;分析：首先，这里提供了两种解法，一种为LinkedHashMap，一种为HashMap，这两种解法的不同之处就在于最后获取值的时候，LinkedHashMap获取最终值是遍历LinkedHashMap的entrySet，但是HashMap获取最终值是遍历原字符串。因而当数据庞大的时候，显然使用LinkedHashMap性能更高。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;然后，再分析一下这两种解法不另外一个不同之处，没错！就是大神的解法中使用map存放key对应的value值是Boolean型！（<span style=\"background-color: #ffcc00;\">这个真的是神一般的存在</span>），既省去了计算次数的麻烦，同时最后取的时候也不需要判断次数。wc！同一种解法，为什么天差地别！</strong></p>","blogGoods":0,"blogId":"1253956468789600256","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6j7Y6ACrySAAAaZr2Bc1U825.jpg","blogRead":0,"blogRemark":"剑指offer----第一次只出现一次的字符","blogTitle":"剑指offer----第一次只出现一次的字符","createdTime":"2020-04-25 15:58:14","typeName":"LeetCode","updateTime":"2020-04-25 15:58:14"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，连续子数组的最大和</strong></h2>\n<p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>\n<p>要求时间复杂度为O(n)。</p>\n<p>示例1:</p>\n<p>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br />输出: 6<br />解释:&nbsp;连续子数组&nbsp;[4,-1,2,1] 的和最大，为&nbsp;6。</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;看到这道题，最简单的想法肯定是求出所有连续子数组的值，然后进行比较，找出最大的即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;但是随后会想到既然要找出所有的子数组，那么我们可以使用分治的思想，因为分治的分过程即可以得到所有子序列</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;随后，再深一步，既然可以分治的思想，分的过程即是递归的过程，而且子数组的最大值依赖与前一子数组，所以可以想到使用动态规划</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：设dp[i]为以nums[i]为结尾的最大子数组和，初始值dp[0] = nums[0]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;遍历数组，如果dp[i-1]&gt;=0。则说明前面的最大子数组对当前子数组有增益效果，所以dp[i] = dp[i-1]+nums[i]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果dp[i-1]&lt;0。说明前面的最大子数组对当前子数组有夫负效果，还不如nums[i]本身，所以dp[i]=nums[i]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主的这样的写法：时间复杂度为O（N），空间复杂度也为O（N），但是实际上不需要使用dp数组，使用nums原数组就行，所以可以减小空间复杂度为O（1）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 动态规划\n     * 算法思想：因为求的是连续子数组的最大和\n     * 所以我们可以设dp[i]为以nums[i]结尾的最大连续子数组\n     * 如果dp[i]&lt;=nums[i],dp[i]=nums[i]\n     * 如果dp[i]&gt;nums[i],则dp[i]=dp[i]+nums[i]\n     * @param nums\n     * @return\n     */\n    public static int maxSubArray(int[] nums) {\n        int[] dp  = new int[nums.length];\n        dp[0] = nums[0];\n        int res = nums[0];\n        for (int i = 1; i &lt; nums.length; i++) {\n            if(dp[i-1]&lt;0){\n                dp[i] = nums[i];\n            }else{\n                dp[i] = dp[i-1]+nums[i];\n            }\n            res = Math.max(res,dp[i]);\n        }\n        return res;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1253938714590175232","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6j3QSACLxRAAAaZr2Bc1U017.jpg","blogRead":0,"blogRemark":"剑指offer---连续子数组的最大和---LeetCode53","blogTitle":"剑指offer---连续子数组的最大和---LeetCode53","createdTime":"2020-04-25 14:47:41","typeName":"LeetCode","updateTime":"2020-04-25 14:47:41"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，最小的k个数</strong></h2>\n<p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>\n<p>示例 1：</p>\n<p>输入：arr = [3,2,1], k = 2<br />输出：[1,2] 或者 [2,1]<br />示例 2：</p>\n<p>输入：arr = [0,1,2,1], k = 1<br />输出：[0]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;1,可以采用快排的思想，将原数组按照升序排序，然后取出前k个数即可，时间复杂度为O（NlogN）。但是其实跟API中的sort方法好像差别不大</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 对原数组升序排序，然后取前k个元素\n     * @param arr\n     * @param k\n     * @return\n     */\n    public static int[] getLeastNumbers(int[] arr, int k) {\n        quickSort(arr,0,arr.length-1);\n        int[] result = new int[k];\n        for (int i = 0; i &lt; k; i++) {\n            result[i] = arr[i];\n        }\n        return result;\n    }\n\n    /**\n     * 快排\n     * @param nums\n     * @param low\n     * @param high\n     */\n    public static void quickSort(int[] nums,int low,int high){\n        int base = nums[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //先从右向左找到第一个小于基准元素的元素\n            while(L&lt;R&amp;&amp;nums[R]&gt;=base){\n                R--;\n            }\n            if(nums[R]&lt;base){\n                swap(nums,L,R);\n            }\n            //再从左向右找到第一个大于基准元素的元素\n            while(L&lt;R&amp;&amp;nums[L]&lt;=base){\n                L++;\n            }\n            if(nums[L]&gt;base){\n                swap(nums,L,R);\n            }\n        }\n        //左递归\n        if(L&gt;low){\n            quickSort(nums,low,L-1);\n        }\n        //右递归\n        if(high&gt;R){\n            quickSort(nums,R+1,high);\n        }\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>2，堆排序：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;先讲解一下堆排序：堆排序是一种完全二叉树的结构，常见的存在两种堆结构，小根堆（即满足arr[2i+1]&gt;=arr[i]&amp;&amp;arr[2i+2]&gt;=arr[i]），大根堆（即满足arr[2i+1]&lt;=arr[i]&amp;&amp;arr[2i+2]&lt;=arr[i]）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;基本算法思想：第一步，初始化堆，即堆初始化为大根堆或者小根堆（这里我们简称调整堆）；第二步，将堆顶元素与堆的末尾元素进行交换，然后重新调整堆。在java中堆通常用来实现优先级队列PriorityQueue(默认的采用小根堆，若想使用大根堆，需要在创建时实现comparator)</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;使用情况：这里以java中的优先级队列为例，堆的使用情况不能按照堆名断章取义，例如小根堆实际上是将元素升序存放，因为在算法第二步中将堆顶元素与末尾元素进行交换，然后重新调整，交换的堆顶元素为最小元素，也是最先从堆中进入队列的。所以小根堆适用于TOPk大的算法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;相反的，大根堆适用于TOPk小的算法，下面分别给出小根堆和大根堆的算法：</strong></p>\n<p><strong>小根堆：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 堆排序---小根堆\n     * @param nums\n     */\n    public static void HeapSort(int[] nums){\n        //先初始化堆\n        for (int i = nums.length/2-1; i &gt;=0 ; i--) {\n            adjustHeap(nums,i,nums.length);\n        }\n        //交换堆顶与末尾节点+重新调整为小根堆\n        for (int i = nums.length-1; i &gt;0; i--) {\n            //先交换\n            swap(nums,0,i);\n            //再调整\n            adjustHeap(nums,0,i);\n        }\n    }\n\n    /**\n     * 调整为小根堆\n     * @param nums\n     * @param i\n     * @param length\n     */\n    public static void adjustHeap(int[] nums,int i,int length){\n        int temp = nums[i];\n        for (int j = 2*i+1; j &lt; length; j=2*j+1) {\n            //找出左右节点中的最小值\n            if(j+1&lt;length&amp;&amp;nums[j]&gt;nums[j+1]){\n                j++;\n            }\n            if(nums[j]&lt;temp){\n                nums[i] = nums[j];\n                i = j;\n            }\n        }\n        nums[i] = temp;\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p><strong>大根堆：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 堆排序---大根堆\n     * @param nums\n     */\n    public static void heapSort(int[] nums){\n\n        //初始化堆的过程\n        for (int i = nums.length/2-1; i &gt;=0; i--) {\n            adjustHeap(nums,i,nums.length);\n        }\n        //调整+交换堆顶和末尾的元素\n        for (int i = nums.length-1; i &gt;0; i--) {\n            //先交换，再重新调整\n            swap(nums,0,i);\n            adjustHeap(nums,0,i);\n        }\n    }\n\n    /**\n     * 调整大顶堆的过程\n     * @param nums\n     * @param i\n     * @param length\n     */\n    public static void adjustHeap(int[] nums,int i,int length){\n        int temp = nums[i];\n        for (int j = 2*i+1; j &lt; length; j=2*j+1) {\n            //找出左右节点中的最大值\n            if(j+1&lt;length&amp;&amp;nums[j]&lt;nums[j+1]){\n                j++;\n            }\n            if(nums[j]&gt;temp){\n                nums[i] = nums[j];\n                i = j;\n            }\n        }\n        nums[i] = temp;\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>本题利用大根堆解法，且使用java中自带的优先级队列PriorityQueue：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用堆数据结构，java中的优先级队列对应着最小堆\n     * 实现其comparator即可\n     * @param arr\n     * @param k\n     * @return\n     */\n    public static int[] getLeastNumbers2(int[] arr, int k){\n        Queue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(k,(v1,v2)-&gt;v2-v1);\n        for (int i : arr) {\n            if(heap.isEmpty()||heap.size()&lt;k||i&lt;heap.peek()){\n                heap.offer(i);\n            }\n            if(heap.size()&gt;k){\n                heap.poll();\n            }\n        }\n        int[] result = new int[k];\n        int j = 0;\n        for (Integer val : heap) {\n            result[j++] = val;\n        }\n        return result;\n    }</code></pre>","blogGoods":0,"blogId":"1253874832811089920","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6joYWAF3oqAAAaZr2Bc1U671.jpg","blogRead":2,"blogRemark":"剑指offer----之最小的k个数","blogTitle":"剑指offer----之最小的k个数","createdTime":"2020-04-25 10:33:50","typeName":"LeetCode","updateTime":"2020-04-25 11:53:15"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，数组中出现次数超过一半的元素---即众数</strong></h2>\n<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>\n<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>\n<p>示例&nbsp;1:</p>\n<p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br />输出: 2</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>方法有三：哈希表统计法，数组排序法，摩尔投票法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;哈希统计法：时间复杂度O（N），空间复杂度O（N）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 博主刚开始看到这道题的时候，首先想到的是哈希表统计法，因为博主想的是要找到众数，那么肯定得统计每个数字的出现次数，然后按照次数比较。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 单单是想到这些，用了map集合之后发现还是不行，因为即便用map集合统计出了每个数字和其对应的出现次数之后，你会发现没有办法按照出现的次数进行比较并且得到次数最多的数字（众数</strong><strong>）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 然后，就又审了一遍题目，结果发现了一个本题很关键的点，（<span style=\"background-color: #ffcc00;\">数组中有一个数字出现的次数超过数组长度的一半</span>），也就是说数组中有且仅有一个数字的出现次数会超过数组长度的一半（别笑博主笨，我是真的刚开始没反应过来）</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 那么我为什么要把数组中的所有元素和其次数全部存放进入map集合，然后再取次数进行比较呢？我为什么不在将元素和其次数存入集合的过程中判断次数是否已经超过数组长度的一半了呢？如果超过一半了，那它肯定是众数了呀！</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 思路：根据题意需要找出两个东西，一是多素元素，二是多素元素的出现次数\n     * 所以我们首先想到的是采用map集合\n     * 然后遍历数组，如果元素不存在与集合中，我们就将其加入map，value置为1\n     * 如果元素存在于map中，则我们取出其value将其加1与数组长度的一半做比较\n     * 如果大于数组长度一半，直接返回该元素即可\n     * 小于数组长度一半，则将其value加1存入map覆盖原有的值即可\n     *\n     * @param nums\n     * @return\n     */\n    public static int majorityElement(int[] nums) {\n        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(nums.length);\n        for (int num : nums) {\n            if(!map.containsKey(num)){\n                map.put(num,1);\n            }else{\n                Integer val = map.get(num);\n                if(++val&gt;nums.length/2){\n                    return num;\n                }else{\n                    map.put(num,val);\n                }\n            }\n        }\n        throw new RuntimeException(\"\");\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>数组排序法：由题可知，数组众必然存在一个多数元素，且出现次数超过数组长度的一半。所以我们可以对原数组进行排序，然后取数组中间的元素即可。（我擦，我当时看到这个，就在想，好简单，这个思路，但是我为什么没想到，对，因为我没有仔细的分析题目，超过一半看见没）。既然进行排序，那么我们可以选择快排，这样时间复杂度就是O（NlogN），空间复杂度O（1）.</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 数组排序法，因为多数元素的出现次数超过数组长度一半，\n     * 所以我们可以先对其进行排序，采用快排，时间复杂度O（NlogN）\n     * 然后取数组中点元素即可\n     * @param nums\n     * @return\n     */\n    public static int majorityElement2(int[] nums){\n        quickSort(nums,0,nums.length-1);\n        return nums[nums.length/2];\n    }\n\n    /**\n     * 快排\n     * @param nums\n     * @param low\n     * @param high\n     */\n    public static void quickSort(int[] nums,int low,int high){\n        int base = nums[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //从右向左找到第一个比基准元素小的元素\n            while(L&lt;R&amp;&amp;nums[R]&gt;=base){\n                R--;\n            }\n            if(nums[R]&lt;base){\n                swap(nums,L,R);\n            }\n            //从左向右找到第一个比基准元素大的元素\n            while(L&lt;R&amp;&amp;nums[L]&lt;=base){\n                L++;\n            }\n            if(nums[L]&gt;base){\n                swap(nums,L,R);\n            }\n        }\n        //左递归\n        if(L&gt;low){\n            quickSort(nums,low,L-1);\n        }\n        //右递归\n        if(high&gt;R){\n            quickSort(nums,R+1,high);\n        }\n    }\n\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>摩尔投票法（我将其称为大佬解法）：大概的意思就是采用正负抵消的方法，设置一个投票变量votes，初始设置为0；设置一个本题中的众数变量x，初始设置为数组首元素。然后遍历数组，判断跟设置的众数变量是否相等，如果相等将votes加一，如果不相等，则重置votes为0，且将x设置为数组下一个元素。本题众因为已经声明了肯定存在众数，所以不需要进行验证，但是如果没有声明的话，需要验证，下列代码众添加了验证：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 摩尔投票法\n     * @param nums\n     */\n    public static int majorityElement3(int[] nums){\n        int votes = 0;\n        int x = nums[0];\n        int count = 0;\n        for (int num : nums) {\n            if(votes==0){\n                x = num;\n            }\n            votes+=(num==x)?1:-1;\n        }\n        //验证数组众是否存在众数\n        for (int num : nums) {\n            if(num==x){\n                count++;\n            }\n        }\n        return count&gt;nums.length/2?x:0;\n    }</code></pre>","blogGoods":0,"blogId":"1253674617332162560","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6i5v-AUh39AAAaZr2Bc1U885.jpg","blogRead":0,"blogRemark":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","blogTitle":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","createdTime":"2020-04-24 21:18:14","typeName":"LeetCode","updateTime":"2020-04-24 21:18:14"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，从上到下打印二叉树-2</strong></h2>\n<p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>\n<p>例如:<br />给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>\n<p>3<br />/ \\<br />9 20<br />/ \\<br />15 7<br />返回其层次遍历结果：</p>\n<p>[<br />[3],<br />[9,20],<br />[15,7]<br />]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;BFS（广度优先搜索）：层次遍历</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * BFS\n     * @param root\n     * @return\n     */\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {\n        if (root == null) {\n            return new ArrayList&lt;&gt;(0);\n        }\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();\n        TreeNode current;\n        while (!queue.isEmpty()) {\n            List&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();\n            for (int i = queue.size(); i &gt; 0; i--) {\n                current = queue.poll();\n                arrayList.add(current.val);\n                if (current.left != null) {\n                    queue.add(current.left);\n                }\n                if (current.right != null) {\n                    queue.add(current.right);\n                }\n            }\n            list.add(arrayList);\n        }\n        return list;\n    }</code></pre>","blogGoods":0,"blogId":"1253350612905598976","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6huUyATZJ_AAAaZr2Bc1U363.jpg","blogRead":1,"blogRemark":"剑指offer----之从上到下打印二叉树----LeetCode102","blogTitle":"剑指offer----之从上到下打印二叉树----LeetCode102","createdTime":"2020-04-23 23:50:45","typeName":"LeetCode","updateTime":"2020-04-23 23:50:57"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，从上打印二叉树-1</strong></h2>\n<p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>\n<p>例如:<br />给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>\n<p>3<br />/ \\<br />9 20<br />/ \\<br />15 7<br />返回：</p>\n<p>[3,9,20,15,7]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;BFS（广度优先搜索）：也即是二叉树的层次遍历，代码和注意事项看代码注释</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 二叉树的层次遍历\n     * 这里是将层次遍历的结果存储在数组中\n     * 但是因为二叉树的节点个数并不知道\n     * 所以不能使用数组直接进行存储，因为无法初始化数组的大小\n     * 所以可以想到使用容量能自动扩充的list集合\n     * 然后再根据list集合的size来初始化数组的大小\n     * 并且将list元素赋值到数组中\n     * @param root\n     * @return\n     */\n    public static int[] levelOrder(TreeNode root) {\n        if(root==null){\n            return new int[0];\n        }\n        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n        TreeNode current;\n        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n        while(!queue.isEmpty()){\n            current = queue.poll();\n            list.add(current.val);\n            if(current.left!=null){\n                queue.add(current.left);\n            }\n            if(current.right!=null){\n                queue.add(current.right);\n            }\n        }\n        int[] result = new int[list.size()];\n        for (int i = 0; i &lt; list.size(); i++) {\n            result[i] = list.get(i);\n        }\n        return result;\n    }</code></pre>","blogGoods":0,"blogId":"1253346228108894208","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6htTeAUHGlAAAaZr2Bc1U102.jpg","blogRead":0,"blogRemark":"剑指offer----之从上到下打印二叉树","blogTitle":"剑指offer----之从上到下打印二叉树","createdTime":"2020-04-23 23:33:20","typeName":"LeetCode","updateTime":"2020-04-23 23:33:20"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，包含min函数的栈</strong></h2>\n<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>\n<p>&nbsp;</p>\n<p>示例:</p>\n<p>MinStack minStack = new MinStack();<br />minStack.push(-2);<br />minStack.push(0);<br />minStack.push(-3);<br />minStack.min(); --&gt; 返回 -3.<br />minStack.pop();<br />minStack.top(); --&gt; 返回 0.<br />minStack.min(); --&gt; 返回 -2.</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>&nbsp;辅助栈法：即初始化两个栈A,B</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;A栈用于实现基本的push(),pop(),top()的正常逻辑</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;B栈用来存放A栈中的非严格降序元素（这个我也理解不了，看代码就知道是存放什么的啦），代码中的方法注释很清楚</strong></p>\n<pre class=\"language-java\"><code>public class MinStack {\n    /** initialize your data structure here. */\n    Stack&lt;Integer&gt; A,B;\n\n    public MinStack() {\n        A = new Stack&lt;&gt;();\n        B = new Stack&lt;&gt;();\n    }\n\n    /**\n     * 入栈操作，元素先入A栈\n     * 如果B栈为空或者B栈的栈顶元素大于待入栈元素，则B栈也执行入栈操作\n     * @param x\n     */\n    public void push(int x) {\n        A.add(x);\n        if(B.isEmpty()||B.peek()&gt;=x){\n            B.add(x);\n        }\n    }\n\n    /**\n     * 这段代码优点巧妙\n     * 注意这里使用的A.pop()而不是A.peek()\n     * 所以这里实际上是分为两种情况的\n     * 第一种：当A的栈顶元素不为当前栈中的最小元素，即不等于栈B的栈顶元素\n     *         则只进行栈A的出栈操作，即A.pop()\n     * 第二种：当A的栈顶元素为当前栈中的最小元素，即等于栈B的栈顶元素\n     *        则不仅要A.pop(),而且为了保证A,B栈中最小元素的同步性\n     *        B栈也要执行出栈操作\n     */\n    public void pop() {\n        if(A.pop().equals(B.peek())){\n            B.pop();\n        }\n    }\n\n    /**\n     * 正常获取A的栈顶元素\n     * @return\n     */\n    public int top() {\n        return A.peek();\n    }\n\n    /**\n     * 获取A栈的最小元素，即B栈的栈顶元素\n     * @return\n     */\n    public int min() {\n        return B.peek();\n    }\n}</code></pre>","blogGoods":0,"blogId":"1253331349566234624","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hp12AMy2MAAAaZr2Bc1U568.jpg","blogRead":4,"blogRemark":"剑指offer----之包含min函数的栈---LeetCode155","blogTitle":"剑指offer----之包含min函数的栈---LeetCode155","createdTime":"2020-04-23 22:34:13","typeName":"LeetCode","updateTime":"2020-04-23 23:50:51"},{"blogCollection":0,"blogComment":0,"blogContent":"<h3><strong>晚上九点多，坐在床上，面前摆放着电脑，屏幕显示的是LeetCode中的《剑指offer》的题解</strong></h3>\n<h3><strong>此时的我毫无睡意，当然，这并不是因为解出一道题的喜悦冲淡了我的睡意</strong></h3>\n<h3><strong>相反的，这是一种难以言明的心情，包含着对自己无知的羞愧，也包含着别人面对如此无知的自己也能给出耐心回应的感动</strong></h3>\n<h3><strong>人有时或许就是这样，刻意的举动会让人心生防备，但是无意的善举却能温润人心</strong></h3>\n<h3><strong>别人无意的一个回答，一个小举动，一句肯定的话</strong></h3>\n<h3><strong>殊不知却能为对方赋予无穷无尽的能量</strong></h3>\n<h3><strong>将这一天的疲惫和劳累都消除</strong></h3>\n<h3><strong>赠人玫瑰，手有余香</strong></h3>\n<h3><strong>我一直抱着这样的一种心态，或许我无法做到赠人玫瑰，但是我会尽量将自己的善意展现给别人</strong></h3>\n<h3><strong>也许他刚刚好正处于某个难关，而你又刚刚好是他难关之初的引导者</strong></h3>\n<h3><strong>一句话，或许对于你来说只是人生中微不足道的几秒钟</strong></h3>\n<h3><strong>而对他来说，或许可能是多年之后回忆起来也能嘴角上扬的美好岁月</strong></h3>\n<h3><strong>想起前段时间一部剧里面的话，在这里也送给屏幕前的你：愿你永怀善意，清澈明朗</strong></h3>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1253326423486144512","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hosWANYd2AAHQzo49lBU641.jpg","blogRead":3,"blogRemark":"2020-4-23有感","blogTitle":"2020-4-23有感","createdTime":"2020-04-23 22:14:38","typeName":"随心日记","updateTime":"2020-04-25 21:22:30"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，顺时针打印矩阵</strong></h2>\n<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>\n<p>示例 1：</p>\n<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br />输出：[1,2,3,6,9,8,7,4,5]<br />示例 2：</p>\n<p>输入：matrix =&nbsp;[[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br />输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p>\n<p>限制：</p>\n<p>0 &lt;= matrix.length &lt;= 100<br />0 &lt;= matrix[i].length&nbsp;&lt;= 100</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;模拟顺时针打印的这种循环结构：设置四个边界条件，l,r,t,b。按照从左往右，从上往下，从右往左，从下网往上的顺序依次读取矩阵的元素，并且每一次都判断边界是否相遇，直到将整个矩阵元素都加入到数组中即可。</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 设置四个边界值，分别为left=0,right=matrix[0].length-1,top=0,bottom=matrix.length-1\n     * 顺时针顺序即先从左到右，再从上到下，再从右向左，再从下向上，每一次执行都要判断边界值\n     * @param matrix\n     * @return\n     */\n    public static int[] spiralOrder(int[][] matrix) {\n        if(matrix.length==0){\n            return new int[0];\n        }\n        int l = 0;\n        int r=matrix[0].length-1;\n        int t=0;\n        int b=matrix.length-1;\n        int x=0;\n        int[] res = new int[(r+1)*(b+1)];\n        while(true){\n            //从左向右\n            for(int i=l;i&lt;=r;i++){\n                res[x++]=matrix[t][i];\n            }\n            if(++t&gt;b) {\n                break;\n            }\n            //从上向下\n            for(int i=t;i&lt;=b;i++){\n                res[x++] = matrix[i][r];\n            }\n            if(--r&lt;l){\n                break;\n            }\n            //从右向左\n            for(int i=r;i&gt;=l;i--){\n                res[x++] = matrix[b][i];\n            }\n            if(--b&lt;t){\n                break;\n            }\n            //从下往上\n            for(int i=b;i&gt;=t;i--){\n                res[x++] = matrix[i][l];\n            }\n            if(++l&gt;r){\n                break;\n            }\n        }\n        return res;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1253250557729087488","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hXB2ASIQwAAAaZr2Bc1U016.jpg","blogRead":0,"blogRemark":"剑指offer-----之顺时针打印矩阵----LeetCode54","blogTitle":"剑指offer-----之顺时针打印矩阵----LeetCode54","createdTime":"2020-04-23 17:13:11","typeName":"LeetCode","updateTime":"2020-04-23 17:13:11"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，对称的二叉树</strong></h2>\n<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>\n<p>例如，二叉树&nbsp;[1,2,2,3,4,4,3] 是对称的。</p>\n<p>&nbsp; &nbsp; 1<br />&nbsp; &nbsp;/ \\<br />&nbsp; 2 &nbsp; 2<br />&nbsp;/ \\ / \\<br />3 &nbsp;4 4 &nbsp;3<br />但是下面这个&nbsp;[1,2,2,null,3,null,3] 则不是镜像对称的:</p>\n<p>&nbsp; &nbsp; 1<br />&nbsp; &nbsp;/ \\<br />&nbsp; 2 &nbsp; 2<br />&nbsp; &nbsp;\\ &nbsp; \\<br />&nbsp; &nbsp;3 &nbsp; &nbsp;3</p>\n<p>示例 1：</p>\n<p>输入：root = [1,2,2,3,4,4,3]<br />输出：true<br />示例 2：</p>\n<p>输入：root = [1,2,2,null,3,null,3]<br />输出：false</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>递归法：从对称的二叉树中我们可以找到如下规律</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果一个二叉树是对称的，则每一个节点的左右子树也是对称的,因此是递归的</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 设L = root.left，R=root.right，则满足L.left.val = R.right.val;L.right.val=R.left.val;</strong></p>\n<pre class=\"language-java\"><code>public boolean isSymmetric(TreeNode root) {\n        return  root==null?true:recur(root.left,root.right);\n    }\n    public boolean recur(TreeNode L,TreeNode R){\n        if(L==null&amp;&amp;R==null){\n            return true;\n        }\n        if(L==null||R==null||L.val!=R.val){\n            return false;\n        }\n        return recur(L.left,R.right)&amp;&amp;recur(L.right,R.left);\n    }</code></pre>","blogGoods":0,"blogId":"1252992659794968576","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6ga--AKQdvAAAaZr2Bc1U862.jpg","blogRead":1,"blogRemark":"剑指offer----之对称的二叉树----LeetCode101","blogTitle":"剑指offer----之对称的二叉树----LeetCode101","createdTime":"2020-04-23 00:08:23","typeName":"LeetCode","updateTime":"2020-04-23 00:12:33"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，二叉树镜像</strong></h2>\n<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>\n<p>例如输入：</p>\n<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; 2 &nbsp; &nbsp; 7<br />&nbsp;/ \\ &nbsp; / \\<br />1 &nbsp; 3 6 &nbsp; 9<br />镜像输出：</p>\n<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; 7 &nbsp; &nbsp; 2<br />&nbsp;/ \\ &nbsp; / \\<br />9 &nbsp; 6 3&nbsp; &nbsp;1</p>\n<p>示例 1：</p>\n<p>输入：root = [4,2,7,1,3,6,9]<br />输出：[4,7,2,9,6,3,1]</p>\n<p>限制：</p>\n<p>0 &lt;= 节点个数 &lt;= 1000</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;递归法：即递归的去交换根节点的左右子树，直到根节点为叶子节点</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用递归的方法，交换根节点的左子树和右子树\n     * 递归出口为，根节点为叶子节点\n     * @param root\n     * @return\n     */\n    public TreeNode mirrorTree(TreeNode root) {\n        TreeNode center = root;\n        if(center!=null){\n            TreeNode temp = center.left;\n            center.left = center.right;\n            center.right = temp;\n            mirrorTree(center.left);\n            mirrorTree(center.right);\n        }\n        return root;\n    }</code></pre>","blogGoods":0,"blogId":"1252985443281027072","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6gZTWABF55AAAaZr2Bc1U678.jpg","blogRead":0,"blogRemark":"剑指offer----之二叉树的镜像----LeetCode226","blogTitle":"剑指offer----之二叉树的镜像----LeetCode226","createdTime":"2020-04-22 23:39:43","typeName":"LeetCode","updateTime":"2020-04-22 23:39:43"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，合并两个有序链表</strong></h2>\n<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>\n<p>示例1：</p>\n<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br />输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br />限制：</p>\n<p>0 &lt;= 链表长度 &lt;= 1000</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>伪头节点法：即创建一个伪头节点head和一个用于辅助的节点cur</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法：如果l1.val&lt;=l2.val,就让cur指向l1，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l1指向其next</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果l1.val&gt;l2.val,就让cur指向l2，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l2指向其next</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;直到l1和l2有一个为空为止，让cur指向剩余的一个非空链表即可，若两个链表的长度为M,N则时间复杂度为O(M+N)</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用四节点，一个伪头节点，一个当前节点cur，已经链表的两个节点l1,l2\n     * 每次比较l1,l2节点的val大小，将小的节点连接到当前节点cur上即可\n     * 直到l1,l2有一个空，则将剩余的一个非空链表连接到cur尾部即可\n     * @param l1\n     * @param l2\n     * @return\n     */\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode head;\n        ListNode cur;\n        head = cur = new ListNode(0);\n        while(l1!=null&amp;&amp;l2!=null){\n            if(l1.val&lt;=l2.val){\n                cur.next = l1;\n                cur = cur.next;\n                l1 = l1.next;\n            }else{\n                cur.next = l2;\n                cur = cur.next;\n                l2 = l2.next;\n            }\n        }\n        if(l1!=null){\n            cur.next = l1;\n        }\n        if(l2!=null){\n            cur.next = l2;\n        }\n        return head.next;\n    }</code></pre>","blogGoods":0,"blogId":"1252980258446000128","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6gYGWAe-MZAAAaZr2Bc1U550.jpg","blogRead":0,"blogRemark":"剑指offer----之合并有序链表---LeetCode21","blogTitle":"剑指offer----之合并有序链表---LeetCode21","createdTime":"2020-04-22 23:19:06","typeName":"LeetCode","updateTime":"2020-04-22 23:19:06"}],"pageSize":15,"params":{},"sortColumn":"created_time","sortMethod":"DESC","totalCount":53,"totalPage":4},"msg":"操作成功!"}
2020-04-26 23:30:13.780 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/getTimeLine
2020-04-26 23:30:13.780 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:30:13.780 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:30:13.781 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getTimeLine
2020-04-26 23:30:13.781 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:30:13.878 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 98
2020-04-26 23:30:13.879 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"blogVoList":[{"blogId":"1254063045920022528","blogMonth":"2020-04","blogTitle":"剑指offer----0~n-1中缺失的数字","createdTime":"2020-04-25 23:01:44"},{"blogId":"1254055163115724800","blogMonth":"2020-04","blogTitle":"剑指offer----在排序数组中查找数字I----LeetCode34","createdTime":"2020-04-25 22:30:24"},{"blogId":"1253992797703364608","blogMonth":"2020-04","blogTitle":"剑指offer----之两个链表的第一个公共节点----LeetCode160","createdTime":"2020-04-25 18:22:35"},{"blogId":"1253956468789600256","blogMonth":"2020-04","blogTitle":"剑指offer----第一次只出现一次的字符","createdTime":"2020-04-25 15:58:14"},{"blogId":"1253938714590175232","blogMonth":"2020-04","blogTitle":"剑指offer---连续子数组的最大和---LeetCode53","createdTime":"2020-04-25 14:47:41"},{"blogId":"1253874832811089920","blogMonth":"2020-04","blogTitle":"剑指offer----之最小的k个数","createdTime":"2020-04-25 10:33:50"},{"blogId":"1253674617332162560","blogMonth":"2020-04","blogTitle":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","createdTime":"2020-04-24 21:18:14"},{"blogId":"1253350612905598976","blogMonth":"2020-04","blogTitle":"剑指offer----之从上到下打印二叉树----LeetCode102","createdTime":"2020-04-23 23:50:45"},{"blogId":"1253346228108894208","blogMonth":"2020-04","blogTitle":"剑指offer----之从上到下打印二叉树","createdTime":"2020-04-23 23:33:20"},{"blogId":"1253331349566234624","blogMonth":"2020-04","blogTitle":"剑指offer----之包含min函数的栈---LeetCode155","createdTime":"2020-04-23 22:34:13"},{"blogId":"1253326423486144512","blogMonth":"2020-04","blogTitle":"2020-4-23有感","createdTime":"2020-04-23 22:14:38"},{"blogId":"1253250557729087488","blogMonth":"2020-04","blogTitle":"剑指offer-----之顺时针打印矩阵----LeetCode54","createdTime":"2020-04-23 17:13:11"},{"blogId":"1252992659794968576","blogMonth":"2020-04","blogTitle":"剑指offer----之对称的二叉树----LeetCode101","createdTime":"2020-04-23 00:08:23"},{"blogId":"1252985443281027072","blogMonth":"2020-04","blogTitle":"剑指offer----之二叉树的镜像----LeetCode226","createdTime":"2020-04-22 23:39:43"},{"blogId":"1252980258446000128","blogMonth":"2020-04","blogTitle":"剑指offer----之合并有序链表---LeetCode21","createdTime":"2020-04-22 23:19:06"},{"blogId":"1252636594674872320","blogMonth":"2020-04","blogTitle":"剑指offer----之反转链表----LeetCode206","createdTime":"2020-04-22 00:33:31"},{"blogId":"1252621660096311296","blogMonth":"2020-04","blogTitle":"剑指offer----之链表中的到数第k个节点","createdTime":"2020-04-21 23:34:10"},{"blogId":"1252617033468620800","blogMonth":"2020-04","blogTitle":"剑指offer----之调整数组顺序使奇数在前，偶数在后","createdTime":"2020-04-21 23:15:47"},{"blogId":"1252610331612557312","blogMonth":"2020-04","blogTitle":"剑指offer----之删除链表的节点","createdTime":"2020-04-21 22:49:09"},{"blogId":"1252604581645398016","blogMonth":"2020-04","blogTitle":"剑指offer----之打印从1到最大的n位数","createdTime":"2020-04-21 22:26:18"},{"blogId":"1252518351972872192","blogMonth":"2020-04","blogTitle":"LeetCode191---之二进制数中1的个数","createdTime":"2020-04-21 16:43:40"},{"blogId":"1252503447316475904","blogMonth":"2020-04","blogTitle":"LeetCode154----之旋转数组的最小值","createdTime":"2020-04-21 15:44:26"},{"blogId":"1252439650715316224","blogMonth":"2020-04","blogTitle":"LeetCode70----青蛙跳台阶","createdTime":"2020-04-21 11:30:56"},{"blogId":"1252423800151093248","blogMonth":"2020-04","blogTitle":"LeetCode509----斐波那契数列","createdTime":"2020-04-21 10:27:57"},{"blogId":"1252270516845203456","blogMonth":"2020-04","blogTitle":"剑指offer--用两个栈实现队列","createdTime":"2020-04-21 00:18:51"},{"blogId":"1252264352052989952","blogMonth":"2020-04","blogTitle":"剑指offer----之从尾到头打印链表","createdTime":"2020-04-20 23:54:22"},{"blogId":"1252257654055686144","blogMonth":"2020-04","blogTitle":"剑指offer----之替换空格","createdTime":"2020-04-20 23:27:45"},{"blogId":"1252250357355040768","blogMonth":"2020-04","blogTitle":"LeetCode240","createdTime":"2020-04-20 22:58:45"},{"blogId":"1252230734534463488","blogMonth":"2020-04","blogTitle":"剑指Offer----之寻找数组中的重复数字","createdTime":"2020-04-20 21:40:47"},{"blogId":"1251888137978793984","blogMonth":"2020-04","blogTitle":"标签云无法实现连续点击切换Bug","createdTime":"2020-04-19 22:59:26"},{"blogId":"1251457803692810240","blogMonth":"2020-04","blogTitle":"面试（九）-----之设计模式（观察者模式）","createdTime":"2020-04-18 18:29:26"},{"blogId":"1251436080364814336","blogMonth":"2020-04","blogTitle":"面试（九）------之设计模式（代理模式）","createdTime":"2020-04-18 17:03:07"},{"blogId":"1251428943714615296","blogMonth":"2020-04","blogTitle":"面试（九）------之设计模式（装饰者模式）","createdTime":"2020-04-18 16:34:45"},{"blogId":"1251421326858551296","blogMonth":"2020-04","blogTitle":"面试（九）-----之设计模式（适配器模式）","createdTime":"2020-04-18 16:04:29"},{"blogId":"1251376301936246784","blogMonth":"2020-04","blogTitle":"面试（九）-----之设计模式（建造者模式）","createdTime":"2020-04-18 13:05:35"},{"blogId":"1251342530616786944","blogMonth":"2020-04","blogTitle":"面试（九）-----之设计模式（单例模式）","createdTime":"2020-04-18 10:51:23"},{"blogId":"1251186933548199936","blogMonth":"2020-04","blogTitle":"粒子特效覆盖分页按钮点击Bug","createdTime":"2020-04-18 00:33:06"},{"blogId":"1251175051101745152","blogMonth":"2020-04","blogTitle":"面试（九）------之设计模式（工厂模式）","createdTime":"2020-04-17 23:45:53"},{"blogId":"1250802898447667200","blogMonth":"2020-04","blogTitle":"项目中的时区问题","createdTime":"2020-04-16 23:07:05"},{"blogId":"1250774653945802752","blogMonth":"2020-04","blogTitle":"面试（八）------之分布式缓存的原理及应用","createdTime":"2020-04-16 13:14:51"},{"blogId":"1250704122190073856","blogMonth":"2020-04","blogTitle":"面试（七）-----数据库及分布式事务","createdTime":"2020-04-16 08:34:35"},{"blogId":"1250622112591376384","blogMonth":"2020-04","blogTitle":"面试（六）------之网络与负载均衡","createdTime":"2020-04-16 03:08:42"},{"blogId":"1250364779516665856","blogMonth":"2020-04","blogTitle":"面试（五）------之算法","createdTime":"2020-04-15 10:06:09"},{"blogId":"1250068950784536576","blogMonth":"2020-04","blogTitle":"面试（四）------之数据结构篇","createdTime":"2020-04-14 14:30:37"},{"blogId":"1249742755949817856","blogMonth":"2020-04","blogTitle":"面试（三）------之并发编程篇（下）","createdTime":"2020-04-13 16:54:26"},{"blogId":"1249588251598041088","blogMonth":"2020-04","blogTitle":"redis基础（一）","createdTime":"2020-04-13 06:40:30"},{"blogId":"1249313090567143424","blogMonth":"2020-04","blogTitle":"面试（三）------之并发编程篇（上）","createdTime":"2020-04-12 12:27:07"},{"blogId":"1248605157059497984","blogMonth":"2020-04","blogTitle":"面试（二）------之JAVA基础篇","createdTime":"2020-04-10 13:34:02"},{"blogId":"1248500061625745408","blogMonth":"2020-04","blogTitle":"Linux基本命令","createdTime":"2020-04-10 06:36:25"},{"blogId":"1248224512563068928","blogMonth":"2020-04","blogTitle":"面试（一）------之JVM篇","createdTime":"2020-04-09 12:21:30"},{"blogId":"1248135765829918720","blogMonth":"2020-04","blogTitle":"CSS----之flex弹性布局","createdTime":"2020-04-09 06:28:51"},{"blogId":"1247867141693128704","blogMonth":"2020-04","blogTitle":"闲谈前后端分离开发","createdTime":"2020-04-08 12:41:25"},{"blogId":"1247745014683947008","blogMonth":"2020-04","blogTitle":"博客开发总结（一）-----之数据库设计篇","createdTime":"2020-04-08 04:36:07"}],"month":"2020-04"}],"msg":"操作成功!"}
2020-04-26 23:30:15.531 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/getTimeLine
2020-04-26 23:30:15.531 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /admin/getInfo
2020-04-26 23:30:15.531 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:30:15.531 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:30:15.532 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:30:15.532 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:30:15.532 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getTimeLine
2020-04-26 23:30:15.532 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.AdminController.getInfo
2020-04-26 23:30:15.532 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:30:15.532 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:30:15.624 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 93
2020-04-26 23:30:15.624 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"header":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMSKACehsAACHOzTvceE295.jpg","id":1,"name":"小屋","signature":"时光好不经用，转眼已是半生","username":"admin"},"msg":"操作成功!"}
2020-04-26 23:30:15.626 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 95
2020-04-26 23:30:15.627 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"blogVoList":[{"blogId":"1254063045920022528","blogMonth":"2020-04","blogTitle":"剑指offer----0~n-1中缺失的数字","createdTime":"2020-04-25 23:01:44"},{"blogId":"1254055163115724800","blogMonth":"2020-04","blogTitle":"剑指offer----在排序数组中查找数字I----LeetCode34","createdTime":"2020-04-25 22:30:24"},{"blogId":"1253992797703364608","blogMonth":"2020-04","blogTitle":"剑指offer----之两个链表的第一个公共节点----LeetCode160","createdTime":"2020-04-25 18:22:35"},{"blogId":"1253956468789600256","blogMonth":"2020-04","blogTitle":"剑指offer----第一次只出现一次的字符","createdTime":"2020-04-25 15:58:14"},{"blogId":"1253938714590175232","blogMonth":"2020-04","blogTitle":"剑指offer---连续子数组的最大和---LeetCode53","createdTime":"2020-04-25 14:47:41"},{"blogId":"1253874832811089920","blogMonth":"2020-04","blogTitle":"剑指offer----之最小的k个数","createdTime":"2020-04-25 10:33:50"},{"blogId":"1253674617332162560","blogMonth":"2020-04","blogTitle":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","createdTime":"2020-04-24 21:18:14"},{"blogId":"1253350612905598976","blogMonth":"2020-04","blogTitle":"剑指offer----之从上到下打印二叉树----LeetCode102","createdTime":"2020-04-23 23:50:45"},{"blogId":"1253346228108894208","blogMonth":"2020-04","blogTitle":"剑指offer----之从上到下打印二叉树","createdTime":"2020-04-23 23:33:20"},{"blogId":"1253331349566234624","blogMonth":"2020-04","blogTitle":"剑指offer----之包含min函数的栈---LeetCode155","createdTime":"2020-04-23 22:34:13"},{"blogId":"1253326423486144512","blogMonth":"2020-04","blogTitle":"2020-4-23有感","createdTime":"2020-04-23 22:14:38"},{"blogId":"1253250557729087488","blogMonth":"2020-04","blogTitle":"剑指offer-----之顺时针打印矩阵----LeetCode54","createdTime":"2020-04-23 17:13:11"},{"blogId":"1252992659794968576","blogMonth":"2020-04","blogTitle":"剑指offer----之对称的二叉树----LeetCode101","createdTime":"2020-04-23 00:08:23"},{"blogId":"1252985443281027072","blogMonth":"2020-04","blogTitle":"剑指offer----之二叉树的镜像----LeetCode226","createdTime":"2020-04-22 23:39:43"},{"blogId":"1252980258446000128","blogMonth":"2020-04","blogTitle":"剑指offer----之合并有序链表---LeetCode21","createdTime":"2020-04-22 23:19:06"},{"blogId":"1252636594674872320","blogMonth":"2020-04","blogTitle":"剑指offer----之反转链表----LeetCode206","createdTime":"2020-04-22 00:33:31"},{"blogId":"1252621660096311296","blogMonth":"2020-04","blogTitle":"剑指offer----之链表中的到数第k个节点","createdTime":"2020-04-21 23:34:10"},{"blogId":"1252617033468620800","blogMonth":"2020-04","blogTitle":"剑指offer----之调整数组顺序使奇数在前，偶数在后","createdTime":"2020-04-21 23:15:47"},{"blogId":"1252610331612557312","blogMonth":"2020-04","blogTitle":"剑指offer----之删除链表的节点","createdTime":"2020-04-21 22:49:09"},{"blogId":"1252604581645398016","blogMonth":"2020-04","blogTitle":"剑指offer----之打印从1到最大的n位数","createdTime":"2020-04-21 22:26:18"},{"blogId":"1252518351972872192","blogMonth":"2020-04","blogTitle":"LeetCode191---之二进制数中1的个数","createdTime":"2020-04-21 16:43:40"},{"blogId":"1252503447316475904","blogMonth":"2020-04","blogTitle":"LeetCode154----之旋转数组的最小值","createdTime":"2020-04-21 15:44:26"},{"blogId":"1252439650715316224","blogMonth":"2020-04","blogTitle":"LeetCode70----青蛙跳台阶","createdTime":"2020-04-21 11:30:56"},{"blogId":"1252423800151093248","blogMonth":"2020-04","blogTitle":"LeetCode509----斐波那契数列","createdTime":"2020-04-21 10:27:57"},{"blogId":"1252270516845203456","blogMonth":"2020-04","blogTitle":"剑指offer--用两个栈实现队列","createdTime":"2020-04-21 00:18:51"},{"blogId":"1252264352052989952","blogMonth":"2020-04","blogTitle":"剑指offer----之从尾到头打印链表","createdTime":"2020-04-20 23:54:22"},{"blogId":"1252257654055686144","blogMonth":"2020-04","blogTitle":"剑指offer----之替换空格","createdTime":"2020-04-20 23:27:45"},{"blogId":"1252250357355040768","blogMonth":"2020-04","blogTitle":"LeetCode240","createdTime":"2020-04-20 22:58:45"},{"blogId":"1252230734534463488","blogMonth":"2020-04","blogTitle":"剑指Offer----之寻找数组中的重复数字","createdTime":"2020-04-20 21:40:47"},{"blogId":"1251888137978793984","blogMonth":"2020-04","blogTitle":"标签云无法实现连续点击切换Bug","createdTime":"2020-04-19 22:59:26"},{"blogId":"1251457803692810240","blogMonth":"2020-04","blogTitle":"面试（九）-----之设计模式（观察者模式）","createdTime":"2020-04-18 18:29:26"},{"blogId":"1251436080364814336","blogMonth":"2020-04","blogTitle":"面试（九）------之设计模式（代理模式）","createdTime":"2020-04-18 17:03:07"},{"blogId":"1251428943714615296","blogMonth":"2020-04","blogTitle":"面试（九）------之设计模式（装饰者模式）","createdTime":"2020-04-18 16:34:45"},{"blogId":"1251421326858551296","blogMonth":"2020-04","blogTitle":"面试（九）-----之设计模式（适配器模式）","createdTime":"2020-04-18 16:04:29"},{"blogId":"1251376301936246784","blogMonth":"2020-04","blogTitle":"面试（九）-----之设计模式（建造者模式）","createdTime":"2020-04-18 13:05:35"},{"blogId":"1251342530616786944","blogMonth":"2020-04","blogTitle":"面试（九）-----之设计模式（单例模式）","createdTime":"2020-04-18 10:51:23"},{"blogId":"1251186933548199936","blogMonth":"2020-04","blogTitle":"粒子特效覆盖分页按钮点击Bug","createdTime":"2020-04-18 00:33:06"},{"blogId":"1251175051101745152","blogMonth":"2020-04","blogTitle":"面试（九）------之设计模式（工厂模式）","createdTime":"2020-04-17 23:45:53"},{"blogId":"1250802898447667200","blogMonth":"2020-04","blogTitle":"项目中的时区问题","createdTime":"2020-04-16 23:07:05"},{"blogId":"1250774653945802752","blogMonth":"2020-04","blogTitle":"面试（八）------之分布式缓存的原理及应用","createdTime":"2020-04-16 13:14:51"},{"blogId":"1250704122190073856","blogMonth":"2020-04","blogTitle":"面试（七）-----数据库及分布式事务","createdTime":"2020-04-16 08:34:35"},{"blogId":"1250622112591376384","blogMonth":"2020-04","blogTitle":"面试（六）------之网络与负载均衡","createdTime":"2020-04-16 03:08:42"},{"blogId":"1250364779516665856","blogMonth":"2020-04","blogTitle":"面试（五）------之算法","createdTime":"2020-04-15 10:06:09"},{"blogId":"1250068950784536576","blogMonth":"2020-04","blogTitle":"面试（四）------之数据结构篇","createdTime":"2020-04-14 14:30:37"},{"blogId":"1249742755949817856","blogMonth":"2020-04","blogTitle":"面试（三）------之并发编程篇（下）","createdTime":"2020-04-13 16:54:26"},{"blogId":"1249588251598041088","blogMonth":"2020-04","blogTitle":"redis基础（一）","createdTime":"2020-04-13 06:40:30"},{"blogId":"1249313090567143424","blogMonth":"2020-04","blogTitle":"面试（三）------之并发编程篇（上）","createdTime":"2020-04-12 12:27:07"},{"blogId":"1248605157059497984","blogMonth":"2020-04","blogTitle":"面试（二）------之JAVA基础篇","createdTime":"2020-04-10 13:34:02"},{"blogId":"1248500061625745408","blogMonth":"2020-04","blogTitle":"Linux基本命令","createdTime":"2020-04-10 06:36:25"},{"blogId":"1248224512563068928","blogMonth":"2020-04","blogTitle":"面试（一）------之JVM篇","createdTime":"2020-04-09 12:21:30"},{"blogId":"1248135765829918720","blogMonth":"2020-04","blogTitle":"CSS----之flex弹性布局","createdTime":"2020-04-09 06:28:51"},{"blogId":"1247867141693128704","blogMonth":"2020-04","blogTitle":"闲谈前后端分离开发","createdTime":"2020-04-08 12:41:25"},{"blogId":"1247745014683947008","blogMonth":"2020-04","blogTitle":"博客开发总结（一）-----之数据库设计篇","createdTime":"2020-04-08 04:36:07"}],"month":"2020-04"}],"msg":"操作成功!"}
2020-04-26 23:30:15.730 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listFront
2020-04-26 23:30:15.731 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/recommendRead
2020-04-26 23:30:15.731 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/getTotal
2020-04-26 23:30:15.731 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:30:15.731 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:30:15.731 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:30:15.731 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:30:15.731 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:30:15.731 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:30:15.731 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeLists
2020-04-26 23:30:15.731 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getTotal
2020-04-26 23:30:15.731 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.recommendRead
2020-04-26 23:30:15.732 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:30:15.732 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:30:15.732 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:30:15.833 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 102
2020-04-26 23:30:15.833 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 103
2020-04-26 23:30:15.834 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":53,"msg":"操作成功!"}
2020-04-26 23:30:15.834 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":1,"typeName":"Linux"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":2,"typeName":"Docker"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"SpringBoot"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":4,"typeName":"Mybatis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":5,"typeName":"爬虫"},{"deleted":0,"enable":1,"typeBlogCount":4,"typeId":6,"typeName":"博客开发和维护总结"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":7,"typeName":"CSS"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"JavaScript"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Vue"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":10,"typeName":"随笔"},{"deleted":0,"enable":1,"typeBlogCount":16,"typeId":11,"typeName":"java面试篇"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":13,"typeName":"JDK源码阅读"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":14,"typeName":"redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":15,"typeName":"MongoDB"},{"deleted":0,"enable":1,"typeBlogCount":28,"typeId":16,"typeName":"LeetCode"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":17,"typeName":"随心日记"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":18,"typeName":"计算机网络"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":19,"typeName":"操作系统"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":20,"typeName":"数据结构"}],"msg":"操作成功!"}
2020-04-26 23:30:15.836 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 105
2020-04-26 23:30:15.837 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1248605157059497984","blogRead":27,"blogTitle":"面试（二）------之JAVA基础篇","createdTime":"2020-04-10 13:34:02","typeName":"java面试篇"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1247745014683947008","blogRead":21,"blogTitle":"博客开发总结（一）-----之数据库设计篇","createdTime":"2020-04-08 04:36:07","typeName":"博客开发和维护总结"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1248224512563068928","blogRead":17,"blogTitle":"面试（一）------之JVM篇","createdTime":"2020-04-09 12:21:30","typeName":"java面试篇"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1249742755949817856","blogRead":17,"blogTitle":"面试（三）------之并发编程篇（下）","createdTime":"2020-04-13 16:54:26","typeName":"java面试篇"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1250622112591376384","blogRead":8,"blogTitle":"面试（六）------之网络与负载均衡","createdTime":"2020-04-16 03:08:42","typeName":"java面试篇"}],"msg":"操作成功!"}
2020-04-26 23:30:15.841 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /music/listFront
2020-04-26 23:30:15.843 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:30:15.844 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:30:15.845 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.MusicController.getMusicList
2020-04-26 23:30:15.845 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:30:15.941 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 100
2020-04-26 23:30:15.942 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"artist":"周深","cover":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMh2AFeEFAAAZaWcYmAM180.jpg","id":1,"lrc":"[00:00.37]周深 - 直破穹苍 (《斗破苍穹》动画第三季主题曲)\n[00:02.79]作词：冥凰\n[00:03.86]作曲：李建衡\n[00:05.19]编曲：崔博源、李建衡\n[00:07.13]人声录制：徐威@上海V-Studio\n[00:09.23]监唱：徐威@上海V-Studio\n[00:11.38]混音：周天澈@Studio21A\n[00:24.13]有没有想过 穿越这片沙漠\n[00:32.21]前方是什么\n[00:35.16]是就此陨落\n[00:37.97]还是抓牢命运脉搏\n[00:45.38]他曾经 爱过 恨过 痛过\n[00:51.07]直到望见远处那抹焰火\n[00:56.73]也许这 是祸 是过 是错\n[01:02.41]仍不害怕 去烧灼\n[01:08.50]管那六合八荒 斗一场\n[01:14.06]焰分噬浪谁能抗\n[01:19.28]漫却这漫漫险关 莫登攀\n[01:24.88]他欲乘风 直破穹苍\n[01:43.04]太多的纠葛 太多悲欢离合\n[01:51.39]要人太执着\n[01:54.21]该如何选择\n[01:57.02]才能看清是非漩涡\n[02:04.58]他曾经 哭过 泪过 笑过\n[02:10.16]直到紧握手心那抹焰火\n[02:15.77]走遍这 荒山 大漠 湖泊\n[02:21.49]仍不退缩 去冲破\n[02:27.44]管那龙潭虎穴 斗一场\n[02:32.72]生死福祸也跌宕\n[02:38.28]漫却他太多如果 都过往\n[02:43.86]还来惊诧 满堂\n[02:50.00]管那六合八荒 斗一场\n[02:55.22]焰分噬浪谁能抗\n[03:00.85]漫却这漫漫险关 莫登攀\n[03:06.51]他欲乘风 直破穹苍","name":"直破苍穹","url":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMlWAC1FrAr8ypaThmW479.flac"},{"artist":"冷鸢","cover":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMnWAa32EAABwmk6a5Cs834.jpg","id":2,"lrc":"你是信的开头诗的内容\n童话的结尾\n你是理所当然的奇迹\n你是月色真美\n你是圣诞老人送给我\n好孩子的礼物\n你是三千美丽世界里\n我的一瓢水\n所以让我再靠近一点点\n因为你太温暖\n我会再变得坚强一点点\n因为你太柔软\n交换无名指金色的契约\n给彼此岁月\n说好从今以后都牵着手\n因为要走很远\n你是我万水千山的冒险\n要找的标记点\n你是分割我人生的线\n又将它们相连\n你是前世千次的回眸\n虔诚牵的手\n你是其余所有的一切\n是我的世界\n所以请你再闪亮一点点\n尽管我太平凡\n我会再变得柔软一点点\n因为你太敏感\n交换无名指金色的契约\n给彼此岁月\n说好从今以后都牵着手\n不管要走多远\n让我再靠近一点点\n因为你太温暖\n我会再变得坚强一点点\n因为你太柔软\n交换无名指金色的契约\n给彼此岁月\n说好从今以后都牵着手\n因为要走很远","name":"勾指起誓","url":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMomAGXdvAHZQ_9pwL9c866.mp3"}],"msg":"操作成功!"}
2020-04-26 23:30:16.089 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /link/list
2020-04-26 23:30:16.089 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:30:16.090 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:30:16.090 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.LinkController.getLinkList
2020-04-26 23:30:16.090 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:30:16.181 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 92
2020-04-26 23:30:16.181 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"createdTime":"2020-04-08 02:11:26","linkId":1,"linkName":"百度","linkUrl":"www.baidu.com","updateTime":"2020-04-08 02:11:26","version":1},{"createdTime":"2020-04-18 21:39:52","linkId":2,"linkName":"CSDN","linkUrl":"https://www.csdn.net/","updateTime":"2020-04-18 21:39:52","version":1}],"msg":"操作成功!"}
2020-04-26 23:30:17.061 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listFront
2020-04-26 23:30:17.062 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:30:17.062 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:30:17.063 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeLists
2020-04-26 23:30:17.063 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:30:17.155 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 94
2020-04-26 23:30:17.155 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":1,"typeName":"Linux"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":2,"typeName":"Docker"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"SpringBoot"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":4,"typeName":"Mybatis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":5,"typeName":"爬虫"},{"deleted":0,"enable":1,"typeBlogCount":4,"typeId":6,"typeName":"博客开发和维护总结"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":7,"typeName":"CSS"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"JavaScript"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Vue"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":10,"typeName":"随笔"},{"deleted":0,"enable":1,"typeBlogCount":16,"typeId":11,"typeName":"java面试篇"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":13,"typeName":"JDK源码阅读"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":14,"typeName":"redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":15,"typeName":"MongoDB"},{"deleted":0,"enable":1,"typeBlogCount":28,"typeId":16,"typeName":"LeetCode"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":17,"typeName":"随心日记"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":18,"typeName":"计算机网络"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":19,"typeName":"操作系统"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":20,"typeName":"数据结构"}],"msg":"操作成功!"}
2020-04-26 23:30:44.289 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /rotation-picture/listFront
2020-04-26 23:30:44.289 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:30:44.290 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:30:44.290 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.RotationPictureController.getRotationPictureListFront
2020-04-26 23:30:44.291 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:30:44.303 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/list
2020-04-26 23:30:44.304 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:30:44.304 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:30:44.304 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogList
2020-04-26 23:30:44.304 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=15, totalPage=0, totalCount=0, list=[], params={}, sortColumn=created_time, sortMethod=DESC)]
2020-04-26 23:30:44.386 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 97
2020-04-26 23:30:44.387 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"createdTime":"2020-04-09 13:31:20","enable":1,"rotationId":4,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PI6aAZIz1AASCO4hlpJI295.jpg"},{"createdTime":"2020-04-09 13:37:02","enable":1,"rotationId":9,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJPyAbm8fAAG9gfO8lxE28.jpeg"},{"createdTime":"2020-04-09 13:41:30","enable":1,"rotationId":10,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJgeAeG8wAAS2pjJC5QU547.jpg"},{"createdTime":"2020-04-09 13:41:38","enable":1,"rotationId":11,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhGAQFZbAAP2OOBWb6k310.jpg"},{"createdTime":"2020-04-09 13:41:50","enable":1,"rotationId":12,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhyABMZCAAG7doyXiM8109.jpg"},{"createdTime":"2020-04-09 13:41:59","enable":1,"rotationId":13,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJiWAL7BoAARW3_O3ISw651.jpg"}],"msg":"操作成功!"}
2020-04-26 23:30:44.617 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 314
2020-04-26 23:30:44.619 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，0~n-1中缺失的数字</strong></h2>\n<p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>\n<p>示例 1:</p>\n<p>输入: [0,1,3]<br />输出: 2<br />示例&nbsp;2:</p>\n<p>输入: [0,1,2,3,4,5,6,7,9]<br />输出: 8</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主能想到的并且写出来的方法有：使用map存储数组中的所有元素，然后遍历0-n-1找出不在map中的元素。此种方法时间复杂度O（N），空间复杂度O（N）-----垃圾</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 统计0-n-1所有数字的数字和，再统计数组中所有数字的数字和，两和只差即为所求数字，时间复杂度O（N），空间复杂度O（1）-----垃圾</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;最优解法（二分查找法）：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;通常来说，我们使用二分查找法是查找一个存在于数组中的元素，但是本题需要求不在数组中的一个元素，因此到这很多人就会迷惑，不知道该怎么求了。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;但是我们首先要搞明白二分查找法的本质是什么：1，并不局限于仅仅查找存在于数组中的元素；2，二分查找的本质是对数组根据mid中间值在某一条件上进行二分（例如：通常的num[mid]&gt;target或者nums[mid]&lt;target进行左右切分）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;因此明白这一点，就好解决问题了。拿到这道题，使用二分，我们首先想到的应该是寻找根据mid中间值进行二分的条件</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;审题：题目中提及数组为递增数组，而且0-n-1内的n个数字有一个不在数组中，则不在的这个数字之前的数字满足nums[i]=i即元素本身等于数组下标，而之后的数字nums[i]!=i,所以这就是进行二分的条件了</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 二分查找法\n     * 算法思想：二分查找法的本质是能够有一个条件将数组根据mid中间值进行左右切分\n     * 所以我们想到二分查找法之后，首先需要做的是找出切分数组的条件\n     * 题目中给出了数组是一个递增数组，且0-n-1内的n个数字有一个不在这个长度为n-1的数组内\n     * 因此，不在的这个元素其左边元素必有数组下标值等于元素本身即nums[i]=i\n     * 而不在的这个元素的右边必有nums[i]!=i\n     * 所以根据此条件进行划分数组即可\n     * @param nums\n     * @return\n     */\n    public static int missingNumber(int[] nums) {\n        int low = 0;\n        int high = nums.length-1;\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]==mid){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        return low;\n    }</code></pre>","blogGoods":0,"blogId":"1254063045920022528","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kUM-AON88AAAaZr2Bc1U903.jpg","blogRead":0,"blogRemark":"剑指offer----0~n-1中缺失的数字","blogTitle":"剑指offer----0~n-1中缺失的数字","createdTime":"2020-04-25 23:01:44","typeName":"LeetCode","updateTime":"2020-04-25 23:01:44"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，在排序数组中查找数字I</strong></h2>\n<p>统计一个数字在排序数组中出现的次数。</p>\n<p>示例 1:</p>\n<p>输入: nums = [5,7,7,8,8,10], target = 8<br />输出: 2<br />示例&nbsp;2:</p>\n<p>输入: nums = [5,7,7,8,8,10], target = 6<br />输出: 0</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解法一：直接遍历统计，时间复杂度为O（N）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 遍历数组\n     * 找到第一个与目标元素相等的元素，res+1\n     * 然后往后找到第一个与目标元素不相等的元素,返回res即可\n     * 时间复杂度为O(N)\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static int search(int[] nums, int target) {\n        int res = 0;\n        for (int num : nums) {\n            if(num==target){\n                res++;\n            }\n        }\n        return res;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解法二：二分法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：利用二分法查找数字在排序数组中的左边界Left和右边界Right.如下，如果要寻找数组中的8，则其左边界为left=2,有边界right=5.所以出现次数为right-left-1.时间复杂度为O（logN）</strong></p>\n<table style=\"width: 20%; border-collapse: collapse; margin-left: auto; margin-right: auto;\" border=\"1\" cellpadding=\"5\">\n<tbody>\n<tr>\n<td style=\"width: 16.6667%;\">5</td>\n<td style=\"width: 16.6667%;\">7</td>\n<td style=\"width: 16.6667%;\">7</td>\n<td style=\"width: 16.6667%;\">8</td>\n<td style=\"width: 16.6667%;\">8</td>\n<td style=\"width: 16.6667%;\">10</td>\n</tr>\n</tbody>\n</table>\n<pre class=\"language-java\"><code>    /**\n     * 二分查找法\n     * 时间复杂度为O（logN）\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static int search2(int[] nums, int target){\n        int low = 0;\n        int high = nums.length-1;\n        int left,right;\n        left = right = 0;\n        //一次二分\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]&lt;=target){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        right = low;\n\n        low = 0;\n        high = nums.length -1;\n        //二次二分\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]&lt;target){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        left = high;\n        return right -left -1;\n    }</code></pre>","blogGoods":0,"blogId":"1254055163115724800","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kSXiAYRyFAAAaZr2Bc1U379.jpg","blogRead":0,"blogRemark":"剑指offer----在排序数组中查找数字I----LeetCode34","blogTitle":"剑指offer----在排序数组中查找数字I----LeetCode34","createdTime":"2020-04-25 22:30:24","typeName":"LeetCode","updateTime":"2020-04-25 22:30:24"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，两个链表的第一个公共节点</strong></h2>\n<p><strong><img src=\"https://images-cdn.shimo.im/Wd1NC8pveQYp9iIL.png__thumbnail\" alt=\"示例图\" width=\"742\" height=\"241\" /></strong></p>\n<p><strong>这是我从官方截下的一张图，也是有些人疑惑的地方，因为官方这张图给出的公共节点为8，而大多数人看到这张图，认为公共节点应该是1.</strong></p>\n<p><strong>但是实际上这里的公共节点不仅要节点的value相等，同时还需要节点的地址相等。从图中可以看出两个1节点虽然值相等，但是地址却不同，因而不是公共节点</strong></p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解法一：双指针</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：初始化两个指针p1=headA,p2=headB</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;分别遍历两个链表，求出两个链表的长度l1,l2</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;然后重置p1,p2指针指向头节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;让长链表的指针先走多的步数（l1-l2或者l2-l1）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;然后让两个指针同时走，直到两者相遇，即找到公共节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解疑：弄清楚第一个value相等的节点和指针相遇的节点，这两种节点是不同的，指针相遇的节点，不仅包含value相等，同时地址也相等。（如图中的8）；而第一个value相等的节点则可能并不在同一个地址，因此不一定是公共节点</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法\n     * @param headA\n     * @param headB\n     * @return\n     */\n    public static ListNode getIntersectionNode2(ListNode headA, ListNode headB){\n        ListNode p1 =headA;\n        ListNode p2 = headB;\n        int l1 = 0;\n        int l2 = 0;\n        //计算链表1的长度\n        while(p1!=null){\n            l1++;\n            p1 = p1.next;\n        }\n        //计算链表2的长度\n        while(p2!=null){\n            l2++;\n            p2 = p2.next;\n        }\n        p1 = headA;\n        p2 = headB;\n        //让长链表指针先走长的步数\n        if(l1&gt;l2){\n            for (int i = 0; i &lt; l1-l2; i++) {\n                p1 = p1.next;\n            }\n        }else{\n            for (int i = 0; i &lt; l2-l1; i++) {\n                p2 = p2.next;\n            }\n        }\n        //然后让两个指针同时走，直到相遇\n        while(p1!=p2){\n            p1 = p1.next;\n            p2 = p2.next;\n        }\n        return p1;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;解法二（大神解法）：丘比特相遇法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;利用两个指针p1=headA,p2=headB,让两个指针同时走，</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果p1先走到底，就将p1置为headB，</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果p2,先走到底，就将p2置为headA,</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;当两个指针相遇的时候，他们就相爱了（当然是找到公共节点了）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法p1=headA,p2=headB\n     * 思想是：两个节点同时从各自的链表出发\n     * p1走到末尾时，回到headB的头部\n     * p2走到末尾时，回到headA的头部\n     * 两个指针相遇的时候，即使要找的公共节点\n     * @param headA\n     * @param headB\n     * @return\n     */\n    public static ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode p1 = headA;\n        ListNode p2 = headB;\n        while(p1!=p2){\n            p1 = (p1==null)?headB:p1.next;\n            p2 = (p2==null)?headA:p2.next;\n        }\n        return p1;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1253992797703364608","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kD2OADD3mAAAaZr2Bc1U709.jpg","blogRead":0,"blogRemark":"剑指offer----之两个链表的第一个公共节点----LeetCode160","blogTitle":"剑指offer----之两个链表的第一个公共节点----LeetCode160","createdTime":"2020-04-25 18:22:35","typeName":"LeetCode","updateTime":"2020-04-25 18:22:35"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，第一个只出现一次的字符</strong></h2>\n<p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。</p>\n<p>示例:</p>\n<p>s = \"abaccdeff\"<br />返回 \"b\"</p>\n<p>s = \"\" <br />返回 \" \"</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主现在发现，做一道算法题的时候，最重要的一步就是读题，审题，在草稿纸上写下自己的思路（当然那种望眼欲穿的大佬除外）。然后才开始动笔，对于IT人来说，真的，多将时间花费在思考上面，而不是无意义的重复搬砖。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;题目分析：看到这道题，抓住两个关键字：第一个，只出现一次。什么意思呢，例如\"abaccdeff\"，其中只出现一次的字符有'b','d','e'三个，然后在三个字符中第一个出现在字符串中的是'b'，因此本题的答案是'b'.</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法分析：根据题目分析，我们最直观的解法应该是，先找出字符串中只出现一次的字符，然后再找出只出现一次字符中，第一个在字符串中出现的。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;所以我们需要做两件事，一是统计字符串中各个字符的出现次数，并且记录；二，统计完毕后，找出第一个出现次数为1的字符，返回即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;因此我们既要存字符，还要存字符对应的出现次数，所以理所当然我们选择map集合。当然对于本题而言，因为求第一个出现一次的字符，所以我们更好的是可以使用LinkedHashMap。这样免去最后的一次遍历字符串</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;下面提供两种解法：三种解法都是使用map集合，但是略有不同</strong></p>\n<p><strong>LinkedHashMap：（这是博主写的，代码冗余，这里用来和大神的写法做比较，警醒自己）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 用LinkedHashMap\n     * 思想：遍历字符串，如果map为空或者map中不含当前字符，则将其存入map\n     * 如果map中已经含有当前字符，则从map中移除\n     * 最终map中只剩出现一次的字符\n     * 返货map中的第一个即可\n     * @param s\n     * @return\n     */\n    public static char firstUniqChar(String s) {\n        Map&lt;Character,Integer&gt;map = new LinkedHashMap&lt;&gt;();\n        for (int i = 0; i &lt; s.length(); i++) {\n            char ch = s.charAt(i);\n            if(map.isEmpty()||!map.containsKey(ch)){\n                map.put(ch,1);\n            }else{\n                Integer val = map.get(ch);\n                map.put(ch,++val);\n            }\n        }\n        //返回map中第一个元素即可\n        Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entries = map.entrySet();\n        for (Map.Entry&lt;Character, Integer&gt; entry : entries) {\n            if(entry.getValue()==1){\n                return entry.getKey();\n            }\n        }\n        return ' ';\n    }</code></pre>\n<p><strong>HashMap（大神解法）：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 哈希表法\n     * @param s\n     * @return\n     */\n    public char firstUniqChar2(String s) {\n        Map&lt;Character,Boolean&gt; map = new HashMap&lt;&gt;();\n        char[] chars = s.toCharArray();\n        for (char ch : chars) {\n            map.put(ch,!map.containsKey(ch));\n        }\n        for (char ch : chars) {\n            if(map.get(ch)){\n                return ch;\n            }\n        }\n        return ' ';\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;分析：首先，这里提供了两种解法，一种为LinkedHashMap，一种为HashMap，这两种解法的不同之处就在于最后获取值的时候，LinkedHashMap获取最终值是遍历LinkedHashMap的entrySet，但是HashMap获取最终值是遍历原字符串。因而当数据庞大的时候，显然使用LinkedHashMap性能更高。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;然后，再分析一下这两种解法不另外一个不同之处，没错！就是大神的解法中使用map存放key对应的value值是Boolean型！（<span style=\"background-color: #ffcc00;\">这个真的是神一般的存在</span>），既省去了计算次数的麻烦，同时最后取的时候也不需要判断次数。wc！同一种解法，为什么天差地别！</strong></p>","blogGoods":0,"blogId":"1253956468789600256","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6j7Y6ACrySAAAaZr2Bc1U825.jpg","blogRead":0,"blogRemark":"剑指offer----第一次只出现一次的字符","blogTitle":"剑指offer----第一次只出现一次的字符","createdTime":"2020-04-25 15:58:14","typeName":"LeetCode","updateTime":"2020-04-25 15:58:14"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，连续子数组的最大和</strong></h2>\n<p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>\n<p>要求时间复杂度为O(n)。</p>\n<p>示例1:</p>\n<p>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br />输出: 6<br />解释:&nbsp;连续子数组&nbsp;[4,-1,2,1] 的和最大，为&nbsp;6。</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;看到这道题，最简单的想法肯定是求出所有连续子数组的值，然后进行比较，找出最大的即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;但是随后会想到既然要找出所有的子数组，那么我们可以使用分治的思想，因为分治的分过程即可以得到所有子序列</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;随后，再深一步，既然可以分治的思想，分的过程即是递归的过程，而且子数组的最大值依赖与前一子数组，所以可以想到使用动态规划</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：设dp[i]为以nums[i]为结尾的最大子数组和，初始值dp[0] = nums[0]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;遍历数组，如果dp[i-1]&gt;=0。则说明前面的最大子数组对当前子数组有增益效果，所以dp[i] = dp[i-1]+nums[i]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果dp[i-1]&lt;0。说明前面的最大子数组对当前子数组有夫负效果，还不如nums[i]本身，所以dp[i]=nums[i]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主的这样的写法：时间复杂度为O（N），空间复杂度也为O（N），但是实际上不需要使用dp数组，使用nums原数组就行，所以可以减小空间复杂度为O（1）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 动态规划\n     * 算法思想：因为求的是连续子数组的最大和\n     * 所以我们可以设dp[i]为以nums[i]结尾的最大连续子数组\n     * 如果dp[i]&lt;=nums[i],dp[i]=nums[i]\n     * 如果dp[i]&gt;nums[i],则dp[i]=dp[i]+nums[i]\n     * @param nums\n     * @return\n     */\n    public static int maxSubArray(int[] nums) {\n        int[] dp  = new int[nums.length];\n        dp[0] = nums[0];\n        int res = nums[0];\n        for (int i = 1; i &lt; nums.length; i++) {\n            if(dp[i-1]&lt;0){\n                dp[i] = nums[i];\n            }else{\n                dp[i] = dp[i-1]+nums[i];\n            }\n            res = Math.max(res,dp[i]);\n        }\n        return res;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1253938714590175232","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6j3QSACLxRAAAaZr2Bc1U017.jpg","blogRead":0,"blogRemark":"剑指offer---连续子数组的最大和---LeetCode53","blogTitle":"剑指offer---连续子数组的最大和---LeetCode53","createdTime":"2020-04-25 14:47:41","typeName":"LeetCode","updateTime":"2020-04-25 14:47:41"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，最小的k个数</strong></h2>\n<p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>\n<p>示例 1：</p>\n<p>输入：arr = [3,2,1], k = 2<br />输出：[1,2] 或者 [2,1]<br />示例 2：</p>\n<p>输入：arr = [0,1,2,1], k = 1<br />输出：[0]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;1,可以采用快排的思想，将原数组按照升序排序，然后取出前k个数即可，时间复杂度为O（NlogN）。但是其实跟API中的sort方法好像差别不大</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 对原数组升序排序，然后取前k个元素\n     * @param arr\n     * @param k\n     * @return\n     */\n    public static int[] getLeastNumbers(int[] arr, int k) {\n        quickSort(arr,0,arr.length-1);\n        int[] result = new int[k];\n        for (int i = 0; i &lt; k; i++) {\n            result[i] = arr[i];\n        }\n        return result;\n    }\n\n    /**\n     * 快排\n     * @param nums\n     * @param low\n     * @param high\n     */\n    public static void quickSort(int[] nums,int low,int high){\n        int base = nums[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //先从右向左找到第一个小于基准元素的元素\n            while(L&lt;R&amp;&amp;nums[R]&gt;=base){\n                R--;\n            }\n            if(nums[R]&lt;base){\n                swap(nums,L,R);\n            }\n            //再从左向右找到第一个大于基准元素的元素\n            while(L&lt;R&amp;&amp;nums[L]&lt;=base){\n                L++;\n            }\n            if(nums[L]&gt;base){\n                swap(nums,L,R);\n            }\n        }\n        //左递归\n        if(L&gt;low){\n            quickSort(nums,low,L-1);\n        }\n        //右递归\n        if(high&gt;R){\n            quickSort(nums,R+1,high);\n        }\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>2，堆排序：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;先讲解一下堆排序：堆排序是一种完全二叉树的结构，常见的存在两种堆结构，小根堆（即满足arr[2i+1]&gt;=arr[i]&amp;&amp;arr[2i+2]&gt;=arr[i]），大根堆（即满足arr[2i+1]&lt;=arr[i]&amp;&amp;arr[2i+2]&lt;=arr[i]）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;基本算法思想：第一步，初始化堆，即堆初始化为大根堆或者小根堆（这里我们简称调整堆）；第二步，将堆顶元素与堆的末尾元素进行交换，然后重新调整堆。在java中堆通常用来实现优先级队列PriorityQueue(默认的采用小根堆，若想使用大根堆，需要在创建时实现comparator)</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;使用情况：这里以java中的优先级队列为例，堆的使用情况不能按照堆名断章取义，例如小根堆实际上是将元素升序存放，因为在算法第二步中将堆顶元素与末尾元素进行交换，然后重新调整，交换的堆顶元素为最小元素，也是最先从堆中进入队列的。所以小根堆适用于TOPk大的算法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;相反的，大根堆适用于TOPk小的算法，下面分别给出小根堆和大根堆的算法：</strong></p>\n<p><strong>小根堆：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 堆排序---小根堆\n     * @param nums\n     */\n    public static void HeapSort(int[] nums){\n        //先初始化堆\n        for (int i = nums.length/2-1; i &gt;=0 ; i--) {\n            adjustHeap(nums,i,nums.length);\n        }\n        //交换堆顶与末尾节点+重新调整为小根堆\n        for (int i = nums.length-1; i &gt;0; i--) {\n            //先交换\n            swap(nums,0,i);\n            //再调整\n            adjustHeap(nums,0,i);\n        }\n    }\n\n    /**\n     * 调整为小根堆\n     * @param nums\n     * @param i\n     * @param length\n     */\n    public static void adjustHeap(int[] nums,int i,int length){\n        int temp = nums[i];\n        for (int j = 2*i+1; j &lt; length; j=2*j+1) {\n            //找出左右节点中的最小值\n            if(j+1&lt;length&amp;&amp;nums[j]&gt;nums[j+1]){\n                j++;\n            }\n            if(nums[j]&lt;temp){\n                nums[i] = nums[j];\n                i = j;\n            }\n        }\n        nums[i] = temp;\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p><strong>大根堆：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 堆排序---大根堆\n     * @param nums\n     */\n    public static void heapSort(int[] nums){\n\n        //初始化堆的过程\n        for (int i = nums.length/2-1; i &gt;=0; i--) {\n            adjustHeap(nums,i,nums.length);\n        }\n        //调整+交换堆顶和末尾的元素\n        for (int i = nums.length-1; i &gt;0; i--) {\n            //先交换，再重新调整\n            swap(nums,0,i);\n            adjustHeap(nums,0,i);\n        }\n    }\n\n    /**\n     * 调整大顶堆的过程\n     * @param nums\n     * @param i\n     * @param length\n     */\n    public static void adjustHeap(int[] nums,int i,int length){\n        int temp = nums[i];\n        for (int j = 2*i+1; j &lt; length; j=2*j+1) {\n            //找出左右节点中的最大值\n            if(j+1&lt;length&amp;&amp;nums[j]&lt;nums[j+1]){\n                j++;\n            }\n            if(nums[j]&gt;temp){\n                nums[i] = nums[j];\n                i = j;\n            }\n        }\n        nums[i] = temp;\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>本题利用大根堆解法，且使用java中自带的优先级队列PriorityQueue：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用堆数据结构，java中的优先级队列对应着最小堆\n     * 实现其comparator即可\n     * @param arr\n     * @param k\n     * @return\n     */\n    public static int[] getLeastNumbers2(int[] arr, int k){\n        Queue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(k,(v1,v2)-&gt;v2-v1);\n        for (int i : arr) {\n            if(heap.isEmpty()||heap.size()&lt;k||i&lt;heap.peek()){\n                heap.offer(i);\n            }\n            if(heap.size()&gt;k){\n                heap.poll();\n            }\n        }\n        int[] result = new int[k];\n        int j = 0;\n        for (Integer val : heap) {\n            result[j++] = val;\n        }\n        return result;\n    }</code></pre>","blogGoods":0,"blogId":"1253874832811089920","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6joYWAF3oqAAAaZr2Bc1U671.jpg","blogRead":2,"blogRemark":"剑指offer----之最小的k个数","blogTitle":"剑指offer----之最小的k个数","createdTime":"2020-04-25 10:33:50","typeName":"LeetCode","updateTime":"2020-04-25 11:53:15"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，数组中出现次数超过一半的元素---即众数</strong></h2>\n<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>\n<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>\n<p>示例&nbsp;1:</p>\n<p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br />输出: 2</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>方法有三：哈希表统计法，数组排序法，摩尔投票法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;哈希统计法：时间复杂度O（N），空间复杂度O（N）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 博主刚开始看到这道题的时候，首先想到的是哈希表统计法，因为博主想的是要找到众数，那么肯定得统计每个数字的出现次数，然后按照次数比较。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 单单是想到这些，用了map集合之后发现还是不行，因为即便用map集合统计出了每个数字和其对应的出现次数之后，你会发现没有办法按照出现的次数进行比较并且得到次数最多的数字（众数</strong><strong>）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 然后，就又审了一遍题目，结果发现了一个本题很关键的点，（<span style=\"background-color: #ffcc00;\">数组中有一个数字出现的次数超过数组长度的一半</span>），也就是说数组中有且仅有一个数字的出现次数会超过数组长度的一半（别笑博主笨，我是真的刚开始没反应过来）</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 那么我为什么要把数组中的所有元素和其次数全部存放进入map集合，然后再取次数进行比较呢？我为什么不在将元素和其次数存入集合的过程中判断次数是否已经超过数组长度的一半了呢？如果超过一半了，那它肯定是众数了呀！</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 思路：根据题意需要找出两个东西，一是多素元素，二是多素元素的出现次数\n     * 所以我们首先想到的是采用map集合\n     * 然后遍历数组，如果元素不存在与集合中，我们就将其加入map，value置为1\n     * 如果元素存在于map中，则我们取出其value将其加1与数组长度的一半做比较\n     * 如果大于数组长度一半，直接返回该元素即可\n     * 小于数组长度一半，则将其value加1存入map覆盖原有的值即可\n     *\n     * @param nums\n     * @return\n     */\n    public static int majorityElement(int[] nums) {\n        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(nums.length);\n        for (int num : nums) {\n            if(!map.containsKey(num)){\n                map.put(num,1);\n            }else{\n                Integer val = map.get(num);\n                if(++val&gt;nums.length/2){\n                    return num;\n                }else{\n                    map.put(num,val);\n                }\n            }\n        }\n        throw new RuntimeException(\"\");\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>数组排序法：由题可知，数组众必然存在一个多数元素，且出现次数超过数组长度的一半。所以我们可以对原数组进行排序，然后取数组中间的元素即可。（我擦，我当时看到这个，就在想，好简单，这个思路，但是我为什么没想到，对，因为我没有仔细的分析题目，超过一半看见没）。既然进行排序，那么我们可以选择快排，这样时间复杂度就是O（NlogN），空间复杂度O（1）.</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 数组排序法，因为多数元素的出现次数超过数组长度一半，\n     * 所以我们可以先对其进行排序，采用快排，时间复杂度O（NlogN）\n     * 然后取数组中点元素即可\n     * @param nums\n     * @return\n     */\n    public static int majorityElement2(int[] nums){\n        quickSort(nums,0,nums.length-1);\n        return nums[nums.length/2];\n    }\n\n    /**\n     * 快排\n     * @param nums\n     * @param low\n     * @param high\n     */\n    public static void quickSort(int[] nums,int low,int high){\n        int base = nums[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //从右向左找到第一个比基准元素小的元素\n            while(L&lt;R&amp;&amp;nums[R]&gt;=base){\n                R--;\n            }\n            if(nums[R]&lt;base){\n                swap(nums,L,R);\n            }\n            //从左向右找到第一个比基准元素大的元素\n            while(L&lt;R&amp;&amp;nums[L]&lt;=base){\n                L++;\n            }\n            if(nums[L]&gt;base){\n                swap(nums,L,R);\n            }\n        }\n        //左递归\n        if(L&gt;low){\n            quickSort(nums,low,L-1);\n        }\n        //右递归\n        if(high&gt;R){\n            quickSort(nums,R+1,high);\n        }\n    }\n\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>摩尔投票法（我将其称为大佬解法）：大概的意思就是采用正负抵消的方法，设置一个投票变量votes，初始设置为0；设置一个本题中的众数变量x，初始设置为数组首元素。然后遍历数组，判断跟设置的众数变量是否相等，如果相等将votes加一，如果不相等，则重置votes为0，且将x设置为数组下一个元素。本题众因为已经声明了肯定存在众数，所以不需要进行验证，但是如果没有声明的话，需要验证，下列代码众添加了验证：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 摩尔投票法\n     * @param nums\n     */\n    public static int majorityElement3(int[] nums){\n        int votes = 0;\n        int x = nums[0];\n        int count = 0;\n        for (int num : nums) {\n            if(votes==0){\n                x = num;\n            }\n            votes+=(num==x)?1:-1;\n        }\n        //验证数组众是否存在众数\n        for (int num : nums) {\n            if(num==x){\n                count++;\n            }\n        }\n        return count&gt;nums.length/2?x:0;\n    }</code></pre>","blogGoods":0,"blogId":"1253674617332162560","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6i5v-AUh39AAAaZr2Bc1U885.jpg","blogRead":0,"blogRemark":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","blogTitle":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","createdTime":"2020-04-24 21:18:14","typeName":"LeetCode","updateTime":"2020-04-24 21:18:14"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，从上到下打印二叉树-2</strong></h2>\n<p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>\n<p>例如:<br />给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>\n<p>3<br />/ \\<br />9 20<br />/ \\<br />15 7<br />返回其层次遍历结果：</p>\n<p>[<br />[3],<br />[9,20],<br />[15,7]<br />]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;BFS（广度优先搜索）：层次遍历</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * BFS\n     * @param root\n     * @return\n     */\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {\n        if (root == null) {\n            return new ArrayList&lt;&gt;(0);\n        }\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();\n        TreeNode current;\n        while (!queue.isEmpty()) {\n            List&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();\n            for (int i = queue.size(); i &gt; 0; i--) {\n                current = queue.poll();\n                arrayList.add(current.val);\n                if (current.left != null) {\n                    queue.add(current.left);\n                }\n                if (current.right != null) {\n                    queue.add(current.right);\n                }\n            }\n            list.add(arrayList);\n        }\n        return list;\n    }</code></pre>","blogGoods":0,"blogId":"1253350612905598976","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6huUyATZJ_AAAaZr2Bc1U363.jpg","blogRead":1,"blogRemark":"剑指offer----之从上到下打印二叉树----LeetCode102","blogTitle":"剑指offer----之从上到下打印二叉树----LeetCode102","createdTime":"2020-04-23 23:50:45","typeName":"LeetCode","updateTime":"2020-04-23 23:50:57"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，从上打印二叉树-1</strong></h2>\n<p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>\n<p>例如:<br />给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>\n<p>3<br />/ \\<br />9 20<br />/ \\<br />15 7<br />返回：</p>\n<p>[3,9,20,15,7]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;BFS（广度优先搜索）：也即是二叉树的层次遍历，代码和注意事项看代码注释</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 二叉树的层次遍历\n     * 这里是将层次遍历的结果存储在数组中\n     * 但是因为二叉树的节点个数并不知道\n     * 所以不能使用数组直接进行存储，因为无法初始化数组的大小\n     * 所以可以想到使用容量能自动扩充的list集合\n     * 然后再根据list集合的size来初始化数组的大小\n     * 并且将list元素赋值到数组中\n     * @param root\n     * @return\n     */\n    public static int[] levelOrder(TreeNode root) {\n        if(root==null){\n            return new int[0];\n        }\n        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n        TreeNode current;\n        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n        while(!queue.isEmpty()){\n            current = queue.poll();\n            list.add(current.val);\n            if(current.left!=null){\n                queue.add(current.left);\n            }\n            if(current.right!=null){\n                queue.add(current.right);\n            }\n        }\n        int[] result = new int[list.size()];\n        for (int i = 0; i &lt; list.size(); i++) {\n            result[i] = list.get(i);\n        }\n        return result;\n    }</code></pre>","blogGoods":0,"blogId":"1253346228108894208","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6htTeAUHGlAAAaZr2Bc1U102.jpg","blogRead":0,"blogRemark":"剑指offer----之从上到下打印二叉树","blogTitle":"剑指offer----之从上到下打印二叉树","createdTime":"2020-04-23 23:33:20","typeName":"LeetCode","updateTime":"2020-04-23 23:33:20"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，包含min函数的栈</strong></h2>\n<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>\n<p>&nbsp;</p>\n<p>示例:</p>\n<p>MinStack minStack = new MinStack();<br />minStack.push(-2);<br />minStack.push(0);<br />minStack.push(-3);<br />minStack.min(); --&gt; 返回 -3.<br />minStack.pop();<br />minStack.top(); --&gt; 返回 0.<br />minStack.min(); --&gt; 返回 -2.</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>&nbsp;辅助栈法：即初始化两个栈A,B</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;A栈用于实现基本的push(),pop(),top()的正常逻辑</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;B栈用来存放A栈中的非严格降序元素（这个我也理解不了，看代码就知道是存放什么的啦），代码中的方法注释很清楚</strong></p>\n<pre class=\"language-java\"><code>public class MinStack {\n    /** initialize your data structure here. */\n    Stack&lt;Integer&gt; A,B;\n\n    public MinStack() {\n        A = new Stack&lt;&gt;();\n        B = new Stack&lt;&gt;();\n    }\n\n    /**\n     * 入栈操作，元素先入A栈\n     * 如果B栈为空或者B栈的栈顶元素大于待入栈元素，则B栈也执行入栈操作\n     * @param x\n     */\n    public void push(int x) {\n        A.add(x);\n        if(B.isEmpty()||B.peek()&gt;=x){\n            B.add(x);\n        }\n    }\n\n    /**\n     * 这段代码优点巧妙\n     * 注意这里使用的A.pop()而不是A.peek()\n     * 所以这里实际上是分为两种情况的\n     * 第一种：当A的栈顶元素不为当前栈中的最小元素，即不等于栈B的栈顶元素\n     *         则只进行栈A的出栈操作，即A.pop()\n     * 第二种：当A的栈顶元素为当前栈中的最小元素，即等于栈B的栈顶元素\n     *        则不仅要A.pop(),而且为了保证A,B栈中最小元素的同步性\n     *        B栈也要执行出栈操作\n     */\n    public void pop() {\n        if(A.pop().equals(B.peek())){\n            B.pop();\n        }\n    }\n\n    /**\n     * 正常获取A的栈顶元素\n     * @return\n     */\n    public int top() {\n        return A.peek();\n    }\n\n    /**\n     * 获取A栈的最小元素，即B栈的栈顶元素\n     * @return\n     */\n    public int min() {\n        return B.peek();\n    }\n}</code></pre>","blogGoods":0,"blogId":"1253331349566234624","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hp12AMy2MAAAaZr2Bc1U568.jpg","blogRead":4,"blogRemark":"剑指offer----之包含min函数的栈---LeetCode155","blogTitle":"剑指offer----之包含min函数的栈---LeetCode155","createdTime":"2020-04-23 22:34:13","typeName":"LeetCode","updateTime":"2020-04-23 23:50:51"},{"blogCollection":0,"blogComment":0,"blogContent":"<h3><strong>晚上九点多，坐在床上，面前摆放着电脑，屏幕显示的是LeetCode中的《剑指offer》的题解</strong></h3>\n<h3><strong>此时的我毫无睡意，当然，这并不是因为解出一道题的喜悦冲淡了我的睡意</strong></h3>\n<h3><strong>相反的，这是一种难以言明的心情，包含着对自己无知的羞愧，也包含着别人面对如此无知的自己也能给出耐心回应的感动</strong></h3>\n<h3><strong>人有时或许就是这样，刻意的举动会让人心生防备，但是无意的善举却能温润人心</strong></h3>\n<h3><strong>别人无意的一个回答，一个小举动，一句肯定的话</strong></h3>\n<h3><strong>殊不知却能为对方赋予无穷无尽的能量</strong></h3>\n<h3><strong>将这一天的疲惫和劳累都消除</strong></h3>\n<h3><strong>赠人玫瑰，手有余香</strong></h3>\n<h3><strong>我一直抱着这样的一种心态，或许我无法做到赠人玫瑰，但是我会尽量将自己的善意展现给别人</strong></h3>\n<h3><strong>也许他刚刚好正处于某个难关，而你又刚刚好是他难关之初的引导者</strong></h3>\n<h3><strong>一句话，或许对于你来说只是人生中微不足道的几秒钟</strong></h3>\n<h3><strong>而对他来说，或许可能是多年之后回忆起来也能嘴角上扬的美好岁月</strong></h3>\n<h3><strong>想起前段时间一部剧里面的话，在这里也送给屏幕前的你：愿你永怀善意，清澈明朗</strong></h3>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1253326423486144512","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hosWANYd2AAHQzo49lBU641.jpg","blogRead":3,"blogRemark":"2020-4-23有感","blogTitle":"2020-4-23有感","createdTime":"2020-04-23 22:14:38","typeName":"随心日记","updateTime":"2020-04-25 21:22:30"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，顺时针打印矩阵</strong></h2>\n<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>\n<p>示例 1：</p>\n<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br />输出：[1,2,3,6,9,8,7,4,5]<br />示例 2：</p>\n<p>输入：matrix =&nbsp;[[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br />输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p>\n<p>限制：</p>\n<p>0 &lt;= matrix.length &lt;= 100<br />0 &lt;= matrix[i].length&nbsp;&lt;= 100</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;模拟顺时针打印的这种循环结构：设置四个边界条件，l,r,t,b。按照从左往右，从上往下，从右往左，从下网往上的顺序依次读取矩阵的元素，并且每一次都判断边界是否相遇，直到将整个矩阵元素都加入到数组中即可。</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 设置四个边界值，分别为left=0,right=matrix[0].length-1,top=0,bottom=matrix.length-1\n     * 顺时针顺序即先从左到右，再从上到下，再从右向左，再从下向上，每一次执行都要判断边界值\n     * @param matrix\n     * @return\n     */\n    public static int[] spiralOrder(int[][] matrix) {\n        if(matrix.length==0){\n            return new int[0];\n        }\n        int l = 0;\n        int r=matrix[0].length-1;\n        int t=0;\n        int b=matrix.length-1;\n        int x=0;\n        int[] res = new int[(r+1)*(b+1)];\n        while(true){\n            //从左向右\n            for(int i=l;i&lt;=r;i++){\n                res[x++]=matrix[t][i];\n            }\n            if(++t&gt;b) {\n                break;\n            }\n            //从上向下\n            for(int i=t;i&lt;=b;i++){\n                res[x++] = matrix[i][r];\n            }\n            if(--r&lt;l){\n                break;\n            }\n            //从右向左\n            for(int i=r;i&gt;=l;i--){\n                res[x++] = matrix[b][i];\n            }\n            if(--b&lt;t){\n                break;\n            }\n            //从下往上\n            for(int i=b;i&gt;=t;i--){\n                res[x++] = matrix[i][l];\n            }\n            if(++l&gt;r){\n                break;\n            }\n        }\n        return res;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1253250557729087488","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hXB2ASIQwAAAaZr2Bc1U016.jpg","blogRead":0,"blogRemark":"剑指offer-----之顺时针打印矩阵----LeetCode54","blogTitle":"剑指offer-----之顺时针打印矩阵----LeetCode54","createdTime":"2020-04-23 17:13:11","typeName":"LeetCode","updateTime":"2020-04-23 17:13:11"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，对称的二叉树</strong></h2>\n<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>\n<p>例如，二叉树&nbsp;[1,2,2,3,4,4,3] 是对称的。</p>\n<p>&nbsp; &nbsp; 1<br />&nbsp; &nbsp;/ \\<br />&nbsp; 2 &nbsp; 2<br />&nbsp;/ \\ / \\<br />3 &nbsp;4 4 &nbsp;3<br />但是下面这个&nbsp;[1,2,2,null,3,null,3] 则不是镜像对称的:</p>\n<p>&nbsp; &nbsp; 1<br />&nbsp; &nbsp;/ \\<br />&nbsp; 2 &nbsp; 2<br />&nbsp; &nbsp;\\ &nbsp; \\<br />&nbsp; &nbsp;3 &nbsp; &nbsp;3</p>\n<p>示例 1：</p>\n<p>输入：root = [1,2,2,3,4,4,3]<br />输出：true<br />示例 2：</p>\n<p>输入：root = [1,2,2,null,3,null,3]<br />输出：false</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>递归法：从对称的二叉树中我们可以找到如下规律</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果一个二叉树是对称的，则每一个节点的左右子树也是对称的,因此是递归的</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 设L = root.left，R=root.right，则满足L.left.val = R.right.val;L.right.val=R.left.val;</strong></p>\n<pre class=\"language-java\"><code>public boolean isSymmetric(TreeNode root) {\n        return  root==null?true:recur(root.left,root.right);\n    }\n    public boolean recur(TreeNode L,TreeNode R){\n        if(L==null&amp;&amp;R==null){\n            return true;\n        }\n        if(L==null||R==null||L.val!=R.val){\n            return false;\n        }\n        return recur(L.left,R.right)&amp;&amp;recur(L.right,R.left);\n    }</code></pre>","blogGoods":0,"blogId":"1252992659794968576","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6ga--AKQdvAAAaZr2Bc1U862.jpg","blogRead":1,"blogRemark":"剑指offer----之对称的二叉树----LeetCode101","blogTitle":"剑指offer----之对称的二叉树----LeetCode101","createdTime":"2020-04-23 00:08:23","typeName":"LeetCode","updateTime":"2020-04-23 00:12:33"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，二叉树镜像</strong></h2>\n<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>\n<p>例如输入：</p>\n<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; 2 &nbsp; &nbsp; 7<br />&nbsp;/ \\ &nbsp; / \\<br />1 &nbsp; 3 6 &nbsp; 9<br />镜像输出：</p>\n<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; 7 &nbsp; &nbsp; 2<br />&nbsp;/ \\ &nbsp; / \\<br />9 &nbsp; 6 3&nbsp; &nbsp;1</p>\n<p>示例 1：</p>\n<p>输入：root = [4,2,7,1,3,6,9]<br />输出：[4,7,2,9,6,3,1]</p>\n<p>限制：</p>\n<p>0 &lt;= 节点个数 &lt;= 1000</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;递归法：即递归的去交换根节点的左右子树，直到根节点为叶子节点</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用递归的方法，交换根节点的左子树和右子树\n     * 递归出口为，根节点为叶子节点\n     * @param root\n     * @return\n     */\n    public TreeNode mirrorTree(TreeNode root) {\n        TreeNode center = root;\n        if(center!=null){\n            TreeNode temp = center.left;\n            center.left = center.right;\n            center.right = temp;\n            mirrorTree(center.left);\n            mirrorTree(center.right);\n        }\n        return root;\n    }</code></pre>","blogGoods":0,"blogId":"1252985443281027072","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6gZTWABF55AAAaZr2Bc1U678.jpg","blogRead":0,"blogRemark":"剑指offer----之二叉树的镜像----LeetCode226","blogTitle":"剑指offer----之二叉树的镜像----LeetCode226","createdTime":"2020-04-22 23:39:43","typeName":"LeetCode","updateTime":"2020-04-22 23:39:43"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，合并两个有序链表</strong></h2>\n<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>\n<p>示例1：</p>\n<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br />输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br />限制：</p>\n<p>0 &lt;= 链表长度 &lt;= 1000</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>伪头节点法：即创建一个伪头节点head和一个用于辅助的节点cur</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法：如果l1.val&lt;=l2.val,就让cur指向l1，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l1指向其next</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果l1.val&gt;l2.val,就让cur指向l2，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l2指向其next</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;直到l1和l2有一个为空为止，让cur指向剩余的一个非空链表即可，若两个链表的长度为M,N则时间复杂度为O(M+N)</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用四节点，一个伪头节点，一个当前节点cur，已经链表的两个节点l1,l2\n     * 每次比较l1,l2节点的val大小，将小的节点连接到当前节点cur上即可\n     * 直到l1,l2有一个空，则将剩余的一个非空链表连接到cur尾部即可\n     * @param l1\n     * @param l2\n     * @return\n     */\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode head;\n        ListNode cur;\n        head = cur = new ListNode(0);\n        while(l1!=null&amp;&amp;l2!=null){\n            if(l1.val&lt;=l2.val){\n                cur.next = l1;\n                cur = cur.next;\n                l1 = l1.next;\n            }else{\n                cur.next = l2;\n                cur = cur.next;\n                l2 = l2.next;\n            }\n        }\n        if(l1!=null){\n            cur.next = l1;\n        }\n        if(l2!=null){\n            cur.next = l2;\n        }\n        return head.next;\n    }</code></pre>","blogGoods":0,"blogId":"1252980258446000128","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6gYGWAe-MZAAAaZr2Bc1U550.jpg","blogRead":0,"blogRemark":"剑指offer----之合并有序链表---LeetCode21","blogTitle":"剑指offer----之合并有序链表---LeetCode21","createdTime":"2020-04-22 23:19:06","typeName":"LeetCode","updateTime":"2020-04-22 23:19:06"}],"pageSize":15,"params":{},"sortColumn":"created_time","sortMethod":"DESC","totalCount":53,"totalPage":4},"msg":"操作成功!"}
2020-04-26 23:35:36.793 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /user/getCommentAndCollection
2020-04-26 23:35:36.793 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:35:36.794 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:35:36.794 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.UserController.getCommentAndCollection
2020-04-26 23:35:36.794 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:35:39.041 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /user/getCollection
2020-04-26 23:35:39.042 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:35:39.042 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:35:39.042 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.UserController.getCollection
2020-04-26 23:35:39.042 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=ASC)]
2020-04-26 23:35:39.190 INFO  [http-nio-1000-exec-6]org.mongodb.driver.connection.info:71 -Opened connection [connectionId{localValue:3, serverValue:622}] to 121.199.34.159:27017
2020-04-26 23:35:39.231 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 190
2020-04-26 23:35:39.232 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[],"pageSize":10,"params":{},"sortMethod":"ASC","totalCount":0,"totalPage":0},"msg":"操作成功!"}
2020-04-26 23:35:40.589 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /user/getComment
2020-04-26 23:35:40.590 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:35:40.591 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:35:40.591 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.UserController.getComment
2020-04-26 23:35:40.591 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=ASC)]
2020-04-26 23:35:40.637 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 48
2020-04-26 23:35:40.638 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[],"pageSize":10,"params":{},"sortMethod":"ASC","totalCount":0,"totalPage":0},"msg":"操作成功!"}
2020-04-26 23:35:43.286 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /user/getCommentAndCollection
2020-04-26 23:35:43.287 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:35:43.287 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:35:43.287 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.UserController.getCommentAndCollection
2020-04-26 23:35:43.287 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:35:43.406 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 120
2020-04-26 23:35:43.407 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"comment":0,"collection":0},"msg":"操作成功!"}
2020-04-26 23:35:44.050 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /user/getCollection
2020-04-26 23:35:44.050 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:35:44.050 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:35:44.051 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.UserController.getCollection
2020-04-26 23:35:44.051 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=ASC)]
2020-04-26 23:35:44.091 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 41
2020-04-26 23:35:44.092 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[],"pageSize":10,"params":{},"sortMethod":"ASC","totalCount":0,"totalPage":0},"msg":"操作成功!"}
2020-04-26 23:35:45.738 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /user/getCommentAndCollection
2020-04-26 23:35:45.738 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:35:45.738 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:35:45.739 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.UserController.getCommentAndCollection
2020-04-26 23:35:45.739 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:35:45.823 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 85
2020-04-26 23:35:45.823 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"comment":0,"collection":0},"msg":"操作成功!"}
2020-04-26 23:35:48.473 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /user/getCollection
2020-04-26 23:35:48.473 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:35:48.474 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:35:48.474 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.UserController.getCollection
2020-04-26 23:35:48.474 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=10, totalPage=0, totalCount=0, list=[], params={}, sortColumn=null, sortMethod=ASC)]
2020-04-26 23:35:48.516 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 43
2020-04-26 23:35:48.517 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[],"pageSize":10,"params":{},"sortMethod":"ASC","totalCount":0,"totalPage":0},"msg":"操作成功!"}
2020-04-26 23:35:50.066 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /user/getCommentAndCollection
2020-04-26 23:35:50.067 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:35:50.067 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:35:50.068 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.UserController.getCommentAndCollection
2020-04-26 23:35:50.068 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:35:50.156 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 90
2020-04-26 23:35:50.157 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"comment":0,"collection":0},"msg":"操作成功!"}
2020-04-26 23:35:55.982 INFO  [http-nio-1000-exec-9]org.mongodb.driver.connection.info:71 -Closed connection [connectionId{localValue:2, serverValue:621}] to 121.199.34.159:27017 because there was a socket exception raised by this connection.
2020-04-26 23:35:56.066 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 19273
2020-04-26 23:35:56.067 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"comment":0,"collection":0},"msg":"操作成功!"}
2020-04-26 23:36:00.201 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /rotation-picture/listFront
2020-04-26 23:36:00.202 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:36:00.202 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:36:00.202 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.RotationPictureController.getRotationPictureListFront
2020-04-26 23:36:00.202 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:36:00.217 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/list
2020-04-26 23:36:00.218 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:36:00.218 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:36:00.218 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogList
2020-04-26 23:36:00.219 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=15, totalPage=0, totalCount=0, list=[], params={}, sortColumn=created_time, sortMethod=DESC)]
2020-04-26 23:36:00.291 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 90
2020-04-26 23:36:00.292 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"createdTime":"2020-04-09 13:31:20","enable":1,"rotationId":4,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PI6aAZIz1AASCO4hlpJI295.jpg"},{"createdTime":"2020-04-09 13:37:02","enable":1,"rotationId":9,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJPyAbm8fAAG9gfO8lxE28.jpeg"},{"createdTime":"2020-04-09 13:41:30","enable":1,"rotationId":10,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJgeAeG8wAAS2pjJC5QU547.jpg"},{"createdTime":"2020-04-09 13:41:38","enable":1,"rotationId":11,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhGAQFZbAAP2OOBWb6k310.jpg"},{"createdTime":"2020-04-09 13:41:50","enable":1,"rotationId":12,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhyABMZCAAG7doyXiM8109.jpg"},{"createdTime":"2020-04-09 13:41:59","enable":1,"rotationId":13,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJiWAL7BoAARW3_O3ISw651.jpg"}],"msg":"操作成功!"}
2020-04-26 23:36:00.569 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 352
2020-04-26 23:36:00.570 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，0~n-1中缺失的数字</strong></h2>\n<p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>\n<p>示例 1:</p>\n<p>输入: [0,1,3]<br />输出: 2<br />示例&nbsp;2:</p>\n<p>输入: [0,1,2,3,4,5,6,7,9]<br />输出: 8</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主能想到的并且写出来的方法有：使用map存储数组中的所有元素，然后遍历0-n-1找出不在map中的元素。此种方法时间复杂度O（N），空间复杂度O（N）-----垃圾</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 统计0-n-1所有数字的数字和，再统计数组中所有数字的数字和，两和只差即为所求数字，时间复杂度O（N），空间复杂度O（1）-----垃圾</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;最优解法（二分查找法）：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;通常来说，我们使用二分查找法是查找一个存在于数组中的元素，但是本题需要求不在数组中的一个元素，因此到这很多人就会迷惑，不知道该怎么求了。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;但是我们首先要搞明白二分查找法的本质是什么：1，并不局限于仅仅查找存在于数组中的元素；2，二分查找的本质是对数组根据mid中间值在某一条件上进行二分（例如：通常的num[mid]&gt;target或者nums[mid]&lt;target进行左右切分）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;因此明白这一点，就好解决问题了。拿到这道题，使用二分，我们首先想到的应该是寻找根据mid中间值进行二分的条件</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;审题：题目中提及数组为递增数组，而且0-n-1内的n个数字有一个不在数组中，则不在的这个数字之前的数字满足nums[i]=i即元素本身等于数组下标，而之后的数字nums[i]!=i,所以这就是进行二分的条件了</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 二分查找法\n     * 算法思想：二分查找法的本质是能够有一个条件将数组根据mid中间值进行左右切分\n     * 所以我们想到二分查找法之后，首先需要做的是找出切分数组的条件\n     * 题目中给出了数组是一个递增数组，且0-n-1内的n个数字有一个不在这个长度为n-1的数组内\n     * 因此，不在的这个元素其左边元素必有数组下标值等于元素本身即nums[i]=i\n     * 而不在的这个元素的右边必有nums[i]!=i\n     * 所以根据此条件进行划分数组即可\n     * @param nums\n     * @return\n     */\n    public static int missingNumber(int[] nums) {\n        int low = 0;\n        int high = nums.length-1;\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]==mid){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        return low;\n    }</code></pre>","blogGoods":0,"blogId":"1254063045920022528","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kUM-AON88AAAaZr2Bc1U903.jpg","blogRead":0,"blogRemark":"剑指offer----0~n-1中缺失的数字","blogTitle":"剑指offer----0~n-1中缺失的数字","createdTime":"2020-04-25 23:01:44","typeName":"LeetCode","updateTime":"2020-04-25 23:01:44"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，在排序数组中查找数字I</strong></h2>\n<p>统计一个数字在排序数组中出现的次数。</p>\n<p>示例 1:</p>\n<p>输入: nums = [5,7,7,8,8,10], target = 8<br />输出: 2<br />示例&nbsp;2:</p>\n<p>输入: nums = [5,7,7,8,8,10], target = 6<br />输出: 0</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解法一：直接遍历统计，时间复杂度为O（N）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 遍历数组\n     * 找到第一个与目标元素相等的元素，res+1\n     * 然后往后找到第一个与目标元素不相等的元素,返回res即可\n     * 时间复杂度为O(N)\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static int search(int[] nums, int target) {\n        int res = 0;\n        for (int num : nums) {\n            if(num==target){\n                res++;\n            }\n        }\n        return res;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解法二：二分法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：利用二分法查找数字在排序数组中的左边界Left和右边界Right.如下，如果要寻找数组中的8，则其左边界为left=2,有边界right=5.所以出现次数为right-left-1.时间复杂度为O（logN）</strong></p>\n<table style=\"width: 20%; border-collapse: collapse; margin-left: auto; margin-right: auto;\" border=\"1\" cellpadding=\"5\">\n<tbody>\n<tr>\n<td style=\"width: 16.6667%;\">5</td>\n<td style=\"width: 16.6667%;\">7</td>\n<td style=\"width: 16.6667%;\">7</td>\n<td style=\"width: 16.6667%;\">8</td>\n<td style=\"width: 16.6667%;\">8</td>\n<td style=\"width: 16.6667%;\">10</td>\n</tr>\n</tbody>\n</table>\n<pre class=\"language-java\"><code>    /**\n     * 二分查找法\n     * 时间复杂度为O（logN）\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static int search2(int[] nums, int target){\n        int low = 0;\n        int high = nums.length-1;\n        int left,right;\n        left = right = 0;\n        //一次二分\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]&lt;=target){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        right = low;\n\n        low = 0;\n        high = nums.length -1;\n        //二次二分\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]&lt;target){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        left = high;\n        return right -left -1;\n    }</code></pre>","blogGoods":0,"blogId":"1254055163115724800","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kSXiAYRyFAAAaZr2Bc1U379.jpg","blogRead":0,"blogRemark":"剑指offer----在排序数组中查找数字I----LeetCode34","blogTitle":"剑指offer----在排序数组中查找数字I----LeetCode34","createdTime":"2020-04-25 22:30:24","typeName":"LeetCode","updateTime":"2020-04-25 22:30:24"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，两个链表的第一个公共节点</strong></h2>\n<p><strong><img src=\"https://images-cdn.shimo.im/Wd1NC8pveQYp9iIL.png__thumbnail\" alt=\"示例图\" width=\"742\" height=\"241\" /></strong></p>\n<p><strong>这是我从官方截下的一张图，也是有些人疑惑的地方，因为官方这张图给出的公共节点为8，而大多数人看到这张图，认为公共节点应该是1.</strong></p>\n<p><strong>但是实际上这里的公共节点不仅要节点的value相等，同时还需要节点的地址相等。从图中可以看出两个1节点虽然值相等，但是地址却不同，因而不是公共节点</strong></p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解法一：双指针</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：初始化两个指针p1=headA,p2=headB</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;分别遍历两个链表，求出两个链表的长度l1,l2</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;然后重置p1,p2指针指向头节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;让长链表的指针先走多的步数（l1-l2或者l2-l1）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;然后让两个指针同时走，直到两者相遇，即找到公共节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解疑：弄清楚第一个value相等的节点和指针相遇的节点，这两种节点是不同的，指针相遇的节点，不仅包含value相等，同时地址也相等。（如图中的8）；而第一个value相等的节点则可能并不在同一个地址，因此不一定是公共节点</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法\n     * @param headA\n     * @param headB\n     * @return\n     */\n    public static ListNode getIntersectionNode2(ListNode headA, ListNode headB){\n        ListNode p1 =headA;\n        ListNode p2 = headB;\n        int l1 = 0;\n        int l2 = 0;\n        //计算链表1的长度\n        while(p1!=null){\n            l1++;\n            p1 = p1.next;\n        }\n        //计算链表2的长度\n        while(p2!=null){\n            l2++;\n            p2 = p2.next;\n        }\n        p1 = headA;\n        p2 = headB;\n        //让长链表指针先走长的步数\n        if(l1&gt;l2){\n            for (int i = 0; i &lt; l1-l2; i++) {\n                p1 = p1.next;\n            }\n        }else{\n            for (int i = 0; i &lt; l2-l1; i++) {\n                p2 = p2.next;\n            }\n        }\n        //然后让两个指针同时走，直到相遇\n        while(p1!=p2){\n            p1 = p1.next;\n            p2 = p2.next;\n        }\n        return p1;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;解法二（大神解法）：丘比特相遇法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;利用两个指针p1=headA,p2=headB,让两个指针同时走，</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果p1先走到底，就将p1置为headB，</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果p2,先走到底，就将p2置为headA,</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;当两个指针相遇的时候，他们就相爱了（当然是找到公共节点了）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法p1=headA,p2=headB\n     * 思想是：两个节点同时从各自的链表出发\n     * p1走到末尾时，回到headB的头部\n     * p2走到末尾时，回到headA的头部\n     * 两个指针相遇的时候，即使要找的公共节点\n     * @param headA\n     * @param headB\n     * @return\n     */\n    public static ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode p1 = headA;\n        ListNode p2 = headB;\n        while(p1!=p2){\n            p1 = (p1==null)?headB:p1.next;\n            p2 = (p2==null)?headA:p2.next;\n        }\n        return p1;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1253992797703364608","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kD2OADD3mAAAaZr2Bc1U709.jpg","blogRead":0,"blogRemark":"剑指offer----之两个链表的第一个公共节点----LeetCode160","blogTitle":"剑指offer----之两个链表的第一个公共节点----LeetCode160","createdTime":"2020-04-25 18:22:35","typeName":"LeetCode","updateTime":"2020-04-25 18:22:35"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，第一个只出现一次的字符</strong></h2>\n<p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。</p>\n<p>示例:</p>\n<p>s = \"abaccdeff\"<br />返回 \"b\"</p>\n<p>s = \"\" <br />返回 \" \"</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主现在发现，做一道算法题的时候，最重要的一步就是读题，审题，在草稿纸上写下自己的思路（当然那种望眼欲穿的大佬除外）。然后才开始动笔，对于IT人来说，真的，多将时间花费在思考上面，而不是无意义的重复搬砖。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;题目分析：看到这道题，抓住两个关键字：第一个，只出现一次。什么意思呢，例如\"abaccdeff\"，其中只出现一次的字符有'b','d','e'三个，然后在三个字符中第一个出现在字符串中的是'b'，因此本题的答案是'b'.</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法分析：根据题目分析，我们最直观的解法应该是，先找出字符串中只出现一次的字符，然后再找出只出现一次字符中，第一个在字符串中出现的。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;所以我们需要做两件事，一是统计字符串中各个字符的出现次数，并且记录；二，统计完毕后，找出第一个出现次数为1的字符，返回即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;因此我们既要存字符，还要存字符对应的出现次数，所以理所当然我们选择map集合。当然对于本题而言，因为求第一个出现一次的字符，所以我们更好的是可以使用LinkedHashMap。这样免去最后的一次遍历字符串</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;下面提供两种解法：三种解法都是使用map集合，但是略有不同</strong></p>\n<p><strong>LinkedHashMap：（这是博主写的，代码冗余，这里用来和大神的写法做比较，警醒自己）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 用LinkedHashMap\n     * 思想：遍历字符串，如果map为空或者map中不含当前字符，则将其存入map\n     * 如果map中已经含有当前字符，则从map中移除\n     * 最终map中只剩出现一次的字符\n     * 返货map中的第一个即可\n     * @param s\n     * @return\n     */\n    public static char firstUniqChar(String s) {\n        Map&lt;Character,Integer&gt;map = new LinkedHashMap&lt;&gt;();\n        for (int i = 0; i &lt; s.length(); i++) {\n            char ch = s.charAt(i);\n            if(map.isEmpty()||!map.containsKey(ch)){\n                map.put(ch,1);\n            }else{\n                Integer val = map.get(ch);\n                map.put(ch,++val);\n            }\n        }\n        //返回map中第一个元素即可\n        Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entries = map.entrySet();\n        for (Map.Entry&lt;Character, Integer&gt; entry : entries) {\n            if(entry.getValue()==1){\n                return entry.getKey();\n            }\n        }\n        return ' ';\n    }</code></pre>\n<p><strong>HashMap（大神解法）：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 哈希表法\n     * @param s\n     * @return\n     */\n    public char firstUniqChar2(String s) {\n        Map&lt;Character,Boolean&gt; map = new HashMap&lt;&gt;();\n        char[] chars = s.toCharArray();\n        for (char ch : chars) {\n            map.put(ch,!map.containsKey(ch));\n        }\n        for (char ch : chars) {\n            if(map.get(ch)){\n                return ch;\n            }\n        }\n        return ' ';\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;分析：首先，这里提供了两种解法，一种为LinkedHashMap，一种为HashMap，这两种解法的不同之处就在于最后获取值的时候，LinkedHashMap获取最终值是遍历LinkedHashMap的entrySet，但是HashMap获取最终值是遍历原字符串。因而当数据庞大的时候，显然使用LinkedHashMap性能更高。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;然后，再分析一下这两种解法不另外一个不同之处，没错！就是大神的解法中使用map存放key对应的value值是Boolean型！（<span style=\"background-color: #ffcc00;\">这个真的是神一般的存在</span>），既省去了计算次数的麻烦，同时最后取的时候也不需要判断次数。wc！同一种解法，为什么天差地别！</strong></p>","blogGoods":0,"blogId":"1253956468789600256","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6j7Y6ACrySAAAaZr2Bc1U825.jpg","blogRead":0,"blogRemark":"剑指offer----第一次只出现一次的字符","blogTitle":"剑指offer----第一次只出现一次的字符","createdTime":"2020-04-25 15:58:14","typeName":"LeetCode","updateTime":"2020-04-25 15:58:14"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，连续子数组的最大和</strong></h2>\n<p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>\n<p>要求时间复杂度为O(n)。</p>\n<p>示例1:</p>\n<p>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br />输出: 6<br />解释:&nbsp;连续子数组&nbsp;[4,-1,2,1] 的和最大，为&nbsp;6。</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;看到这道题，最简单的想法肯定是求出所有连续子数组的值，然后进行比较，找出最大的即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;但是随后会想到既然要找出所有的子数组，那么我们可以使用分治的思想，因为分治的分过程即可以得到所有子序列</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;随后，再深一步，既然可以分治的思想，分的过程即是递归的过程，而且子数组的最大值依赖与前一子数组，所以可以想到使用动态规划</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：设dp[i]为以nums[i]为结尾的最大子数组和，初始值dp[0] = nums[0]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;遍历数组，如果dp[i-1]&gt;=0。则说明前面的最大子数组对当前子数组有增益效果，所以dp[i] = dp[i-1]+nums[i]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果dp[i-1]&lt;0。说明前面的最大子数组对当前子数组有夫负效果，还不如nums[i]本身，所以dp[i]=nums[i]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主的这样的写法：时间复杂度为O（N），空间复杂度也为O（N），但是实际上不需要使用dp数组，使用nums原数组就行，所以可以减小空间复杂度为O（1）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 动态规划\n     * 算法思想：因为求的是连续子数组的最大和\n     * 所以我们可以设dp[i]为以nums[i]结尾的最大连续子数组\n     * 如果dp[i]&lt;=nums[i],dp[i]=nums[i]\n     * 如果dp[i]&gt;nums[i],则dp[i]=dp[i]+nums[i]\n     * @param nums\n     * @return\n     */\n    public static int maxSubArray(int[] nums) {\n        int[] dp  = new int[nums.length];\n        dp[0] = nums[0];\n        int res = nums[0];\n        for (int i = 1; i &lt; nums.length; i++) {\n            if(dp[i-1]&lt;0){\n                dp[i] = nums[i];\n            }else{\n                dp[i] = dp[i-1]+nums[i];\n            }\n            res = Math.max(res,dp[i]);\n        }\n        return res;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1253938714590175232","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6j3QSACLxRAAAaZr2Bc1U017.jpg","blogRead":0,"blogRemark":"剑指offer---连续子数组的最大和---LeetCode53","blogTitle":"剑指offer---连续子数组的最大和---LeetCode53","createdTime":"2020-04-25 14:47:41","typeName":"LeetCode","updateTime":"2020-04-25 14:47:41"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，最小的k个数</strong></h2>\n<p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>\n<p>示例 1：</p>\n<p>输入：arr = [3,2,1], k = 2<br />输出：[1,2] 或者 [2,1]<br />示例 2：</p>\n<p>输入：arr = [0,1,2,1], k = 1<br />输出：[0]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;1,可以采用快排的思想，将原数组按照升序排序，然后取出前k个数即可，时间复杂度为O（NlogN）。但是其实跟API中的sort方法好像差别不大</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 对原数组升序排序，然后取前k个元素\n     * @param arr\n     * @param k\n     * @return\n     */\n    public static int[] getLeastNumbers(int[] arr, int k) {\n        quickSort(arr,0,arr.length-1);\n        int[] result = new int[k];\n        for (int i = 0; i &lt; k; i++) {\n            result[i] = arr[i];\n        }\n        return result;\n    }\n\n    /**\n     * 快排\n     * @param nums\n     * @param low\n     * @param high\n     */\n    public static void quickSort(int[] nums,int low,int high){\n        int base = nums[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //先从右向左找到第一个小于基准元素的元素\n            while(L&lt;R&amp;&amp;nums[R]&gt;=base){\n                R--;\n            }\n            if(nums[R]&lt;base){\n                swap(nums,L,R);\n            }\n            //再从左向右找到第一个大于基准元素的元素\n            while(L&lt;R&amp;&amp;nums[L]&lt;=base){\n                L++;\n            }\n            if(nums[L]&gt;base){\n                swap(nums,L,R);\n            }\n        }\n        //左递归\n        if(L&gt;low){\n            quickSort(nums,low,L-1);\n        }\n        //右递归\n        if(high&gt;R){\n            quickSort(nums,R+1,high);\n        }\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>2，堆排序：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;先讲解一下堆排序：堆排序是一种完全二叉树的结构，常见的存在两种堆结构，小根堆（即满足arr[2i+1]&gt;=arr[i]&amp;&amp;arr[2i+2]&gt;=arr[i]），大根堆（即满足arr[2i+1]&lt;=arr[i]&amp;&amp;arr[2i+2]&lt;=arr[i]）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;基本算法思想：第一步，初始化堆，即堆初始化为大根堆或者小根堆（这里我们简称调整堆）；第二步，将堆顶元素与堆的末尾元素进行交换，然后重新调整堆。在java中堆通常用来实现优先级队列PriorityQueue(默认的采用小根堆，若想使用大根堆，需要在创建时实现comparator)</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;使用情况：这里以java中的优先级队列为例，堆的使用情况不能按照堆名断章取义，例如小根堆实际上是将元素升序存放，因为在算法第二步中将堆顶元素与末尾元素进行交换，然后重新调整，交换的堆顶元素为最小元素，也是最先从堆中进入队列的。所以小根堆适用于TOPk大的算法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;相反的，大根堆适用于TOPk小的算法，下面分别给出小根堆和大根堆的算法：</strong></p>\n<p><strong>小根堆：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 堆排序---小根堆\n     * @param nums\n     */\n    public static void HeapSort(int[] nums){\n        //先初始化堆\n        for (int i = nums.length/2-1; i &gt;=0 ; i--) {\n            adjustHeap(nums,i,nums.length);\n        }\n        //交换堆顶与末尾节点+重新调整为小根堆\n        for (int i = nums.length-1; i &gt;0; i--) {\n            //先交换\n            swap(nums,0,i);\n            //再调整\n            adjustHeap(nums,0,i);\n        }\n    }\n\n    /**\n     * 调整为小根堆\n     * @param nums\n     * @param i\n     * @param length\n     */\n    public static void adjustHeap(int[] nums,int i,int length){\n        int temp = nums[i];\n        for (int j = 2*i+1; j &lt; length; j=2*j+1) {\n            //找出左右节点中的最小值\n            if(j+1&lt;length&amp;&amp;nums[j]&gt;nums[j+1]){\n                j++;\n            }\n            if(nums[j]&lt;temp){\n                nums[i] = nums[j];\n                i = j;\n            }\n        }\n        nums[i] = temp;\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p><strong>大根堆：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 堆排序---大根堆\n     * @param nums\n     */\n    public static void heapSort(int[] nums){\n\n        //初始化堆的过程\n        for (int i = nums.length/2-1; i &gt;=0; i--) {\n            adjustHeap(nums,i,nums.length);\n        }\n        //调整+交换堆顶和末尾的元素\n        for (int i = nums.length-1; i &gt;0; i--) {\n            //先交换，再重新调整\n            swap(nums,0,i);\n            adjustHeap(nums,0,i);\n        }\n    }\n\n    /**\n     * 调整大顶堆的过程\n     * @param nums\n     * @param i\n     * @param length\n     */\n    public static void adjustHeap(int[] nums,int i,int length){\n        int temp = nums[i];\n        for (int j = 2*i+1; j &lt; length; j=2*j+1) {\n            //找出左右节点中的最大值\n            if(j+1&lt;length&amp;&amp;nums[j]&lt;nums[j+1]){\n                j++;\n            }\n            if(nums[j]&gt;temp){\n                nums[i] = nums[j];\n                i = j;\n            }\n        }\n        nums[i] = temp;\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>本题利用大根堆解法，且使用java中自带的优先级队列PriorityQueue：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用堆数据结构，java中的优先级队列对应着最小堆\n     * 实现其comparator即可\n     * @param arr\n     * @param k\n     * @return\n     */\n    public static int[] getLeastNumbers2(int[] arr, int k){\n        Queue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(k,(v1,v2)-&gt;v2-v1);\n        for (int i : arr) {\n            if(heap.isEmpty()||heap.size()&lt;k||i&lt;heap.peek()){\n                heap.offer(i);\n            }\n            if(heap.size()&gt;k){\n                heap.poll();\n            }\n        }\n        int[] result = new int[k];\n        int j = 0;\n        for (Integer val : heap) {\n            result[j++] = val;\n        }\n        return result;\n    }</code></pre>","blogGoods":0,"blogId":"1253874832811089920","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6joYWAF3oqAAAaZr2Bc1U671.jpg","blogRead":2,"blogRemark":"剑指offer----之最小的k个数","blogTitle":"剑指offer----之最小的k个数","createdTime":"2020-04-25 10:33:50","typeName":"LeetCode","updateTime":"2020-04-25 11:53:15"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，数组中出现次数超过一半的元素---即众数</strong></h2>\n<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>\n<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>\n<p>示例&nbsp;1:</p>\n<p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br />输出: 2</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>方法有三：哈希表统计法，数组排序法，摩尔投票法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;哈希统计法：时间复杂度O（N），空间复杂度O（N）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 博主刚开始看到这道题的时候，首先想到的是哈希表统计法，因为博主想的是要找到众数，那么肯定得统计每个数字的出现次数，然后按照次数比较。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 单单是想到这些，用了map集合之后发现还是不行，因为即便用map集合统计出了每个数字和其对应的出现次数之后，你会发现没有办法按照出现的次数进行比较并且得到次数最多的数字（众数</strong><strong>）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 然后，就又审了一遍题目，结果发现了一个本题很关键的点，（<span style=\"background-color: #ffcc00;\">数组中有一个数字出现的次数超过数组长度的一半</span>），也就是说数组中有且仅有一个数字的出现次数会超过数组长度的一半（别笑博主笨，我是真的刚开始没反应过来）</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 那么我为什么要把数组中的所有元素和其次数全部存放进入map集合，然后再取次数进行比较呢？我为什么不在将元素和其次数存入集合的过程中判断次数是否已经超过数组长度的一半了呢？如果超过一半了，那它肯定是众数了呀！</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 思路：根据题意需要找出两个东西，一是多素元素，二是多素元素的出现次数\n     * 所以我们首先想到的是采用map集合\n     * 然后遍历数组，如果元素不存在与集合中，我们就将其加入map，value置为1\n     * 如果元素存在于map中，则我们取出其value将其加1与数组长度的一半做比较\n     * 如果大于数组长度一半，直接返回该元素即可\n     * 小于数组长度一半，则将其value加1存入map覆盖原有的值即可\n     *\n     * @param nums\n     * @return\n     */\n    public static int majorityElement(int[] nums) {\n        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(nums.length);\n        for (int num : nums) {\n            if(!map.containsKey(num)){\n                map.put(num,1);\n            }else{\n                Integer val = map.get(num);\n                if(++val&gt;nums.length/2){\n                    return num;\n                }else{\n                    map.put(num,val);\n                }\n            }\n        }\n        throw new RuntimeException(\"\");\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>数组排序法：由题可知，数组众必然存在一个多数元素，且出现次数超过数组长度的一半。所以我们可以对原数组进行排序，然后取数组中间的元素即可。（我擦，我当时看到这个，就在想，好简单，这个思路，但是我为什么没想到，对，因为我没有仔细的分析题目，超过一半看见没）。既然进行排序，那么我们可以选择快排，这样时间复杂度就是O（NlogN），空间复杂度O（1）.</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 数组排序法，因为多数元素的出现次数超过数组长度一半，\n     * 所以我们可以先对其进行排序，采用快排，时间复杂度O（NlogN）\n     * 然后取数组中点元素即可\n     * @param nums\n     * @return\n     */\n    public static int majorityElement2(int[] nums){\n        quickSort(nums,0,nums.length-1);\n        return nums[nums.length/2];\n    }\n\n    /**\n     * 快排\n     * @param nums\n     * @param low\n     * @param high\n     */\n    public static void quickSort(int[] nums,int low,int high){\n        int base = nums[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //从右向左找到第一个比基准元素小的元素\n            while(L&lt;R&amp;&amp;nums[R]&gt;=base){\n                R--;\n            }\n            if(nums[R]&lt;base){\n                swap(nums,L,R);\n            }\n            //从左向右找到第一个比基准元素大的元素\n            while(L&lt;R&amp;&amp;nums[L]&lt;=base){\n                L++;\n            }\n            if(nums[L]&gt;base){\n                swap(nums,L,R);\n            }\n        }\n        //左递归\n        if(L&gt;low){\n            quickSort(nums,low,L-1);\n        }\n        //右递归\n        if(high&gt;R){\n            quickSort(nums,R+1,high);\n        }\n    }\n\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>摩尔投票法（我将其称为大佬解法）：大概的意思就是采用正负抵消的方法，设置一个投票变量votes，初始设置为0；设置一个本题中的众数变量x，初始设置为数组首元素。然后遍历数组，判断跟设置的众数变量是否相等，如果相等将votes加一，如果不相等，则重置votes为0，且将x设置为数组下一个元素。本题众因为已经声明了肯定存在众数，所以不需要进行验证，但是如果没有声明的话，需要验证，下列代码众添加了验证：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 摩尔投票法\n     * @param nums\n     */\n    public static int majorityElement3(int[] nums){\n        int votes = 0;\n        int x = nums[0];\n        int count = 0;\n        for (int num : nums) {\n            if(votes==0){\n                x = num;\n            }\n            votes+=(num==x)?1:-1;\n        }\n        //验证数组众是否存在众数\n        for (int num : nums) {\n            if(num==x){\n                count++;\n            }\n        }\n        return count&gt;nums.length/2?x:0;\n    }</code></pre>","blogGoods":0,"blogId":"1253674617332162560","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6i5v-AUh39AAAaZr2Bc1U885.jpg","blogRead":0,"blogRemark":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","blogTitle":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","createdTime":"2020-04-24 21:18:14","typeName":"LeetCode","updateTime":"2020-04-24 21:18:14"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，从上到下打印二叉树-2</strong></h2>\n<p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>\n<p>例如:<br />给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>\n<p>3<br />/ \\<br />9 20<br />/ \\<br />15 7<br />返回其层次遍历结果：</p>\n<p>[<br />[3],<br />[9,20],<br />[15,7]<br />]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;BFS（广度优先搜索）：层次遍历</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * BFS\n     * @param root\n     * @return\n     */\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {\n        if (root == null) {\n            return new ArrayList&lt;&gt;(0);\n        }\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();\n        TreeNode current;\n        while (!queue.isEmpty()) {\n            List&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();\n            for (int i = queue.size(); i &gt; 0; i--) {\n                current = queue.poll();\n                arrayList.add(current.val);\n                if (current.left != null) {\n                    queue.add(current.left);\n                }\n                if (current.right != null) {\n                    queue.add(current.right);\n                }\n            }\n            list.add(arrayList);\n        }\n        return list;\n    }</code></pre>","blogGoods":0,"blogId":"1253350612905598976","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6huUyATZJ_AAAaZr2Bc1U363.jpg","blogRead":1,"blogRemark":"剑指offer----之从上到下打印二叉树----LeetCode102","blogTitle":"剑指offer----之从上到下打印二叉树----LeetCode102","createdTime":"2020-04-23 23:50:45","typeName":"LeetCode","updateTime":"2020-04-23 23:50:57"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，从上打印二叉树-1</strong></h2>\n<p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>\n<p>例如:<br />给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>\n<p>3<br />/ \\<br />9 20<br />/ \\<br />15 7<br />返回：</p>\n<p>[3,9,20,15,7]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;BFS（广度优先搜索）：也即是二叉树的层次遍历，代码和注意事项看代码注释</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 二叉树的层次遍历\n     * 这里是将层次遍历的结果存储在数组中\n     * 但是因为二叉树的节点个数并不知道\n     * 所以不能使用数组直接进行存储，因为无法初始化数组的大小\n     * 所以可以想到使用容量能自动扩充的list集合\n     * 然后再根据list集合的size来初始化数组的大小\n     * 并且将list元素赋值到数组中\n     * @param root\n     * @return\n     */\n    public static int[] levelOrder(TreeNode root) {\n        if(root==null){\n            return new int[0];\n        }\n        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n        TreeNode current;\n        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n        while(!queue.isEmpty()){\n            current = queue.poll();\n            list.add(current.val);\n            if(current.left!=null){\n                queue.add(current.left);\n            }\n            if(current.right!=null){\n                queue.add(current.right);\n            }\n        }\n        int[] result = new int[list.size()];\n        for (int i = 0; i &lt; list.size(); i++) {\n            result[i] = list.get(i);\n        }\n        return result;\n    }</code></pre>","blogGoods":0,"blogId":"1253346228108894208","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6htTeAUHGlAAAaZr2Bc1U102.jpg","blogRead":0,"blogRemark":"剑指offer----之从上到下打印二叉树","blogTitle":"剑指offer----之从上到下打印二叉树","createdTime":"2020-04-23 23:33:20","typeName":"LeetCode","updateTime":"2020-04-23 23:33:20"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，包含min函数的栈</strong></h2>\n<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>\n<p>&nbsp;</p>\n<p>示例:</p>\n<p>MinStack minStack = new MinStack();<br />minStack.push(-2);<br />minStack.push(0);<br />minStack.push(-3);<br />minStack.min(); --&gt; 返回 -3.<br />minStack.pop();<br />minStack.top(); --&gt; 返回 0.<br />minStack.min(); --&gt; 返回 -2.</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>&nbsp;辅助栈法：即初始化两个栈A,B</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;A栈用于实现基本的push(),pop(),top()的正常逻辑</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;B栈用来存放A栈中的非严格降序元素（这个我也理解不了，看代码就知道是存放什么的啦），代码中的方法注释很清楚</strong></p>\n<pre class=\"language-java\"><code>public class MinStack {\n    /** initialize your data structure here. */\n    Stack&lt;Integer&gt; A,B;\n\n    public MinStack() {\n        A = new Stack&lt;&gt;();\n        B = new Stack&lt;&gt;();\n    }\n\n    /**\n     * 入栈操作，元素先入A栈\n     * 如果B栈为空或者B栈的栈顶元素大于待入栈元素，则B栈也执行入栈操作\n     * @param x\n     */\n    public void push(int x) {\n        A.add(x);\n        if(B.isEmpty()||B.peek()&gt;=x){\n            B.add(x);\n        }\n    }\n\n    /**\n     * 这段代码优点巧妙\n     * 注意这里使用的A.pop()而不是A.peek()\n     * 所以这里实际上是分为两种情况的\n     * 第一种：当A的栈顶元素不为当前栈中的最小元素，即不等于栈B的栈顶元素\n     *         则只进行栈A的出栈操作，即A.pop()\n     * 第二种：当A的栈顶元素为当前栈中的最小元素，即等于栈B的栈顶元素\n     *        则不仅要A.pop(),而且为了保证A,B栈中最小元素的同步性\n     *        B栈也要执行出栈操作\n     */\n    public void pop() {\n        if(A.pop().equals(B.peek())){\n            B.pop();\n        }\n    }\n\n    /**\n     * 正常获取A的栈顶元素\n     * @return\n     */\n    public int top() {\n        return A.peek();\n    }\n\n    /**\n     * 获取A栈的最小元素，即B栈的栈顶元素\n     * @return\n     */\n    public int min() {\n        return B.peek();\n    }\n}</code></pre>","blogGoods":0,"blogId":"1253331349566234624","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hp12AMy2MAAAaZr2Bc1U568.jpg","blogRead":4,"blogRemark":"剑指offer----之包含min函数的栈---LeetCode155","blogTitle":"剑指offer----之包含min函数的栈---LeetCode155","createdTime":"2020-04-23 22:34:13","typeName":"LeetCode","updateTime":"2020-04-23 23:50:51"},{"blogCollection":0,"blogComment":0,"blogContent":"<h3><strong>晚上九点多，坐在床上，面前摆放着电脑，屏幕显示的是LeetCode中的《剑指offer》的题解</strong></h3>\n<h3><strong>此时的我毫无睡意，当然，这并不是因为解出一道题的喜悦冲淡了我的睡意</strong></h3>\n<h3><strong>相反的，这是一种难以言明的心情，包含着对自己无知的羞愧，也包含着别人面对如此无知的自己也能给出耐心回应的感动</strong></h3>\n<h3><strong>人有时或许就是这样，刻意的举动会让人心生防备，但是无意的善举却能温润人心</strong></h3>\n<h3><strong>别人无意的一个回答，一个小举动，一句肯定的话</strong></h3>\n<h3><strong>殊不知却能为对方赋予无穷无尽的能量</strong></h3>\n<h3><strong>将这一天的疲惫和劳累都消除</strong></h3>\n<h3><strong>赠人玫瑰，手有余香</strong></h3>\n<h3><strong>我一直抱着这样的一种心态，或许我无法做到赠人玫瑰，但是我会尽量将自己的善意展现给别人</strong></h3>\n<h3><strong>也许他刚刚好正处于某个难关，而你又刚刚好是他难关之初的引导者</strong></h3>\n<h3><strong>一句话，或许对于你来说只是人生中微不足道的几秒钟</strong></h3>\n<h3><strong>而对他来说，或许可能是多年之后回忆起来也能嘴角上扬的美好岁月</strong></h3>\n<h3><strong>想起前段时间一部剧里面的话，在这里也送给屏幕前的你：愿你永怀善意，清澈明朗</strong></h3>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1253326423486144512","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hosWANYd2AAHQzo49lBU641.jpg","blogRead":3,"blogRemark":"2020-4-23有感","blogTitle":"2020-4-23有感","createdTime":"2020-04-23 22:14:38","typeName":"随心日记","updateTime":"2020-04-25 21:22:30"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，顺时针打印矩阵</strong></h2>\n<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>\n<p>示例 1：</p>\n<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br />输出：[1,2,3,6,9,8,7,4,5]<br />示例 2：</p>\n<p>输入：matrix =&nbsp;[[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br />输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p>\n<p>限制：</p>\n<p>0 &lt;= matrix.length &lt;= 100<br />0 &lt;= matrix[i].length&nbsp;&lt;= 100</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;模拟顺时针打印的这种循环结构：设置四个边界条件，l,r,t,b。按照从左往右，从上往下，从右往左，从下网往上的顺序依次读取矩阵的元素，并且每一次都判断边界是否相遇，直到将整个矩阵元素都加入到数组中即可。</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 设置四个边界值，分别为left=0,right=matrix[0].length-1,top=0,bottom=matrix.length-1\n     * 顺时针顺序即先从左到右，再从上到下，再从右向左，再从下向上，每一次执行都要判断边界值\n     * @param matrix\n     * @return\n     */\n    public static int[] spiralOrder(int[][] matrix) {\n        if(matrix.length==0){\n            return new int[0];\n        }\n        int l = 0;\n        int r=matrix[0].length-1;\n        int t=0;\n        int b=matrix.length-1;\n        int x=0;\n        int[] res = new int[(r+1)*(b+1)];\n        while(true){\n            //从左向右\n            for(int i=l;i&lt;=r;i++){\n                res[x++]=matrix[t][i];\n            }\n            if(++t&gt;b) {\n                break;\n            }\n            //从上向下\n            for(int i=t;i&lt;=b;i++){\n                res[x++] = matrix[i][r];\n            }\n            if(--r&lt;l){\n                break;\n            }\n            //从右向左\n            for(int i=r;i&gt;=l;i--){\n                res[x++] = matrix[b][i];\n            }\n            if(--b&lt;t){\n                break;\n            }\n            //从下往上\n            for(int i=b;i&gt;=t;i--){\n                res[x++] = matrix[i][l];\n            }\n            if(++l&gt;r){\n                break;\n            }\n        }\n        return res;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1253250557729087488","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hXB2ASIQwAAAaZr2Bc1U016.jpg","blogRead":0,"blogRemark":"剑指offer-----之顺时针打印矩阵----LeetCode54","blogTitle":"剑指offer-----之顺时针打印矩阵----LeetCode54","createdTime":"2020-04-23 17:13:11","typeName":"LeetCode","updateTime":"2020-04-23 17:13:11"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，对称的二叉树</strong></h2>\n<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>\n<p>例如，二叉树&nbsp;[1,2,2,3,4,4,3] 是对称的。</p>\n<p>&nbsp; &nbsp; 1<br />&nbsp; &nbsp;/ \\<br />&nbsp; 2 &nbsp; 2<br />&nbsp;/ \\ / \\<br />3 &nbsp;4 4 &nbsp;3<br />但是下面这个&nbsp;[1,2,2,null,3,null,3] 则不是镜像对称的:</p>\n<p>&nbsp; &nbsp; 1<br />&nbsp; &nbsp;/ \\<br />&nbsp; 2 &nbsp; 2<br />&nbsp; &nbsp;\\ &nbsp; \\<br />&nbsp; &nbsp;3 &nbsp; &nbsp;3</p>\n<p>示例 1：</p>\n<p>输入：root = [1,2,2,3,4,4,3]<br />输出：true<br />示例 2：</p>\n<p>输入：root = [1,2,2,null,3,null,3]<br />输出：false</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>递归法：从对称的二叉树中我们可以找到如下规律</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果一个二叉树是对称的，则每一个节点的左右子树也是对称的,因此是递归的</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 设L = root.left，R=root.right，则满足L.left.val = R.right.val;L.right.val=R.left.val;</strong></p>\n<pre class=\"language-java\"><code>public boolean isSymmetric(TreeNode root) {\n        return  root==null?true:recur(root.left,root.right);\n    }\n    public boolean recur(TreeNode L,TreeNode R){\n        if(L==null&amp;&amp;R==null){\n            return true;\n        }\n        if(L==null||R==null||L.val!=R.val){\n            return false;\n        }\n        return recur(L.left,R.right)&amp;&amp;recur(L.right,R.left);\n    }</code></pre>","blogGoods":0,"blogId":"1252992659794968576","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6ga--AKQdvAAAaZr2Bc1U862.jpg","blogRead":1,"blogRemark":"剑指offer----之对称的二叉树----LeetCode101","blogTitle":"剑指offer----之对称的二叉树----LeetCode101","createdTime":"2020-04-23 00:08:23","typeName":"LeetCode","updateTime":"2020-04-23 00:12:33"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，二叉树镜像</strong></h2>\n<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>\n<p>例如输入：</p>\n<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; 2 &nbsp; &nbsp; 7<br />&nbsp;/ \\ &nbsp; / \\<br />1 &nbsp; 3 6 &nbsp; 9<br />镜像输出：</p>\n<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; 7 &nbsp; &nbsp; 2<br />&nbsp;/ \\ &nbsp; / \\<br />9 &nbsp; 6 3&nbsp; &nbsp;1</p>\n<p>示例 1：</p>\n<p>输入：root = [4,2,7,1,3,6,9]<br />输出：[4,7,2,9,6,3,1]</p>\n<p>限制：</p>\n<p>0 &lt;= 节点个数 &lt;= 1000</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;递归法：即递归的去交换根节点的左右子树，直到根节点为叶子节点</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用递归的方法，交换根节点的左子树和右子树\n     * 递归出口为，根节点为叶子节点\n     * @param root\n     * @return\n     */\n    public TreeNode mirrorTree(TreeNode root) {\n        TreeNode center = root;\n        if(center!=null){\n            TreeNode temp = center.left;\n            center.left = center.right;\n            center.right = temp;\n            mirrorTree(center.left);\n            mirrorTree(center.right);\n        }\n        return root;\n    }</code></pre>","blogGoods":0,"blogId":"1252985443281027072","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6gZTWABF55AAAaZr2Bc1U678.jpg","blogRead":0,"blogRemark":"剑指offer----之二叉树的镜像----LeetCode226","blogTitle":"剑指offer----之二叉树的镜像----LeetCode226","createdTime":"2020-04-22 23:39:43","typeName":"LeetCode","updateTime":"2020-04-22 23:39:43"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，合并两个有序链表</strong></h2>\n<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>\n<p>示例1：</p>\n<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br />输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br />限制：</p>\n<p>0 &lt;= 链表长度 &lt;= 1000</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>伪头节点法：即创建一个伪头节点head和一个用于辅助的节点cur</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法：如果l1.val&lt;=l2.val,就让cur指向l1，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l1指向其next</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果l1.val&gt;l2.val,就让cur指向l2，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l2指向其next</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;直到l1和l2有一个为空为止，让cur指向剩余的一个非空链表即可，若两个链表的长度为M,N则时间复杂度为O(M+N)</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用四节点，一个伪头节点，一个当前节点cur，已经链表的两个节点l1,l2\n     * 每次比较l1,l2节点的val大小，将小的节点连接到当前节点cur上即可\n     * 直到l1,l2有一个空，则将剩余的一个非空链表连接到cur尾部即可\n     * @param l1\n     * @param l2\n     * @return\n     */\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode head;\n        ListNode cur;\n        head = cur = new ListNode(0);\n        while(l1!=null&amp;&amp;l2!=null){\n            if(l1.val&lt;=l2.val){\n                cur.next = l1;\n                cur = cur.next;\n                l1 = l1.next;\n            }else{\n                cur.next = l2;\n                cur = cur.next;\n                l2 = l2.next;\n            }\n        }\n        if(l1!=null){\n            cur.next = l1;\n        }\n        if(l2!=null){\n            cur.next = l2;\n        }\n        return head.next;\n    }</code></pre>","blogGoods":0,"blogId":"1252980258446000128","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6gYGWAe-MZAAAaZr2Bc1U550.jpg","blogRead":0,"blogRemark":"剑指offer----之合并有序链表---LeetCode21","blogTitle":"剑指offer----之合并有序链表---LeetCode21","createdTime":"2020-04-22 23:19:06","typeName":"LeetCode","updateTime":"2020-04-22 23:19:06"}],"pageSize":15,"params":{},"sortColumn":"created_time","sortMethod":"DESC","totalCount":53,"totalPage":4},"msg":"操作成功!"}
2020-04-26 23:37:47.241 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /user/getCommentAndCollection
2020-04-26 23:37:47.242 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:37:47.242 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:37:47.243 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.UserController.getCommentAndCollection
2020-04-26 23:37:47.243 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:37:47.326 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 85
2020-04-26 23:37:47.326 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"comment":0,"collection":0},"msg":"操作成功!"}
2020-04-26 23:37:56.921 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /rotation-picture/listFront
2020-04-26 23:37:56.921 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:37:56.921 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:37:56.922 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.RotationPictureController.getRotationPictureListFront
2020-04-26 23:37:56.922 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:37:56.935 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/list
2020-04-26 23:37:56.936 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:37:56.936 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:37:56.937 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogList
2020-04-26 23:37:56.937 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=15, totalPage=0, totalCount=0, list=[], params={}, sortColumn=created_time, sortMethod=DESC)]
2020-04-26 23:37:57.013 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 92
2020-04-26 23:37:57.014 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"createdTime":"2020-04-09 13:31:20","enable":1,"rotationId":4,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PI6aAZIz1AASCO4hlpJI295.jpg"},{"createdTime":"2020-04-09 13:37:02","enable":1,"rotationId":9,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJPyAbm8fAAG9gfO8lxE28.jpeg"},{"createdTime":"2020-04-09 13:41:30","enable":1,"rotationId":10,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJgeAeG8wAAS2pjJC5QU547.jpg"},{"createdTime":"2020-04-09 13:41:38","enable":1,"rotationId":11,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhGAQFZbAAP2OOBWb6k310.jpg"},{"createdTime":"2020-04-09 13:41:50","enable":1,"rotationId":12,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhyABMZCAAG7doyXiM8109.jpg"},{"createdTime":"2020-04-09 13:41:59","enable":1,"rotationId":13,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJiWAL7BoAARW3_O3ISw651.jpg"}],"msg":"操作成功!"}
2020-04-26 23:37:57.297 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 362
2020-04-26 23:37:57.298 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，0~n-1中缺失的数字</strong></h2>\n<p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>\n<p>示例 1:</p>\n<p>输入: [0,1,3]<br />输出: 2<br />示例&nbsp;2:</p>\n<p>输入: [0,1,2,3,4,5,6,7,9]<br />输出: 8</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主能想到的并且写出来的方法有：使用map存储数组中的所有元素，然后遍历0-n-1找出不在map中的元素。此种方法时间复杂度O（N），空间复杂度O（N）-----垃圾</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 统计0-n-1所有数字的数字和，再统计数组中所有数字的数字和，两和只差即为所求数字，时间复杂度O（N），空间复杂度O（1）-----垃圾</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;最优解法（二分查找法）：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;通常来说，我们使用二分查找法是查找一个存在于数组中的元素，但是本题需要求不在数组中的一个元素，因此到这很多人就会迷惑，不知道该怎么求了。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;但是我们首先要搞明白二分查找法的本质是什么：1，并不局限于仅仅查找存在于数组中的元素；2，二分查找的本质是对数组根据mid中间值在某一条件上进行二分（例如：通常的num[mid]&gt;target或者nums[mid]&lt;target进行左右切分）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;因此明白这一点，就好解决问题了。拿到这道题，使用二分，我们首先想到的应该是寻找根据mid中间值进行二分的条件</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;审题：题目中提及数组为递增数组，而且0-n-1内的n个数字有一个不在数组中，则不在的这个数字之前的数字满足nums[i]=i即元素本身等于数组下标，而之后的数字nums[i]!=i,所以这就是进行二分的条件了</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 二分查找法\n     * 算法思想：二分查找法的本质是能够有一个条件将数组根据mid中间值进行左右切分\n     * 所以我们想到二分查找法之后，首先需要做的是找出切分数组的条件\n     * 题目中给出了数组是一个递增数组，且0-n-1内的n个数字有一个不在这个长度为n-1的数组内\n     * 因此，不在的这个元素其左边元素必有数组下标值等于元素本身即nums[i]=i\n     * 而不在的这个元素的右边必有nums[i]!=i\n     * 所以根据此条件进行划分数组即可\n     * @param nums\n     * @return\n     */\n    public static int missingNumber(int[] nums) {\n        int low = 0;\n        int high = nums.length-1;\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]==mid){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        return low;\n    }</code></pre>","blogGoods":0,"blogId":"1254063045920022528","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kUM-AON88AAAaZr2Bc1U903.jpg","blogRead":0,"blogRemark":"剑指offer----0~n-1中缺失的数字","blogTitle":"剑指offer----0~n-1中缺失的数字","createdTime":"2020-04-25 23:01:44","typeName":"LeetCode","updateTime":"2020-04-25 23:01:44"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，在排序数组中查找数字I</strong></h2>\n<p>统计一个数字在排序数组中出现的次数。</p>\n<p>示例 1:</p>\n<p>输入: nums = [5,7,7,8,8,10], target = 8<br />输出: 2<br />示例&nbsp;2:</p>\n<p>输入: nums = [5,7,7,8,8,10], target = 6<br />输出: 0</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解法一：直接遍历统计，时间复杂度为O（N）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 遍历数组\n     * 找到第一个与目标元素相等的元素，res+1\n     * 然后往后找到第一个与目标元素不相等的元素,返回res即可\n     * 时间复杂度为O(N)\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static int search(int[] nums, int target) {\n        int res = 0;\n        for (int num : nums) {\n            if(num==target){\n                res++;\n            }\n        }\n        return res;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解法二：二分法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：利用二分法查找数字在排序数组中的左边界Left和右边界Right.如下，如果要寻找数组中的8，则其左边界为left=2,有边界right=5.所以出现次数为right-left-1.时间复杂度为O（logN）</strong></p>\n<table style=\"width: 20%; border-collapse: collapse; margin-left: auto; margin-right: auto;\" border=\"1\" cellpadding=\"5\">\n<tbody>\n<tr>\n<td style=\"width: 16.6667%;\">5</td>\n<td style=\"width: 16.6667%;\">7</td>\n<td style=\"width: 16.6667%;\">7</td>\n<td style=\"width: 16.6667%;\">8</td>\n<td style=\"width: 16.6667%;\">8</td>\n<td style=\"width: 16.6667%;\">10</td>\n</tr>\n</tbody>\n</table>\n<pre class=\"language-java\"><code>    /**\n     * 二分查找法\n     * 时间复杂度为O（logN）\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static int search2(int[] nums, int target){\n        int low = 0;\n        int high = nums.length-1;\n        int left,right;\n        left = right = 0;\n        //一次二分\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]&lt;=target){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        right = low;\n\n        low = 0;\n        high = nums.length -1;\n        //二次二分\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]&lt;target){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        left = high;\n        return right -left -1;\n    }</code></pre>","blogGoods":0,"blogId":"1254055163115724800","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kSXiAYRyFAAAaZr2Bc1U379.jpg","blogRead":0,"blogRemark":"剑指offer----在排序数组中查找数字I----LeetCode34","blogTitle":"剑指offer----在排序数组中查找数字I----LeetCode34","createdTime":"2020-04-25 22:30:24","typeName":"LeetCode","updateTime":"2020-04-25 22:30:24"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，两个链表的第一个公共节点</strong></h2>\n<p><strong><img src=\"https://images-cdn.shimo.im/Wd1NC8pveQYp9iIL.png__thumbnail\" alt=\"示例图\" width=\"742\" height=\"241\" /></strong></p>\n<p><strong>这是我从官方截下的一张图，也是有些人疑惑的地方，因为官方这张图给出的公共节点为8，而大多数人看到这张图，认为公共节点应该是1.</strong></p>\n<p><strong>但是实际上这里的公共节点不仅要节点的value相等，同时还需要节点的地址相等。从图中可以看出两个1节点虽然值相等，但是地址却不同，因而不是公共节点</strong></p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解法一：双指针</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：初始化两个指针p1=headA,p2=headB</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;分别遍历两个链表，求出两个链表的长度l1,l2</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;然后重置p1,p2指针指向头节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;让长链表的指针先走多的步数（l1-l2或者l2-l1）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;然后让两个指针同时走，直到两者相遇，即找到公共节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解疑：弄清楚第一个value相等的节点和指针相遇的节点，这两种节点是不同的，指针相遇的节点，不仅包含value相等，同时地址也相等。（如图中的8）；而第一个value相等的节点则可能并不在同一个地址，因此不一定是公共节点</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法\n     * @param headA\n     * @param headB\n     * @return\n     */\n    public static ListNode getIntersectionNode2(ListNode headA, ListNode headB){\n        ListNode p1 =headA;\n        ListNode p2 = headB;\n        int l1 = 0;\n        int l2 = 0;\n        //计算链表1的长度\n        while(p1!=null){\n            l1++;\n            p1 = p1.next;\n        }\n        //计算链表2的长度\n        while(p2!=null){\n            l2++;\n            p2 = p2.next;\n        }\n        p1 = headA;\n        p2 = headB;\n        //让长链表指针先走长的步数\n        if(l1&gt;l2){\n            for (int i = 0; i &lt; l1-l2; i++) {\n                p1 = p1.next;\n            }\n        }else{\n            for (int i = 0; i &lt; l2-l1; i++) {\n                p2 = p2.next;\n            }\n        }\n        //然后让两个指针同时走，直到相遇\n        while(p1!=p2){\n            p1 = p1.next;\n            p2 = p2.next;\n        }\n        return p1;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;解法二（大神解法）：丘比特相遇法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;利用两个指针p1=headA,p2=headB,让两个指针同时走，</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果p1先走到底，就将p1置为headB，</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果p2,先走到底，就将p2置为headA,</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;当两个指针相遇的时候，他们就相爱了（当然是找到公共节点了）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法p1=headA,p2=headB\n     * 思想是：两个节点同时从各自的链表出发\n     * p1走到末尾时，回到headB的头部\n     * p2走到末尾时，回到headA的头部\n     * 两个指针相遇的时候，即使要找的公共节点\n     * @param headA\n     * @param headB\n     * @return\n     */\n    public static ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode p1 = headA;\n        ListNode p2 = headB;\n        while(p1!=p2){\n            p1 = (p1==null)?headB:p1.next;\n            p2 = (p2==null)?headA:p2.next;\n        }\n        return p1;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1253992797703364608","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kD2OADD3mAAAaZr2Bc1U709.jpg","blogRead":0,"blogRemark":"剑指offer----之两个链表的第一个公共节点----LeetCode160","blogTitle":"剑指offer----之两个链表的第一个公共节点----LeetCode160","createdTime":"2020-04-25 18:22:35","typeName":"LeetCode","updateTime":"2020-04-25 18:22:35"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，第一个只出现一次的字符</strong></h2>\n<p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。</p>\n<p>示例:</p>\n<p>s = \"abaccdeff\"<br />返回 \"b\"</p>\n<p>s = \"\" <br />返回 \" \"</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主现在发现，做一道算法题的时候，最重要的一步就是读题，审题，在草稿纸上写下自己的思路（当然那种望眼欲穿的大佬除外）。然后才开始动笔，对于IT人来说，真的，多将时间花费在思考上面，而不是无意义的重复搬砖。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;题目分析：看到这道题，抓住两个关键字：第一个，只出现一次。什么意思呢，例如\"abaccdeff\"，其中只出现一次的字符有'b','d','e'三个，然后在三个字符中第一个出现在字符串中的是'b'，因此本题的答案是'b'.</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法分析：根据题目分析，我们最直观的解法应该是，先找出字符串中只出现一次的字符，然后再找出只出现一次字符中，第一个在字符串中出现的。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;所以我们需要做两件事，一是统计字符串中各个字符的出现次数，并且记录；二，统计完毕后，找出第一个出现次数为1的字符，返回即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;因此我们既要存字符，还要存字符对应的出现次数，所以理所当然我们选择map集合。当然对于本题而言，因为求第一个出现一次的字符，所以我们更好的是可以使用LinkedHashMap。这样免去最后的一次遍历字符串</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;下面提供两种解法：三种解法都是使用map集合，但是略有不同</strong></p>\n<p><strong>LinkedHashMap：（这是博主写的，代码冗余，这里用来和大神的写法做比较，警醒自己）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 用LinkedHashMap\n     * 思想：遍历字符串，如果map为空或者map中不含当前字符，则将其存入map\n     * 如果map中已经含有当前字符，则从map中移除\n     * 最终map中只剩出现一次的字符\n     * 返货map中的第一个即可\n     * @param s\n     * @return\n     */\n    public static char firstUniqChar(String s) {\n        Map&lt;Character,Integer&gt;map = new LinkedHashMap&lt;&gt;();\n        for (int i = 0; i &lt; s.length(); i++) {\n            char ch = s.charAt(i);\n            if(map.isEmpty()||!map.containsKey(ch)){\n                map.put(ch,1);\n            }else{\n                Integer val = map.get(ch);\n                map.put(ch,++val);\n            }\n        }\n        //返回map中第一个元素即可\n        Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entries = map.entrySet();\n        for (Map.Entry&lt;Character, Integer&gt; entry : entries) {\n            if(entry.getValue()==1){\n                return entry.getKey();\n            }\n        }\n        return ' ';\n    }</code></pre>\n<p><strong>HashMap（大神解法）：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 哈希表法\n     * @param s\n     * @return\n     */\n    public char firstUniqChar2(String s) {\n        Map&lt;Character,Boolean&gt; map = new HashMap&lt;&gt;();\n        char[] chars = s.toCharArray();\n        for (char ch : chars) {\n            map.put(ch,!map.containsKey(ch));\n        }\n        for (char ch : chars) {\n            if(map.get(ch)){\n                return ch;\n            }\n        }\n        return ' ';\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;分析：首先，这里提供了两种解法，一种为LinkedHashMap，一种为HashMap，这两种解法的不同之处就在于最后获取值的时候，LinkedHashMap获取最终值是遍历LinkedHashMap的entrySet，但是HashMap获取最终值是遍历原字符串。因而当数据庞大的时候，显然使用LinkedHashMap性能更高。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;然后，再分析一下这两种解法不另外一个不同之处，没错！就是大神的解法中使用map存放key对应的value值是Boolean型！（<span style=\"background-color: #ffcc00;\">这个真的是神一般的存在</span>），既省去了计算次数的麻烦，同时最后取的时候也不需要判断次数。wc！同一种解法，为什么天差地别！</strong></p>","blogGoods":0,"blogId":"1253956468789600256","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6j7Y6ACrySAAAaZr2Bc1U825.jpg","blogRead":0,"blogRemark":"剑指offer----第一次只出现一次的字符","blogTitle":"剑指offer----第一次只出现一次的字符","createdTime":"2020-04-25 15:58:14","typeName":"LeetCode","updateTime":"2020-04-25 15:58:14"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，连续子数组的最大和</strong></h2>\n<p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>\n<p>要求时间复杂度为O(n)。</p>\n<p>示例1:</p>\n<p>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br />输出: 6<br />解释:&nbsp;连续子数组&nbsp;[4,-1,2,1] 的和最大，为&nbsp;6。</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;看到这道题，最简单的想法肯定是求出所有连续子数组的值，然后进行比较，找出最大的即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;但是随后会想到既然要找出所有的子数组，那么我们可以使用分治的思想，因为分治的分过程即可以得到所有子序列</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;随后，再深一步，既然可以分治的思想，分的过程即是递归的过程，而且子数组的最大值依赖与前一子数组，所以可以想到使用动态规划</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：设dp[i]为以nums[i]为结尾的最大子数组和，初始值dp[0] = nums[0]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;遍历数组，如果dp[i-1]&gt;=0。则说明前面的最大子数组对当前子数组有增益效果，所以dp[i] = dp[i-1]+nums[i]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果dp[i-1]&lt;0。说明前面的最大子数组对当前子数组有夫负效果，还不如nums[i]本身，所以dp[i]=nums[i]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主的这样的写法：时间复杂度为O（N），空间复杂度也为O（N），但是实际上不需要使用dp数组，使用nums原数组就行，所以可以减小空间复杂度为O（1）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 动态规划\n     * 算法思想：因为求的是连续子数组的最大和\n     * 所以我们可以设dp[i]为以nums[i]结尾的最大连续子数组\n     * 如果dp[i]&lt;=nums[i],dp[i]=nums[i]\n     * 如果dp[i]&gt;nums[i],则dp[i]=dp[i]+nums[i]\n     * @param nums\n     * @return\n     */\n    public static int maxSubArray(int[] nums) {\n        int[] dp  = new int[nums.length];\n        dp[0] = nums[0];\n        int res = nums[0];\n        for (int i = 1; i &lt; nums.length; i++) {\n            if(dp[i-1]&lt;0){\n                dp[i] = nums[i];\n            }else{\n                dp[i] = dp[i-1]+nums[i];\n            }\n            res = Math.max(res,dp[i]);\n        }\n        return res;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1253938714590175232","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6j3QSACLxRAAAaZr2Bc1U017.jpg","blogRead":0,"blogRemark":"剑指offer---连续子数组的最大和---LeetCode53","blogTitle":"剑指offer---连续子数组的最大和---LeetCode53","createdTime":"2020-04-25 14:47:41","typeName":"LeetCode","updateTime":"2020-04-25 14:47:41"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，最小的k个数</strong></h2>\n<p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>\n<p>示例 1：</p>\n<p>输入：arr = [3,2,1], k = 2<br />输出：[1,2] 或者 [2,1]<br />示例 2：</p>\n<p>输入：arr = [0,1,2,1], k = 1<br />输出：[0]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;1,可以采用快排的思想，将原数组按照升序排序，然后取出前k个数即可，时间复杂度为O（NlogN）。但是其实跟API中的sort方法好像差别不大</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 对原数组升序排序，然后取前k个元素\n     * @param arr\n     * @param k\n     * @return\n     */\n    public static int[] getLeastNumbers(int[] arr, int k) {\n        quickSort(arr,0,arr.length-1);\n        int[] result = new int[k];\n        for (int i = 0; i &lt; k; i++) {\n            result[i] = arr[i];\n        }\n        return result;\n    }\n\n    /**\n     * 快排\n     * @param nums\n     * @param low\n     * @param high\n     */\n    public static void quickSort(int[] nums,int low,int high){\n        int base = nums[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //先从右向左找到第一个小于基准元素的元素\n            while(L&lt;R&amp;&amp;nums[R]&gt;=base){\n                R--;\n            }\n            if(nums[R]&lt;base){\n                swap(nums,L,R);\n            }\n            //再从左向右找到第一个大于基准元素的元素\n            while(L&lt;R&amp;&amp;nums[L]&lt;=base){\n                L++;\n            }\n            if(nums[L]&gt;base){\n                swap(nums,L,R);\n            }\n        }\n        //左递归\n        if(L&gt;low){\n            quickSort(nums,low,L-1);\n        }\n        //右递归\n        if(high&gt;R){\n            quickSort(nums,R+1,high);\n        }\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>2，堆排序：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;先讲解一下堆排序：堆排序是一种完全二叉树的结构，常见的存在两种堆结构，小根堆（即满足arr[2i+1]&gt;=arr[i]&amp;&amp;arr[2i+2]&gt;=arr[i]），大根堆（即满足arr[2i+1]&lt;=arr[i]&amp;&amp;arr[2i+2]&lt;=arr[i]）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;基本算法思想：第一步，初始化堆，即堆初始化为大根堆或者小根堆（这里我们简称调整堆）；第二步，将堆顶元素与堆的末尾元素进行交换，然后重新调整堆。在java中堆通常用来实现优先级队列PriorityQueue(默认的采用小根堆，若想使用大根堆，需要在创建时实现comparator)</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;使用情况：这里以java中的优先级队列为例，堆的使用情况不能按照堆名断章取义，例如小根堆实际上是将元素升序存放，因为在算法第二步中将堆顶元素与末尾元素进行交换，然后重新调整，交换的堆顶元素为最小元素，也是最先从堆中进入队列的。所以小根堆适用于TOPk大的算法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;相反的，大根堆适用于TOPk小的算法，下面分别给出小根堆和大根堆的算法：</strong></p>\n<p><strong>小根堆：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 堆排序---小根堆\n     * @param nums\n     */\n    public static void HeapSort(int[] nums){\n        //先初始化堆\n        for (int i = nums.length/2-1; i &gt;=0 ; i--) {\n            adjustHeap(nums,i,nums.length);\n        }\n        //交换堆顶与末尾节点+重新调整为小根堆\n        for (int i = nums.length-1; i &gt;0; i--) {\n            //先交换\n            swap(nums,0,i);\n            //再调整\n            adjustHeap(nums,0,i);\n        }\n    }\n\n    /**\n     * 调整为小根堆\n     * @param nums\n     * @param i\n     * @param length\n     */\n    public static void adjustHeap(int[] nums,int i,int length){\n        int temp = nums[i];\n        for (int j = 2*i+1; j &lt; length; j=2*j+1) {\n            //找出左右节点中的最小值\n            if(j+1&lt;length&amp;&amp;nums[j]&gt;nums[j+1]){\n                j++;\n            }\n            if(nums[j]&lt;temp){\n                nums[i] = nums[j];\n                i = j;\n            }\n        }\n        nums[i] = temp;\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p><strong>大根堆：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 堆排序---大根堆\n     * @param nums\n     */\n    public static void heapSort(int[] nums){\n\n        //初始化堆的过程\n        for (int i = nums.length/2-1; i &gt;=0; i--) {\n            adjustHeap(nums,i,nums.length);\n        }\n        //调整+交换堆顶和末尾的元素\n        for (int i = nums.length-1; i &gt;0; i--) {\n            //先交换，再重新调整\n            swap(nums,0,i);\n            adjustHeap(nums,0,i);\n        }\n    }\n\n    /**\n     * 调整大顶堆的过程\n     * @param nums\n     * @param i\n     * @param length\n     */\n    public static void adjustHeap(int[] nums,int i,int length){\n        int temp = nums[i];\n        for (int j = 2*i+1; j &lt; length; j=2*j+1) {\n            //找出左右节点中的最大值\n            if(j+1&lt;length&amp;&amp;nums[j]&lt;nums[j+1]){\n                j++;\n            }\n            if(nums[j]&gt;temp){\n                nums[i] = nums[j];\n                i = j;\n            }\n        }\n        nums[i] = temp;\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>本题利用大根堆解法，且使用java中自带的优先级队列PriorityQueue：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用堆数据结构，java中的优先级队列对应着最小堆\n     * 实现其comparator即可\n     * @param arr\n     * @param k\n     * @return\n     */\n    public static int[] getLeastNumbers2(int[] arr, int k){\n        Queue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(k,(v1,v2)-&gt;v2-v1);\n        for (int i : arr) {\n            if(heap.isEmpty()||heap.size()&lt;k||i&lt;heap.peek()){\n                heap.offer(i);\n            }\n            if(heap.size()&gt;k){\n                heap.poll();\n            }\n        }\n        int[] result = new int[k];\n        int j = 0;\n        for (Integer val : heap) {\n            result[j++] = val;\n        }\n        return result;\n    }</code></pre>","blogGoods":0,"blogId":"1253874832811089920","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6joYWAF3oqAAAaZr2Bc1U671.jpg","blogRead":2,"blogRemark":"剑指offer----之最小的k个数","blogTitle":"剑指offer----之最小的k个数","createdTime":"2020-04-25 10:33:50","typeName":"LeetCode","updateTime":"2020-04-25 11:53:15"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，数组中出现次数超过一半的元素---即众数</strong></h2>\n<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>\n<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>\n<p>示例&nbsp;1:</p>\n<p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br />输出: 2</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>方法有三：哈希表统计法，数组排序法，摩尔投票法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;哈希统计法：时间复杂度O（N），空间复杂度O（N）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 博主刚开始看到这道题的时候，首先想到的是哈希表统计法，因为博主想的是要找到众数，那么肯定得统计每个数字的出现次数，然后按照次数比较。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 单单是想到这些，用了map集合之后发现还是不行，因为即便用map集合统计出了每个数字和其对应的出现次数之后，你会发现没有办法按照出现的次数进行比较并且得到次数最多的数字（众数</strong><strong>）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 然后，就又审了一遍题目，结果发现了一个本题很关键的点，（<span style=\"background-color: #ffcc00;\">数组中有一个数字出现的次数超过数组长度的一半</span>），也就是说数组中有且仅有一个数字的出现次数会超过数组长度的一半（别笑博主笨，我是真的刚开始没反应过来）</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 那么我为什么要把数组中的所有元素和其次数全部存放进入map集合，然后再取次数进行比较呢？我为什么不在将元素和其次数存入集合的过程中判断次数是否已经超过数组长度的一半了呢？如果超过一半了，那它肯定是众数了呀！</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 思路：根据题意需要找出两个东西，一是多素元素，二是多素元素的出现次数\n     * 所以我们首先想到的是采用map集合\n     * 然后遍历数组，如果元素不存在与集合中，我们就将其加入map，value置为1\n     * 如果元素存在于map中，则我们取出其value将其加1与数组长度的一半做比较\n     * 如果大于数组长度一半，直接返回该元素即可\n     * 小于数组长度一半，则将其value加1存入map覆盖原有的值即可\n     *\n     * @param nums\n     * @return\n     */\n    public static int majorityElement(int[] nums) {\n        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(nums.length);\n        for (int num : nums) {\n            if(!map.containsKey(num)){\n                map.put(num,1);\n            }else{\n                Integer val = map.get(num);\n                if(++val&gt;nums.length/2){\n                    return num;\n                }else{\n                    map.put(num,val);\n                }\n            }\n        }\n        throw new RuntimeException(\"\");\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>数组排序法：由题可知，数组众必然存在一个多数元素，且出现次数超过数组长度的一半。所以我们可以对原数组进行排序，然后取数组中间的元素即可。（我擦，我当时看到这个，就在想，好简单，这个思路，但是我为什么没想到，对，因为我没有仔细的分析题目，超过一半看见没）。既然进行排序，那么我们可以选择快排，这样时间复杂度就是O（NlogN），空间复杂度O（1）.</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 数组排序法，因为多数元素的出现次数超过数组长度一半，\n     * 所以我们可以先对其进行排序，采用快排，时间复杂度O（NlogN）\n     * 然后取数组中点元素即可\n     * @param nums\n     * @return\n     */\n    public static int majorityElement2(int[] nums){\n        quickSort(nums,0,nums.length-1);\n        return nums[nums.length/2];\n    }\n\n    /**\n     * 快排\n     * @param nums\n     * @param low\n     * @param high\n     */\n    public static void quickSort(int[] nums,int low,int high){\n        int base = nums[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //从右向左找到第一个比基准元素小的元素\n            while(L&lt;R&amp;&amp;nums[R]&gt;=base){\n                R--;\n            }\n            if(nums[R]&lt;base){\n                swap(nums,L,R);\n            }\n            //从左向右找到第一个比基准元素大的元素\n            while(L&lt;R&amp;&amp;nums[L]&lt;=base){\n                L++;\n            }\n            if(nums[L]&gt;base){\n                swap(nums,L,R);\n            }\n        }\n        //左递归\n        if(L&gt;low){\n            quickSort(nums,low,L-1);\n        }\n        //右递归\n        if(high&gt;R){\n            quickSort(nums,R+1,high);\n        }\n    }\n\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>摩尔投票法（我将其称为大佬解法）：大概的意思就是采用正负抵消的方法，设置一个投票变量votes，初始设置为0；设置一个本题中的众数变量x，初始设置为数组首元素。然后遍历数组，判断跟设置的众数变量是否相等，如果相等将votes加一，如果不相等，则重置votes为0，且将x设置为数组下一个元素。本题众因为已经声明了肯定存在众数，所以不需要进行验证，但是如果没有声明的话，需要验证，下列代码众添加了验证：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 摩尔投票法\n     * @param nums\n     */\n    public static int majorityElement3(int[] nums){\n        int votes = 0;\n        int x = nums[0];\n        int count = 0;\n        for (int num : nums) {\n            if(votes==0){\n                x = num;\n            }\n            votes+=(num==x)?1:-1;\n        }\n        //验证数组众是否存在众数\n        for (int num : nums) {\n            if(num==x){\n                count++;\n            }\n        }\n        return count&gt;nums.length/2?x:0;\n    }</code></pre>","blogGoods":0,"blogId":"1253674617332162560","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6i5v-AUh39AAAaZr2Bc1U885.jpg","blogRead":0,"blogRemark":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","blogTitle":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","createdTime":"2020-04-24 21:18:14","typeName":"LeetCode","updateTime":"2020-04-24 21:18:14"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，从上到下打印二叉树-2</strong></h2>\n<p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>\n<p>例如:<br />给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>\n<p>3<br />/ \\<br />9 20<br />/ \\<br />15 7<br />返回其层次遍历结果：</p>\n<p>[<br />[3],<br />[9,20],<br />[15,7]<br />]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;BFS（广度优先搜索）：层次遍历</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * BFS\n     * @param root\n     * @return\n     */\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {\n        if (root == null) {\n            return new ArrayList&lt;&gt;(0);\n        }\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();\n        TreeNode current;\n        while (!queue.isEmpty()) {\n            List&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();\n            for (int i = queue.size(); i &gt; 0; i--) {\n                current = queue.poll();\n                arrayList.add(current.val);\n                if (current.left != null) {\n                    queue.add(current.left);\n                }\n                if (current.right != null) {\n                    queue.add(current.right);\n                }\n            }\n            list.add(arrayList);\n        }\n        return list;\n    }</code></pre>","blogGoods":0,"blogId":"1253350612905598976","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6huUyATZJ_AAAaZr2Bc1U363.jpg","blogRead":1,"blogRemark":"剑指offer----之从上到下打印二叉树----LeetCode102","blogTitle":"剑指offer----之从上到下打印二叉树----LeetCode102","createdTime":"2020-04-23 23:50:45","typeName":"LeetCode","updateTime":"2020-04-23 23:50:57"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，从上打印二叉树-1</strong></h2>\n<p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>\n<p>例如:<br />给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>\n<p>3<br />/ \\<br />9 20<br />/ \\<br />15 7<br />返回：</p>\n<p>[3,9,20,15,7]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;BFS（广度优先搜索）：也即是二叉树的层次遍历，代码和注意事项看代码注释</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 二叉树的层次遍历\n     * 这里是将层次遍历的结果存储在数组中\n     * 但是因为二叉树的节点个数并不知道\n     * 所以不能使用数组直接进行存储，因为无法初始化数组的大小\n     * 所以可以想到使用容量能自动扩充的list集合\n     * 然后再根据list集合的size来初始化数组的大小\n     * 并且将list元素赋值到数组中\n     * @param root\n     * @return\n     */\n    public static int[] levelOrder(TreeNode root) {\n        if(root==null){\n            return new int[0];\n        }\n        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n        TreeNode current;\n        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n        while(!queue.isEmpty()){\n            current = queue.poll();\n            list.add(current.val);\n            if(current.left!=null){\n                queue.add(current.left);\n            }\n            if(current.right!=null){\n                queue.add(current.right);\n            }\n        }\n        int[] result = new int[list.size()];\n        for (int i = 0; i &lt; list.size(); i++) {\n            result[i] = list.get(i);\n        }\n        return result;\n    }</code></pre>","blogGoods":0,"blogId":"1253346228108894208","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6htTeAUHGlAAAaZr2Bc1U102.jpg","blogRead":0,"blogRemark":"剑指offer----之从上到下打印二叉树","blogTitle":"剑指offer----之从上到下打印二叉树","createdTime":"2020-04-23 23:33:20","typeName":"LeetCode","updateTime":"2020-04-23 23:33:20"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，包含min函数的栈</strong></h2>\n<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>\n<p>&nbsp;</p>\n<p>示例:</p>\n<p>MinStack minStack = new MinStack();<br />minStack.push(-2);<br />minStack.push(0);<br />minStack.push(-3);<br />minStack.min(); --&gt; 返回 -3.<br />minStack.pop();<br />minStack.top(); --&gt; 返回 0.<br />minStack.min(); --&gt; 返回 -2.</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>&nbsp;辅助栈法：即初始化两个栈A,B</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;A栈用于实现基本的push(),pop(),top()的正常逻辑</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;B栈用来存放A栈中的非严格降序元素（这个我也理解不了，看代码就知道是存放什么的啦），代码中的方法注释很清楚</strong></p>\n<pre class=\"language-java\"><code>public class MinStack {\n    /** initialize your data structure here. */\n    Stack&lt;Integer&gt; A,B;\n\n    public MinStack() {\n        A = new Stack&lt;&gt;();\n        B = new Stack&lt;&gt;();\n    }\n\n    /**\n     * 入栈操作，元素先入A栈\n     * 如果B栈为空或者B栈的栈顶元素大于待入栈元素，则B栈也执行入栈操作\n     * @param x\n     */\n    public void push(int x) {\n        A.add(x);\n        if(B.isEmpty()||B.peek()&gt;=x){\n            B.add(x);\n        }\n    }\n\n    /**\n     * 这段代码优点巧妙\n     * 注意这里使用的A.pop()而不是A.peek()\n     * 所以这里实际上是分为两种情况的\n     * 第一种：当A的栈顶元素不为当前栈中的最小元素，即不等于栈B的栈顶元素\n     *         则只进行栈A的出栈操作，即A.pop()\n     * 第二种：当A的栈顶元素为当前栈中的最小元素，即等于栈B的栈顶元素\n     *        则不仅要A.pop(),而且为了保证A,B栈中最小元素的同步性\n     *        B栈也要执行出栈操作\n     */\n    public void pop() {\n        if(A.pop().equals(B.peek())){\n            B.pop();\n        }\n    }\n\n    /**\n     * 正常获取A的栈顶元素\n     * @return\n     */\n    public int top() {\n        return A.peek();\n    }\n\n    /**\n     * 获取A栈的最小元素，即B栈的栈顶元素\n     * @return\n     */\n    public int min() {\n        return B.peek();\n    }\n}</code></pre>","blogGoods":0,"blogId":"1253331349566234624","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hp12AMy2MAAAaZr2Bc1U568.jpg","blogRead":4,"blogRemark":"剑指offer----之包含min函数的栈---LeetCode155","blogTitle":"剑指offer----之包含min函数的栈---LeetCode155","createdTime":"2020-04-23 22:34:13","typeName":"LeetCode","updateTime":"2020-04-23 23:50:51"},{"blogCollection":0,"blogComment":0,"blogContent":"<h3><strong>晚上九点多，坐在床上，面前摆放着电脑，屏幕显示的是LeetCode中的《剑指offer》的题解</strong></h3>\n<h3><strong>此时的我毫无睡意，当然，这并不是因为解出一道题的喜悦冲淡了我的睡意</strong></h3>\n<h3><strong>相反的，这是一种难以言明的心情，包含着对自己无知的羞愧，也包含着别人面对如此无知的自己也能给出耐心回应的感动</strong></h3>\n<h3><strong>人有时或许就是这样，刻意的举动会让人心生防备，但是无意的善举却能温润人心</strong></h3>\n<h3><strong>别人无意的一个回答，一个小举动，一句肯定的话</strong></h3>\n<h3><strong>殊不知却能为对方赋予无穷无尽的能量</strong></h3>\n<h3><strong>将这一天的疲惫和劳累都消除</strong></h3>\n<h3><strong>赠人玫瑰，手有余香</strong></h3>\n<h3><strong>我一直抱着这样的一种心态，或许我无法做到赠人玫瑰，但是我会尽量将自己的善意展现给别人</strong></h3>\n<h3><strong>也许他刚刚好正处于某个难关，而你又刚刚好是他难关之初的引导者</strong></h3>\n<h3><strong>一句话，或许对于你来说只是人生中微不足道的几秒钟</strong></h3>\n<h3><strong>而对他来说，或许可能是多年之后回忆起来也能嘴角上扬的美好岁月</strong></h3>\n<h3><strong>想起前段时间一部剧里面的话，在这里也送给屏幕前的你：愿你永怀善意，清澈明朗</strong></h3>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1253326423486144512","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hosWANYd2AAHQzo49lBU641.jpg","blogRead":3,"blogRemark":"2020-4-23有感","blogTitle":"2020-4-23有感","createdTime":"2020-04-23 22:14:38","typeName":"随心日记","updateTime":"2020-04-25 21:22:30"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，顺时针打印矩阵</strong></h2>\n<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>\n<p>示例 1：</p>\n<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br />输出：[1,2,3,6,9,8,7,4,5]<br />示例 2：</p>\n<p>输入：matrix =&nbsp;[[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br />输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p>\n<p>限制：</p>\n<p>0 &lt;= matrix.length &lt;= 100<br />0 &lt;= matrix[i].length&nbsp;&lt;= 100</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;模拟顺时针打印的这种循环结构：设置四个边界条件，l,r,t,b。按照从左往右，从上往下，从右往左，从下网往上的顺序依次读取矩阵的元素，并且每一次都判断边界是否相遇，直到将整个矩阵元素都加入到数组中即可。</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 设置四个边界值，分别为left=0,right=matrix[0].length-1,top=0,bottom=matrix.length-1\n     * 顺时针顺序即先从左到右，再从上到下，再从右向左，再从下向上，每一次执行都要判断边界值\n     * @param matrix\n     * @return\n     */\n    public static int[] spiralOrder(int[][] matrix) {\n        if(matrix.length==0){\n            return new int[0];\n        }\n        int l = 0;\n        int r=matrix[0].length-1;\n        int t=0;\n        int b=matrix.length-1;\n        int x=0;\n        int[] res = new int[(r+1)*(b+1)];\n        while(true){\n            //从左向右\n            for(int i=l;i&lt;=r;i++){\n                res[x++]=matrix[t][i];\n            }\n            if(++t&gt;b) {\n                break;\n            }\n            //从上向下\n            for(int i=t;i&lt;=b;i++){\n                res[x++] = matrix[i][r];\n            }\n            if(--r&lt;l){\n                break;\n            }\n            //从右向左\n            for(int i=r;i&gt;=l;i--){\n                res[x++] = matrix[b][i];\n            }\n            if(--b&lt;t){\n                break;\n            }\n            //从下往上\n            for(int i=b;i&gt;=t;i--){\n                res[x++] = matrix[i][l];\n            }\n            if(++l&gt;r){\n                break;\n            }\n        }\n        return res;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1253250557729087488","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hXB2ASIQwAAAaZr2Bc1U016.jpg","blogRead":0,"blogRemark":"剑指offer-----之顺时针打印矩阵----LeetCode54","blogTitle":"剑指offer-----之顺时针打印矩阵----LeetCode54","createdTime":"2020-04-23 17:13:11","typeName":"LeetCode","updateTime":"2020-04-23 17:13:11"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，对称的二叉树</strong></h2>\n<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>\n<p>例如，二叉树&nbsp;[1,2,2,3,4,4,3] 是对称的。</p>\n<p>&nbsp; &nbsp; 1<br />&nbsp; &nbsp;/ \\<br />&nbsp; 2 &nbsp; 2<br />&nbsp;/ \\ / \\<br />3 &nbsp;4 4 &nbsp;3<br />但是下面这个&nbsp;[1,2,2,null,3,null,3] 则不是镜像对称的:</p>\n<p>&nbsp; &nbsp; 1<br />&nbsp; &nbsp;/ \\<br />&nbsp; 2 &nbsp; 2<br />&nbsp; &nbsp;\\ &nbsp; \\<br />&nbsp; &nbsp;3 &nbsp; &nbsp;3</p>\n<p>示例 1：</p>\n<p>输入：root = [1,2,2,3,4,4,3]<br />输出：true<br />示例 2：</p>\n<p>输入：root = [1,2,2,null,3,null,3]<br />输出：false</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>递归法：从对称的二叉树中我们可以找到如下规律</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果一个二叉树是对称的，则每一个节点的左右子树也是对称的,因此是递归的</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 设L = root.left，R=root.right，则满足L.left.val = R.right.val;L.right.val=R.left.val;</strong></p>\n<pre class=\"language-java\"><code>public boolean isSymmetric(TreeNode root) {\n        return  root==null?true:recur(root.left,root.right);\n    }\n    public boolean recur(TreeNode L,TreeNode R){\n        if(L==null&amp;&amp;R==null){\n            return true;\n        }\n        if(L==null||R==null||L.val!=R.val){\n            return false;\n        }\n        return recur(L.left,R.right)&amp;&amp;recur(L.right,R.left);\n    }</code></pre>","blogGoods":0,"blogId":"1252992659794968576","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6ga--AKQdvAAAaZr2Bc1U862.jpg","blogRead":1,"blogRemark":"剑指offer----之对称的二叉树----LeetCode101","blogTitle":"剑指offer----之对称的二叉树----LeetCode101","createdTime":"2020-04-23 00:08:23","typeName":"LeetCode","updateTime":"2020-04-23 00:12:33"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，二叉树镜像</strong></h2>\n<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>\n<p>例如输入：</p>\n<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; 2 &nbsp; &nbsp; 7<br />&nbsp;/ \\ &nbsp; / \\<br />1 &nbsp; 3 6 &nbsp; 9<br />镜像输出：</p>\n<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; 7 &nbsp; &nbsp; 2<br />&nbsp;/ \\ &nbsp; / \\<br />9 &nbsp; 6 3&nbsp; &nbsp;1</p>\n<p>示例 1：</p>\n<p>输入：root = [4,2,7,1,3,6,9]<br />输出：[4,7,2,9,6,3,1]</p>\n<p>限制：</p>\n<p>0 &lt;= 节点个数 &lt;= 1000</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;递归法：即递归的去交换根节点的左右子树，直到根节点为叶子节点</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用递归的方法，交换根节点的左子树和右子树\n     * 递归出口为，根节点为叶子节点\n     * @param root\n     * @return\n     */\n    public TreeNode mirrorTree(TreeNode root) {\n        TreeNode center = root;\n        if(center!=null){\n            TreeNode temp = center.left;\n            center.left = center.right;\n            center.right = temp;\n            mirrorTree(center.left);\n            mirrorTree(center.right);\n        }\n        return root;\n    }</code></pre>","blogGoods":0,"blogId":"1252985443281027072","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6gZTWABF55AAAaZr2Bc1U678.jpg","blogRead":0,"blogRemark":"剑指offer----之二叉树的镜像----LeetCode226","blogTitle":"剑指offer----之二叉树的镜像----LeetCode226","createdTime":"2020-04-22 23:39:43","typeName":"LeetCode","updateTime":"2020-04-22 23:39:43"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，合并两个有序链表</strong></h2>\n<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>\n<p>示例1：</p>\n<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br />输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br />限制：</p>\n<p>0 &lt;= 链表长度 &lt;= 1000</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>伪头节点法：即创建一个伪头节点head和一个用于辅助的节点cur</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法：如果l1.val&lt;=l2.val,就让cur指向l1，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l1指向其next</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果l1.val&gt;l2.val,就让cur指向l2，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l2指向其next</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;直到l1和l2有一个为空为止，让cur指向剩余的一个非空链表即可，若两个链表的长度为M,N则时间复杂度为O(M+N)</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用四节点，一个伪头节点，一个当前节点cur，已经链表的两个节点l1,l2\n     * 每次比较l1,l2节点的val大小，将小的节点连接到当前节点cur上即可\n     * 直到l1,l2有一个空，则将剩余的一个非空链表连接到cur尾部即可\n     * @param l1\n     * @param l2\n     * @return\n     */\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode head;\n        ListNode cur;\n        head = cur = new ListNode(0);\n        while(l1!=null&amp;&amp;l2!=null){\n            if(l1.val&lt;=l2.val){\n                cur.next = l1;\n                cur = cur.next;\n                l1 = l1.next;\n            }else{\n                cur.next = l2;\n                cur = cur.next;\n                l2 = l2.next;\n            }\n        }\n        if(l1!=null){\n            cur.next = l1;\n        }\n        if(l2!=null){\n            cur.next = l2;\n        }\n        return head.next;\n    }</code></pre>","blogGoods":0,"blogId":"1252980258446000128","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6gYGWAe-MZAAAaZr2Bc1U550.jpg","blogRead":0,"blogRemark":"剑指offer----之合并有序链表---LeetCode21","blogTitle":"剑指offer----之合并有序链表---LeetCode21","createdTime":"2020-04-22 23:19:06","typeName":"LeetCode","updateTime":"2020-04-22 23:19:06"}],"pageSize":15,"params":{},"sortColumn":"created_time","sortMethod":"DESC","totalCount":53,"totalPage":4},"msg":"操作成功!"}
2020-04-26 23:38:25.388 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /rotation-picture/listFront
2020-04-26 23:38:25.389 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:38:25.389 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:38:25.389 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.RotationPictureController.getRotationPictureListFront
2020-04-26 23:38:25.389 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:38:25.427 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /admin/getInfo
2020-04-26 23:38:25.427 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/list
2020-04-26 23:38:25.427 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:38:25.427 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:38:25.427 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:38:25.428 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:38:25.428 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.AdminController.getInfo
2020-04-26 23:38:25.428 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogList
2020-04-26 23:38:25.428 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:38:25.429 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=15, totalPage=0, totalCount=0, list=[], params={}, sortColumn=created_time, sortMethod=DESC)]
2020-04-26 23:38:25.482 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 94
2020-04-26 23:38:25.482 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"createdTime":"2020-04-09 13:31:20","enable":1,"rotationId":4,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PI6aAZIz1AASCO4hlpJI295.jpg"},{"createdTime":"2020-04-09 13:37:02","enable":1,"rotationId":9,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJPyAbm8fAAG9gfO8lxE28.jpeg"},{"createdTime":"2020-04-09 13:41:30","enable":1,"rotationId":10,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJgeAeG8wAAS2pjJC5QU547.jpg"},{"createdTime":"2020-04-09 13:41:38","enable":1,"rotationId":11,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhGAQFZbAAP2OOBWb6k310.jpg"},{"createdTime":"2020-04-09 13:41:50","enable":1,"rotationId":12,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhyABMZCAAG7doyXiM8109.jpg"},{"createdTime":"2020-04-09 13:41:59","enable":1,"rotationId":13,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJiWAL7BoAARW3_O3ISw651.jpg"}],"msg":"操作成功!"}
2020-04-26 23:38:25.692 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listFront
2020-04-26 23:38:25.692 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/getTotal
2020-04-26 23:38:25.692 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/recommendRead
2020-04-26 23:38:25.692 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:38:25.692 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:38:25.693 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:38:25.693 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:38:25.692 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:38:25.693 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeLists
2020-04-26 23:38:25.693 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getTotal
2020-04-26 23:38:25.693 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:38:25.693 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:38:25.693 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:38:25.694 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.recommendRead
2020-04-26 23:38:25.694 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:38:25.780 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 353
2020-04-26 23:38:25.782 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，0~n-1中缺失的数字</strong></h2>\n<p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>\n<p>示例 1:</p>\n<p>输入: [0,1,3]<br />输出: 2<br />示例&nbsp;2:</p>\n<p>输入: [0,1,2,3,4,5,6,7,9]<br />输出: 8</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主能想到的并且写出来的方法有：使用map存储数组中的所有元素，然后遍历0-n-1找出不在map中的元素。此种方法时间复杂度O（N），空间复杂度O（N）-----垃圾</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 统计0-n-1所有数字的数字和，再统计数组中所有数字的数字和，两和只差即为所求数字，时间复杂度O（N），空间复杂度O（1）-----垃圾</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;最优解法（二分查找法）：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;通常来说，我们使用二分查找法是查找一个存在于数组中的元素，但是本题需要求不在数组中的一个元素，因此到这很多人就会迷惑，不知道该怎么求了。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;但是我们首先要搞明白二分查找法的本质是什么：1，并不局限于仅仅查找存在于数组中的元素；2，二分查找的本质是对数组根据mid中间值在某一条件上进行二分（例如：通常的num[mid]&gt;target或者nums[mid]&lt;target进行左右切分）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;因此明白这一点，就好解决问题了。拿到这道题，使用二分，我们首先想到的应该是寻找根据mid中间值进行二分的条件</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;审题：题目中提及数组为递增数组，而且0-n-1内的n个数字有一个不在数组中，则不在的这个数字之前的数字满足nums[i]=i即元素本身等于数组下标，而之后的数字nums[i]!=i,所以这就是进行二分的条件了</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 二分查找法\n     * 算法思想：二分查找法的本质是能够有一个条件将数组根据mid中间值进行左右切分\n     * 所以我们想到二分查找法之后，首先需要做的是找出切分数组的条件\n     * 题目中给出了数组是一个递增数组，且0-n-1内的n个数字有一个不在这个长度为n-1的数组内\n     * 因此，不在的这个元素其左边元素必有数组下标值等于元素本身即nums[i]=i\n     * 而不在的这个元素的右边必有nums[i]!=i\n     * 所以根据此条件进行划分数组即可\n     * @param nums\n     * @return\n     */\n    public static int missingNumber(int[] nums) {\n        int low = 0;\n        int high = nums.length-1;\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]==mid){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        return low;\n    }</code></pre>","blogGoods":0,"blogId":"1254063045920022528","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kUM-AON88AAAaZr2Bc1U903.jpg","blogRead":0,"blogRemark":"剑指offer----0~n-1中缺失的数字","blogTitle":"剑指offer----0~n-1中缺失的数字","createdTime":"2020-04-25 23:01:44","typeName":"LeetCode","updateTime":"2020-04-25 23:01:44"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，在排序数组中查找数字I</strong></h2>\n<p>统计一个数字在排序数组中出现的次数。</p>\n<p>示例 1:</p>\n<p>输入: nums = [5,7,7,8,8,10], target = 8<br />输出: 2<br />示例&nbsp;2:</p>\n<p>输入: nums = [5,7,7,8,8,10], target = 6<br />输出: 0</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解法一：直接遍历统计，时间复杂度为O（N）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 遍历数组\n     * 找到第一个与目标元素相等的元素，res+1\n     * 然后往后找到第一个与目标元素不相等的元素,返回res即可\n     * 时间复杂度为O(N)\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static int search(int[] nums, int target) {\n        int res = 0;\n        for (int num : nums) {\n            if(num==target){\n                res++;\n            }\n        }\n        return res;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解法二：二分法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：利用二分法查找数字在排序数组中的左边界Left和右边界Right.如下，如果要寻找数组中的8，则其左边界为left=2,有边界right=5.所以出现次数为right-left-1.时间复杂度为O（logN）</strong></p>\n<table style=\"width: 20%; border-collapse: collapse; margin-left: auto; margin-right: auto;\" border=\"1\" cellpadding=\"5\">\n<tbody>\n<tr>\n<td style=\"width: 16.6667%;\">5</td>\n<td style=\"width: 16.6667%;\">7</td>\n<td style=\"width: 16.6667%;\">7</td>\n<td style=\"width: 16.6667%;\">8</td>\n<td style=\"width: 16.6667%;\">8</td>\n<td style=\"width: 16.6667%;\">10</td>\n</tr>\n</tbody>\n</table>\n<pre class=\"language-java\"><code>    /**\n     * 二分查找法\n     * 时间复杂度为O（logN）\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static int search2(int[] nums, int target){\n        int low = 0;\n        int high = nums.length-1;\n        int left,right;\n        left = right = 0;\n        //一次二分\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]&lt;=target){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        right = low;\n\n        low = 0;\n        high = nums.length -1;\n        //二次二分\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]&lt;target){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        left = high;\n        return right -left -1;\n    }</code></pre>","blogGoods":0,"blogId":"1254055163115724800","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kSXiAYRyFAAAaZr2Bc1U379.jpg","blogRead":0,"blogRemark":"剑指offer----在排序数组中查找数字I----LeetCode34","blogTitle":"剑指offer----在排序数组中查找数字I----LeetCode34","createdTime":"2020-04-25 22:30:24","typeName":"LeetCode","updateTime":"2020-04-25 22:30:24"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，两个链表的第一个公共节点</strong></h2>\n<p><strong><img src=\"https://images-cdn.shimo.im/Wd1NC8pveQYp9iIL.png__thumbnail\" alt=\"示例图\" width=\"742\" height=\"241\" /></strong></p>\n<p><strong>这是我从官方截下的一张图，也是有些人疑惑的地方，因为官方这张图给出的公共节点为8，而大多数人看到这张图，认为公共节点应该是1.</strong></p>\n<p><strong>但是实际上这里的公共节点不仅要节点的value相等，同时还需要节点的地址相等。从图中可以看出两个1节点虽然值相等，但是地址却不同，因而不是公共节点</strong></p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解法一：双指针</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：初始化两个指针p1=headA,p2=headB</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;分别遍历两个链表，求出两个链表的长度l1,l2</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;然后重置p1,p2指针指向头节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;让长链表的指针先走多的步数（l1-l2或者l2-l1）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;然后让两个指针同时走，直到两者相遇，即找到公共节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解疑：弄清楚第一个value相等的节点和指针相遇的节点，这两种节点是不同的，指针相遇的节点，不仅包含value相等，同时地址也相等。（如图中的8）；而第一个value相等的节点则可能并不在同一个地址，因此不一定是公共节点</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法\n     * @param headA\n     * @param headB\n     * @return\n     */\n    public static ListNode getIntersectionNode2(ListNode headA, ListNode headB){\n        ListNode p1 =headA;\n        ListNode p2 = headB;\n        int l1 = 0;\n        int l2 = 0;\n        //计算链表1的长度\n        while(p1!=null){\n            l1++;\n            p1 = p1.next;\n        }\n        //计算链表2的长度\n        while(p2!=null){\n            l2++;\n            p2 = p2.next;\n        }\n        p1 = headA;\n        p2 = headB;\n        //让长链表指针先走长的步数\n        if(l1&gt;l2){\n            for (int i = 0; i &lt; l1-l2; i++) {\n                p1 = p1.next;\n            }\n        }else{\n            for (int i = 0; i &lt; l2-l1; i++) {\n                p2 = p2.next;\n            }\n        }\n        //然后让两个指针同时走，直到相遇\n        while(p1!=p2){\n            p1 = p1.next;\n            p2 = p2.next;\n        }\n        return p1;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;解法二（大神解法）：丘比特相遇法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;利用两个指针p1=headA,p2=headB,让两个指针同时走，</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果p1先走到底，就将p1置为headB，</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果p2,先走到底，就将p2置为headA,</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;当两个指针相遇的时候，他们就相爱了（当然是找到公共节点了）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法p1=headA,p2=headB\n     * 思想是：两个节点同时从各自的链表出发\n     * p1走到末尾时，回到headB的头部\n     * p2走到末尾时，回到headA的头部\n     * 两个指针相遇的时候，即使要找的公共节点\n     * @param headA\n     * @param headB\n     * @return\n     */\n    public static ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode p1 = headA;\n        ListNode p2 = headB;\n        while(p1!=p2){\n            p1 = (p1==null)?headB:p1.next;\n            p2 = (p2==null)?headA:p2.next;\n        }\n        return p1;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1253992797703364608","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kD2OADD3mAAAaZr2Bc1U709.jpg","blogRead":0,"blogRemark":"剑指offer----之两个链表的第一个公共节点----LeetCode160","blogTitle":"剑指offer----之两个链表的第一个公共节点----LeetCode160","createdTime":"2020-04-25 18:22:35","typeName":"LeetCode","updateTime":"2020-04-25 18:22:35"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，第一个只出现一次的字符</strong></h2>\n<p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。</p>\n<p>示例:</p>\n<p>s = \"abaccdeff\"<br />返回 \"b\"</p>\n<p>s = \"\" <br />返回 \" \"</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主现在发现，做一道算法题的时候，最重要的一步就是读题，审题，在草稿纸上写下自己的思路（当然那种望眼欲穿的大佬除外）。然后才开始动笔，对于IT人来说，真的，多将时间花费在思考上面，而不是无意义的重复搬砖。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;题目分析：看到这道题，抓住两个关键字：第一个，只出现一次。什么意思呢，例如\"abaccdeff\"，其中只出现一次的字符有'b','d','e'三个，然后在三个字符中第一个出现在字符串中的是'b'，因此本题的答案是'b'.</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法分析：根据题目分析，我们最直观的解法应该是，先找出字符串中只出现一次的字符，然后再找出只出现一次字符中，第一个在字符串中出现的。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;所以我们需要做两件事，一是统计字符串中各个字符的出现次数，并且记录；二，统计完毕后，找出第一个出现次数为1的字符，返回即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;因此我们既要存字符，还要存字符对应的出现次数，所以理所当然我们选择map集合。当然对于本题而言，因为求第一个出现一次的字符，所以我们更好的是可以使用LinkedHashMap。这样免去最后的一次遍历字符串</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;下面提供两种解法：三种解法都是使用map集合，但是略有不同</strong></p>\n<p><strong>LinkedHashMap：（这是博主写的，代码冗余，这里用来和大神的写法做比较，警醒自己）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 用LinkedHashMap\n     * 思想：遍历字符串，如果map为空或者map中不含当前字符，则将其存入map\n     * 如果map中已经含有当前字符，则从map中移除\n     * 最终map中只剩出现一次的字符\n     * 返货map中的第一个即可\n     * @param s\n     * @return\n     */\n    public static char firstUniqChar(String s) {\n        Map&lt;Character,Integer&gt;map = new LinkedHashMap&lt;&gt;();\n        for (int i = 0; i &lt; s.length(); i++) {\n            char ch = s.charAt(i);\n            if(map.isEmpty()||!map.containsKey(ch)){\n                map.put(ch,1);\n            }else{\n                Integer val = map.get(ch);\n                map.put(ch,++val);\n            }\n        }\n        //返回map中第一个元素即可\n        Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entries = map.entrySet();\n        for (Map.Entry&lt;Character, Integer&gt; entry : entries) {\n            if(entry.getValue()==1){\n                return entry.getKey();\n            }\n        }\n        return ' ';\n    }</code></pre>\n<p><strong>HashMap（大神解法）：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 哈希表法\n     * @param s\n     * @return\n     */\n    public char firstUniqChar2(String s) {\n        Map&lt;Character,Boolean&gt; map = new HashMap&lt;&gt;();\n        char[] chars = s.toCharArray();\n        for (char ch : chars) {\n            map.put(ch,!map.containsKey(ch));\n        }\n        for (char ch : chars) {\n            if(map.get(ch)){\n                return ch;\n            }\n        }\n        return ' ';\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;分析：首先，这里提供了两种解法，一种为LinkedHashMap，一种为HashMap，这两种解法的不同之处就在于最后获取值的时候，LinkedHashMap获取最终值是遍历LinkedHashMap的entrySet，但是HashMap获取最终值是遍历原字符串。因而当数据庞大的时候，显然使用LinkedHashMap性能更高。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;然后，再分析一下这两种解法不另外一个不同之处，没错！就是大神的解法中使用map存放key对应的value值是Boolean型！（<span style=\"background-color: #ffcc00;\">这个真的是神一般的存在</span>），既省去了计算次数的麻烦，同时最后取的时候也不需要判断次数。wc！同一种解法，为什么天差地别！</strong></p>","blogGoods":0,"blogId":"1253956468789600256","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6j7Y6ACrySAAAaZr2Bc1U825.jpg","blogRead":0,"blogRemark":"剑指offer----第一次只出现一次的字符","blogTitle":"剑指offer----第一次只出现一次的字符","createdTime":"2020-04-25 15:58:14","typeName":"LeetCode","updateTime":"2020-04-25 15:58:14"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，连续子数组的最大和</strong></h2>\n<p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>\n<p>要求时间复杂度为O(n)。</p>\n<p>示例1:</p>\n<p>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br />输出: 6<br />解释:&nbsp;连续子数组&nbsp;[4,-1,2,1] 的和最大，为&nbsp;6。</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;看到这道题，最简单的想法肯定是求出所有连续子数组的值，然后进行比较，找出最大的即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;但是随后会想到既然要找出所有的子数组，那么我们可以使用分治的思想，因为分治的分过程即可以得到所有子序列</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;随后，再深一步，既然可以分治的思想，分的过程即是递归的过程，而且子数组的最大值依赖与前一子数组，所以可以想到使用动态规划</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：设dp[i]为以nums[i]为结尾的最大子数组和，初始值dp[0] = nums[0]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;遍历数组，如果dp[i-1]&gt;=0。则说明前面的最大子数组对当前子数组有增益效果，所以dp[i] = dp[i-1]+nums[i]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果dp[i-1]&lt;0。说明前面的最大子数组对当前子数组有夫负效果，还不如nums[i]本身，所以dp[i]=nums[i]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主的这样的写法：时间复杂度为O（N），空间复杂度也为O（N），但是实际上不需要使用dp数组，使用nums原数组就行，所以可以减小空间复杂度为O（1）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 动态规划\n     * 算法思想：因为求的是连续子数组的最大和\n     * 所以我们可以设dp[i]为以nums[i]结尾的最大连续子数组\n     * 如果dp[i]&lt;=nums[i],dp[i]=nums[i]\n     * 如果dp[i]&gt;nums[i],则dp[i]=dp[i]+nums[i]\n     * @param nums\n     * @return\n     */\n    public static int maxSubArray(int[] nums) {\n        int[] dp  = new int[nums.length];\n        dp[0] = nums[0];\n        int res = nums[0];\n        for (int i = 1; i &lt; nums.length; i++) {\n            if(dp[i-1]&lt;0){\n                dp[i] = nums[i];\n            }else{\n                dp[i] = dp[i-1]+nums[i];\n            }\n            res = Math.max(res,dp[i]);\n        }\n        return res;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1253938714590175232","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6j3QSACLxRAAAaZr2Bc1U017.jpg","blogRead":0,"blogRemark":"剑指offer---连续子数组的最大和---LeetCode53","blogTitle":"剑指offer---连续子数组的最大和---LeetCode53","createdTime":"2020-04-25 14:47:41","typeName":"LeetCode","updateTime":"2020-04-25 14:47:41"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，最小的k个数</strong></h2>\n<p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>\n<p>示例 1：</p>\n<p>输入：arr = [3,2,1], k = 2<br />输出：[1,2] 或者 [2,1]<br />示例 2：</p>\n<p>输入：arr = [0,1,2,1], k = 1<br />输出：[0]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;1,可以采用快排的思想，将原数组按照升序排序，然后取出前k个数即可，时间复杂度为O（NlogN）。但是其实跟API中的sort方法好像差别不大</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 对原数组升序排序，然后取前k个元素\n     * @param arr\n     * @param k\n     * @return\n     */\n    public static int[] getLeastNumbers(int[] arr, int k) {\n        quickSort(arr,0,arr.length-1);\n        int[] result = new int[k];\n        for (int i = 0; i &lt; k; i++) {\n            result[i] = arr[i];\n        }\n        return result;\n    }\n\n    /**\n     * 快排\n     * @param nums\n     * @param low\n     * @param high\n     */\n    public static void quickSort(int[] nums,int low,int high){\n        int base = nums[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //先从右向左找到第一个小于基准元素的元素\n            while(L&lt;R&amp;&amp;nums[R]&gt;=base){\n                R--;\n            }\n            if(nums[R]&lt;base){\n                swap(nums,L,R);\n            }\n            //再从左向右找到第一个大于基准元素的元素\n            while(L&lt;R&amp;&amp;nums[L]&lt;=base){\n                L++;\n            }\n            if(nums[L]&gt;base){\n                swap(nums,L,R);\n            }\n        }\n        //左递归\n        if(L&gt;low){\n            quickSort(nums,low,L-1);\n        }\n        //右递归\n        if(high&gt;R){\n            quickSort(nums,R+1,high);\n        }\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>2，堆排序：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;先讲解一下堆排序：堆排序是一种完全二叉树的结构，常见的存在两种堆结构，小根堆（即满足arr[2i+1]&gt;=arr[i]&amp;&amp;arr[2i+2]&gt;=arr[i]），大根堆（即满足arr[2i+1]&lt;=arr[i]&amp;&amp;arr[2i+2]&lt;=arr[i]）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;基本算法思想：第一步，初始化堆，即堆初始化为大根堆或者小根堆（这里我们简称调整堆）；第二步，将堆顶元素与堆的末尾元素进行交换，然后重新调整堆。在java中堆通常用来实现优先级队列PriorityQueue(默认的采用小根堆，若想使用大根堆，需要在创建时实现comparator)</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;使用情况：这里以java中的优先级队列为例，堆的使用情况不能按照堆名断章取义，例如小根堆实际上是将元素升序存放，因为在算法第二步中将堆顶元素与末尾元素进行交换，然后重新调整，交换的堆顶元素为最小元素，也是最先从堆中进入队列的。所以小根堆适用于TOPk大的算法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;相反的，大根堆适用于TOPk小的算法，下面分别给出小根堆和大根堆的算法：</strong></p>\n<p><strong>小根堆：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 堆排序---小根堆\n     * @param nums\n     */\n    public static void HeapSort(int[] nums){\n        //先初始化堆\n        for (int i = nums.length/2-1; i &gt;=0 ; i--) {\n            adjustHeap(nums,i,nums.length);\n        }\n        //交换堆顶与末尾节点+重新调整为小根堆\n        for (int i = nums.length-1; i &gt;0; i--) {\n            //先交换\n            swap(nums,0,i);\n            //再调整\n            adjustHeap(nums,0,i);\n        }\n    }\n\n    /**\n     * 调整为小根堆\n     * @param nums\n     * @param i\n     * @param length\n     */\n    public static void adjustHeap(int[] nums,int i,int length){\n        int temp = nums[i];\n        for (int j = 2*i+1; j &lt; length; j=2*j+1) {\n            //找出左右节点中的最小值\n            if(j+1&lt;length&amp;&amp;nums[j]&gt;nums[j+1]){\n                j++;\n            }\n            if(nums[j]&lt;temp){\n                nums[i] = nums[j];\n                i = j;\n            }\n        }\n        nums[i] = temp;\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p><strong>大根堆：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 堆排序---大根堆\n     * @param nums\n     */\n    public static void heapSort(int[] nums){\n\n        //初始化堆的过程\n        for (int i = nums.length/2-1; i &gt;=0; i--) {\n            adjustHeap(nums,i,nums.length);\n        }\n        //调整+交换堆顶和末尾的元素\n        for (int i = nums.length-1; i &gt;0; i--) {\n            //先交换，再重新调整\n            swap(nums,0,i);\n            adjustHeap(nums,0,i);\n        }\n    }\n\n    /**\n     * 调整大顶堆的过程\n     * @param nums\n     * @param i\n     * @param length\n     */\n    public static void adjustHeap(int[] nums,int i,int length){\n        int temp = nums[i];\n        for (int j = 2*i+1; j &lt; length; j=2*j+1) {\n            //找出左右节点中的最大值\n            if(j+1&lt;length&amp;&amp;nums[j]&lt;nums[j+1]){\n                j++;\n            }\n            if(nums[j]&gt;temp){\n                nums[i] = nums[j];\n                i = j;\n            }\n        }\n        nums[i] = temp;\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>本题利用大根堆解法，且使用java中自带的优先级队列PriorityQueue：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用堆数据结构，java中的优先级队列对应着最小堆\n     * 实现其comparator即可\n     * @param arr\n     * @param k\n     * @return\n     */\n    public static int[] getLeastNumbers2(int[] arr, int k){\n        Queue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(k,(v1,v2)-&gt;v2-v1);\n        for (int i : arr) {\n            if(heap.isEmpty()||heap.size()&lt;k||i&lt;heap.peek()){\n                heap.offer(i);\n            }\n            if(heap.size()&gt;k){\n                heap.poll();\n            }\n        }\n        int[] result = new int[k];\n        int j = 0;\n        for (Integer val : heap) {\n            result[j++] = val;\n        }\n        return result;\n    }</code></pre>","blogGoods":0,"blogId":"1253874832811089920","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6joYWAF3oqAAAaZr2Bc1U671.jpg","blogRead":2,"blogRemark":"剑指offer----之最小的k个数","blogTitle":"剑指offer----之最小的k个数","createdTime":"2020-04-25 10:33:50","typeName":"LeetCode","updateTime":"2020-04-25 11:53:15"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，数组中出现次数超过一半的元素---即众数</strong></h2>\n<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>\n<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>\n<p>示例&nbsp;1:</p>\n<p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br />输出: 2</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>方法有三：哈希表统计法，数组排序法，摩尔投票法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;哈希统计法：时间复杂度O（N），空间复杂度O（N）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 博主刚开始看到这道题的时候，首先想到的是哈希表统计法，因为博主想的是要找到众数，那么肯定得统计每个数字的出现次数，然后按照次数比较。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 单单是想到这些，用了map集合之后发现还是不行，因为即便用map集合统计出了每个数字和其对应的出现次数之后，你会发现没有办法按照出现的次数进行比较并且得到次数最多的数字（众数</strong><strong>）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 然后，就又审了一遍题目，结果发现了一个本题很关键的点，（<span style=\"background-color: #ffcc00;\">数组中有一个数字出现的次数超过数组长度的一半</span>），也就是说数组中有且仅有一个数字的出现次数会超过数组长度的一半（别笑博主笨，我是真的刚开始没反应过来）</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 那么我为什么要把数组中的所有元素和其次数全部存放进入map集合，然后再取次数进行比较呢？我为什么不在将元素和其次数存入集合的过程中判断次数是否已经超过数组长度的一半了呢？如果超过一半了，那它肯定是众数了呀！</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 思路：根据题意需要找出两个东西，一是多素元素，二是多素元素的出现次数\n     * 所以我们首先想到的是采用map集合\n     * 然后遍历数组，如果元素不存在与集合中，我们就将其加入map，value置为1\n     * 如果元素存在于map中，则我们取出其value将其加1与数组长度的一半做比较\n     * 如果大于数组长度一半，直接返回该元素即可\n     * 小于数组长度一半，则将其value加1存入map覆盖原有的值即可\n     *\n     * @param nums\n     * @return\n     */\n    public static int majorityElement(int[] nums) {\n        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(nums.length);\n        for (int num : nums) {\n            if(!map.containsKey(num)){\n                map.put(num,1);\n            }else{\n                Integer val = map.get(num);\n                if(++val&gt;nums.length/2){\n                    return num;\n                }else{\n                    map.put(num,val);\n                }\n            }\n        }\n        throw new RuntimeException(\"\");\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>数组排序法：由题可知，数组众必然存在一个多数元素，且出现次数超过数组长度的一半。所以我们可以对原数组进行排序，然后取数组中间的元素即可。（我擦，我当时看到这个，就在想，好简单，这个思路，但是我为什么没想到，对，因为我没有仔细的分析题目，超过一半看见没）。既然进行排序，那么我们可以选择快排，这样时间复杂度就是O（NlogN），空间复杂度O（1）.</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 数组排序法，因为多数元素的出现次数超过数组长度一半，\n     * 所以我们可以先对其进行排序，采用快排，时间复杂度O（NlogN）\n     * 然后取数组中点元素即可\n     * @param nums\n     * @return\n     */\n    public static int majorityElement2(int[] nums){\n        quickSort(nums,0,nums.length-1);\n        return nums[nums.length/2];\n    }\n\n    /**\n     * 快排\n     * @param nums\n     * @param low\n     * @param high\n     */\n    public static void quickSort(int[] nums,int low,int high){\n        int base = nums[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //从右向左找到第一个比基准元素小的元素\n            while(L&lt;R&amp;&amp;nums[R]&gt;=base){\n                R--;\n            }\n            if(nums[R]&lt;base){\n                swap(nums,L,R);\n            }\n            //从左向右找到第一个比基准元素大的元素\n            while(L&lt;R&amp;&amp;nums[L]&lt;=base){\n                L++;\n            }\n            if(nums[L]&gt;base){\n                swap(nums,L,R);\n            }\n        }\n        //左递归\n        if(L&gt;low){\n            quickSort(nums,low,L-1);\n        }\n        //右递归\n        if(high&gt;R){\n            quickSort(nums,R+1,high);\n        }\n    }\n\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>摩尔投票法（我将其称为大佬解法）：大概的意思就是采用正负抵消的方法，设置一个投票变量votes，初始设置为0；设置一个本题中的众数变量x，初始设置为数组首元素。然后遍历数组，判断跟设置的众数变量是否相等，如果相等将votes加一，如果不相等，则重置votes为0，且将x设置为数组下一个元素。本题众因为已经声明了肯定存在众数，所以不需要进行验证，但是如果没有声明的话，需要验证，下列代码众添加了验证：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 摩尔投票法\n     * @param nums\n     */\n    public static int majorityElement3(int[] nums){\n        int votes = 0;\n        int x = nums[0];\n        int count = 0;\n        for (int num : nums) {\n            if(votes==0){\n                x = num;\n            }\n            votes+=(num==x)?1:-1;\n        }\n        //验证数组众是否存在众数\n        for (int num : nums) {\n            if(num==x){\n                count++;\n            }\n        }\n        return count&gt;nums.length/2?x:0;\n    }</code></pre>","blogGoods":0,"blogId":"1253674617332162560","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6i5v-AUh39AAAaZr2Bc1U885.jpg","blogRead":0,"blogRemark":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","blogTitle":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","createdTime":"2020-04-24 21:18:14","typeName":"LeetCode","updateTime":"2020-04-24 21:18:14"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，从上到下打印二叉树-2</strong></h2>\n<p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>\n<p>例如:<br />给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>\n<p>3<br />/ \\<br />9 20<br />/ \\<br />15 7<br />返回其层次遍历结果：</p>\n<p>[<br />[3],<br />[9,20],<br />[15,7]<br />]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;BFS（广度优先搜索）：层次遍历</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * BFS\n     * @param root\n     * @return\n     */\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {\n        if (root == null) {\n            return new ArrayList&lt;&gt;(0);\n        }\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();\n        TreeNode current;\n        while (!queue.isEmpty()) {\n            List&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();\n            for (int i = queue.size(); i &gt; 0; i--) {\n                current = queue.poll();\n                arrayList.add(current.val);\n                if (current.left != null) {\n                    queue.add(current.left);\n                }\n                if (current.right != null) {\n                    queue.add(current.right);\n                }\n            }\n            list.add(arrayList);\n        }\n        return list;\n    }</code></pre>","blogGoods":0,"blogId":"1253350612905598976","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6huUyATZJ_AAAaZr2Bc1U363.jpg","blogRead":1,"blogRemark":"剑指offer----之从上到下打印二叉树----LeetCode102","blogTitle":"剑指offer----之从上到下打印二叉树----LeetCode102","createdTime":"2020-04-23 23:50:45","typeName":"LeetCode","updateTime":"2020-04-23 23:50:57"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，从上打印二叉树-1</strong></h2>\n<p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>\n<p>例如:<br />给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>\n<p>3<br />/ \\<br />9 20<br />/ \\<br />15 7<br />返回：</p>\n<p>[3,9,20,15,7]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;BFS（广度优先搜索）：也即是二叉树的层次遍历，代码和注意事项看代码注释</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 二叉树的层次遍历\n     * 这里是将层次遍历的结果存储在数组中\n     * 但是因为二叉树的节点个数并不知道\n     * 所以不能使用数组直接进行存储，因为无法初始化数组的大小\n     * 所以可以想到使用容量能自动扩充的list集合\n     * 然后再根据list集合的size来初始化数组的大小\n     * 并且将list元素赋值到数组中\n     * @param root\n     * @return\n     */\n    public static int[] levelOrder(TreeNode root) {\n        if(root==null){\n            return new int[0];\n        }\n        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n        TreeNode current;\n        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n        while(!queue.isEmpty()){\n            current = queue.poll();\n            list.add(current.val);\n            if(current.left!=null){\n                queue.add(current.left);\n            }\n            if(current.right!=null){\n                queue.add(current.right);\n            }\n        }\n        int[] result = new int[list.size()];\n        for (int i = 0; i &lt; list.size(); i++) {\n            result[i] = list.get(i);\n        }\n        return result;\n    }</code></pre>","blogGoods":0,"blogId":"1253346228108894208","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6htTeAUHGlAAAaZr2Bc1U102.jpg","blogRead":0,"blogRemark":"剑指offer----之从上到下打印二叉树","blogTitle":"剑指offer----之从上到下打印二叉树","createdTime":"2020-04-23 23:33:20","typeName":"LeetCode","updateTime":"2020-04-23 23:33:20"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，包含min函数的栈</strong></h2>\n<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>\n<p>&nbsp;</p>\n<p>示例:</p>\n<p>MinStack minStack = new MinStack();<br />minStack.push(-2);<br />minStack.push(0);<br />minStack.push(-3);<br />minStack.min(); --&gt; 返回 -3.<br />minStack.pop();<br />minStack.top(); --&gt; 返回 0.<br />minStack.min(); --&gt; 返回 -2.</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>&nbsp;辅助栈法：即初始化两个栈A,B</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;A栈用于实现基本的push(),pop(),top()的正常逻辑</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;B栈用来存放A栈中的非严格降序元素（这个我也理解不了，看代码就知道是存放什么的啦），代码中的方法注释很清楚</strong></p>\n<pre class=\"language-java\"><code>public class MinStack {\n    /** initialize your data structure here. */\n    Stack&lt;Integer&gt; A,B;\n\n    public MinStack() {\n        A = new Stack&lt;&gt;();\n        B = new Stack&lt;&gt;();\n    }\n\n    /**\n     * 入栈操作，元素先入A栈\n     * 如果B栈为空或者B栈的栈顶元素大于待入栈元素，则B栈也执行入栈操作\n     * @param x\n     */\n    public void push(int x) {\n        A.add(x);\n        if(B.isEmpty()||B.peek()&gt;=x){\n            B.add(x);\n        }\n    }\n\n    /**\n     * 这段代码优点巧妙\n     * 注意这里使用的A.pop()而不是A.peek()\n     * 所以这里实际上是分为两种情况的\n     * 第一种：当A的栈顶元素不为当前栈中的最小元素，即不等于栈B的栈顶元素\n     *         则只进行栈A的出栈操作，即A.pop()\n     * 第二种：当A的栈顶元素为当前栈中的最小元素，即等于栈B的栈顶元素\n     *        则不仅要A.pop(),而且为了保证A,B栈中最小元素的同步性\n     *        B栈也要执行出栈操作\n     */\n    public void pop() {\n        if(A.pop().equals(B.peek())){\n            B.pop();\n        }\n    }\n\n    /**\n     * 正常获取A的栈顶元素\n     * @return\n     */\n    public int top() {\n        return A.peek();\n    }\n\n    /**\n     * 获取A栈的最小元素，即B栈的栈顶元素\n     * @return\n     */\n    public int min() {\n        return B.peek();\n    }\n}</code></pre>","blogGoods":0,"blogId":"1253331349566234624","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hp12AMy2MAAAaZr2Bc1U568.jpg","blogRead":4,"blogRemark":"剑指offer----之包含min函数的栈---LeetCode155","blogTitle":"剑指offer----之包含min函数的栈---LeetCode155","createdTime":"2020-04-23 22:34:13","typeName":"LeetCode","updateTime":"2020-04-23 23:50:51"},{"blogCollection":0,"blogComment":0,"blogContent":"<h3><strong>晚上九点多，坐在床上，面前摆放着电脑，屏幕显示的是LeetCode中的《剑指offer》的题解</strong></h3>\n<h3><strong>此时的我毫无睡意，当然，这并不是因为解出一道题的喜悦冲淡了我的睡意</strong></h3>\n<h3><strong>相反的，这是一种难以言明的心情，包含着对自己无知的羞愧，也包含着别人面对如此无知的自己也能给出耐心回应的感动</strong></h3>\n<h3><strong>人有时或许就是这样，刻意的举动会让人心生防备，但是无意的善举却能温润人心</strong></h3>\n<h3><strong>别人无意的一个回答，一个小举动，一句肯定的话</strong></h3>\n<h3><strong>殊不知却能为对方赋予无穷无尽的能量</strong></h3>\n<h3><strong>将这一天的疲惫和劳累都消除</strong></h3>\n<h3><strong>赠人玫瑰，手有余香</strong></h3>\n<h3><strong>我一直抱着这样的一种心态，或许我无法做到赠人玫瑰，但是我会尽量将自己的善意展现给别人</strong></h3>\n<h3><strong>也许他刚刚好正处于某个难关，而你又刚刚好是他难关之初的引导者</strong></h3>\n<h3><strong>一句话，或许对于你来说只是人生中微不足道的几秒钟</strong></h3>\n<h3><strong>而对他来说，或许可能是多年之后回忆起来也能嘴角上扬的美好岁月</strong></h3>\n<h3><strong>想起前段时间一部剧里面的话，在这里也送给屏幕前的你：愿你永怀善意，清澈明朗</strong></h3>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1253326423486144512","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hosWANYd2AAHQzo49lBU641.jpg","blogRead":3,"blogRemark":"2020-4-23有感","blogTitle":"2020-4-23有感","createdTime":"2020-04-23 22:14:38","typeName":"随心日记","updateTime":"2020-04-25 21:22:30"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，顺时针打印矩阵</strong></h2>\n<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>\n<p>示例 1：</p>\n<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br />输出：[1,2,3,6,9,8,7,4,5]<br />示例 2：</p>\n<p>输入：matrix =&nbsp;[[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br />输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p>\n<p>限制：</p>\n<p>0 &lt;= matrix.length &lt;= 100<br />0 &lt;= matrix[i].length&nbsp;&lt;= 100</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;模拟顺时针打印的这种循环结构：设置四个边界条件，l,r,t,b。按照从左往右，从上往下，从右往左，从下网往上的顺序依次读取矩阵的元素，并且每一次都判断边界是否相遇，直到将整个矩阵元素都加入到数组中即可。</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 设置四个边界值，分别为left=0,right=matrix[0].length-1,top=0,bottom=matrix.length-1\n     * 顺时针顺序即先从左到右，再从上到下，再从右向左，再从下向上，每一次执行都要判断边界值\n     * @param matrix\n     * @return\n     */\n    public static int[] spiralOrder(int[][] matrix) {\n        if(matrix.length==0){\n            return new int[0];\n        }\n        int l = 0;\n        int r=matrix[0].length-1;\n        int t=0;\n        int b=matrix.length-1;\n        int x=0;\n        int[] res = new int[(r+1)*(b+1)];\n        while(true){\n            //从左向右\n            for(int i=l;i&lt;=r;i++){\n                res[x++]=matrix[t][i];\n            }\n            if(++t&gt;b) {\n                break;\n            }\n            //从上向下\n            for(int i=t;i&lt;=b;i++){\n                res[x++] = matrix[i][r];\n            }\n            if(--r&lt;l){\n                break;\n            }\n            //从右向左\n            for(int i=r;i&gt;=l;i--){\n                res[x++] = matrix[b][i];\n            }\n            if(--b&lt;t){\n                break;\n            }\n            //从下往上\n            for(int i=b;i&gt;=t;i--){\n                res[x++] = matrix[i][l];\n            }\n            if(++l&gt;r){\n                break;\n            }\n        }\n        return res;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1253250557729087488","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hXB2ASIQwAAAaZr2Bc1U016.jpg","blogRead":0,"blogRemark":"剑指offer-----之顺时针打印矩阵----LeetCode54","blogTitle":"剑指offer-----之顺时针打印矩阵----LeetCode54","createdTime":"2020-04-23 17:13:11","typeName":"LeetCode","updateTime":"2020-04-23 17:13:11"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，对称的二叉树</strong></h2>\n<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>\n<p>例如，二叉树&nbsp;[1,2,2,3,4,4,3] 是对称的。</p>\n<p>&nbsp; &nbsp; 1<br />&nbsp; &nbsp;/ \\<br />&nbsp; 2 &nbsp; 2<br />&nbsp;/ \\ / \\<br />3 &nbsp;4 4 &nbsp;3<br />但是下面这个&nbsp;[1,2,2,null,3,null,3] 则不是镜像对称的:</p>\n<p>&nbsp; &nbsp; 1<br />&nbsp; &nbsp;/ \\<br />&nbsp; 2 &nbsp; 2<br />&nbsp; &nbsp;\\ &nbsp; \\<br />&nbsp; &nbsp;3 &nbsp; &nbsp;3</p>\n<p>示例 1：</p>\n<p>输入：root = [1,2,2,3,4,4,3]<br />输出：true<br />示例 2：</p>\n<p>输入：root = [1,2,2,null,3,null,3]<br />输出：false</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>递归法：从对称的二叉树中我们可以找到如下规律</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果一个二叉树是对称的，则每一个节点的左右子树也是对称的,因此是递归的</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 设L = root.left，R=root.right，则满足L.left.val = R.right.val;L.right.val=R.left.val;</strong></p>\n<pre class=\"language-java\"><code>public boolean isSymmetric(TreeNode root) {\n        return  root==null?true:recur(root.left,root.right);\n    }\n    public boolean recur(TreeNode L,TreeNode R){\n        if(L==null&amp;&amp;R==null){\n            return true;\n        }\n        if(L==null||R==null||L.val!=R.val){\n            return false;\n        }\n        return recur(L.left,R.right)&amp;&amp;recur(L.right,R.left);\n    }</code></pre>","blogGoods":0,"blogId":"1252992659794968576","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6ga--AKQdvAAAaZr2Bc1U862.jpg","blogRead":1,"blogRemark":"剑指offer----之对称的二叉树----LeetCode101","blogTitle":"剑指offer----之对称的二叉树----LeetCode101","createdTime":"2020-04-23 00:08:23","typeName":"LeetCode","updateTime":"2020-04-23 00:12:33"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，二叉树镜像</strong></h2>\n<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>\n<p>例如输入：</p>\n<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; 2 &nbsp; &nbsp; 7<br />&nbsp;/ \\ &nbsp; / \\<br />1 &nbsp; 3 6 &nbsp; 9<br />镜像输出：</p>\n<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; 7 &nbsp; &nbsp; 2<br />&nbsp;/ \\ &nbsp; / \\<br />9 &nbsp; 6 3&nbsp; &nbsp;1</p>\n<p>示例 1：</p>\n<p>输入：root = [4,2,7,1,3,6,9]<br />输出：[4,7,2,9,6,3,1]</p>\n<p>限制：</p>\n<p>0 &lt;= 节点个数 &lt;= 1000</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;递归法：即递归的去交换根节点的左右子树，直到根节点为叶子节点</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用递归的方法，交换根节点的左子树和右子树\n     * 递归出口为，根节点为叶子节点\n     * @param root\n     * @return\n     */\n    public TreeNode mirrorTree(TreeNode root) {\n        TreeNode center = root;\n        if(center!=null){\n            TreeNode temp = center.left;\n            center.left = center.right;\n            center.right = temp;\n            mirrorTree(center.left);\n            mirrorTree(center.right);\n        }\n        return root;\n    }</code></pre>","blogGoods":0,"blogId":"1252985443281027072","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6gZTWABF55AAAaZr2Bc1U678.jpg","blogRead":0,"blogRemark":"剑指offer----之二叉树的镜像----LeetCode226","blogTitle":"剑指offer----之二叉树的镜像----LeetCode226","createdTime":"2020-04-22 23:39:43","typeName":"LeetCode","updateTime":"2020-04-22 23:39:43"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，合并两个有序链表</strong></h2>\n<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>\n<p>示例1：</p>\n<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br />输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br />限制：</p>\n<p>0 &lt;= 链表长度 &lt;= 1000</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>伪头节点法：即创建一个伪头节点head和一个用于辅助的节点cur</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法：如果l1.val&lt;=l2.val,就让cur指向l1，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l1指向其next</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果l1.val&gt;l2.val,就让cur指向l2，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l2指向其next</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;直到l1和l2有一个为空为止，让cur指向剩余的一个非空链表即可，若两个链表的长度为M,N则时间复杂度为O(M+N)</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用四节点，一个伪头节点，一个当前节点cur，已经链表的两个节点l1,l2\n     * 每次比较l1,l2节点的val大小，将小的节点连接到当前节点cur上即可\n     * 直到l1,l2有一个空，则将剩余的一个非空链表连接到cur尾部即可\n     * @param l1\n     * @param l2\n     * @return\n     */\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode head;\n        ListNode cur;\n        head = cur = new ListNode(0);\n        while(l1!=null&amp;&amp;l2!=null){\n            if(l1.val&lt;=l2.val){\n                cur.next = l1;\n                cur = cur.next;\n                l1 = l1.next;\n            }else{\n                cur.next = l2;\n                cur = cur.next;\n                l2 = l2.next;\n            }\n        }\n        if(l1!=null){\n            cur.next = l1;\n        }\n        if(l2!=null){\n            cur.next = l2;\n        }\n        return head.next;\n    }</code></pre>","blogGoods":0,"blogId":"1252980258446000128","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6gYGWAe-MZAAAaZr2Bc1U550.jpg","blogRead":0,"blogRemark":"剑指offer----之合并有序链表---LeetCode21","blogTitle":"剑指offer----之合并有序链表---LeetCode21","createdTime":"2020-04-22 23:19:06","typeName":"LeetCode","updateTime":"2020-04-22 23:19:06"}],"pageSize":15,"params":{},"sortColumn":"created_time","sortMethod":"DESC","totalCount":53,"totalPage":4},"msg":"操作成功!"}
2020-04-26 23:38:25.877 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 185
2020-04-26 23:38:25.878 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1248605157059497984","blogRead":27,"blogTitle":"面试（二）------之JAVA基础篇","createdTime":"2020-04-10 13:34:02","typeName":"java面试篇"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1247745014683947008","blogRead":21,"blogTitle":"博客开发总结（一）-----之数据库设计篇","createdTime":"2020-04-08 04:36:07","typeName":"博客开发和维护总结"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1248224512563068928","blogRead":17,"blogTitle":"面试（一）------之JVM篇","createdTime":"2020-04-09 12:21:30","typeName":"java面试篇"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1249742755949817856","blogRead":17,"blogTitle":"面试（三）------之并发编程篇（下）","createdTime":"2020-04-13 16:54:26","typeName":"java面试篇"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1250622112591376384","blogRead":8,"blogTitle":"面试（六）------之网络与负载均衡","createdTime":"2020-04-16 03:08:42","typeName":"java面试篇"}],"msg":"操作成功!"}
2020-04-26 23:38:25.930 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /music/listFront
2020-04-26 23:38:25.930 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:38:25.931 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:38:25.931 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.MusicController.getMusicList
2020-04-26 23:38:25.932 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:38:26.302 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 372
2020-04-26 23:38:26.303 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"artist":"周深","cover":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMh2AFeEFAAAZaWcYmAM180.jpg","id":1,"lrc":"[00:00.37]周深 - 直破穹苍 (《斗破苍穹》动画第三季主题曲)\n[00:02.79]作词：冥凰\n[00:03.86]作曲：李建衡\n[00:05.19]编曲：崔博源、李建衡\n[00:07.13]人声录制：徐威@上海V-Studio\n[00:09.23]监唱：徐威@上海V-Studio\n[00:11.38]混音：周天澈@Studio21A\n[00:24.13]有没有想过 穿越这片沙漠\n[00:32.21]前方是什么\n[00:35.16]是就此陨落\n[00:37.97]还是抓牢命运脉搏\n[00:45.38]他曾经 爱过 恨过 痛过\n[00:51.07]直到望见远处那抹焰火\n[00:56.73]也许这 是祸 是过 是错\n[01:02.41]仍不害怕 去烧灼\n[01:08.50]管那六合八荒 斗一场\n[01:14.06]焰分噬浪谁能抗\n[01:19.28]漫却这漫漫险关 莫登攀\n[01:24.88]他欲乘风 直破穹苍\n[01:43.04]太多的纠葛 太多悲欢离合\n[01:51.39]要人太执着\n[01:54.21]该如何选择\n[01:57.02]才能看清是非漩涡\n[02:04.58]他曾经 哭过 泪过 笑过\n[02:10.16]直到紧握手心那抹焰火\n[02:15.77]走遍这 荒山 大漠 湖泊\n[02:21.49]仍不退缩 去冲破\n[02:27.44]管那龙潭虎穴 斗一场\n[02:32.72]生死福祸也跌宕\n[02:38.28]漫却他太多如果 都过往\n[02:43.86]还来惊诧 满堂\n[02:50.00]管那六合八荒 斗一场\n[02:55.22]焰分噬浪谁能抗\n[03:00.85]漫却这漫漫险关 莫登攀\n[03:06.51]他欲乘风 直破穹苍","name":"直破苍穹","url":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMlWAC1FrAr8ypaThmW479.flac"},{"artist":"冷鸢","cover":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMnWAa32EAABwmk6a5Cs834.jpg","id":2,"lrc":"你是信的开头诗的内容\n童话的结尾\n你是理所当然的奇迹\n你是月色真美\n你是圣诞老人送给我\n好孩子的礼物\n你是三千美丽世界里\n我的一瓢水\n所以让我再靠近一点点\n因为你太温暖\n我会再变得坚强一点点\n因为你太柔软\n交换无名指金色的契约\n给彼此岁月\n说好从今以后都牵着手\n因为要走很远\n你是我万水千山的冒险\n要找的标记点\n你是分割我人生的线\n又将它们相连\n你是前世千次的回眸\n虔诚牵的手\n你是其余所有的一切\n是我的世界\n所以请你再闪亮一点点\n尽管我太平凡\n我会再变得柔软一点点\n因为你太敏感\n交换无名指金色的契约\n给彼此岁月\n说好从今以后都牵着手\n不管要走多远\n让我再靠近一点点\n因为你太温暖\n我会再变得坚强一点点\n因为你太柔软\n交换无名指金色的契约\n给彼此岁月\n说好从今以后都牵着手\n因为要走很远","name":"勾指起誓","url":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMomAGXdvAHZQ_9pwL9c866.mp3"}],"msg":"操作成功!"}
2020-04-26 23:38:26.385 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /link/list
2020-04-26 23:38:26.386 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:38:26.386 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:38:26.386 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.LinkController.getLinkList
2020-04-26 23:38:26.386 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:38:26.480 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 95
2020-04-26 23:38:26.480 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"createdTime":"2020-04-08 02:11:26","linkId":1,"linkName":"百度","linkUrl":"www.baidu.com","updateTime":"2020-04-08 02:11:26","version":1},{"createdTime":"2020-04-18 21:39:52","linkId":2,"linkName":"CSDN","linkUrl":"https://www.csdn.net/","updateTime":"2020-04-18 21:39:52","version":1}],"msg":"操作成功!"}
2020-04-26 23:38:26.530 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 1103
2020-04-26 23:38:26.530 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"header":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMSKACehsAACHOzTvceE295.jpg","id":1,"name":"小屋","signature":"时光好不经用，转眼已是半生","username":"admin"},"msg":"操作成功!"}
2020-04-26 23:38:26.540 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 848
2020-04-26 23:38:26.541 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":1,"typeName":"Linux"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":2,"typeName":"Docker"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"SpringBoot"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":4,"typeName":"Mybatis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":5,"typeName":"爬虫"},{"deleted":0,"enable":1,"typeBlogCount":4,"typeId":6,"typeName":"博客开发和维护总结"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":7,"typeName":"CSS"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"JavaScript"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Vue"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":10,"typeName":"随笔"},{"deleted":0,"enable":1,"typeBlogCount":16,"typeId":11,"typeName":"java面试篇"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":13,"typeName":"JDK源码阅读"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":14,"typeName":"redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":15,"typeName":"MongoDB"},{"deleted":0,"enable":1,"typeBlogCount":28,"typeId":16,"typeName":"LeetCode"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":17,"typeName":"随心日记"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":18,"typeName":"计算机网络"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":19,"typeName":"操作系统"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":20,"typeName":"数据结构"}],"msg":"操作成功!"}
2020-04-26 23:38:26.799 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 1107
2020-04-26 23:38:26.799 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":53,"msg":"操作成功!"}
2020-04-26 23:38:51.009 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /user/login
2020-04-26 23:38:51.010 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:38:51.010 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:38:51.010 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.UserController.login
2020-04-26 23:38:51.011 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[User(userId=null, username=admin, password=123456, name=null, sex=null, header=null, nickname=null, userEmail=null, createdTime=null, updateTime=null, version=null, deleted=null)]
2020-04-26 23:38:51.096 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 87
2020-04-26 23:38:51.096 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"user":{"header":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NWkaAJPVvAANwwcjPp-g88.jpeg","name":"","nickname":"小屋","password":"","sex":1,"userEmail":"570857634@qq.com","userId":1,"username":"admin"},"token":"BF45BF0A52B5839C0DC85B6C5148EC1E"},"msg":"操作成功!"}
2020-04-26 23:38:51.535 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /rotation-picture/listFront
2020-04-26 23:38:51.535 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:38:51.536 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:38:51.536 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.RotationPictureController.getRotationPictureListFront
2020-04-26 23:38:51.536 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:38:51.615 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 80
2020-04-26 23:38:51.616 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"createdTime":"2020-04-09 13:31:20","enable":1,"rotationId":4,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PI6aAZIz1AASCO4hlpJI295.jpg"},{"createdTime":"2020-04-09 13:37:02","enable":1,"rotationId":9,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJPyAbm8fAAG9gfO8lxE28.jpeg"},{"createdTime":"2020-04-09 13:41:30","enable":1,"rotationId":10,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJgeAeG8wAAS2pjJC5QU547.jpg"},{"createdTime":"2020-04-09 13:41:38","enable":1,"rotationId":11,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhGAQFZbAAP2OOBWb6k310.jpg"},{"createdTime":"2020-04-09 13:41:50","enable":1,"rotationId":12,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhyABMZCAAG7doyXiM8109.jpg"},{"createdTime":"2020-04-09 13:41:59","enable":1,"rotationId":13,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJiWAL7BoAARW3_O3ISw651.jpg"}],"msg":"操作成功!"}
2020-04-26 23:38:51.838 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/list
2020-04-26 23:38:51.838 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:38:51.839 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:38:51.840 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogList
2020-04-26 23:38:51.840 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=15, totalPage=0, totalCount=0, list=[], params={}, sortColumn=created_time, sortMethod=DESC)]
2020-04-26 23:38:51.845 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /admin/getInfo
2020-04-26 23:38:51.846 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:38:51.847 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:38:51.847 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.AdminController.getInfo
2020-04-26 23:38:51.847 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:38:51.856 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/recommendRead
2020-04-26 23:38:51.856 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/getTotal
2020-04-26 23:38:51.856 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listFront
2020-04-26 23:38:51.857 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:38:51.857 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:38:51.857 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:38:51.857 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:38:51.857 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:38:51.857 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:38:51.858 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.recommendRead
2020-04-26 23:38:51.858 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getTotal
2020-04-26 23:38:51.858 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:38:51.858 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:38:51.858 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeLists
2020-04-26 23:38:51.858 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:38:51.938 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 93
2020-04-26 23:38:51.939 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"header":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMSKACehsAACHOzTvceE295.jpg","id":1,"name":"小屋","signature":"时光好不经用，转眼已是半生","username":"admin"},"msg":"操作成功!"}
2020-04-26 23:38:51.946 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 90
2020-04-26 23:38:51.946 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":53,"msg":"操作成功!"}
2020-04-26 23:38:51.948 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 92
2020-04-26 23:38:51.948 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1248605157059497984","blogRead":27,"blogTitle":"面试（二）------之JAVA基础篇","createdTime":"2020-04-10 13:34:02","typeName":"java面试篇"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1247745014683947008","blogRead":21,"blogTitle":"博客开发总结（一）-----之数据库设计篇","createdTime":"2020-04-08 04:36:07","typeName":"博客开发和维护总结"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1248224512563068928","blogRead":17,"blogTitle":"面试（一）------之JVM篇","createdTime":"2020-04-09 12:21:30","typeName":"java面试篇"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1249742755949817856","blogRead":17,"blogTitle":"面试（三）------之并发编程篇（下）","createdTime":"2020-04-13 16:54:26","typeName":"java面试篇"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1250622112591376384","blogRead":8,"blogTitle":"面试（六）------之网络与负载均衡","createdTime":"2020-04-16 03:08:42","typeName":"java面试篇"}],"msg":"操作成功!"}
2020-04-26 23:38:52.027 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 171
2020-04-26 23:38:52.027 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":1,"typeName":"Linux"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":2,"typeName":"Docker"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"SpringBoot"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":4,"typeName":"Mybatis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":5,"typeName":"爬虫"},{"deleted":0,"enable":1,"typeBlogCount":4,"typeId":6,"typeName":"博客开发和维护总结"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":7,"typeName":"CSS"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"JavaScript"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Vue"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":10,"typeName":"随笔"},{"deleted":0,"enable":1,"typeBlogCount":16,"typeId":11,"typeName":"java面试篇"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":13,"typeName":"JDK源码阅读"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":14,"typeName":"redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":15,"typeName":"MongoDB"},{"deleted":0,"enable":1,"typeBlogCount":28,"typeId":16,"typeName":"LeetCode"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":17,"typeName":"随心日记"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":18,"typeName":"计算机网络"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":19,"typeName":"操作系统"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":20,"typeName":"数据结构"}],"msg":"操作成功!"}
2020-04-26 23:38:52.052 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /music/listFront
2020-04-26 23:38:52.053 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:38:52.053 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:38:52.054 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.MusicController.getMusicList
2020-04-26 23:38:52.054 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:38:52.177 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 125
2020-04-26 23:38:52.177 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"artist":"周深","cover":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMh2AFeEFAAAZaWcYmAM180.jpg","id":1,"lrc":"[00:00.37]周深 - 直破穹苍 (《斗破苍穹》动画第三季主题曲)\n[00:02.79]作词：冥凰\n[00:03.86]作曲：李建衡\n[00:05.19]编曲：崔博源、李建衡\n[00:07.13]人声录制：徐威@上海V-Studio\n[00:09.23]监唱：徐威@上海V-Studio\n[00:11.38]混音：周天澈@Studio21A\n[00:24.13]有没有想过 穿越这片沙漠\n[00:32.21]前方是什么\n[00:35.16]是就此陨落\n[00:37.97]还是抓牢命运脉搏\n[00:45.38]他曾经 爱过 恨过 痛过\n[00:51.07]直到望见远处那抹焰火\n[00:56.73]也许这 是祸 是过 是错\n[01:02.41]仍不害怕 去烧灼\n[01:08.50]管那六合八荒 斗一场\n[01:14.06]焰分噬浪谁能抗\n[01:19.28]漫却这漫漫险关 莫登攀\n[01:24.88]他欲乘风 直破穹苍\n[01:43.04]太多的纠葛 太多悲欢离合\n[01:51.39]要人太执着\n[01:54.21]该如何选择\n[01:57.02]才能看清是非漩涡\n[02:04.58]他曾经 哭过 泪过 笑过\n[02:10.16]直到紧握手心那抹焰火\n[02:15.77]走遍这 荒山 大漠 湖泊\n[02:21.49]仍不退缩 去冲破\n[02:27.44]管那龙潭虎穴 斗一场\n[02:32.72]生死福祸也跌宕\n[02:38.28]漫却他太多如果 都过往\n[02:43.86]还来惊诧 满堂\n[02:50.00]管那六合八荒 斗一场\n[02:55.22]焰分噬浪谁能抗\n[03:00.85]漫却这漫漫险关 莫登攀\n[03:06.51]他欲乘风 直破穹苍","name":"直破苍穹","url":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMlWAC1FrAr8ypaThmW479.flac"},{"artist":"冷鸢","cover":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMnWAa32EAABwmk6a5Cs834.jpg","id":2,"lrc":"你是信的开头诗的内容\n童话的结尾\n你是理所当然的奇迹\n你是月色真美\n你是圣诞老人送给我\n好孩子的礼物\n你是三千美丽世界里\n我的一瓢水\n所以让我再靠近一点点\n因为你太温暖\n我会再变得坚强一点点\n因为你太柔软\n交换无名指金色的契约\n给彼此岁月\n说好从今以后都牵着手\n因为要走很远\n你是我万水千山的冒险\n要找的标记点\n你是分割我人生的线\n又将它们相连\n你是前世千次的回眸\n虔诚牵的手\n你是其余所有的一切\n是我的世界\n所以请你再闪亮一点点\n尽管我太平凡\n我会再变得柔软一点点\n因为你太敏感\n交换无名指金色的契约\n给彼此岁月\n说好从今以后都牵着手\n不管要走多远\n让我再靠近一点点\n因为你太温暖\n我会再变得坚强一点点\n因为你太柔软\n交换无名指金色的契约\n给彼此岁月\n说好从今以后都牵着手\n因为要走很远","name":"勾指起誓","url":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMomAGXdvAHZQ_9pwL9c866.mp3"}],"msg":"操作成功!"}
2020-04-26 23:38:52.378 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /link/list
2020-04-26 23:38:52.378 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:38:52.378 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:38:52.378 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.LinkController.getLinkList
2020-04-26 23:38:52.379 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:38:52.468 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 90
2020-04-26 23:38:52.469 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"createdTime":"2020-04-08 02:11:26","linkId":1,"linkName":"百度","linkUrl":"www.baidu.com","updateTime":"2020-04-08 02:11:26","version":1},{"createdTime":"2020-04-18 21:39:52","linkId":2,"linkName":"CSDN","linkUrl":"https://www.csdn.net/","updateTime":"2020-04-18 21:39:52","version":1}],"msg":"操作成功!"}
2020-04-26 23:38:53.736 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 1898
2020-04-26 23:38:53.738 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，0~n-1中缺失的数字</strong></h2>\n<p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>\n<p>示例 1:</p>\n<p>输入: [0,1,3]<br />输出: 2<br />示例&nbsp;2:</p>\n<p>输入: [0,1,2,3,4,5,6,7,9]<br />输出: 8</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主能想到的并且写出来的方法有：使用map存储数组中的所有元素，然后遍历0-n-1找出不在map中的元素。此种方法时间复杂度O（N），空间复杂度O（N）-----垃圾</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 统计0-n-1所有数字的数字和，再统计数组中所有数字的数字和，两和只差即为所求数字，时间复杂度O（N），空间复杂度O（1）-----垃圾</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;最优解法（二分查找法）：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;通常来说，我们使用二分查找法是查找一个存在于数组中的元素，但是本题需要求不在数组中的一个元素，因此到这很多人就会迷惑，不知道该怎么求了。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;但是我们首先要搞明白二分查找法的本质是什么：1，并不局限于仅仅查找存在于数组中的元素；2，二分查找的本质是对数组根据mid中间值在某一条件上进行二分（例如：通常的num[mid]&gt;target或者nums[mid]&lt;target进行左右切分）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;因此明白这一点，就好解决问题了。拿到这道题，使用二分，我们首先想到的应该是寻找根据mid中间值进行二分的条件</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;审题：题目中提及数组为递增数组，而且0-n-1内的n个数字有一个不在数组中，则不在的这个数字之前的数字满足nums[i]=i即元素本身等于数组下标，而之后的数字nums[i]!=i,所以这就是进行二分的条件了</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 二分查找法\n     * 算法思想：二分查找法的本质是能够有一个条件将数组根据mid中间值进行左右切分\n     * 所以我们想到二分查找法之后，首先需要做的是找出切分数组的条件\n     * 题目中给出了数组是一个递增数组，且0-n-1内的n个数字有一个不在这个长度为n-1的数组内\n     * 因此，不在的这个元素其左边元素必有数组下标值等于元素本身即nums[i]=i\n     * 而不在的这个元素的右边必有nums[i]!=i\n     * 所以根据此条件进行划分数组即可\n     * @param nums\n     * @return\n     */\n    public static int missingNumber(int[] nums) {\n        int low = 0;\n        int high = nums.length-1;\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]==mid){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        return low;\n    }</code></pre>","blogGoods":0,"blogId":"1254063045920022528","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kUM-AON88AAAaZr2Bc1U903.jpg","blogRead":0,"blogRemark":"剑指offer----0~n-1中缺失的数字","blogTitle":"剑指offer----0~n-1中缺失的数字","createdTime":"2020-04-25 23:01:44","typeName":"LeetCode","updateTime":"2020-04-25 23:01:44"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，在排序数组中查找数字I</strong></h2>\n<p>统计一个数字在排序数组中出现的次数。</p>\n<p>示例 1:</p>\n<p>输入: nums = [5,7,7,8,8,10], target = 8<br />输出: 2<br />示例&nbsp;2:</p>\n<p>输入: nums = [5,7,7,8,8,10], target = 6<br />输出: 0</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解法一：直接遍历统计，时间复杂度为O（N）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 遍历数组\n     * 找到第一个与目标元素相等的元素，res+1\n     * 然后往后找到第一个与目标元素不相等的元素,返回res即可\n     * 时间复杂度为O(N)\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static int search(int[] nums, int target) {\n        int res = 0;\n        for (int num : nums) {\n            if(num==target){\n                res++;\n            }\n        }\n        return res;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解法二：二分法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：利用二分法查找数字在排序数组中的左边界Left和右边界Right.如下，如果要寻找数组中的8，则其左边界为left=2,有边界right=5.所以出现次数为right-left-1.时间复杂度为O（logN）</strong></p>\n<table style=\"width: 20%; border-collapse: collapse; margin-left: auto; margin-right: auto;\" border=\"1\" cellpadding=\"5\">\n<tbody>\n<tr>\n<td style=\"width: 16.6667%;\">5</td>\n<td style=\"width: 16.6667%;\">7</td>\n<td style=\"width: 16.6667%;\">7</td>\n<td style=\"width: 16.6667%;\">8</td>\n<td style=\"width: 16.6667%;\">8</td>\n<td style=\"width: 16.6667%;\">10</td>\n</tr>\n</tbody>\n</table>\n<pre class=\"language-java\"><code>    /**\n     * 二分查找法\n     * 时间复杂度为O（logN）\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static int search2(int[] nums, int target){\n        int low = 0;\n        int high = nums.length-1;\n        int left,right;\n        left = right = 0;\n        //一次二分\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]&lt;=target){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        right = low;\n\n        low = 0;\n        high = nums.length -1;\n        //二次二分\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]&lt;target){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        left = high;\n        return right -left -1;\n    }</code></pre>","blogGoods":0,"blogId":"1254055163115724800","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kSXiAYRyFAAAaZr2Bc1U379.jpg","blogRead":0,"blogRemark":"剑指offer----在排序数组中查找数字I----LeetCode34","blogTitle":"剑指offer----在排序数组中查找数字I----LeetCode34","createdTime":"2020-04-25 22:30:24","typeName":"LeetCode","updateTime":"2020-04-25 22:30:24"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，两个链表的第一个公共节点</strong></h2>\n<p><strong><img src=\"https://images-cdn.shimo.im/Wd1NC8pveQYp9iIL.png__thumbnail\" alt=\"示例图\" width=\"742\" height=\"241\" /></strong></p>\n<p><strong>这是我从官方截下的一张图，也是有些人疑惑的地方，因为官方这张图给出的公共节点为8，而大多数人看到这张图，认为公共节点应该是1.</strong></p>\n<p><strong>但是实际上这里的公共节点不仅要节点的value相等，同时还需要节点的地址相等。从图中可以看出两个1节点虽然值相等，但是地址却不同，因而不是公共节点</strong></p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解法一：双指针</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：初始化两个指针p1=headA,p2=headB</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;分别遍历两个链表，求出两个链表的长度l1,l2</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;然后重置p1,p2指针指向头节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;让长链表的指针先走多的步数（l1-l2或者l2-l1）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;然后让两个指针同时走，直到两者相遇，即找到公共节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解疑：弄清楚第一个value相等的节点和指针相遇的节点，这两种节点是不同的，指针相遇的节点，不仅包含value相等，同时地址也相等。（如图中的8）；而第一个value相等的节点则可能并不在同一个地址，因此不一定是公共节点</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法\n     * @param headA\n     * @param headB\n     * @return\n     */\n    public static ListNode getIntersectionNode2(ListNode headA, ListNode headB){\n        ListNode p1 =headA;\n        ListNode p2 = headB;\n        int l1 = 0;\n        int l2 = 0;\n        //计算链表1的长度\n        while(p1!=null){\n            l1++;\n            p1 = p1.next;\n        }\n        //计算链表2的长度\n        while(p2!=null){\n            l2++;\n            p2 = p2.next;\n        }\n        p1 = headA;\n        p2 = headB;\n        //让长链表指针先走长的步数\n        if(l1&gt;l2){\n            for (int i = 0; i &lt; l1-l2; i++) {\n                p1 = p1.next;\n            }\n        }else{\n            for (int i = 0; i &lt; l2-l1; i++) {\n                p2 = p2.next;\n            }\n        }\n        //然后让两个指针同时走，直到相遇\n        while(p1!=p2){\n            p1 = p1.next;\n            p2 = p2.next;\n        }\n        return p1;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;解法二（大神解法）：丘比特相遇法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;利用两个指针p1=headA,p2=headB,让两个指针同时走，</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果p1先走到底，就将p1置为headB，</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果p2,先走到底，就将p2置为headA,</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;当两个指针相遇的时候，他们就相爱了（当然是找到公共节点了）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法p1=headA,p2=headB\n     * 思想是：两个节点同时从各自的链表出发\n     * p1走到末尾时，回到headB的头部\n     * p2走到末尾时，回到headA的头部\n     * 两个指针相遇的时候，即使要找的公共节点\n     * @param headA\n     * @param headB\n     * @return\n     */\n    public static ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode p1 = headA;\n        ListNode p2 = headB;\n        while(p1!=p2){\n            p1 = (p1==null)?headB:p1.next;\n            p2 = (p2==null)?headA:p2.next;\n        }\n        return p1;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1253992797703364608","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kD2OADD3mAAAaZr2Bc1U709.jpg","blogRead":0,"blogRemark":"剑指offer----之两个链表的第一个公共节点----LeetCode160","blogTitle":"剑指offer----之两个链表的第一个公共节点----LeetCode160","createdTime":"2020-04-25 18:22:35","typeName":"LeetCode","updateTime":"2020-04-25 18:22:35"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，第一个只出现一次的字符</strong></h2>\n<p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。</p>\n<p>示例:</p>\n<p>s = \"abaccdeff\"<br />返回 \"b\"</p>\n<p>s = \"\" <br />返回 \" \"</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主现在发现，做一道算法题的时候，最重要的一步就是读题，审题，在草稿纸上写下自己的思路（当然那种望眼欲穿的大佬除外）。然后才开始动笔，对于IT人来说，真的，多将时间花费在思考上面，而不是无意义的重复搬砖。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;题目分析：看到这道题，抓住两个关键字：第一个，只出现一次。什么意思呢，例如\"abaccdeff\"，其中只出现一次的字符有'b','d','e'三个，然后在三个字符中第一个出现在字符串中的是'b'，因此本题的答案是'b'.</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法分析：根据题目分析，我们最直观的解法应该是，先找出字符串中只出现一次的字符，然后再找出只出现一次字符中，第一个在字符串中出现的。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;所以我们需要做两件事，一是统计字符串中各个字符的出现次数，并且记录；二，统计完毕后，找出第一个出现次数为1的字符，返回即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;因此我们既要存字符，还要存字符对应的出现次数，所以理所当然我们选择map集合。当然对于本题而言，因为求第一个出现一次的字符，所以我们更好的是可以使用LinkedHashMap。这样免去最后的一次遍历字符串</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;下面提供两种解法：三种解法都是使用map集合，但是略有不同</strong></p>\n<p><strong>LinkedHashMap：（这是博主写的，代码冗余，这里用来和大神的写法做比较，警醒自己）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 用LinkedHashMap\n     * 思想：遍历字符串，如果map为空或者map中不含当前字符，则将其存入map\n     * 如果map中已经含有当前字符，则从map中移除\n     * 最终map中只剩出现一次的字符\n     * 返货map中的第一个即可\n     * @param s\n     * @return\n     */\n    public static char firstUniqChar(String s) {\n        Map&lt;Character,Integer&gt;map = new LinkedHashMap&lt;&gt;();\n        for (int i = 0; i &lt; s.length(); i++) {\n            char ch = s.charAt(i);\n            if(map.isEmpty()||!map.containsKey(ch)){\n                map.put(ch,1);\n            }else{\n                Integer val = map.get(ch);\n                map.put(ch,++val);\n            }\n        }\n        //返回map中第一个元素即可\n        Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entries = map.entrySet();\n        for (Map.Entry&lt;Character, Integer&gt; entry : entries) {\n            if(entry.getValue()==1){\n                return entry.getKey();\n            }\n        }\n        return ' ';\n    }</code></pre>\n<p><strong>HashMap（大神解法）：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 哈希表法\n     * @param s\n     * @return\n     */\n    public char firstUniqChar2(String s) {\n        Map&lt;Character,Boolean&gt; map = new HashMap&lt;&gt;();\n        char[] chars = s.toCharArray();\n        for (char ch : chars) {\n            map.put(ch,!map.containsKey(ch));\n        }\n        for (char ch : chars) {\n            if(map.get(ch)){\n                return ch;\n            }\n        }\n        return ' ';\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;分析：首先，这里提供了两种解法，一种为LinkedHashMap，一种为HashMap，这两种解法的不同之处就在于最后获取值的时候，LinkedHashMap获取最终值是遍历LinkedHashMap的entrySet，但是HashMap获取最终值是遍历原字符串。因而当数据庞大的时候，显然使用LinkedHashMap性能更高。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;然后，再分析一下这两种解法不另外一个不同之处，没错！就是大神的解法中使用map存放key对应的value值是Boolean型！（<span style=\"background-color: #ffcc00;\">这个真的是神一般的存在</span>），既省去了计算次数的麻烦，同时最后取的时候也不需要判断次数。wc！同一种解法，为什么天差地别！</strong></p>","blogGoods":0,"blogId":"1253956468789600256","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6j7Y6ACrySAAAaZr2Bc1U825.jpg","blogRead":0,"blogRemark":"剑指offer----第一次只出现一次的字符","blogTitle":"剑指offer----第一次只出现一次的字符","createdTime":"2020-04-25 15:58:14","typeName":"LeetCode","updateTime":"2020-04-25 15:58:14"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，连续子数组的最大和</strong></h2>\n<p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>\n<p>要求时间复杂度为O(n)。</p>\n<p>示例1:</p>\n<p>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br />输出: 6<br />解释:&nbsp;连续子数组&nbsp;[4,-1,2,1] 的和最大，为&nbsp;6。</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;看到这道题，最简单的想法肯定是求出所有连续子数组的值，然后进行比较，找出最大的即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;但是随后会想到既然要找出所有的子数组，那么我们可以使用分治的思想，因为分治的分过程即可以得到所有子序列</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;随后，再深一步，既然可以分治的思想，分的过程即是递归的过程，而且子数组的最大值依赖与前一子数组，所以可以想到使用动态规划</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：设dp[i]为以nums[i]为结尾的最大子数组和，初始值dp[0] = nums[0]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;遍历数组，如果dp[i-1]&gt;=0。则说明前面的最大子数组对当前子数组有增益效果，所以dp[i] = dp[i-1]+nums[i]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果dp[i-1]&lt;0。说明前面的最大子数组对当前子数组有夫负效果，还不如nums[i]本身，所以dp[i]=nums[i]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主的这样的写法：时间复杂度为O（N），空间复杂度也为O（N），但是实际上不需要使用dp数组，使用nums原数组就行，所以可以减小空间复杂度为O（1）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 动态规划\n     * 算法思想：因为求的是连续子数组的最大和\n     * 所以我们可以设dp[i]为以nums[i]结尾的最大连续子数组\n     * 如果dp[i]&lt;=nums[i],dp[i]=nums[i]\n     * 如果dp[i]&gt;nums[i],则dp[i]=dp[i]+nums[i]\n     * @param nums\n     * @return\n     */\n    public static int maxSubArray(int[] nums) {\n        int[] dp  = new int[nums.length];\n        dp[0] = nums[0];\n        int res = nums[0];\n        for (int i = 1; i &lt; nums.length; i++) {\n            if(dp[i-1]&lt;0){\n                dp[i] = nums[i];\n            }else{\n                dp[i] = dp[i-1]+nums[i];\n            }\n            res = Math.max(res,dp[i]);\n        }\n        return res;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1253938714590175232","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6j3QSACLxRAAAaZr2Bc1U017.jpg","blogRead":0,"blogRemark":"剑指offer---连续子数组的最大和---LeetCode53","blogTitle":"剑指offer---连续子数组的最大和---LeetCode53","createdTime":"2020-04-25 14:47:41","typeName":"LeetCode","updateTime":"2020-04-25 14:47:41"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，最小的k个数</strong></h2>\n<p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>\n<p>示例 1：</p>\n<p>输入：arr = [3,2,1], k = 2<br />输出：[1,2] 或者 [2,1]<br />示例 2：</p>\n<p>输入：arr = [0,1,2,1], k = 1<br />输出：[0]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;1,可以采用快排的思想，将原数组按照升序排序，然后取出前k个数即可，时间复杂度为O（NlogN）。但是其实跟API中的sort方法好像差别不大</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 对原数组升序排序，然后取前k个元素\n     * @param arr\n     * @param k\n     * @return\n     */\n    public static int[] getLeastNumbers(int[] arr, int k) {\n        quickSort(arr,0,arr.length-1);\n        int[] result = new int[k];\n        for (int i = 0; i &lt; k; i++) {\n            result[i] = arr[i];\n        }\n        return result;\n    }\n\n    /**\n     * 快排\n     * @param nums\n     * @param low\n     * @param high\n     */\n    public static void quickSort(int[] nums,int low,int high){\n        int base = nums[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //先从右向左找到第一个小于基准元素的元素\n            while(L&lt;R&amp;&amp;nums[R]&gt;=base){\n                R--;\n            }\n            if(nums[R]&lt;base){\n                swap(nums,L,R);\n            }\n            //再从左向右找到第一个大于基准元素的元素\n            while(L&lt;R&amp;&amp;nums[L]&lt;=base){\n                L++;\n            }\n            if(nums[L]&gt;base){\n                swap(nums,L,R);\n            }\n        }\n        //左递归\n        if(L&gt;low){\n            quickSort(nums,low,L-1);\n        }\n        //右递归\n        if(high&gt;R){\n            quickSort(nums,R+1,high);\n        }\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>2，堆排序：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;先讲解一下堆排序：堆排序是一种完全二叉树的结构，常见的存在两种堆结构，小根堆（即满足arr[2i+1]&gt;=arr[i]&amp;&amp;arr[2i+2]&gt;=arr[i]），大根堆（即满足arr[2i+1]&lt;=arr[i]&amp;&amp;arr[2i+2]&lt;=arr[i]）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;基本算法思想：第一步，初始化堆，即堆初始化为大根堆或者小根堆（这里我们简称调整堆）；第二步，将堆顶元素与堆的末尾元素进行交换，然后重新调整堆。在java中堆通常用来实现优先级队列PriorityQueue(默认的采用小根堆，若想使用大根堆，需要在创建时实现comparator)</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;使用情况：这里以java中的优先级队列为例，堆的使用情况不能按照堆名断章取义，例如小根堆实际上是将元素升序存放，因为在算法第二步中将堆顶元素与末尾元素进行交换，然后重新调整，交换的堆顶元素为最小元素，也是最先从堆中进入队列的。所以小根堆适用于TOPk大的算法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;相反的，大根堆适用于TOPk小的算法，下面分别给出小根堆和大根堆的算法：</strong></p>\n<p><strong>小根堆：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 堆排序---小根堆\n     * @param nums\n     */\n    public static void HeapSort(int[] nums){\n        //先初始化堆\n        for (int i = nums.length/2-1; i &gt;=0 ; i--) {\n            adjustHeap(nums,i,nums.length);\n        }\n        //交换堆顶与末尾节点+重新调整为小根堆\n        for (int i = nums.length-1; i &gt;0; i--) {\n            //先交换\n            swap(nums,0,i);\n            //再调整\n            adjustHeap(nums,0,i);\n        }\n    }\n\n    /**\n     * 调整为小根堆\n     * @param nums\n     * @param i\n     * @param length\n     */\n    public static void adjustHeap(int[] nums,int i,int length){\n        int temp = nums[i];\n        for (int j = 2*i+1; j &lt; length; j=2*j+1) {\n            //找出左右节点中的最小值\n            if(j+1&lt;length&amp;&amp;nums[j]&gt;nums[j+1]){\n                j++;\n            }\n            if(nums[j]&lt;temp){\n                nums[i] = nums[j];\n                i = j;\n            }\n        }\n        nums[i] = temp;\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p><strong>大根堆：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 堆排序---大根堆\n     * @param nums\n     */\n    public static void heapSort(int[] nums){\n\n        //初始化堆的过程\n        for (int i = nums.length/2-1; i &gt;=0; i--) {\n            adjustHeap(nums,i,nums.length);\n        }\n        //调整+交换堆顶和末尾的元素\n        for (int i = nums.length-1; i &gt;0; i--) {\n            //先交换，再重新调整\n            swap(nums,0,i);\n            adjustHeap(nums,0,i);\n        }\n    }\n\n    /**\n     * 调整大顶堆的过程\n     * @param nums\n     * @param i\n     * @param length\n     */\n    public static void adjustHeap(int[] nums,int i,int length){\n        int temp = nums[i];\n        for (int j = 2*i+1; j &lt; length; j=2*j+1) {\n            //找出左右节点中的最大值\n            if(j+1&lt;length&amp;&amp;nums[j]&lt;nums[j+1]){\n                j++;\n            }\n            if(nums[j]&gt;temp){\n                nums[i] = nums[j];\n                i = j;\n            }\n        }\n        nums[i] = temp;\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>本题利用大根堆解法，且使用java中自带的优先级队列PriorityQueue：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用堆数据结构，java中的优先级队列对应着最小堆\n     * 实现其comparator即可\n     * @param arr\n     * @param k\n     * @return\n     */\n    public static int[] getLeastNumbers2(int[] arr, int k){\n        Queue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(k,(v1,v2)-&gt;v2-v1);\n        for (int i : arr) {\n            if(heap.isEmpty()||heap.size()&lt;k||i&lt;heap.peek()){\n                heap.offer(i);\n            }\n            if(heap.size()&gt;k){\n                heap.poll();\n            }\n        }\n        int[] result = new int[k];\n        int j = 0;\n        for (Integer val : heap) {\n            result[j++] = val;\n        }\n        return result;\n    }</code></pre>","blogGoods":0,"blogId":"1253874832811089920","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6joYWAF3oqAAAaZr2Bc1U671.jpg","blogRead":2,"blogRemark":"剑指offer----之最小的k个数","blogTitle":"剑指offer----之最小的k个数","createdTime":"2020-04-25 10:33:50","typeName":"LeetCode","updateTime":"2020-04-25 11:53:15"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，数组中出现次数超过一半的元素---即众数</strong></h2>\n<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>\n<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>\n<p>示例&nbsp;1:</p>\n<p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br />输出: 2</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>方法有三：哈希表统计法，数组排序法，摩尔投票法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;哈希统计法：时间复杂度O（N），空间复杂度O（N）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 博主刚开始看到这道题的时候，首先想到的是哈希表统计法，因为博主想的是要找到众数，那么肯定得统计每个数字的出现次数，然后按照次数比较。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 单单是想到这些，用了map集合之后发现还是不行，因为即便用map集合统计出了每个数字和其对应的出现次数之后，你会发现没有办法按照出现的次数进行比较并且得到次数最多的数字（众数</strong><strong>）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 然后，就又审了一遍题目，结果发现了一个本题很关键的点，（<span style=\"background-color: #ffcc00;\">数组中有一个数字出现的次数超过数组长度的一半</span>），也就是说数组中有且仅有一个数字的出现次数会超过数组长度的一半（别笑博主笨，我是真的刚开始没反应过来）</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 那么我为什么要把数组中的所有元素和其次数全部存放进入map集合，然后再取次数进行比较呢？我为什么不在将元素和其次数存入集合的过程中判断次数是否已经超过数组长度的一半了呢？如果超过一半了，那它肯定是众数了呀！</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 思路：根据题意需要找出两个东西，一是多素元素，二是多素元素的出现次数\n     * 所以我们首先想到的是采用map集合\n     * 然后遍历数组，如果元素不存在与集合中，我们就将其加入map，value置为1\n     * 如果元素存在于map中，则我们取出其value将其加1与数组长度的一半做比较\n     * 如果大于数组长度一半，直接返回该元素即可\n     * 小于数组长度一半，则将其value加1存入map覆盖原有的值即可\n     *\n     * @param nums\n     * @return\n     */\n    public static int majorityElement(int[] nums) {\n        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(nums.length);\n        for (int num : nums) {\n            if(!map.containsKey(num)){\n                map.put(num,1);\n            }else{\n                Integer val = map.get(num);\n                if(++val&gt;nums.length/2){\n                    return num;\n                }else{\n                    map.put(num,val);\n                }\n            }\n        }\n        throw new RuntimeException(\"\");\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>数组排序法：由题可知，数组众必然存在一个多数元素，且出现次数超过数组长度的一半。所以我们可以对原数组进行排序，然后取数组中间的元素即可。（我擦，我当时看到这个，就在想，好简单，这个思路，但是我为什么没想到，对，因为我没有仔细的分析题目，超过一半看见没）。既然进行排序，那么我们可以选择快排，这样时间复杂度就是O（NlogN），空间复杂度O（1）.</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 数组排序法，因为多数元素的出现次数超过数组长度一半，\n     * 所以我们可以先对其进行排序，采用快排，时间复杂度O（NlogN）\n     * 然后取数组中点元素即可\n     * @param nums\n     * @return\n     */\n    public static int majorityElement2(int[] nums){\n        quickSort(nums,0,nums.length-1);\n        return nums[nums.length/2];\n    }\n\n    /**\n     * 快排\n     * @param nums\n     * @param low\n     * @param high\n     */\n    public static void quickSort(int[] nums,int low,int high){\n        int base = nums[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //从右向左找到第一个比基准元素小的元素\n            while(L&lt;R&amp;&amp;nums[R]&gt;=base){\n                R--;\n            }\n            if(nums[R]&lt;base){\n                swap(nums,L,R);\n            }\n            //从左向右找到第一个比基准元素大的元素\n            while(L&lt;R&amp;&amp;nums[L]&lt;=base){\n                L++;\n            }\n            if(nums[L]&gt;base){\n                swap(nums,L,R);\n            }\n        }\n        //左递归\n        if(L&gt;low){\n            quickSort(nums,low,L-1);\n        }\n        //右递归\n        if(high&gt;R){\n            quickSort(nums,R+1,high);\n        }\n    }\n\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>摩尔投票法（我将其称为大佬解法）：大概的意思就是采用正负抵消的方法，设置一个投票变量votes，初始设置为0；设置一个本题中的众数变量x，初始设置为数组首元素。然后遍历数组，判断跟设置的众数变量是否相等，如果相等将votes加一，如果不相等，则重置votes为0，且将x设置为数组下一个元素。本题众因为已经声明了肯定存在众数，所以不需要进行验证，但是如果没有声明的话，需要验证，下列代码众添加了验证：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 摩尔投票法\n     * @param nums\n     */\n    public static int majorityElement3(int[] nums){\n        int votes = 0;\n        int x = nums[0];\n        int count = 0;\n        for (int num : nums) {\n            if(votes==0){\n                x = num;\n            }\n            votes+=(num==x)?1:-1;\n        }\n        //验证数组众是否存在众数\n        for (int num : nums) {\n            if(num==x){\n                count++;\n            }\n        }\n        return count&gt;nums.length/2?x:0;\n    }</code></pre>","blogGoods":0,"blogId":"1253674617332162560","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6i5v-AUh39AAAaZr2Bc1U885.jpg","blogRead":0,"blogRemark":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","blogTitle":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","createdTime":"2020-04-24 21:18:14","typeName":"LeetCode","updateTime":"2020-04-24 21:18:14"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，从上到下打印二叉树-2</strong></h2>\n<p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>\n<p>例如:<br />给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>\n<p>3<br />/ \\<br />9 20<br />/ \\<br />15 7<br />返回其层次遍历结果：</p>\n<p>[<br />[3],<br />[9,20],<br />[15,7]<br />]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;BFS（广度优先搜索）：层次遍历</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * BFS\n     * @param root\n     * @return\n     */\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {\n        if (root == null) {\n            return new ArrayList&lt;&gt;(0);\n        }\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();\n        TreeNode current;\n        while (!queue.isEmpty()) {\n            List&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();\n            for (int i = queue.size(); i &gt; 0; i--) {\n                current = queue.poll();\n                arrayList.add(current.val);\n                if (current.left != null) {\n                    queue.add(current.left);\n                }\n                if (current.right != null) {\n                    queue.add(current.right);\n                }\n            }\n            list.add(arrayList);\n        }\n        return list;\n    }</code></pre>","blogGoods":0,"blogId":"1253350612905598976","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6huUyATZJ_AAAaZr2Bc1U363.jpg","blogRead":1,"blogRemark":"剑指offer----之从上到下打印二叉树----LeetCode102","blogTitle":"剑指offer----之从上到下打印二叉树----LeetCode102","createdTime":"2020-04-23 23:50:45","typeName":"LeetCode","updateTime":"2020-04-23 23:50:57"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，从上打印二叉树-1</strong></h2>\n<p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>\n<p>例如:<br />给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>\n<p>3<br />/ \\<br />9 20<br />/ \\<br />15 7<br />返回：</p>\n<p>[3,9,20,15,7]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;BFS（广度优先搜索）：也即是二叉树的层次遍历，代码和注意事项看代码注释</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 二叉树的层次遍历\n     * 这里是将层次遍历的结果存储在数组中\n     * 但是因为二叉树的节点个数并不知道\n     * 所以不能使用数组直接进行存储，因为无法初始化数组的大小\n     * 所以可以想到使用容量能自动扩充的list集合\n     * 然后再根据list集合的size来初始化数组的大小\n     * 并且将list元素赋值到数组中\n     * @param root\n     * @return\n     */\n    public static int[] levelOrder(TreeNode root) {\n        if(root==null){\n            return new int[0];\n        }\n        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n        TreeNode current;\n        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n        while(!queue.isEmpty()){\n            current = queue.poll();\n            list.add(current.val);\n            if(current.left!=null){\n                queue.add(current.left);\n            }\n            if(current.right!=null){\n                queue.add(current.right);\n            }\n        }\n        int[] result = new int[list.size()];\n        for (int i = 0; i &lt; list.size(); i++) {\n            result[i] = list.get(i);\n        }\n        return result;\n    }</code></pre>","blogGoods":0,"blogId":"1253346228108894208","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6htTeAUHGlAAAaZr2Bc1U102.jpg","blogRead":0,"blogRemark":"剑指offer----之从上到下打印二叉树","blogTitle":"剑指offer----之从上到下打印二叉树","createdTime":"2020-04-23 23:33:20","typeName":"LeetCode","updateTime":"2020-04-23 23:33:20"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，包含min函数的栈</strong></h2>\n<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>\n<p>&nbsp;</p>\n<p>示例:</p>\n<p>MinStack minStack = new MinStack();<br />minStack.push(-2);<br />minStack.push(0);<br />minStack.push(-3);<br />minStack.min(); --&gt; 返回 -3.<br />minStack.pop();<br />minStack.top(); --&gt; 返回 0.<br />minStack.min(); --&gt; 返回 -2.</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>&nbsp;辅助栈法：即初始化两个栈A,B</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;A栈用于实现基本的push(),pop(),top()的正常逻辑</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;B栈用来存放A栈中的非严格降序元素（这个我也理解不了，看代码就知道是存放什么的啦），代码中的方法注释很清楚</strong></p>\n<pre class=\"language-java\"><code>public class MinStack {\n    /** initialize your data structure here. */\n    Stack&lt;Integer&gt; A,B;\n\n    public MinStack() {\n        A = new Stack&lt;&gt;();\n        B = new Stack&lt;&gt;();\n    }\n\n    /**\n     * 入栈操作，元素先入A栈\n     * 如果B栈为空或者B栈的栈顶元素大于待入栈元素，则B栈也执行入栈操作\n     * @param x\n     */\n    public void push(int x) {\n        A.add(x);\n        if(B.isEmpty()||B.peek()&gt;=x){\n            B.add(x);\n        }\n    }\n\n    /**\n     * 这段代码优点巧妙\n     * 注意这里使用的A.pop()而不是A.peek()\n     * 所以这里实际上是分为两种情况的\n     * 第一种：当A的栈顶元素不为当前栈中的最小元素，即不等于栈B的栈顶元素\n     *         则只进行栈A的出栈操作，即A.pop()\n     * 第二种：当A的栈顶元素为当前栈中的最小元素，即等于栈B的栈顶元素\n     *        则不仅要A.pop(),而且为了保证A,B栈中最小元素的同步性\n     *        B栈也要执行出栈操作\n     */\n    public void pop() {\n        if(A.pop().equals(B.peek())){\n            B.pop();\n        }\n    }\n\n    /**\n     * 正常获取A的栈顶元素\n     * @return\n     */\n    public int top() {\n        return A.peek();\n    }\n\n    /**\n     * 获取A栈的最小元素，即B栈的栈顶元素\n     * @return\n     */\n    public int min() {\n        return B.peek();\n    }\n}</code></pre>","blogGoods":0,"blogId":"1253331349566234624","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hp12AMy2MAAAaZr2Bc1U568.jpg","blogRead":4,"blogRemark":"剑指offer----之包含min函数的栈---LeetCode155","blogTitle":"剑指offer----之包含min函数的栈---LeetCode155","createdTime":"2020-04-23 22:34:13","typeName":"LeetCode","updateTime":"2020-04-23 23:50:51"},{"blogCollection":0,"blogComment":0,"blogContent":"<h3><strong>晚上九点多，坐在床上，面前摆放着电脑，屏幕显示的是LeetCode中的《剑指offer》的题解</strong></h3>\n<h3><strong>此时的我毫无睡意，当然，这并不是因为解出一道题的喜悦冲淡了我的睡意</strong></h3>\n<h3><strong>相反的，这是一种难以言明的心情，包含着对自己无知的羞愧，也包含着别人面对如此无知的自己也能给出耐心回应的感动</strong></h3>\n<h3><strong>人有时或许就是这样，刻意的举动会让人心生防备，但是无意的善举却能温润人心</strong></h3>\n<h3><strong>别人无意的一个回答，一个小举动，一句肯定的话</strong></h3>\n<h3><strong>殊不知却能为对方赋予无穷无尽的能量</strong></h3>\n<h3><strong>将这一天的疲惫和劳累都消除</strong></h3>\n<h3><strong>赠人玫瑰，手有余香</strong></h3>\n<h3><strong>我一直抱着这样的一种心态，或许我无法做到赠人玫瑰，但是我会尽量将自己的善意展现给别人</strong></h3>\n<h3><strong>也许他刚刚好正处于某个难关，而你又刚刚好是他难关之初的引导者</strong></h3>\n<h3><strong>一句话，或许对于你来说只是人生中微不足道的几秒钟</strong></h3>\n<h3><strong>而对他来说，或许可能是多年之后回忆起来也能嘴角上扬的美好岁月</strong></h3>\n<h3><strong>想起前段时间一部剧里面的话，在这里也送给屏幕前的你：愿你永怀善意，清澈明朗</strong></h3>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1253326423486144512","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hosWANYd2AAHQzo49lBU641.jpg","blogRead":3,"blogRemark":"2020-4-23有感","blogTitle":"2020-4-23有感","createdTime":"2020-04-23 22:14:38","typeName":"随心日记","updateTime":"2020-04-25 21:22:30"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，顺时针打印矩阵</strong></h2>\n<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>\n<p>示例 1：</p>\n<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br />输出：[1,2,3,6,9,8,7,4,5]<br />示例 2：</p>\n<p>输入：matrix =&nbsp;[[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br />输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p>\n<p>限制：</p>\n<p>0 &lt;= matrix.length &lt;= 100<br />0 &lt;= matrix[i].length&nbsp;&lt;= 100</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;模拟顺时针打印的这种循环结构：设置四个边界条件，l,r,t,b。按照从左往右，从上往下，从右往左，从下网往上的顺序依次读取矩阵的元素，并且每一次都判断边界是否相遇，直到将整个矩阵元素都加入到数组中即可。</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 设置四个边界值，分别为left=0,right=matrix[0].length-1,top=0,bottom=matrix.length-1\n     * 顺时针顺序即先从左到右，再从上到下，再从右向左，再从下向上，每一次执行都要判断边界值\n     * @param matrix\n     * @return\n     */\n    public static int[] spiralOrder(int[][] matrix) {\n        if(matrix.length==0){\n            return new int[0];\n        }\n        int l = 0;\n        int r=matrix[0].length-1;\n        int t=0;\n        int b=matrix.length-1;\n        int x=0;\n        int[] res = new int[(r+1)*(b+1)];\n        while(true){\n            //从左向右\n            for(int i=l;i&lt;=r;i++){\n                res[x++]=matrix[t][i];\n            }\n            if(++t&gt;b) {\n                break;\n            }\n            //从上向下\n            for(int i=t;i&lt;=b;i++){\n                res[x++] = matrix[i][r];\n            }\n            if(--r&lt;l){\n                break;\n            }\n            //从右向左\n            for(int i=r;i&gt;=l;i--){\n                res[x++] = matrix[b][i];\n            }\n            if(--b&lt;t){\n                break;\n            }\n            //从下往上\n            for(int i=b;i&gt;=t;i--){\n                res[x++] = matrix[i][l];\n            }\n            if(++l&gt;r){\n                break;\n            }\n        }\n        return res;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1253250557729087488","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hXB2ASIQwAAAaZr2Bc1U016.jpg","blogRead":0,"blogRemark":"剑指offer-----之顺时针打印矩阵----LeetCode54","blogTitle":"剑指offer-----之顺时针打印矩阵----LeetCode54","createdTime":"2020-04-23 17:13:11","typeName":"LeetCode","updateTime":"2020-04-23 17:13:11"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，对称的二叉树</strong></h2>\n<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>\n<p>例如，二叉树&nbsp;[1,2,2,3,4,4,3] 是对称的。</p>\n<p>&nbsp; &nbsp; 1<br />&nbsp; &nbsp;/ \\<br />&nbsp; 2 &nbsp; 2<br />&nbsp;/ \\ / \\<br />3 &nbsp;4 4 &nbsp;3<br />但是下面这个&nbsp;[1,2,2,null,3,null,3] 则不是镜像对称的:</p>\n<p>&nbsp; &nbsp; 1<br />&nbsp; &nbsp;/ \\<br />&nbsp; 2 &nbsp; 2<br />&nbsp; &nbsp;\\ &nbsp; \\<br />&nbsp; &nbsp;3 &nbsp; &nbsp;3</p>\n<p>示例 1：</p>\n<p>输入：root = [1,2,2,3,4,4,3]<br />输出：true<br />示例 2：</p>\n<p>输入：root = [1,2,2,null,3,null,3]<br />输出：false</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>递归法：从对称的二叉树中我们可以找到如下规律</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果一个二叉树是对称的，则每一个节点的左右子树也是对称的,因此是递归的</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 设L = root.left，R=root.right，则满足L.left.val = R.right.val;L.right.val=R.left.val;</strong></p>\n<pre class=\"language-java\"><code>public boolean isSymmetric(TreeNode root) {\n        return  root==null?true:recur(root.left,root.right);\n    }\n    public boolean recur(TreeNode L,TreeNode R){\n        if(L==null&amp;&amp;R==null){\n            return true;\n        }\n        if(L==null||R==null||L.val!=R.val){\n            return false;\n        }\n        return recur(L.left,R.right)&amp;&amp;recur(L.right,R.left);\n    }</code></pre>","blogGoods":0,"blogId":"1252992659794968576","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6ga--AKQdvAAAaZr2Bc1U862.jpg","blogRead":1,"blogRemark":"剑指offer----之对称的二叉树----LeetCode101","blogTitle":"剑指offer----之对称的二叉树----LeetCode101","createdTime":"2020-04-23 00:08:23","typeName":"LeetCode","updateTime":"2020-04-23 00:12:33"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，二叉树镜像</strong></h2>\n<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>\n<p>例如输入：</p>\n<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; 2 &nbsp; &nbsp; 7<br />&nbsp;/ \\ &nbsp; / \\<br />1 &nbsp; 3 6 &nbsp; 9<br />镜像输出：</p>\n<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; 7 &nbsp; &nbsp; 2<br />&nbsp;/ \\ &nbsp; / \\<br />9 &nbsp; 6 3&nbsp; &nbsp;1</p>\n<p>示例 1：</p>\n<p>输入：root = [4,2,7,1,3,6,9]<br />输出：[4,7,2,9,6,3,1]</p>\n<p>限制：</p>\n<p>0 &lt;= 节点个数 &lt;= 1000</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;递归法：即递归的去交换根节点的左右子树，直到根节点为叶子节点</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用递归的方法，交换根节点的左子树和右子树\n     * 递归出口为，根节点为叶子节点\n     * @param root\n     * @return\n     */\n    public TreeNode mirrorTree(TreeNode root) {\n        TreeNode center = root;\n        if(center!=null){\n            TreeNode temp = center.left;\n            center.left = center.right;\n            center.right = temp;\n            mirrorTree(center.left);\n            mirrorTree(center.right);\n        }\n        return root;\n    }</code></pre>","blogGoods":0,"blogId":"1252985443281027072","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6gZTWABF55AAAaZr2Bc1U678.jpg","blogRead":0,"blogRemark":"剑指offer----之二叉树的镜像----LeetCode226","blogTitle":"剑指offer----之二叉树的镜像----LeetCode226","createdTime":"2020-04-22 23:39:43","typeName":"LeetCode","updateTime":"2020-04-22 23:39:43"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，合并两个有序链表</strong></h2>\n<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>\n<p>示例1：</p>\n<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br />输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br />限制：</p>\n<p>0 &lt;= 链表长度 &lt;= 1000</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>伪头节点法：即创建一个伪头节点head和一个用于辅助的节点cur</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法：如果l1.val&lt;=l2.val,就让cur指向l1，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l1指向其next</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果l1.val&gt;l2.val,就让cur指向l2，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l2指向其next</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;直到l1和l2有一个为空为止，让cur指向剩余的一个非空链表即可，若两个链表的长度为M,N则时间复杂度为O(M+N)</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用四节点，一个伪头节点，一个当前节点cur，已经链表的两个节点l1,l2\n     * 每次比较l1,l2节点的val大小，将小的节点连接到当前节点cur上即可\n     * 直到l1,l2有一个空，则将剩余的一个非空链表连接到cur尾部即可\n     * @param l1\n     * @param l2\n     * @return\n     */\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode head;\n        ListNode cur;\n        head = cur = new ListNode(0);\n        while(l1!=null&amp;&amp;l2!=null){\n            if(l1.val&lt;=l2.val){\n                cur.next = l1;\n                cur = cur.next;\n                l1 = l1.next;\n            }else{\n                cur.next = l2;\n                cur = cur.next;\n                l2 = l2.next;\n            }\n        }\n        if(l1!=null){\n            cur.next = l1;\n        }\n        if(l2!=null){\n            cur.next = l2;\n        }\n        return head.next;\n    }</code></pre>","blogGoods":0,"blogId":"1252980258446000128","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6gYGWAe-MZAAAaZr2Bc1U550.jpg","blogRead":0,"blogRemark":"剑指offer----之合并有序链表---LeetCode21","blogTitle":"剑指offer----之合并有序链表---LeetCode21","createdTime":"2020-04-22 23:19:06","typeName":"LeetCode","updateTime":"2020-04-22 23:19:06"}],"pageSize":15,"params":{},"sortColumn":"created_time","sortMethod":"DESC","totalCount":53,"totalPage":4},"msg":"操作成功!"}
2020-04-26 23:39:04.086 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /admin/info
2020-04-26 23:39:04.086 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:39:04.087 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:39:04.088 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.AdminController.getAdminInfo
2020-04-26 23:39:04.088 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:47:46.755 INFO  [restartedMain]com.wcj.BlogApplication.logStarting:55 -Starting BlogApplication on LAPTOP-SF80F1HO with PID 27092 (D:\MyBlog\blog\target\classes started by 邬成军 in D:\MyBlog\blog)
2020-04-26 23:47:46.760 INFO  [restartedMain]com.wcj.BlogApplication.logStartupProfileInfo:655 -The following profiles are active: pro
2020-04-26 23:47:46.828 INFO  [restartedMain]o.s.b.devtools.env.DevToolsPropertyDefaultsPostProcessor.logTo:225 -Devtools property defaults active! Set 'spring.devtools.add-properties' to 'false' to disable
2020-04-26 23:47:46.829 INFO  [restartedMain]o.s.b.devtools.env.DevToolsPropertyDefaultsPostProcessor.logTo:225 -For additional web related logging consider setting the 'logging.level.web' property to 'DEBUG'
2020-04-26 23:47:47.724 INFO  [restartedMain]o.s.d.repository.config.RepositoryConfigurationDelegate.registerRepositoriesIn:127 -Bootstrapping Spring Data MongoDB repositories in DEFAULT mode.
2020-04-26 23:47:47.818 INFO  [restartedMain]o.s.d.repository.config.RepositoryConfigurationDelegate.registerRepositoriesIn:187 -Finished Spring Data repository scanning in 88ms. Found 4 MongoDB repository interfaces.
2020-04-26 23:47:48.322 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'shiroConfig' of type [com.wcj.config.ShiroConfig$$EnhancerBySpringCGLIB$$64e69320] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:48.348 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'hashedCredentialsMatcher' of type [org.apache.shiro.authc.credential.HashedCredentialsMatcher] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:48.383 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mybatis-org.mybatis.spring.boot.autoconfigure.MybatisProperties' of type [org.mybatis.spring.boot.autoconfigure.MybatisProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:48.395 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration' of type [org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration$$EnhancerBySpringCGLIB$$c19894c7] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:48.399 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceAutoConfigure' of type [com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceAutoConfigure$$EnhancerBySpringCGLIB$$a8703909] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:48.404 INFO  [restartedMain]c.a.d.s.boot.autoconfigure.DruidDataSourceAutoConfigure.dataSource:56 -Init DruidDataSource
2020-04-26 23:47:48.480 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'spring.datasource-org.springframework.boot.autoconfigure.jdbc.DataSourceProperties' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:48.491 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'com.alibaba.druid.spring.boot.autoconfigure.stat.DruidFilterConfiguration' of type [com.alibaba.druid.spring.boot.autoconfigure.stat.DruidFilterConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:48.515 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'statFilter' of type [com.alibaba.druid.filter.stat.StatFilter] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:51.737 INFO  [restartedMain]com.alibaba.druid.pool.DruidDataSource.init:930 -{dataSource-1} inited
2020-04-26 23:47:51.738 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'dataSource' of type [com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceWrapper] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:51.798 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker' of type [org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:51.998 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'sqlSessionFactory' of type [org.apache.ibatis.session.defaults.DefaultSqlSessionFactory] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:52.004 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'sqlSessionTemplate' of type [org.mybatis.spring.SqlSessionTemplate] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:52.012 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'adminMapper' of type [org.mybatis.spring.mapper.MapperFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:52.016 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'adminMapper' of type [com.sun.proxy.$Proxy92] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:52.018 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'adminServiceImpl' of type [com.wcj.service.impl.AdminServiceImpl] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:52.022 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'userMapper' of type [org.mybatis.spring.mapper.MapperFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:52.024 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'userMapper' of type [com.sun.proxy.$Proxy95] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:52.040 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#74fdf91b' of type [org.springframework.beans.factory.config.PropertiesFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:52.042 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#74fdf91b' of type [java.util.Properties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:52.070 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#37e8a224' of type [org.springframework.data.repository.core.support.PropertiesBasedNamedQueries] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:52.075 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#600bb1e9' of type [org.springframework.data.repository.core.support.RepositoryFragmentsFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:52.079 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#600bb1e9' of type [org.springframework.data.repository.core.support.RepositoryComposition$RepositoryFragments] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:52.099 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'spring.data.mongodb-org.springframework.boot.autoconfigure.mongo.MongoProperties' of type [org.springframework.boot.autoconfigure.mongo.MongoProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:52.100 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.data.mongo.MongoDbFactoryDependentConfiguration' of type [org.springframework.boot.autoconfigure.data.mongo.MongoDbFactoryDependentConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:52.102 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.data.mongo.MongoDbFactoryConfiguration' of type [org.springframework.boot.autoconfigure.data.mongo.MongoDbFactoryConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:52.104 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration' of type [org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:52.171 INFO  [restartedMain]org.mongodb.driver.cluster.info:71 -Cluster created with settings {hosts=[121.199.34.159:27017], mode=MULTIPLE, requiredClusterType=UNKNOWN, serverSelectionTimeout='30000 ms', maxWaitQueueSize=500}
2020-04-26 23:47:52.172 INFO  [restartedMain]org.mongodb.driver.cluster.info:71 -Adding discovered server 121.199.34.159:27017 to client view of cluster
2020-04-26 23:47:52.214 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongo' of type [com.mongodb.MongoClient] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:52.226 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongoDbFactory' of type [org.springframework.data.mongodb.core.SimpleMongoDbFactory] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:52.233 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'org.springframework.boot.autoconfigure.data.mongo.MongoDataConfiguration' of type [org.springframework.boot.autoconfigure.data.mongo.MongoDataConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:52.319 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongoCustomConversions' of type [org.springframework.data.mongodb.core.convert.MongoCustomConversions] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:52.335 INFO  [cluster-ClusterId{value='5ea5ad28ee352b1af8c7befb', description='null'}-121.199.34.159:27017]org.mongodb.driver.connection.info:71 -Opened connection [connectionId{localValue:1, serverValue:623}] to 121.199.34.159:27017
2020-04-26 23:47:52.346 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongoMappingContext' of type [org.springframework.data.mongodb.core.mapping.MongoMappingContext] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:52.380 INFO  [cluster-ClusterId{value='5ea5ad28ee352b1af8c7befb', description='null'}-121.199.34.159:27017]org.mongodb.driver.cluster.info:71 -Monitor thread successfully connected to server with description ServerDescription{address=121.199.34.159:27017, type=STANDALONE, state=CONNECTED, ok=true, version=ServerVersion{versionList=[4, 2, 5]}, minWireVersion=0, maxWireVersion=8, maxDocumentSize=16777216, logicalSessionTimeoutMinutes=30, roundTripTimeNanos=42339399}
2020-04-26 23:47:52.381 INFO  [cluster-ClusterId{value='5ea5ad28ee352b1af8c7befb', description='null'}-121.199.34.159:27017]org.mongodb.driver.cluster.info:71 -Discovered cluster type of STANDALONE
2020-04-26 23:47:52.394 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mappingMongoConverter' of type [org.springframework.data.mongodb.core.convert.MappingMongoConverter] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:52.451 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'mongoTemplate' of type [org.springframework.data.mongodb.core.MongoTemplate] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:52.659 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'blogCollectionDao' of type [org.springframework.data.mongodb.repository.support.MongoRepositoryFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:52.669 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'blogCollectionDao' of type [com.sun.proxy.$Proxy110] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:52.694 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'typeMapper' of type [org.mybatis.spring.mapper.MapperFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:52.695 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'typeMapper' of type [com.sun.proxy.$Proxy112] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:52.699 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#736247ea' of type [org.springframework.beans.factory.config.PropertiesFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:52.700 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#736247ea' of type [java.util.Properties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:52.700 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#1b4541f4' of type [org.springframework.data.repository.core.support.PropertiesBasedNamedQueries] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:52.701 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#29941e9e' of type [org.springframework.data.repository.core.support.RepositoryFragmentsFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:52.701 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean '(inner bean)#29941e9e' of type [org.springframework.data.repository.core.support.RepositoryComposition$RepositoryFragments] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:52.717 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'commentDao' of type [org.springframework.data.mongodb.repository.support.MongoRepositoryFactoryBean] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:52.717 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'commentDao' of type [com.sun.proxy.$Proxy116] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:52.736 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'userServiceImpl' of type [com.wcj.service.impl.UserServiceImpl] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:52.748 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'adminRealm' of type [com.wcj.realm.AdminRealm] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:52.779 INFO  [restartedMain]o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker.postProcessAfterInitialization:330 -Bean 'securityManager' of type [org.apache.shiro.web.mgt.DefaultWebSecurityManager] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-26 23:47:53.071 INFO  [restartedMain]o.s.boot.web.embedded.tomcat.TomcatWebServer.initialize:92 -Tomcat initialized with port(s): 1000 (http)
2020-04-26 23:47:53.079 INFO  [restartedMain]org.apache.coyote.http11.Http11NioProtocol.log:173 -Initializing ProtocolHandler ["http-nio-1000"]
2020-04-26 23:47:53.080 INFO  [restartedMain]org.apache.catalina.core.StandardService.log:173 -Starting service [Tomcat]
2020-04-26 23:47:53.080 INFO  [restartedMain]org.apache.catalina.core.StandardEngine.log:173 -Starting Servlet engine: [Apache Tomcat/9.0.31]
2020-04-26 23:47:53.082 INFO  [restartedMain]org.apache.catalina.core.AprLifecycleListener.log:173 -Loaded APR based Apache Tomcat Native library [1.2.23] using APR version [1.7.0].
2020-04-26 23:47:53.082 INFO  [restartedMain]org.apache.catalina.core.AprLifecycleListener.log:173 -APR capabilities: IPv6 [true], sendfile [true], accept filters [false], random [true].
2020-04-26 23:47:53.083 INFO  [restartedMain]org.apache.catalina.core.AprLifecycleListener.log:173 -APR/OpenSSL configuration: useAprConnector [false], useOpenSSL [true]
2020-04-26 23:47:53.087 INFO  [restartedMain]org.apache.catalina.core.AprLifecycleListener.log:173 -OpenSSL successfully initialized [OpenSSL 1.1.1c  28 May 2019]
2020-04-26 23:47:53.185 INFO  [restartedMain]o.a.catalina.core.ContainerBase.[Tomcat].[localhost].[/].log:173 -Initializing Spring embedded WebApplicationContext
2020-04-26 23:47:53.185 INFO  [restartedMain]org.springframework.web.context.ContextLoader.prepareWebApplicationContext:284 -Root WebApplicationContext: initialization completed in 6356 ms
2020-04-26 23:47:53.286 INFO  [restartedMain]o.s.boot.devtools.autoconfigure.OptionalLiveReloadServer.startServer:58 -LiveReload server is running on port 35729
2020-04-26 23:47:54.595 INFO  [restartedMain]org.apache.coyote.http11.Http11NioProtocol.log:173 -Starting ProtocolHandler ["http-nio-1000"]
2020-04-26 23:47:54.617 INFO  [restartedMain]o.s.boot.web.embedded.tomcat.TomcatWebServer.start:204 -Tomcat started on port(s): 1000 (http) with context path ''
2020-04-26 23:47:54.619 INFO  [restartedMain]com.wcj.BlogApplication.logStarted:61 -Started BlogApplication in 8.578 seconds (JVM running for 10.56)
2020-04-26 23:48:22.420 INFO  [http-nio-1000-exec-1]o.a.catalina.core.ContainerBase.[Tomcat].[localhost].[/].log:173 -Initializing Spring DispatcherServlet 'dispatcherServlet'
2020-04-26 23:48:22.420 INFO  [http-nio-1000-exec-1]org.springframework.web.servlet.DispatcherServlet.initServletBean:525 -Initializing Servlet 'dispatcherServlet'
2020-04-26 23:48:22.431 INFO  [http-nio-1000-exec-1]org.springframework.web.servlet.DispatcherServlet.initServletBean:547 -Completed initialization in 11 ms
2020-04-26 23:48:22.516 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /admin/login
2020-04-26 23:48:22.516 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:48:22.518 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:48:22.519 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.AdminController.login
2020-04-26 23:48:22.520 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Admin(id=null, name=null, header=null, signature=null, comment=null, username=admin, password=admin)]
2020-04-26 23:48:22.693 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 176
2020-04-26 23:48:22.743 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"token":"89BDE55693A07F877D33F0DEE50C1D49"},"msg":"操作成功!"}
2020-04-26 23:48:22.935 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /admin/info
2020-04-26 23:48:22.936 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:48:22.936 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:48:22.936 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.AdminController.getAdminInfo
2020-04-26 23:48:22.936 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:48:22.936 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 1
2020-04-26 23:48:22.941 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"header":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMSKACehsAACHOzTvceE295.jpg","name":"小屋","password":"","signature":"时光好不经用，转眼已是半生","username":"admin"},"msg":"操作成功!"}
2020-04-26 23:48:23.495 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listFront
2020-04-26 23:48:23.495 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /rotation-picture/list
2020-04-26 23:48:23.495 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:48:23.496 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:48:23.496 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:48:23.496 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:48:23.496 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeLists
2020-04-26 23:48:23.496 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.RotationPictureController.getRotationPictureList
2020-04-26 23:48:23.497 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:48:23.497 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:48:23.584 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 89
2020-04-26 23:48:23.588 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":1,"typeName":"Linux"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":2,"typeName":"Docker"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"SpringBoot"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":4,"typeName":"Mybatis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":5,"typeName":"爬虫"},{"deleted":0,"enable":1,"typeBlogCount":4,"typeId":6,"typeName":"博客开发和维护总结"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":7,"typeName":"CSS"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"JavaScript"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Vue"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":10,"typeName":"随笔"},{"deleted":0,"enable":1,"typeBlogCount":16,"typeId":11,"typeName":"java面试篇"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":13,"typeName":"JDK源码阅读"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":14,"typeName":"redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":15,"typeName":"MongoDB"},{"deleted":0,"enable":1,"typeBlogCount":28,"typeId":16,"typeName":"LeetCode"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":17,"typeName":"随心日记"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":18,"typeName":"计算机网络"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":19,"typeName":"操作系统"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":20,"typeName":"数据结构"}],"msg":"操作成功!"}
2020-04-26 23:48:23.594 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 99
2020-04-26 23:48:23.596 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"createdTime":"2020-04-09 13:31:20","enable":1,"rotationId":4,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PI6aAZIz1AASCO4hlpJI295.jpg"},{"createdTime":"2020-04-09 13:37:02","enable":1,"rotationId":9,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJPyAbm8fAAG9gfO8lxE28.jpeg"},{"createdTime":"2020-04-09 13:41:30","enable":1,"rotationId":10,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJgeAeG8wAAS2pjJC5QU547.jpg"},{"createdTime":"2020-04-09 13:41:38","enable":1,"rotationId":11,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhGAQFZbAAP2OOBWb6k310.jpg"},{"createdTime":"2020-04-09 13:41:50","enable":1,"rotationId":12,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhyABMZCAAG7doyXiM8109.jpg"},{"createdTime":"2020-04-09 13:41:59","enable":1,"rotationId":13,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJiWAL7BoAARW3_O3ISw651.jpg"}],"msg":"操作成功!"}
2020-04-26 23:48:35.634 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /rotation-picture/listFront
2020-04-26 23:48:35.635 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:48:35.635 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:48:35.635 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.RotationPictureController.getRotationPictureListFront
2020-04-26 23:48:35.635 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:48:35.645 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listFront
2020-04-26 23:48:35.645 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /admin/getInfo
2020-04-26 23:48:35.645 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:48:35.645 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/recommendRead
2020-04-26 23:48:35.645 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:48:35.646 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:48:35.646 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:48:35.646 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:48:35.647 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.AdminController.getInfo
2020-04-26 23:48:35.648 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:48:35.648 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeLists
2020-04-26 23:48:35.648 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/getTotal
2020-04-26 23:48:35.648 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:48:35.648 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:48:35.648 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.recommendRead
2020-04-26 23:48:35.649 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:48:35.649 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:48:35.649 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:48:35.651 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getTotal
2020-04-26 23:48:35.653 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:48:35.673 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/list
2020-04-26 23:48:35.674 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:48:35.674 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:48:35.674 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogList
2020-04-26 23:48:35.674 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=15, totalPage=0, totalCount=0, list=[], params={}, sortColumn=created_time, sortMethod=DESC)]
2020-04-26 23:48:35.732 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 98
2020-04-26 23:48:35.732 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"createdTime":"2020-04-09 13:31:20","enable":1,"rotationId":4,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PI6aAZIz1AASCO4hlpJI295.jpg"},{"createdTime":"2020-04-09 13:37:02","enable":1,"rotationId":9,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJPyAbm8fAAG9gfO8lxE28.jpeg"},{"createdTime":"2020-04-09 13:41:30","enable":1,"rotationId":10,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJgeAeG8wAAS2pjJC5QU547.jpg"},{"createdTime":"2020-04-09 13:41:38","enable":1,"rotationId":11,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhGAQFZbAAP2OOBWb6k310.jpg"},{"createdTime":"2020-04-09 13:41:50","enable":1,"rotationId":12,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhyABMZCAAG7doyXiM8109.jpg"},{"createdTime":"2020-04-09 13:41:59","enable":1,"rotationId":13,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJiWAL7BoAARW3_O3ISw651.jpg"}],"msg":"操作成功!"}
2020-04-26 23:48:35.733 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 88
2020-04-26 23:48:35.735 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":1,"typeName":"Linux"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":2,"typeName":"Docker"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"SpringBoot"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":4,"typeName":"Mybatis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":5,"typeName":"爬虫"},{"deleted":0,"enable":1,"typeBlogCount":4,"typeId":6,"typeName":"博客开发和维护总结"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":7,"typeName":"CSS"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"JavaScript"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Vue"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":10,"typeName":"随笔"},{"deleted":0,"enable":1,"typeBlogCount":16,"typeId":11,"typeName":"java面试篇"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":13,"typeName":"JDK源码阅读"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":14,"typeName":"redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":15,"typeName":"MongoDB"},{"deleted":0,"enable":1,"typeBlogCount":28,"typeId":16,"typeName":"LeetCode"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":17,"typeName":"随心日记"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":18,"typeName":"计算机网络"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":19,"typeName":"操作系统"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":20,"typeName":"数据结构"}],"msg":"操作成功!"}
2020-04-26 23:48:35.735 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 90
2020-04-26 23:48:35.736 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"header":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMSKACehsAACHOzTvceE295.jpg","id":1,"name":"小屋","signature":"时光好不经用，转眼已是半生","username":"admin"},"msg":"操作成功!"}
2020-04-26 23:48:35.739 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 91
2020-04-26 23:48:35.739 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":53,"msg":"操作成功!"}
2020-04-26 23:48:35.749 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 104
2020-04-26 23:48:35.760 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1248605157059497984","blogRead":27,"blogTitle":"面试（二）------之JAVA基础篇","createdTime":"2020-04-10 13:34:02","typeName":"java面试篇"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1247745014683947008","blogRead":21,"blogTitle":"博客开发总结（一）-----之数据库设计篇","createdTime":"2020-04-08 04:36:07","typeName":"博客开发和维护总结"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1248224512563068928","blogRead":17,"blogTitle":"面试（一）------之JVM篇","createdTime":"2020-04-09 12:21:30","typeName":"java面试篇"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1249742755949817856","blogRead":17,"blogTitle":"面试（三）------之并发编程篇（下）","createdTime":"2020-04-13 16:54:26","typeName":"java面试篇"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1250622112591376384","blogRead":8,"blogTitle":"面试（六）------之网络与负载均衡","createdTime":"2020-04-16 03:08:42","typeName":"java面试篇"}],"msg":"操作成功!"}
2020-04-26 23:48:36.152 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 479
2020-04-26 23:48:36.161 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，0~n-1中缺失的数字</strong></h2>\n<p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>\n<p>示例 1:</p>\n<p>输入: [0,1,3]<br />输出: 2<br />示例&nbsp;2:</p>\n<p>输入: [0,1,2,3,4,5,6,7,9]<br />输出: 8</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主能想到的并且写出来的方法有：使用map存储数组中的所有元素，然后遍历0-n-1找出不在map中的元素。此种方法时间复杂度O（N），空间复杂度O（N）-----垃圾</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 统计0-n-1所有数字的数字和，再统计数组中所有数字的数字和，两和只差即为所求数字，时间复杂度O（N），空间复杂度O（1）-----垃圾</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;最优解法（二分查找法）：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;通常来说，我们使用二分查找法是查找一个存在于数组中的元素，但是本题需要求不在数组中的一个元素，因此到这很多人就会迷惑，不知道该怎么求了。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;但是我们首先要搞明白二分查找法的本质是什么：1，并不局限于仅仅查找存在于数组中的元素；2，二分查找的本质是对数组根据mid中间值在某一条件上进行二分（例如：通常的num[mid]&gt;target或者nums[mid]&lt;target进行左右切分）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;因此明白这一点，就好解决问题了。拿到这道题，使用二分，我们首先想到的应该是寻找根据mid中间值进行二分的条件</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;审题：题目中提及数组为递增数组，而且0-n-1内的n个数字有一个不在数组中，则不在的这个数字之前的数字满足nums[i]=i即元素本身等于数组下标，而之后的数字nums[i]!=i,所以这就是进行二分的条件了</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 二分查找法\n     * 算法思想：二分查找法的本质是能够有一个条件将数组根据mid中间值进行左右切分\n     * 所以我们想到二分查找法之后，首先需要做的是找出切分数组的条件\n     * 题目中给出了数组是一个递增数组，且0-n-1内的n个数字有一个不在这个长度为n-1的数组内\n     * 因此，不在的这个元素其左边元素必有数组下标值等于元素本身即nums[i]=i\n     * 而不在的这个元素的右边必有nums[i]!=i\n     * 所以根据此条件进行划分数组即可\n     * @param nums\n     * @return\n     */\n    public static int missingNumber(int[] nums) {\n        int low = 0;\n        int high = nums.length-1;\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]==mid){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        return low;\n    }</code></pre>","blogGoods":0,"blogId":"1254063045920022528","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kUM-AON88AAAaZr2Bc1U903.jpg","blogRead":0,"blogRemark":"剑指offer----0~n-1中缺失的数字","blogTitle":"剑指offer----0~n-1中缺失的数字","createdTime":"2020-04-25 23:01:44","typeName":"LeetCode","updateTime":"2020-04-25 23:01:44"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，在排序数组中查找数字I</strong></h2>\n<p>统计一个数字在排序数组中出现的次数。</p>\n<p>示例 1:</p>\n<p>输入: nums = [5,7,7,8,8,10], target = 8<br />输出: 2<br />示例&nbsp;2:</p>\n<p>输入: nums = [5,7,7,8,8,10], target = 6<br />输出: 0</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解法一：直接遍历统计，时间复杂度为O（N）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 遍历数组\n     * 找到第一个与目标元素相等的元素，res+1\n     * 然后往后找到第一个与目标元素不相等的元素,返回res即可\n     * 时间复杂度为O(N)\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static int search(int[] nums, int target) {\n        int res = 0;\n        for (int num : nums) {\n            if(num==target){\n                res++;\n            }\n        }\n        return res;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解法二：二分法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：利用二分法查找数字在排序数组中的左边界Left和右边界Right.如下，如果要寻找数组中的8，则其左边界为left=2,有边界right=5.所以出现次数为right-left-1.时间复杂度为O（logN）</strong></p>\n<table style=\"width: 20%; border-collapse: collapse; margin-left: auto; margin-right: auto;\" border=\"1\" cellpadding=\"5\">\n<tbody>\n<tr>\n<td style=\"width: 16.6667%;\">5</td>\n<td style=\"width: 16.6667%;\">7</td>\n<td style=\"width: 16.6667%;\">7</td>\n<td style=\"width: 16.6667%;\">8</td>\n<td style=\"width: 16.6667%;\">8</td>\n<td style=\"width: 16.6667%;\">10</td>\n</tr>\n</tbody>\n</table>\n<pre class=\"language-java\"><code>    /**\n     * 二分查找法\n     * 时间复杂度为O（logN）\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static int search2(int[] nums, int target){\n        int low = 0;\n        int high = nums.length-1;\n        int left,right;\n        left = right = 0;\n        //一次二分\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]&lt;=target){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        right = low;\n\n        low = 0;\n        high = nums.length -1;\n        //二次二分\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]&lt;target){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        left = high;\n        return right -left -1;\n    }</code></pre>","blogGoods":0,"blogId":"1254055163115724800","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kSXiAYRyFAAAaZr2Bc1U379.jpg","blogRead":0,"blogRemark":"剑指offer----在排序数组中查找数字I----LeetCode34","blogTitle":"剑指offer----在排序数组中查找数字I----LeetCode34","createdTime":"2020-04-25 22:30:24","typeName":"LeetCode","updateTime":"2020-04-25 22:30:24"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，两个链表的第一个公共节点</strong></h2>\n<p><strong><img src=\"https://images-cdn.shimo.im/Wd1NC8pveQYp9iIL.png__thumbnail\" alt=\"示例图\" width=\"742\" height=\"241\" /></strong></p>\n<p><strong>这是我从官方截下的一张图，也是有些人疑惑的地方，因为官方这张图给出的公共节点为8，而大多数人看到这张图，认为公共节点应该是1.</strong></p>\n<p><strong>但是实际上这里的公共节点不仅要节点的value相等，同时还需要节点的地址相等。从图中可以看出两个1节点虽然值相等，但是地址却不同，因而不是公共节点</strong></p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解法一：双指针</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：初始化两个指针p1=headA,p2=headB</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;分别遍历两个链表，求出两个链表的长度l1,l2</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;然后重置p1,p2指针指向头节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;让长链表的指针先走多的步数（l1-l2或者l2-l1）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;然后让两个指针同时走，直到两者相遇，即找到公共节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解疑：弄清楚第一个value相等的节点和指针相遇的节点，这两种节点是不同的，指针相遇的节点，不仅包含value相等，同时地址也相等。（如图中的8）；而第一个value相等的节点则可能并不在同一个地址，因此不一定是公共节点</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法\n     * @param headA\n     * @param headB\n     * @return\n     */\n    public static ListNode getIntersectionNode2(ListNode headA, ListNode headB){\n        ListNode p1 =headA;\n        ListNode p2 = headB;\n        int l1 = 0;\n        int l2 = 0;\n        //计算链表1的长度\n        while(p1!=null){\n            l1++;\n            p1 = p1.next;\n        }\n        //计算链表2的长度\n        while(p2!=null){\n            l2++;\n            p2 = p2.next;\n        }\n        p1 = headA;\n        p2 = headB;\n        //让长链表指针先走长的步数\n        if(l1&gt;l2){\n            for (int i = 0; i &lt; l1-l2; i++) {\n                p1 = p1.next;\n            }\n        }else{\n            for (int i = 0; i &lt; l2-l1; i++) {\n                p2 = p2.next;\n            }\n        }\n        //然后让两个指针同时走，直到相遇\n        while(p1!=p2){\n            p1 = p1.next;\n            p2 = p2.next;\n        }\n        return p1;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;解法二（大神解法）：丘比特相遇法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;利用两个指针p1=headA,p2=headB,让两个指针同时走，</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果p1先走到底，就将p1置为headB，</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果p2,先走到底，就将p2置为headA,</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;当两个指针相遇的时候，他们就相爱了（当然是找到公共节点了）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法p1=headA,p2=headB\n     * 思想是：两个节点同时从各自的链表出发\n     * p1走到末尾时，回到headB的头部\n     * p2走到末尾时，回到headA的头部\n     * 两个指针相遇的时候，即使要找的公共节点\n     * @param headA\n     * @param headB\n     * @return\n     */\n    public static ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode p1 = headA;\n        ListNode p2 = headB;\n        while(p1!=p2){\n            p1 = (p1==null)?headB:p1.next;\n            p2 = (p2==null)?headA:p2.next;\n        }\n        return p1;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1253992797703364608","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kD2OADD3mAAAaZr2Bc1U709.jpg","blogRead":0,"blogRemark":"剑指offer----之两个链表的第一个公共节点----LeetCode160","blogTitle":"剑指offer----之两个链表的第一个公共节点----LeetCode160","createdTime":"2020-04-25 18:22:35","typeName":"LeetCode","updateTime":"2020-04-25 18:22:35"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，第一个只出现一次的字符</strong></h2>\n<p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。</p>\n<p>示例:</p>\n<p>s = \"abaccdeff\"<br />返回 \"b\"</p>\n<p>s = \"\" <br />返回 \" \"</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主现在发现，做一道算法题的时候，最重要的一步就是读题，审题，在草稿纸上写下自己的思路（当然那种望眼欲穿的大佬除外）。然后才开始动笔，对于IT人来说，真的，多将时间花费在思考上面，而不是无意义的重复搬砖。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;题目分析：看到这道题，抓住两个关键字：第一个，只出现一次。什么意思呢，例如\"abaccdeff\"，其中只出现一次的字符有'b','d','e'三个，然后在三个字符中第一个出现在字符串中的是'b'，因此本题的答案是'b'.</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法分析：根据题目分析，我们最直观的解法应该是，先找出字符串中只出现一次的字符，然后再找出只出现一次字符中，第一个在字符串中出现的。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;所以我们需要做两件事，一是统计字符串中各个字符的出现次数，并且记录；二，统计完毕后，找出第一个出现次数为1的字符，返回即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;因此我们既要存字符，还要存字符对应的出现次数，所以理所当然我们选择map集合。当然对于本题而言，因为求第一个出现一次的字符，所以我们更好的是可以使用LinkedHashMap。这样免去最后的一次遍历字符串</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;下面提供两种解法：三种解法都是使用map集合，但是略有不同</strong></p>\n<p><strong>LinkedHashMap：（这是博主写的，代码冗余，这里用来和大神的写法做比较，警醒自己）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 用LinkedHashMap\n     * 思想：遍历字符串，如果map为空或者map中不含当前字符，则将其存入map\n     * 如果map中已经含有当前字符，则从map中移除\n     * 最终map中只剩出现一次的字符\n     * 返货map中的第一个即可\n     * @param s\n     * @return\n     */\n    public static char firstUniqChar(String s) {\n        Map&lt;Character,Integer&gt;map = new LinkedHashMap&lt;&gt;();\n        for (int i = 0; i &lt; s.length(); i++) {\n            char ch = s.charAt(i);\n            if(map.isEmpty()||!map.containsKey(ch)){\n                map.put(ch,1);\n            }else{\n                Integer val = map.get(ch);\n                map.put(ch,++val);\n            }\n        }\n        //返回map中第一个元素即可\n        Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entries = map.entrySet();\n        for (Map.Entry&lt;Character, Integer&gt; entry : entries) {\n            if(entry.getValue()==1){\n                return entry.getKey();\n            }\n        }\n        return ' ';\n    }</code></pre>\n<p><strong>HashMap（大神解法）：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 哈希表法\n     * @param s\n     * @return\n     */\n    public char firstUniqChar2(String s) {\n        Map&lt;Character,Boolean&gt; map = new HashMap&lt;&gt;();\n        char[] chars = s.toCharArray();\n        for (char ch : chars) {\n            map.put(ch,!map.containsKey(ch));\n        }\n        for (char ch : chars) {\n            if(map.get(ch)){\n                return ch;\n            }\n        }\n        return ' ';\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;分析：首先，这里提供了两种解法，一种为LinkedHashMap，一种为HashMap，这两种解法的不同之处就在于最后获取值的时候，LinkedHashMap获取最终值是遍历LinkedHashMap的entrySet，但是HashMap获取最终值是遍历原字符串。因而当数据庞大的时候，显然使用LinkedHashMap性能更高。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;然后，再分析一下这两种解法不另外一个不同之处，没错！就是大神的解法中使用map存放key对应的value值是Boolean型！（<span style=\"background-color: #ffcc00;\">这个真的是神一般的存在</span>），既省去了计算次数的麻烦，同时最后取的时候也不需要判断次数。wc！同一种解法，为什么天差地别！</strong></p>","blogGoods":0,"blogId":"1253956468789600256","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6j7Y6ACrySAAAaZr2Bc1U825.jpg","blogRead":0,"blogRemark":"剑指offer----第一次只出现一次的字符","blogTitle":"剑指offer----第一次只出现一次的字符","createdTime":"2020-04-25 15:58:14","typeName":"LeetCode","updateTime":"2020-04-25 15:58:14"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，连续子数组的最大和</strong></h2>\n<p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>\n<p>要求时间复杂度为O(n)。</p>\n<p>示例1:</p>\n<p>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br />输出: 6<br />解释:&nbsp;连续子数组&nbsp;[4,-1,2,1] 的和最大，为&nbsp;6。</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;看到这道题，最简单的想法肯定是求出所有连续子数组的值，然后进行比较，找出最大的即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;但是随后会想到既然要找出所有的子数组，那么我们可以使用分治的思想，因为分治的分过程即可以得到所有子序列</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;随后，再深一步，既然可以分治的思想，分的过程即是递归的过程，而且子数组的最大值依赖与前一子数组，所以可以想到使用动态规划</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：设dp[i]为以nums[i]为结尾的最大子数组和，初始值dp[0] = nums[0]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;遍历数组，如果dp[i-1]&gt;=0。则说明前面的最大子数组对当前子数组有增益效果，所以dp[i] = dp[i-1]+nums[i]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果dp[i-1]&lt;0。说明前面的最大子数组对当前子数组有夫负效果，还不如nums[i]本身，所以dp[i]=nums[i]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主的这样的写法：时间复杂度为O（N），空间复杂度也为O（N），但是实际上不需要使用dp数组，使用nums原数组就行，所以可以减小空间复杂度为O（1）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 动态规划\n     * 算法思想：因为求的是连续子数组的最大和\n     * 所以我们可以设dp[i]为以nums[i]结尾的最大连续子数组\n     * 如果dp[i]&lt;=nums[i],dp[i]=nums[i]\n     * 如果dp[i]&gt;nums[i],则dp[i]=dp[i]+nums[i]\n     * @param nums\n     * @return\n     */\n    public static int maxSubArray(int[] nums) {\n        int[] dp  = new int[nums.length];\n        dp[0] = nums[0];\n        int res = nums[0];\n        for (int i = 1; i &lt; nums.length; i++) {\n            if(dp[i-1]&lt;0){\n                dp[i] = nums[i];\n            }else{\n                dp[i] = dp[i-1]+nums[i];\n            }\n            res = Math.max(res,dp[i]);\n        }\n        return res;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1253938714590175232","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6j3QSACLxRAAAaZr2Bc1U017.jpg","blogRead":0,"blogRemark":"剑指offer---连续子数组的最大和---LeetCode53","blogTitle":"剑指offer---连续子数组的最大和---LeetCode53","createdTime":"2020-04-25 14:47:41","typeName":"LeetCode","updateTime":"2020-04-25 14:47:41"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，最小的k个数</strong></h2>\n<p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>\n<p>示例 1：</p>\n<p>输入：arr = [3,2,1], k = 2<br />输出：[1,2] 或者 [2,1]<br />示例 2：</p>\n<p>输入：arr = [0,1,2,1], k = 1<br />输出：[0]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;1,可以采用快排的思想，将原数组按照升序排序，然后取出前k个数即可，时间复杂度为O（NlogN）。但是其实跟API中的sort方法好像差别不大</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 对原数组升序排序，然后取前k个元素\n     * @param arr\n     * @param k\n     * @return\n     */\n    public static int[] getLeastNumbers(int[] arr, int k) {\n        quickSort(arr,0,arr.length-1);\n        int[] result = new int[k];\n        for (int i = 0; i &lt; k; i++) {\n            result[i] = arr[i];\n        }\n        return result;\n    }\n\n    /**\n     * 快排\n     * @param nums\n     * @param low\n     * @param high\n     */\n    public static void quickSort(int[] nums,int low,int high){\n        int base = nums[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //先从右向左找到第一个小于基准元素的元素\n            while(L&lt;R&amp;&amp;nums[R]&gt;=base){\n                R--;\n            }\n            if(nums[R]&lt;base){\n                swap(nums,L,R);\n            }\n            //再从左向右找到第一个大于基准元素的元素\n            while(L&lt;R&amp;&amp;nums[L]&lt;=base){\n                L++;\n            }\n            if(nums[L]&gt;base){\n                swap(nums,L,R);\n            }\n        }\n        //左递归\n        if(L&gt;low){\n            quickSort(nums,low,L-1);\n        }\n        //右递归\n        if(high&gt;R){\n            quickSort(nums,R+1,high);\n        }\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>2，堆排序：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;先讲解一下堆排序：堆排序是一种完全二叉树的结构，常见的存在两种堆结构，小根堆（即满足arr[2i+1]&gt;=arr[i]&amp;&amp;arr[2i+2]&gt;=arr[i]），大根堆（即满足arr[2i+1]&lt;=arr[i]&amp;&amp;arr[2i+2]&lt;=arr[i]）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;基本算法思想：第一步，初始化堆，即堆初始化为大根堆或者小根堆（这里我们简称调整堆）；第二步，将堆顶元素与堆的末尾元素进行交换，然后重新调整堆。在java中堆通常用来实现优先级队列PriorityQueue(默认的采用小根堆，若想使用大根堆，需要在创建时实现comparator)</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;使用情况：这里以java中的优先级队列为例，堆的使用情况不能按照堆名断章取义，例如小根堆实际上是将元素升序存放，因为在算法第二步中将堆顶元素与末尾元素进行交换，然后重新调整，交换的堆顶元素为最小元素，也是最先从堆中进入队列的。所以小根堆适用于TOPk大的算法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;相反的，大根堆适用于TOPk小的算法，下面分别给出小根堆和大根堆的算法：</strong></p>\n<p><strong>小根堆：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 堆排序---小根堆\n     * @param nums\n     */\n    public static void HeapSort(int[] nums){\n        //先初始化堆\n        for (int i = nums.length/2-1; i &gt;=0 ; i--) {\n            adjustHeap(nums,i,nums.length);\n        }\n        //交换堆顶与末尾节点+重新调整为小根堆\n        for (int i = nums.length-1; i &gt;0; i--) {\n            //先交换\n            swap(nums,0,i);\n            //再调整\n            adjustHeap(nums,0,i);\n        }\n    }\n\n    /**\n     * 调整为小根堆\n     * @param nums\n     * @param i\n     * @param length\n     */\n    public static void adjustHeap(int[] nums,int i,int length){\n        int temp = nums[i];\n        for (int j = 2*i+1; j &lt; length; j=2*j+1) {\n            //找出左右节点中的最小值\n            if(j+1&lt;length&amp;&amp;nums[j]&gt;nums[j+1]){\n                j++;\n            }\n            if(nums[j]&lt;temp){\n                nums[i] = nums[j];\n                i = j;\n            }\n        }\n        nums[i] = temp;\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p><strong>大根堆：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 堆排序---大根堆\n     * @param nums\n     */\n    public static void heapSort(int[] nums){\n\n        //初始化堆的过程\n        for (int i = nums.length/2-1; i &gt;=0; i--) {\n            adjustHeap(nums,i,nums.length);\n        }\n        //调整+交换堆顶和末尾的元素\n        for (int i = nums.length-1; i &gt;0; i--) {\n            //先交换，再重新调整\n            swap(nums,0,i);\n            adjustHeap(nums,0,i);\n        }\n    }\n\n    /**\n     * 调整大顶堆的过程\n     * @param nums\n     * @param i\n     * @param length\n     */\n    public static void adjustHeap(int[] nums,int i,int length){\n        int temp = nums[i];\n        for (int j = 2*i+1; j &lt; length; j=2*j+1) {\n            //找出左右节点中的最大值\n            if(j+1&lt;length&amp;&amp;nums[j]&lt;nums[j+1]){\n                j++;\n            }\n            if(nums[j]&gt;temp){\n                nums[i] = nums[j];\n                i = j;\n            }\n        }\n        nums[i] = temp;\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>本题利用大根堆解法，且使用java中自带的优先级队列PriorityQueue：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用堆数据结构，java中的优先级队列对应着最小堆\n     * 实现其comparator即可\n     * @param arr\n     * @param k\n     * @return\n     */\n    public static int[] getLeastNumbers2(int[] arr, int k){\n        Queue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(k,(v1,v2)-&gt;v2-v1);\n        for (int i : arr) {\n            if(heap.isEmpty()||heap.size()&lt;k||i&lt;heap.peek()){\n                heap.offer(i);\n            }\n            if(heap.size()&gt;k){\n                heap.poll();\n            }\n        }\n        int[] result = new int[k];\n        int j = 0;\n        for (Integer val : heap) {\n            result[j++] = val;\n        }\n        return result;\n    }</code></pre>","blogGoods":0,"blogId":"1253874832811089920","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6joYWAF3oqAAAaZr2Bc1U671.jpg","blogRead":2,"blogRemark":"剑指offer----之最小的k个数","blogTitle":"剑指offer----之最小的k个数","createdTime":"2020-04-25 10:33:50","typeName":"LeetCode","updateTime":"2020-04-25 11:53:15"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，数组中出现次数超过一半的元素---即众数</strong></h2>\n<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>\n<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>\n<p>示例&nbsp;1:</p>\n<p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br />输出: 2</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>方法有三：哈希表统计法，数组排序法，摩尔投票法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;哈希统计法：时间复杂度O（N），空间复杂度O（N）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 博主刚开始看到这道题的时候，首先想到的是哈希表统计法，因为博主想的是要找到众数，那么肯定得统计每个数字的出现次数，然后按照次数比较。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 单单是想到这些，用了map集合之后发现还是不行，因为即便用map集合统计出了每个数字和其对应的出现次数之后，你会发现没有办法按照出现的次数进行比较并且得到次数最多的数字（众数</strong><strong>）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 然后，就又审了一遍题目，结果发现了一个本题很关键的点，（<span style=\"background-color: #ffcc00;\">数组中有一个数字出现的次数超过数组长度的一半</span>），也就是说数组中有且仅有一个数字的出现次数会超过数组长度的一半（别笑博主笨，我是真的刚开始没反应过来）</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 那么我为什么要把数组中的所有元素和其次数全部存放进入map集合，然后再取次数进行比较呢？我为什么不在将元素和其次数存入集合的过程中判断次数是否已经超过数组长度的一半了呢？如果超过一半了，那它肯定是众数了呀！</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 思路：根据题意需要找出两个东西，一是多素元素，二是多素元素的出现次数\n     * 所以我们首先想到的是采用map集合\n     * 然后遍历数组，如果元素不存在与集合中，我们就将其加入map，value置为1\n     * 如果元素存在于map中，则我们取出其value将其加1与数组长度的一半做比较\n     * 如果大于数组长度一半，直接返回该元素即可\n     * 小于数组长度一半，则将其value加1存入map覆盖原有的值即可\n     *\n     * @param nums\n     * @return\n     */\n    public static int majorityElement(int[] nums) {\n        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(nums.length);\n        for (int num : nums) {\n            if(!map.containsKey(num)){\n                map.put(num,1);\n            }else{\n                Integer val = map.get(num);\n                if(++val&gt;nums.length/2){\n                    return num;\n                }else{\n                    map.put(num,val);\n                }\n            }\n        }\n        throw new RuntimeException(\"\");\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>数组排序法：由题可知，数组众必然存在一个多数元素，且出现次数超过数组长度的一半。所以我们可以对原数组进行排序，然后取数组中间的元素即可。（我擦，我当时看到这个，就在想，好简单，这个思路，但是我为什么没想到，对，因为我没有仔细的分析题目，超过一半看见没）。既然进行排序，那么我们可以选择快排，这样时间复杂度就是O（NlogN），空间复杂度O（1）.</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 数组排序法，因为多数元素的出现次数超过数组长度一半，\n     * 所以我们可以先对其进行排序，采用快排，时间复杂度O（NlogN）\n     * 然后取数组中点元素即可\n     * @param nums\n     * @return\n     */\n    public static int majorityElement2(int[] nums){\n        quickSort(nums,0,nums.length-1);\n        return nums[nums.length/2];\n    }\n\n    /**\n     * 快排\n     * @param nums\n     * @param low\n     * @param high\n     */\n    public static void quickSort(int[] nums,int low,int high){\n        int base = nums[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //从右向左找到第一个比基准元素小的元素\n            while(L&lt;R&amp;&amp;nums[R]&gt;=base){\n                R--;\n            }\n            if(nums[R]&lt;base){\n                swap(nums,L,R);\n            }\n            //从左向右找到第一个比基准元素大的元素\n            while(L&lt;R&amp;&amp;nums[L]&lt;=base){\n                L++;\n            }\n            if(nums[L]&gt;base){\n                swap(nums,L,R);\n            }\n        }\n        //左递归\n        if(L&gt;low){\n            quickSort(nums,low,L-1);\n        }\n        //右递归\n        if(high&gt;R){\n            quickSort(nums,R+1,high);\n        }\n    }\n\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>摩尔投票法（我将其称为大佬解法）：大概的意思就是采用正负抵消的方法，设置一个投票变量votes，初始设置为0；设置一个本题中的众数变量x，初始设置为数组首元素。然后遍历数组，判断跟设置的众数变量是否相等，如果相等将votes加一，如果不相等，则重置votes为0，且将x设置为数组下一个元素。本题众因为已经声明了肯定存在众数，所以不需要进行验证，但是如果没有声明的话，需要验证，下列代码众添加了验证：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 摩尔投票法\n     * @param nums\n     */\n    public static int majorityElement3(int[] nums){\n        int votes = 0;\n        int x = nums[0];\n        int count = 0;\n        for (int num : nums) {\n            if(votes==0){\n                x = num;\n            }\n            votes+=(num==x)?1:-1;\n        }\n        //验证数组众是否存在众数\n        for (int num : nums) {\n            if(num==x){\n                count++;\n            }\n        }\n        return count&gt;nums.length/2?x:0;\n    }</code></pre>","blogGoods":0,"blogId":"1253674617332162560","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6i5v-AUh39AAAaZr2Bc1U885.jpg","blogRead":0,"blogRemark":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","blogTitle":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","createdTime":"2020-04-24 21:18:14","typeName":"LeetCode","updateTime":"2020-04-24 21:18:14"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，从上到下打印二叉树-2</strong></h2>\n<p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>\n<p>例如:<br />给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>\n<p>3<br />/ \\<br />9 20<br />/ \\<br />15 7<br />返回其层次遍历结果：</p>\n<p>[<br />[3],<br />[9,20],<br />[15,7]<br />]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;BFS（广度优先搜索）：层次遍历</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * BFS\n     * @param root\n     * @return\n     */\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {\n        if (root == null) {\n            return new ArrayList&lt;&gt;(0);\n        }\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();\n        TreeNode current;\n        while (!queue.isEmpty()) {\n            List&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();\n            for (int i = queue.size(); i &gt; 0; i--) {\n                current = queue.poll();\n                arrayList.add(current.val);\n                if (current.left != null) {\n                    queue.add(current.left);\n                }\n                if (current.right != null) {\n                    queue.add(current.right);\n                }\n            }\n            list.add(arrayList);\n        }\n        return list;\n    }</code></pre>","blogGoods":0,"blogId":"1253350612905598976","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6huUyATZJ_AAAaZr2Bc1U363.jpg","blogRead":1,"blogRemark":"剑指offer----之从上到下打印二叉树----LeetCode102","blogTitle":"剑指offer----之从上到下打印二叉树----LeetCode102","createdTime":"2020-04-23 23:50:45","typeName":"LeetCode","updateTime":"2020-04-23 23:50:57"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，从上打印二叉树-1</strong></h2>\n<p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>\n<p>例如:<br />给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>\n<p>3<br />/ \\<br />9 20<br />/ \\<br />15 7<br />返回：</p>\n<p>[3,9,20,15,7]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;BFS（广度优先搜索）：也即是二叉树的层次遍历，代码和注意事项看代码注释</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 二叉树的层次遍历\n     * 这里是将层次遍历的结果存储在数组中\n     * 但是因为二叉树的节点个数并不知道\n     * 所以不能使用数组直接进行存储，因为无法初始化数组的大小\n     * 所以可以想到使用容量能自动扩充的list集合\n     * 然后再根据list集合的size来初始化数组的大小\n     * 并且将list元素赋值到数组中\n     * @param root\n     * @return\n     */\n    public static int[] levelOrder(TreeNode root) {\n        if(root==null){\n            return new int[0];\n        }\n        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n        TreeNode current;\n        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n        while(!queue.isEmpty()){\n            current = queue.poll();\n            list.add(current.val);\n            if(current.left!=null){\n                queue.add(current.left);\n            }\n            if(current.right!=null){\n                queue.add(current.right);\n            }\n        }\n        int[] result = new int[list.size()];\n        for (int i = 0; i &lt; list.size(); i++) {\n            result[i] = list.get(i);\n        }\n        return result;\n    }</code></pre>","blogGoods":0,"blogId":"1253346228108894208","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6htTeAUHGlAAAaZr2Bc1U102.jpg","blogRead":0,"blogRemark":"剑指offer----之从上到下打印二叉树","blogTitle":"剑指offer----之从上到下打印二叉树","createdTime":"2020-04-23 23:33:20","typeName":"LeetCode","updateTime":"2020-04-23 23:33:20"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，包含min函数的栈</strong></h2>\n<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>\n<p>&nbsp;</p>\n<p>示例:</p>\n<p>MinStack minStack = new MinStack();<br />minStack.push(-2);<br />minStack.push(0);<br />minStack.push(-3);<br />minStack.min(); --&gt; 返回 -3.<br />minStack.pop();<br />minStack.top(); --&gt; 返回 0.<br />minStack.min(); --&gt; 返回 -2.</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>&nbsp;辅助栈法：即初始化两个栈A,B</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;A栈用于实现基本的push(),pop(),top()的正常逻辑</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;B栈用来存放A栈中的非严格降序元素（这个我也理解不了，看代码就知道是存放什么的啦），代码中的方法注释很清楚</strong></p>\n<pre class=\"language-java\"><code>public class MinStack {\n    /** initialize your data structure here. */\n    Stack&lt;Integer&gt; A,B;\n\n    public MinStack() {\n        A = new Stack&lt;&gt;();\n        B = new Stack&lt;&gt;();\n    }\n\n    /**\n     * 入栈操作，元素先入A栈\n     * 如果B栈为空或者B栈的栈顶元素大于待入栈元素，则B栈也执行入栈操作\n     * @param x\n     */\n    public void push(int x) {\n        A.add(x);\n        if(B.isEmpty()||B.peek()&gt;=x){\n            B.add(x);\n        }\n    }\n\n    /**\n     * 这段代码优点巧妙\n     * 注意这里使用的A.pop()而不是A.peek()\n     * 所以这里实际上是分为两种情况的\n     * 第一种：当A的栈顶元素不为当前栈中的最小元素，即不等于栈B的栈顶元素\n     *         则只进行栈A的出栈操作，即A.pop()\n     * 第二种：当A的栈顶元素为当前栈中的最小元素，即等于栈B的栈顶元素\n     *        则不仅要A.pop(),而且为了保证A,B栈中最小元素的同步性\n     *        B栈也要执行出栈操作\n     */\n    public void pop() {\n        if(A.pop().equals(B.peek())){\n            B.pop();\n        }\n    }\n\n    /**\n     * 正常获取A的栈顶元素\n     * @return\n     */\n    public int top() {\n        return A.peek();\n    }\n\n    /**\n     * 获取A栈的最小元素，即B栈的栈顶元素\n     * @return\n     */\n    public int min() {\n        return B.peek();\n    }\n}</code></pre>","blogGoods":0,"blogId":"1253331349566234624","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hp12AMy2MAAAaZr2Bc1U568.jpg","blogRead":4,"blogRemark":"剑指offer----之包含min函数的栈---LeetCode155","blogTitle":"剑指offer----之包含min函数的栈---LeetCode155","createdTime":"2020-04-23 22:34:13","typeName":"LeetCode","updateTime":"2020-04-23 23:50:51"},{"blogCollection":0,"blogComment":0,"blogContent":"<h3><strong>晚上九点多，坐在床上，面前摆放着电脑，屏幕显示的是LeetCode中的《剑指offer》的题解</strong></h3>\n<h3><strong>此时的我毫无睡意，当然，这并不是因为解出一道题的喜悦冲淡了我的睡意</strong></h3>\n<h3><strong>相反的，这是一种难以言明的心情，包含着对自己无知的羞愧，也包含着别人面对如此无知的自己也能给出耐心回应的感动</strong></h3>\n<h3><strong>人有时或许就是这样，刻意的举动会让人心生防备，但是无意的善举却能温润人心</strong></h3>\n<h3><strong>别人无意的一个回答，一个小举动，一句肯定的话</strong></h3>\n<h3><strong>殊不知却能为对方赋予无穷无尽的能量</strong></h3>\n<h3><strong>将这一天的疲惫和劳累都消除</strong></h3>\n<h3><strong>赠人玫瑰，手有余香</strong></h3>\n<h3><strong>我一直抱着这样的一种心态，或许我无法做到赠人玫瑰，但是我会尽量将自己的善意展现给别人</strong></h3>\n<h3><strong>也许他刚刚好正处于某个难关，而你又刚刚好是他难关之初的引导者</strong></h3>\n<h3><strong>一句话，或许对于你来说只是人生中微不足道的几秒钟</strong></h3>\n<h3><strong>而对他来说，或许可能是多年之后回忆起来也能嘴角上扬的美好岁月</strong></h3>\n<h3><strong>想起前段时间一部剧里面的话，在这里也送给屏幕前的你：愿你永怀善意，清澈明朗</strong></h3>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1253326423486144512","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hosWANYd2AAHQzo49lBU641.jpg","blogRead":3,"blogRemark":"2020-4-23有感","blogTitle":"2020-4-23有感","createdTime":"2020-04-23 22:14:38","typeName":"随心日记","updateTime":"2020-04-25 21:22:30"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，顺时针打印矩阵</strong></h2>\n<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>\n<p>示例 1：</p>\n<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br />输出：[1,2,3,6,9,8,7,4,5]<br />示例 2：</p>\n<p>输入：matrix =&nbsp;[[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br />输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p>\n<p>限制：</p>\n<p>0 &lt;= matrix.length &lt;= 100<br />0 &lt;= matrix[i].length&nbsp;&lt;= 100</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;模拟顺时针打印的这种循环结构：设置四个边界条件，l,r,t,b。按照从左往右，从上往下，从右往左，从下网往上的顺序依次读取矩阵的元素，并且每一次都判断边界是否相遇，直到将整个矩阵元素都加入到数组中即可。</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 设置四个边界值，分别为left=0,right=matrix[0].length-1,top=0,bottom=matrix.length-1\n     * 顺时针顺序即先从左到右，再从上到下，再从右向左，再从下向上，每一次执行都要判断边界值\n     * @param matrix\n     * @return\n     */\n    public static int[] spiralOrder(int[][] matrix) {\n        if(matrix.length==0){\n            return new int[0];\n        }\n        int l = 0;\n        int r=matrix[0].length-1;\n        int t=0;\n        int b=matrix.length-1;\n        int x=0;\n        int[] res = new int[(r+1)*(b+1)];\n        while(true){\n            //从左向右\n            for(int i=l;i&lt;=r;i++){\n                res[x++]=matrix[t][i];\n            }\n            if(++t&gt;b) {\n                break;\n            }\n            //从上向下\n            for(int i=t;i&lt;=b;i++){\n                res[x++] = matrix[i][r];\n            }\n            if(--r&lt;l){\n                break;\n            }\n            //从右向左\n            for(int i=r;i&gt;=l;i--){\n                res[x++] = matrix[b][i];\n            }\n            if(--b&lt;t){\n                break;\n            }\n            //从下往上\n            for(int i=b;i&gt;=t;i--){\n                res[x++] = matrix[i][l];\n            }\n            if(++l&gt;r){\n                break;\n            }\n        }\n        return res;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1253250557729087488","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hXB2ASIQwAAAaZr2Bc1U016.jpg","blogRead":0,"blogRemark":"剑指offer-----之顺时针打印矩阵----LeetCode54","blogTitle":"剑指offer-----之顺时针打印矩阵----LeetCode54","createdTime":"2020-04-23 17:13:11","typeName":"LeetCode","updateTime":"2020-04-23 17:13:11"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，对称的二叉树</strong></h2>\n<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>\n<p>例如，二叉树&nbsp;[1,2,2,3,4,4,3] 是对称的。</p>\n<p>&nbsp; &nbsp; 1<br />&nbsp; &nbsp;/ \\<br />&nbsp; 2 &nbsp; 2<br />&nbsp;/ \\ / \\<br />3 &nbsp;4 4 &nbsp;3<br />但是下面这个&nbsp;[1,2,2,null,3,null,3] 则不是镜像对称的:</p>\n<p>&nbsp; &nbsp; 1<br />&nbsp; &nbsp;/ \\<br />&nbsp; 2 &nbsp; 2<br />&nbsp; &nbsp;\\ &nbsp; \\<br />&nbsp; &nbsp;3 &nbsp; &nbsp;3</p>\n<p>示例 1：</p>\n<p>输入：root = [1,2,2,3,4,4,3]<br />输出：true<br />示例 2：</p>\n<p>输入：root = [1,2,2,null,3,null,3]<br />输出：false</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>递归法：从对称的二叉树中我们可以找到如下规律</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果一个二叉树是对称的，则每一个节点的左右子树也是对称的,因此是递归的</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 设L = root.left，R=root.right，则满足L.left.val = R.right.val;L.right.val=R.left.val;</strong></p>\n<pre class=\"language-java\"><code>public boolean isSymmetric(TreeNode root) {\n        return  root==null?true:recur(root.left,root.right);\n    }\n    public boolean recur(TreeNode L,TreeNode R){\n        if(L==null&amp;&amp;R==null){\n            return true;\n        }\n        if(L==null||R==null||L.val!=R.val){\n            return false;\n        }\n        return recur(L.left,R.right)&amp;&amp;recur(L.right,R.left);\n    }</code></pre>","blogGoods":0,"blogId":"1252992659794968576","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6ga--AKQdvAAAaZr2Bc1U862.jpg","blogRead":1,"blogRemark":"剑指offer----之对称的二叉树----LeetCode101","blogTitle":"剑指offer----之对称的二叉树----LeetCode101","createdTime":"2020-04-23 00:08:23","typeName":"LeetCode","updateTime":"2020-04-23 00:12:33"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，二叉树镜像</strong></h2>\n<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>\n<p>例如输入：</p>\n<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; 2 &nbsp; &nbsp; 7<br />&nbsp;/ \\ &nbsp; / \\<br />1 &nbsp; 3 6 &nbsp; 9<br />镜像输出：</p>\n<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; 7 &nbsp; &nbsp; 2<br />&nbsp;/ \\ &nbsp; / \\<br />9 &nbsp; 6 3&nbsp; &nbsp;1</p>\n<p>示例 1：</p>\n<p>输入：root = [4,2,7,1,3,6,9]<br />输出：[4,7,2,9,6,3,1]</p>\n<p>限制：</p>\n<p>0 &lt;= 节点个数 &lt;= 1000</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;递归法：即递归的去交换根节点的左右子树，直到根节点为叶子节点</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用递归的方法，交换根节点的左子树和右子树\n     * 递归出口为，根节点为叶子节点\n     * @param root\n     * @return\n     */\n    public TreeNode mirrorTree(TreeNode root) {\n        TreeNode center = root;\n        if(center!=null){\n            TreeNode temp = center.left;\n            center.left = center.right;\n            center.right = temp;\n            mirrorTree(center.left);\n            mirrorTree(center.right);\n        }\n        return root;\n    }</code></pre>","blogGoods":0,"blogId":"1252985443281027072","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6gZTWABF55AAAaZr2Bc1U678.jpg","blogRead":0,"blogRemark":"剑指offer----之二叉树的镜像----LeetCode226","blogTitle":"剑指offer----之二叉树的镜像----LeetCode226","createdTime":"2020-04-22 23:39:43","typeName":"LeetCode","updateTime":"2020-04-22 23:39:43"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，合并两个有序链表</strong></h2>\n<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>\n<p>示例1：</p>\n<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br />输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br />限制：</p>\n<p>0 &lt;= 链表长度 &lt;= 1000</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>伪头节点法：即创建一个伪头节点head和一个用于辅助的节点cur</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法：如果l1.val&lt;=l2.val,就让cur指向l1，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l1指向其next</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果l1.val&gt;l2.val,就让cur指向l2，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l2指向其next</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;直到l1和l2有一个为空为止，让cur指向剩余的一个非空链表即可，若两个链表的长度为M,N则时间复杂度为O(M+N)</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用四节点，一个伪头节点，一个当前节点cur，已经链表的两个节点l1,l2\n     * 每次比较l1,l2节点的val大小，将小的节点连接到当前节点cur上即可\n     * 直到l1,l2有一个空，则将剩余的一个非空链表连接到cur尾部即可\n     * @param l1\n     * @param l2\n     * @return\n     */\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode head;\n        ListNode cur;\n        head = cur = new ListNode(0);\n        while(l1!=null&amp;&amp;l2!=null){\n            if(l1.val&lt;=l2.val){\n                cur.next = l1;\n                cur = cur.next;\n                l1 = l1.next;\n            }else{\n                cur.next = l2;\n                cur = cur.next;\n                l2 = l2.next;\n            }\n        }\n        if(l1!=null){\n            cur.next = l1;\n        }\n        if(l2!=null){\n            cur.next = l2;\n        }\n        return head.next;\n    }</code></pre>","blogGoods":0,"blogId":"1252980258446000128","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6gYGWAe-MZAAAaZr2Bc1U550.jpg","blogRead":0,"blogRemark":"剑指offer----之合并有序链表---LeetCode21","blogTitle":"剑指offer----之合并有序链表---LeetCode21","createdTime":"2020-04-22 23:19:06","typeName":"LeetCode","updateTime":"2020-04-22 23:19:06"}],"pageSize":15,"params":{},"sortColumn":"created_time","sortMethod":"DESC","totalCount":53,"totalPage":4},"msg":"操作成功!"}
2020-04-26 23:48:36.166 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /music/listFront
2020-04-26 23:48:36.166 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:48:36.167 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:48:36.167 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.MusicController.getMusicList
2020-04-26 23:48:36.167 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:48:36.450 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /link/list
2020-04-26 23:48:36.451 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:48:36.451 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:48:36.451 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.LinkController.getLinkList
2020-04-26 23:48:36.452 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:48:36.525 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 359
2020-04-26 23:48:36.528 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"artist":"周深","cover":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMh2AFeEFAAAZaWcYmAM180.jpg","id":1,"lrc":"[00:00.37]周深 - 直破穹苍 (《斗破苍穹》动画第三季主题曲)\n[00:02.79]作词：冥凰\n[00:03.86]作曲：李建衡\n[00:05.19]编曲：崔博源、李建衡\n[00:07.13]人声录制：徐威@上海V-Studio\n[00:09.23]监唱：徐威@上海V-Studio\n[00:11.38]混音：周天澈@Studio21A\n[00:24.13]有没有想过 穿越这片沙漠\n[00:32.21]前方是什么\n[00:35.16]是就此陨落\n[00:37.97]还是抓牢命运脉搏\n[00:45.38]他曾经 爱过 恨过 痛过\n[00:51.07]直到望见远处那抹焰火\n[00:56.73]也许这 是祸 是过 是错\n[01:02.41]仍不害怕 去烧灼\n[01:08.50]管那六合八荒 斗一场\n[01:14.06]焰分噬浪谁能抗\n[01:19.28]漫却这漫漫险关 莫登攀\n[01:24.88]他欲乘风 直破穹苍\n[01:43.04]太多的纠葛 太多悲欢离合\n[01:51.39]要人太执着\n[01:54.21]该如何选择\n[01:57.02]才能看清是非漩涡\n[02:04.58]他曾经 哭过 泪过 笑过\n[02:10.16]直到紧握手心那抹焰火\n[02:15.77]走遍这 荒山 大漠 湖泊\n[02:21.49]仍不退缩 去冲破\n[02:27.44]管那龙潭虎穴 斗一场\n[02:32.72]生死福祸也跌宕\n[02:38.28]漫却他太多如果 都过往\n[02:43.86]还来惊诧 满堂\n[02:50.00]管那六合八荒 斗一场\n[02:55.22]焰分噬浪谁能抗\n[03:00.85]漫却这漫漫险关 莫登攀\n[03:06.51]他欲乘风 直破穹苍","name":"直破苍穹","url":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMlWAC1FrAr8ypaThmW479.flac"},{"artist":"冷鸢","cover":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMnWAa32EAABwmk6a5Cs834.jpg","id":2,"lrc":"你是信的开头诗的内容\n童话的结尾\n你是理所当然的奇迹\n你是月色真美\n你是圣诞老人送给我\n好孩子的礼物\n你是三千美丽世界里\n我的一瓢水\n所以让我再靠近一点点\n因为你太温暖\n我会再变得坚强一点点\n因为你太柔软\n交换无名指金色的契约\n给彼此岁月\n说好从今以后都牵着手\n因为要走很远\n你是我万水千山的冒险\n要找的标记点\n你是分割我人生的线\n又将它们相连\n你是前世千次的回眸\n虔诚牵的手\n你是其余所有的一切\n是我的世界\n所以请你再闪亮一点点\n尽管我太平凡\n我会再变得柔软一点点\n因为你太敏感\n交换无名指金色的契约\n给彼此岁月\n说好从今以后都牵着手\n不管要走多远\n让我再靠近一点点\n因为你太温暖\n我会再变得坚强一点点\n因为你太柔软\n交换无名指金色的契约\n给彼此岁月\n说好从今以后都牵着手\n因为要走很远","name":"勾指起誓","url":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMomAGXdvAHZQ_9pwL9c866.mp3"}],"msg":"操作成功!"}
2020-04-26 23:48:36.534 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 84
2020-04-26 23:48:36.536 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"createdTime":"2020-04-08 02:11:26","linkId":1,"linkName":"百度","linkUrl":"www.baidu.com","updateTime":"2020-04-08 02:11:26","version":1},{"createdTime":"2020-04-18 21:39:52","linkId":2,"linkName":"CSDN","linkUrl":"https://www.csdn.net/","updateTime":"2020-04-18 21:39:52","version":1}],"msg":"操作成功!"}
2020-04-26 23:48:53.078 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /rotation-picture/listFront
2020-04-26 23:48:53.078 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:48:53.078 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:48:53.079 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.RotationPictureController.getRotationPictureListFront
2020-04-26 23:48:53.079 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:48:53.112 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /admin/getInfo
2020-04-26 23:48:53.112 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:48:53.112 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:48:53.113 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.AdminController.getInfo
2020-04-26 23:48:53.113 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/list
2020-04-26 23:48:53.114 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:48:53.114 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:48:53.114 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:48:53.114 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogList
2020-04-26 23:48:53.114 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=15, totalPage=0, totalCount=0, list=[], params={}, sortColumn=created_time, sortMethod=DESC)]
2020-04-26 23:48:53.162 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 84
2020-04-26 23:48:53.163 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"createdTime":"2020-04-09 13:31:20","enable":1,"rotationId":4,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PI6aAZIz1AASCO4hlpJI295.jpg"},{"createdTime":"2020-04-09 13:37:02","enable":1,"rotationId":9,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJPyAbm8fAAG9gfO8lxE28.jpeg"},{"createdTime":"2020-04-09 13:41:30","enable":1,"rotationId":10,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJgeAeG8wAAS2pjJC5QU547.jpg"},{"createdTime":"2020-04-09 13:41:38","enable":1,"rotationId":11,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhGAQFZbAAP2OOBWb6k310.jpg"},{"createdTime":"2020-04-09 13:41:50","enable":1,"rotationId":12,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhyABMZCAAG7doyXiM8109.jpg"},{"createdTime":"2020-04-09 13:41:59","enable":1,"rotationId":13,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJiWAL7BoAARW3_O3ISw651.jpg"}],"msg":"操作成功!"}
2020-04-26 23:48:53.191 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 79
2020-04-26 23:48:53.192 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"header":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMSKACehsAACHOzTvceE295.jpg","id":1,"name":"小屋","signature":"时光好不经用，转眼已是半生","username":"admin"},"msg":"操作成功!"}
2020-04-26 23:48:53.380 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listFront
2020-04-26 23:48:53.380 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/recommendRead
2020-04-26 23:48:53.380 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/getTotal
2020-04-26 23:48:53.381 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:48:53.381 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:48:53.381 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:48:53.381 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:48:53.381 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:48:53.381 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:48:53.381 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeLists
2020-04-26 23:48:53.381 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.recommendRead
2020-04-26 23:48:53.381 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:48:53.381 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getTotal
2020-04-26 23:48:53.382 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:48:53.382 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:48:53.463 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 84
2020-04-26 23:48:53.463 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":1,"typeName":"Linux"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":2,"typeName":"Docker"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"SpringBoot"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":4,"typeName":"Mybatis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":5,"typeName":"爬虫"},{"deleted":0,"enable":1,"typeBlogCount":4,"typeId":6,"typeName":"博客开发和维护总结"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":7,"typeName":"CSS"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"JavaScript"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Vue"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":10,"typeName":"随笔"},{"deleted":0,"enable":1,"typeBlogCount":16,"typeId":11,"typeName":"java面试篇"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":13,"typeName":"JDK源码阅读"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":14,"typeName":"redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":15,"typeName":"MongoDB"},{"deleted":0,"enable":1,"typeBlogCount":28,"typeId":16,"typeName":"LeetCode"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":17,"typeName":"随心日记"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":18,"typeName":"计算机网络"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":19,"typeName":"操作系统"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":20,"typeName":"数据结构"}],"msg":"操作成功!"}
2020-04-26 23:48:53.488 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 375
2020-04-26 23:48:53.490 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，0~n-1中缺失的数字</strong></h2>\n<p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>\n<p>示例 1:</p>\n<p>输入: [0,1,3]<br />输出: 2<br />示例&nbsp;2:</p>\n<p>输入: [0,1,2,3,4,5,6,7,9]<br />输出: 8</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主能想到的并且写出来的方法有：使用map存储数组中的所有元素，然后遍历0-n-1找出不在map中的元素。此种方法时间复杂度O（N），空间复杂度O（N）-----垃圾</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 统计0-n-1所有数字的数字和，再统计数组中所有数字的数字和，两和只差即为所求数字，时间复杂度O（N），空间复杂度O（1）-----垃圾</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;最优解法（二分查找法）：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;通常来说，我们使用二分查找法是查找一个存在于数组中的元素，但是本题需要求不在数组中的一个元素，因此到这很多人就会迷惑，不知道该怎么求了。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;但是我们首先要搞明白二分查找法的本质是什么：1，并不局限于仅仅查找存在于数组中的元素；2，二分查找的本质是对数组根据mid中间值在某一条件上进行二分（例如：通常的num[mid]&gt;target或者nums[mid]&lt;target进行左右切分）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;因此明白这一点，就好解决问题了。拿到这道题，使用二分，我们首先想到的应该是寻找根据mid中间值进行二分的条件</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;审题：题目中提及数组为递增数组，而且0-n-1内的n个数字有一个不在数组中，则不在的这个数字之前的数字满足nums[i]=i即元素本身等于数组下标，而之后的数字nums[i]!=i,所以这就是进行二分的条件了</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 二分查找法\n     * 算法思想：二分查找法的本质是能够有一个条件将数组根据mid中间值进行左右切分\n     * 所以我们想到二分查找法之后，首先需要做的是找出切分数组的条件\n     * 题目中给出了数组是一个递增数组，且0-n-1内的n个数字有一个不在这个长度为n-1的数组内\n     * 因此，不在的这个元素其左边元素必有数组下标值等于元素本身即nums[i]=i\n     * 而不在的这个元素的右边必有nums[i]!=i\n     * 所以根据此条件进行划分数组即可\n     * @param nums\n     * @return\n     */\n    public static int missingNumber(int[] nums) {\n        int low = 0;\n        int high = nums.length-1;\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]==mid){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        return low;\n    }</code></pre>","blogGoods":0,"blogId":"1254063045920022528","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kUM-AON88AAAaZr2Bc1U903.jpg","blogRead":0,"blogRemark":"剑指offer----0~n-1中缺失的数字","blogTitle":"剑指offer----0~n-1中缺失的数字","createdTime":"2020-04-25 23:01:44","typeName":"LeetCode","updateTime":"2020-04-25 23:01:44"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，在排序数组中查找数字I</strong></h2>\n<p>统计一个数字在排序数组中出现的次数。</p>\n<p>示例 1:</p>\n<p>输入: nums = [5,7,7,8,8,10], target = 8<br />输出: 2<br />示例&nbsp;2:</p>\n<p>输入: nums = [5,7,7,8,8,10], target = 6<br />输出: 0</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解法一：直接遍历统计，时间复杂度为O（N）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 遍历数组\n     * 找到第一个与目标元素相等的元素，res+1\n     * 然后往后找到第一个与目标元素不相等的元素,返回res即可\n     * 时间复杂度为O(N)\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static int search(int[] nums, int target) {\n        int res = 0;\n        for (int num : nums) {\n            if(num==target){\n                res++;\n            }\n        }\n        return res;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解法二：二分法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：利用二分法查找数字在排序数组中的左边界Left和右边界Right.如下，如果要寻找数组中的8，则其左边界为left=2,有边界right=5.所以出现次数为right-left-1.时间复杂度为O（logN）</strong></p>\n<table style=\"width: 20%; border-collapse: collapse; margin-left: auto; margin-right: auto;\" border=\"1\" cellpadding=\"5\">\n<tbody>\n<tr>\n<td style=\"width: 16.6667%;\">5</td>\n<td style=\"width: 16.6667%;\">7</td>\n<td style=\"width: 16.6667%;\">7</td>\n<td style=\"width: 16.6667%;\">8</td>\n<td style=\"width: 16.6667%;\">8</td>\n<td style=\"width: 16.6667%;\">10</td>\n</tr>\n</tbody>\n</table>\n<pre class=\"language-java\"><code>    /**\n     * 二分查找法\n     * 时间复杂度为O（logN）\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static int search2(int[] nums, int target){\n        int low = 0;\n        int high = nums.length-1;\n        int left,right;\n        left = right = 0;\n        //一次二分\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]&lt;=target){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        right = low;\n\n        low = 0;\n        high = nums.length -1;\n        //二次二分\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]&lt;target){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        left = high;\n        return right -left -1;\n    }</code></pre>","blogGoods":0,"blogId":"1254055163115724800","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kSXiAYRyFAAAaZr2Bc1U379.jpg","blogRead":0,"blogRemark":"剑指offer----在排序数组中查找数字I----LeetCode34","blogTitle":"剑指offer----在排序数组中查找数字I----LeetCode34","createdTime":"2020-04-25 22:30:24","typeName":"LeetCode","updateTime":"2020-04-25 22:30:24"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，两个链表的第一个公共节点</strong></h2>\n<p><strong><img src=\"https://images-cdn.shimo.im/Wd1NC8pveQYp9iIL.png__thumbnail\" alt=\"示例图\" width=\"742\" height=\"241\" /></strong></p>\n<p><strong>这是我从官方截下的一张图，也是有些人疑惑的地方，因为官方这张图给出的公共节点为8，而大多数人看到这张图，认为公共节点应该是1.</strong></p>\n<p><strong>但是实际上这里的公共节点不仅要节点的value相等，同时还需要节点的地址相等。从图中可以看出两个1节点虽然值相等，但是地址却不同，因而不是公共节点</strong></p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解法一：双指针</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：初始化两个指针p1=headA,p2=headB</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;分别遍历两个链表，求出两个链表的长度l1,l2</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;然后重置p1,p2指针指向头节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;让长链表的指针先走多的步数（l1-l2或者l2-l1）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;然后让两个指针同时走，直到两者相遇，即找到公共节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解疑：弄清楚第一个value相等的节点和指针相遇的节点，这两种节点是不同的，指针相遇的节点，不仅包含value相等，同时地址也相等。（如图中的8）；而第一个value相等的节点则可能并不在同一个地址，因此不一定是公共节点</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法\n     * @param headA\n     * @param headB\n     * @return\n     */\n    public static ListNode getIntersectionNode2(ListNode headA, ListNode headB){\n        ListNode p1 =headA;\n        ListNode p2 = headB;\n        int l1 = 0;\n        int l2 = 0;\n        //计算链表1的长度\n        while(p1!=null){\n            l1++;\n            p1 = p1.next;\n        }\n        //计算链表2的长度\n        while(p2!=null){\n            l2++;\n            p2 = p2.next;\n        }\n        p1 = headA;\n        p2 = headB;\n        //让长链表指针先走长的步数\n        if(l1&gt;l2){\n            for (int i = 0; i &lt; l1-l2; i++) {\n                p1 = p1.next;\n            }\n        }else{\n            for (int i = 0; i &lt; l2-l1; i++) {\n                p2 = p2.next;\n            }\n        }\n        //然后让两个指针同时走，直到相遇\n        while(p1!=p2){\n            p1 = p1.next;\n            p2 = p2.next;\n        }\n        return p1;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;解法二（大神解法）：丘比特相遇法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;利用两个指针p1=headA,p2=headB,让两个指针同时走，</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果p1先走到底，就将p1置为headB，</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果p2,先走到底，就将p2置为headA,</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;当两个指针相遇的时候，他们就相爱了（当然是找到公共节点了）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法p1=headA,p2=headB\n     * 思想是：两个节点同时从各自的链表出发\n     * p1走到末尾时，回到headB的头部\n     * p2走到末尾时，回到headA的头部\n     * 两个指针相遇的时候，即使要找的公共节点\n     * @param headA\n     * @param headB\n     * @return\n     */\n    public static ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode p1 = headA;\n        ListNode p2 = headB;\n        while(p1!=p2){\n            p1 = (p1==null)?headB:p1.next;\n            p2 = (p2==null)?headA:p2.next;\n        }\n        return p1;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1253992797703364608","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kD2OADD3mAAAaZr2Bc1U709.jpg","blogRead":0,"blogRemark":"剑指offer----之两个链表的第一个公共节点----LeetCode160","blogTitle":"剑指offer----之两个链表的第一个公共节点----LeetCode160","createdTime":"2020-04-25 18:22:35","typeName":"LeetCode","updateTime":"2020-04-25 18:22:35"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，第一个只出现一次的字符</strong></h2>\n<p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。</p>\n<p>示例:</p>\n<p>s = \"abaccdeff\"<br />返回 \"b\"</p>\n<p>s = \"\" <br />返回 \" \"</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主现在发现，做一道算法题的时候，最重要的一步就是读题，审题，在草稿纸上写下自己的思路（当然那种望眼欲穿的大佬除外）。然后才开始动笔，对于IT人来说，真的，多将时间花费在思考上面，而不是无意义的重复搬砖。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;题目分析：看到这道题，抓住两个关键字：第一个，只出现一次。什么意思呢，例如\"abaccdeff\"，其中只出现一次的字符有'b','d','e'三个，然后在三个字符中第一个出现在字符串中的是'b'，因此本题的答案是'b'.</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法分析：根据题目分析，我们最直观的解法应该是，先找出字符串中只出现一次的字符，然后再找出只出现一次字符中，第一个在字符串中出现的。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;所以我们需要做两件事，一是统计字符串中各个字符的出现次数，并且记录；二，统计完毕后，找出第一个出现次数为1的字符，返回即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;因此我们既要存字符，还要存字符对应的出现次数，所以理所当然我们选择map集合。当然对于本题而言，因为求第一个出现一次的字符，所以我们更好的是可以使用LinkedHashMap。这样免去最后的一次遍历字符串</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;下面提供两种解法：三种解法都是使用map集合，但是略有不同</strong></p>\n<p><strong>LinkedHashMap：（这是博主写的，代码冗余，这里用来和大神的写法做比较，警醒自己）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 用LinkedHashMap\n     * 思想：遍历字符串，如果map为空或者map中不含当前字符，则将其存入map\n     * 如果map中已经含有当前字符，则从map中移除\n     * 最终map中只剩出现一次的字符\n     * 返货map中的第一个即可\n     * @param s\n     * @return\n     */\n    public static char firstUniqChar(String s) {\n        Map&lt;Character,Integer&gt;map = new LinkedHashMap&lt;&gt;();\n        for (int i = 0; i &lt; s.length(); i++) {\n            char ch = s.charAt(i);\n            if(map.isEmpty()||!map.containsKey(ch)){\n                map.put(ch,1);\n            }else{\n                Integer val = map.get(ch);\n                map.put(ch,++val);\n            }\n        }\n        //返回map中第一个元素即可\n        Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entries = map.entrySet();\n        for (Map.Entry&lt;Character, Integer&gt; entry : entries) {\n            if(entry.getValue()==1){\n                return entry.getKey();\n            }\n        }\n        return ' ';\n    }</code></pre>\n<p><strong>HashMap（大神解法）：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 哈希表法\n     * @param s\n     * @return\n     */\n    public char firstUniqChar2(String s) {\n        Map&lt;Character,Boolean&gt; map = new HashMap&lt;&gt;();\n        char[] chars = s.toCharArray();\n        for (char ch : chars) {\n            map.put(ch,!map.containsKey(ch));\n        }\n        for (char ch : chars) {\n            if(map.get(ch)){\n                return ch;\n            }\n        }\n        return ' ';\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;分析：首先，这里提供了两种解法，一种为LinkedHashMap，一种为HashMap，这两种解法的不同之处就在于最后获取值的时候，LinkedHashMap获取最终值是遍历LinkedHashMap的entrySet，但是HashMap获取最终值是遍历原字符串。因而当数据庞大的时候，显然使用LinkedHashMap性能更高。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;然后，再分析一下这两种解法不另外一个不同之处，没错！就是大神的解法中使用map存放key对应的value值是Boolean型！（<span style=\"background-color: #ffcc00;\">这个真的是神一般的存在</span>），既省去了计算次数的麻烦，同时最后取的时候也不需要判断次数。wc！同一种解法，为什么天差地别！</strong></p>","blogGoods":0,"blogId":"1253956468789600256","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6j7Y6ACrySAAAaZr2Bc1U825.jpg","blogRead":0,"blogRemark":"剑指offer----第一次只出现一次的字符","blogTitle":"剑指offer----第一次只出现一次的字符","createdTime":"2020-04-25 15:58:14","typeName":"LeetCode","updateTime":"2020-04-25 15:58:14"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，连续子数组的最大和</strong></h2>\n<p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>\n<p>要求时间复杂度为O(n)。</p>\n<p>示例1:</p>\n<p>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br />输出: 6<br />解释:&nbsp;连续子数组&nbsp;[4,-1,2,1] 的和最大，为&nbsp;6。</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;看到这道题，最简单的想法肯定是求出所有连续子数组的值，然后进行比较，找出最大的即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;但是随后会想到既然要找出所有的子数组，那么我们可以使用分治的思想，因为分治的分过程即可以得到所有子序列</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;随后，再深一步，既然可以分治的思想，分的过程即是递归的过程，而且子数组的最大值依赖与前一子数组，所以可以想到使用动态规划</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：设dp[i]为以nums[i]为结尾的最大子数组和，初始值dp[0] = nums[0]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;遍历数组，如果dp[i-1]&gt;=0。则说明前面的最大子数组对当前子数组有增益效果，所以dp[i] = dp[i-1]+nums[i]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果dp[i-1]&lt;0。说明前面的最大子数组对当前子数组有夫负效果，还不如nums[i]本身，所以dp[i]=nums[i]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主的这样的写法：时间复杂度为O（N），空间复杂度也为O（N），但是实际上不需要使用dp数组，使用nums原数组就行，所以可以减小空间复杂度为O（1）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 动态规划\n     * 算法思想：因为求的是连续子数组的最大和\n     * 所以我们可以设dp[i]为以nums[i]结尾的最大连续子数组\n     * 如果dp[i]&lt;=nums[i],dp[i]=nums[i]\n     * 如果dp[i]&gt;nums[i],则dp[i]=dp[i]+nums[i]\n     * @param nums\n     * @return\n     */\n    public static int maxSubArray(int[] nums) {\n        int[] dp  = new int[nums.length];\n        dp[0] = nums[0];\n        int res = nums[0];\n        for (int i = 1; i &lt; nums.length; i++) {\n            if(dp[i-1]&lt;0){\n                dp[i] = nums[i];\n            }else{\n                dp[i] = dp[i-1]+nums[i];\n            }\n            res = Math.max(res,dp[i]);\n        }\n        return res;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1253938714590175232","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6j3QSACLxRAAAaZr2Bc1U017.jpg","blogRead":0,"blogRemark":"剑指offer---连续子数组的最大和---LeetCode53","blogTitle":"剑指offer---连续子数组的最大和---LeetCode53","createdTime":"2020-04-25 14:47:41","typeName":"LeetCode","updateTime":"2020-04-25 14:47:41"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，最小的k个数</strong></h2>\n<p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>\n<p>示例 1：</p>\n<p>输入：arr = [3,2,1], k = 2<br />输出：[1,2] 或者 [2,1]<br />示例 2：</p>\n<p>输入：arr = [0,1,2,1], k = 1<br />输出：[0]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;1,可以采用快排的思想，将原数组按照升序排序，然后取出前k个数即可，时间复杂度为O（NlogN）。但是其实跟API中的sort方法好像差别不大</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 对原数组升序排序，然后取前k个元素\n     * @param arr\n     * @param k\n     * @return\n     */\n    public static int[] getLeastNumbers(int[] arr, int k) {\n        quickSort(arr,0,arr.length-1);\n        int[] result = new int[k];\n        for (int i = 0; i &lt; k; i++) {\n            result[i] = arr[i];\n        }\n        return result;\n    }\n\n    /**\n     * 快排\n     * @param nums\n     * @param low\n     * @param high\n     */\n    public static void quickSort(int[] nums,int low,int high){\n        int base = nums[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //先从右向左找到第一个小于基准元素的元素\n            while(L&lt;R&amp;&amp;nums[R]&gt;=base){\n                R--;\n            }\n            if(nums[R]&lt;base){\n                swap(nums,L,R);\n            }\n            //再从左向右找到第一个大于基准元素的元素\n            while(L&lt;R&amp;&amp;nums[L]&lt;=base){\n                L++;\n            }\n            if(nums[L]&gt;base){\n                swap(nums,L,R);\n            }\n        }\n        //左递归\n        if(L&gt;low){\n            quickSort(nums,low,L-1);\n        }\n        //右递归\n        if(high&gt;R){\n            quickSort(nums,R+1,high);\n        }\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>2，堆排序：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;先讲解一下堆排序：堆排序是一种完全二叉树的结构，常见的存在两种堆结构，小根堆（即满足arr[2i+1]&gt;=arr[i]&amp;&amp;arr[2i+2]&gt;=arr[i]），大根堆（即满足arr[2i+1]&lt;=arr[i]&amp;&amp;arr[2i+2]&lt;=arr[i]）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;基本算法思想：第一步，初始化堆，即堆初始化为大根堆或者小根堆（这里我们简称调整堆）；第二步，将堆顶元素与堆的末尾元素进行交换，然后重新调整堆。在java中堆通常用来实现优先级队列PriorityQueue(默认的采用小根堆，若想使用大根堆，需要在创建时实现comparator)</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;使用情况：这里以java中的优先级队列为例，堆的使用情况不能按照堆名断章取义，例如小根堆实际上是将元素升序存放，因为在算法第二步中将堆顶元素与末尾元素进行交换，然后重新调整，交换的堆顶元素为最小元素，也是最先从堆中进入队列的。所以小根堆适用于TOPk大的算法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;相反的，大根堆适用于TOPk小的算法，下面分别给出小根堆和大根堆的算法：</strong></p>\n<p><strong>小根堆：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 堆排序---小根堆\n     * @param nums\n     */\n    public static void HeapSort(int[] nums){\n        //先初始化堆\n        for (int i = nums.length/2-1; i &gt;=0 ; i--) {\n            adjustHeap(nums,i,nums.length);\n        }\n        //交换堆顶与末尾节点+重新调整为小根堆\n        for (int i = nums.length-1; i &gt;0; i--) {\n            //先交换\n            swap(nums,0,i);\n            //再调整\n            adjustHeap(nums,0,i);\n        }\n    }\n\n    /**\n     * 调整为小根堆\n     * @param nums\n     * @param i\n     * @param length\n     */\n    public static void adjustHeap(int[] nums,int i,int length){\n        int temp = nums[i];\n        for (int j = 2*i+1; j &lt; length; j=2*j+1) {\n            //找出左右节点中的最小值\n            if(j+1&lt;length&amp;&amp;nums[j]&gt;nums[j+1]){\n                j++;\n            }\n            if(nums[j]&lt;temp){\n                nums[i] = nums[j];\n                i = j;\n            }\n        }\n        nums[i] = temp;\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p><strong>大根堆：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 堆排序---大根堆\n     * @param nums\n     */\n    public static void heapSort(int[] nums){\n\n        //初始化堆的过程\n        for (int i = nums.length/2-1; i &gt;=0; i--) {\n            adjustHeap(nums,i,nums.length);\n        }\n        //调整+交换堆顶和末尾的元素\n        for (int i = nums.length-1; i &gt;0; i--) {\n            //先交换，再重新调整\n            swap(nums,0,i);\n            adjustHeap(nums,0,i);\n        }\n    }\n\n    /**\n     * 调整大顶堆的过程\n     * @param nums\n     * @param i\n     * @param length\n     */\n    public static void adjustHeap(int[] nums,int i,int length){\n        int temp = nums[i];\n        for (int j = 2*i+1; j &lt; length; j=2*j+1) {\n            //找出左右节点中的最大值\n            if(j+1&lt;length&amp;&amp;nums[j]&lt;nums[j+1]){\n                j++;\n            }\n            if(nums[j]&gt;temp){\n                nums[i] = nums[j];\n                i = j;\n            }\n        }\n        nums[i] = temp;\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>本题利用大根堆解法，且使用java中自带的优先级队列PriorityQueue：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用堆数据结构，java中的优先级队列对应着最小堆\n     * 实现其comparator即可\n     * @param arr\n     * @param k\n     * @return\n     */\n    public static int[] getLeastNumbers2(int[] arr, int k){\n        Queue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(k,(v1,v2)-&gt;v2-v1);\n        for (int i : arr) {\n            if(heap.isEmpty()||heap.size()&lt;k||i&lt;heap.peek()){\n                heap.offer(i);\n            }\n            if(heap.size()&gt;k){\n                heap.poll();\n            }\n        }\n        int[] result = new int[k];\n        int j = 0;\n        for (Integer val : heap) {\n            result[j++] = val;\n        }\n        return result;\n    }</code></pre>","blogGoods":0,"blogId":"1253874832811089920","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6joYWAF3oqAAAaZr2Bc1U671.jpg","blogRead":2,"blogRemark":"剑指offer----之最小的k个数","blogTitle":"剑指offer----之最小的k个数","createdTime":"2020-04-25 10:33:50","typeName":"LeetCode","updateTime":"2020-04-25 11:53:15"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，数组中出现次数超过一半的元素---即众数</strong></h2>\n<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>\n<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>\n<p>示例&nbsp;1:</p>\n<p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br />输出: 2</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>方法有三：哈希表统计法，数组排序法，摩尔投票法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;哈希统计法：时间复杂度O（N），空间复杂度O（N）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 博主刚开始看到这道题的时候，首先想到的是哈希表统计法，因为博主想的是要找到众数，那么肯定得统计每个数字的出现次数，然后按照次数比较。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 单单是想到这些，用了map集合之后发现还是不行，因为即便用map集合统计出了每个数字和其对应的出现次数之后，你会发现没有办法按照出现的次数进行比较并且得到次数最多的数字（众数</strong><strong>）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 然后，就又审了一遍题目，结果发现了一个本题很关键的点，（<span style=\"background-color: #ffcc00;\">数组中有一个数字出现的次数超过数组长度的一半</span>），也就是说数组中有且仅有一个数字的出现次数会超过数组长度的一半（别笑博主笨，我是真的刚开始没反应过来）</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 那么我为什么要把数组中的所有元素和其次数全部存放进入map集合，然后再取次数进行比较呢？我为什么不在将元素和其次数存入集合的过程中判断次数是否已经超过数组长度的一半了呢？如果超过一半了，那它肯定是众数了呀！</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 思路：根据题意需要找出两个东西，一是多素元素，二是多素元素的出现次数\n     * 所以我们首先想到的是采用map集合\n     * 然后遍历数组，如果元素不存在与集合中，我们就将其加入map，value置为1\n     * 如果元素存在于map中，则我们取出其value将其加1与数组长度的一半做比较\n     * 如果大于数组长度一半，直接返回该元素即可\n     * 小于数组长度一半，则将其value加1存入map覆盖原有的值即可\n     *\n     * @param nums\n     * @return\n     */\n    public static int majorityElement(int[] nums) {\n        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(nums.length);\n        for (int num : nums) {\n            if(!map.containsKey(num)){\n                map.put(num,1);\n            }else{\n                Integer val = map.get(num);\n                if(++val&gt;nums.length/2){\n                    return num;\n                }else{\n                    map.put(num,val);\n                }\n            }\n        }\n        throw new RuntimeException(\"\");\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>数组排序法：由题可知，数组众必然存在一个多数元素，且出现次数超过数组长度的一半。所以我们可以对原数组进行排序，然后取数组中间的元素即可。（我擦，我当时看到这个，就在想，好简单，这个思路，但是我为什么没想到，对，因为我没有仔细的分析题目，超过一半看见没）。既然进行排序，那么我们可以选择快排，这样时间复杂度就是O（NlogN），空间复杂度O（1）.</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 数组排序法，因为多数元素的出现次数超过数组长度一半，\n     * 所以我们可以先对其进行排序，采用快排，时间复杂度O（NlogN）\n     * 然后取数组中点元素即可\n     * @param nums\n     * @return\n     */\n    public static int majorityElement2(int[] nums){\n        quickSort(nums,0,nums.length-1);\n        return nums[nums.length/2];\n    }\n\n    /**\n     * 快排\n     * @param nums\n     * @param low\n     * @param high\n     */\n    public static void quickSort(int[] nums,int low,int high){\n        int base = nums[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //从右向左找到第一个比基准元素小的元素\n            while(L&lt;R&amp;&amp;nums[R]&gt;=base){\n                R--;\n            }\n            if(nums[R]&lt;base){\n                swap(nums,L,R);\n            }\n            //从左向右找到第一个比基准元素大的元素\n            while(L&lt;R&amp;&amp;nums[L]&lt;=base){\n                L++;\n            }\n            if(nums[L]&gt;base){\n                swap(nums,L,R);\n            }\n        }\n        //左递归\n        if(L&gt;low){\n            quickSort(nums,low,L-1);\n        }\n        //右递归\n        if(high&gt;R){\n            quickSort(nums,R+1,high);\n        }\n    }\n\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>摩尔投票法（我将其称为大佬解法）：大概的意思就是采用正负抵消的方法，设置一个投票变量votes，初始设置为0；设置一个本题中的众数变量x，初始设置为数组首元素。然后遍历数组，判断跟设置的众数变量是否相等，如果相等将votes加一，如果不相等，则重置votes为0，且将x设置为数组下一个元素。本题众因为已经声明了肯定存在众数，所以不需要进行验证，但是如果没有声明的话，需要验证，下列代码众添加了验证：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 摩尔投票法\n     * @param nums\n     */\n    public static int majorityElement3(int[] nums){\n        int votes = 0;\n        int x = nums[0];\n        int count = 0;\n        for (int num : nums) {\n            if(votes==0){\n                x = num;\n            }\n            votes+=(num==x)?1:-1;\n        }\n        //验证数组众是否存在众数\n        for (int num : nums) {\n            if(num==x){\n                count++;\n            }\n        }\n        return count&gt;nums.length/2?x:0;\n    }</code></pre>","blogGoods":0,"blogId":"1253674617332162560","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6i5v-AUh39AAAaZr2Bc1U885.jpg","blogRead":0,"blogRemark":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","blogTitle":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","createdTime":"2020-04-24 21:18:14","typeName":"LeetCode","updateTime":"2020-04-24 21:18:14"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，从上到下打印二叉树-2</strong></h2>\n<p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>\n<p>例如:<br />给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>\n<p>3<br />/ \\<br />9 20<br />/ \\<br />15 7<br />返回其层次遍历结果：</p>\n<p>[<br />[3],<br />[9,20],<br />[15,7]<br />]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;BFS（广度优先搜索）：层次遍历</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * BFS\n     * @param root\n     * @return\n     */\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {\n        if (root == null) {\n            return new ArrayList&lt;&gt;(0);\n        }\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();\n        TreeNode current;\n        while (!queue.isEmpty()) {\n            List&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();\n            for (int i = queue.size(); i &gt; 0; i--) {\n                current = queue.poll();\n                arrayList.add(current.val);\n                if (current.left != null) {\n                    queue.add(current.left);\n                }\n                if (current.right != null) {\n                    queue.add(current.right);\n                }\n            }\n            list.add(arrayList);\n        }\n        return list;\n    }</code></pre>","blogGoods":0,"blogId":"1253350612905598976","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6huUyATZJ_AAAaZr2Bc1U363.jpg","blogRead":1,"blogRemark":"剑指offer----之从上到下打印二叉树----LeetCode102","blogTitle":"剑指offer----之从上到下打印二叉树----LeetCode102","createdTime":"2020-04-23 23:50:45","typeName":"LeetCode","updateTime":"2020-04-23 23:50:57"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，从上打印二叉树-1</strong></h2>\n<p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>\n<p>例如:<br />给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>\n<p>3<br />/ \\<br />9 20<br />/ \\<br />15 7<br />返回：</p>\n<p>[3,9,20,15,7]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;BFS（广度优先搜索）：也即是二叉树的层次遍历，代码和注意事项看代码注释</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 二叉树的层次遍历\n     * 这里是将层次遍历的结果存储在数组中\n     * 但是因为二叉树的节点个数并不知道\n     * 所以不能使用数组直接进行存储，因为无法初始化数组的大小\n     * 所以可以想到使用容量能自动扩充的list集合\n     * 然后再根据list集合的size来初始化数组的大小\n     * 并且将list元素赋值到数组中\n     * @param root\n     * @return\n     */\n    public static int[] levelOrder(TreeNode root) {\n        if(root==null){\n            return new int[0];\n        }\n        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n        TreeNode current;\n        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n        while(!queue.isEmpty()){\n            current = queue.poll();\n            list.add(current.val);\n            if(current.left!=null){\n                queue.add(current.left);\n            }\n            if(current.right!=null){\n                queue.add(current.right);\n            }\n        }\n        int[] result = new int[list.size()];\n        for (int i = 0; i &lt; list.size(); i++) {\n            result[i] = list.get(i);\n        }\n        return result;\n    }</code></pre>","blogGoods":0,"blogId":"1253346228108894208","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6htTeAUHGlAAAaZr2Bc1U102.jpg","blogRead":0,"blogRemark":"剑指offer----之从上到下打印二叉树","blogTitle":"剑指offer----之从上到下打印二叉树","createdTime":"2020-04-23 23:33:20","typeName":"LeetCode","updateTime":"2020-04-23 23:33:20"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，包含min函数的栈</strong></h2>\n<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>\n<p>&nbsp;</p>\n<p>示例:</p>\n<p>MinStack minStack = new MinStack();<br />minStack.push(-2);<br />minStack.push(0);<br />minStack.push(-3);<br />minStack.min(); --&gt; 返回 -3.<br />minStack.pop();<br />minStack.top(); --&gt; 返回 0.<br />minStack.min(); --&gt; 返回 -2.</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>&nbsp;辅助栈法：即初始化两个栈A,B</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;A栈用于实现基本的push(),pop(),top()的正常逻辑</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;B栈用来存放A栈中的非严格降序元素（这个我也理解不了，看代码就知道是存放什么的啦），代码中的方法注释很清楚</strong></p>\n<pre class=\"language-java\"><code>public class MinStack {\n    /** initialize your data structure here. */\n    Stack&lt;Integer&gt; A,B;\n\n    public MinStack() {\n        A = new Stack&lt;&gt;();\n        B = new Stack&lt;&gt;();\n    }\n\n    /**\n     * 入栈操作，元素先入A栈\n     * 如果B栈为空或者B栈的栈顶元素大于待入栈元素，则B栈也执行入栈操作\n     * @param x\n     */\n    public void push(int x) {\n        A.add(x);\n        if(B.isEmpty()||B.peek()&gt;=x){\n            B.add(x);\n        }\n    }\n\n    /**\n     * 这段代码优点巧妙\n     * 注意这里使用的A.pop()而不是A.peek()\n     * 所以这里实际上是分为两种情况的\n     * 第一种：当A的栈顶元素不为当前栈中的最小元素，即不等于栈B的栈顶元素\n     *         则只进行栈A的出栈操作，即A.pop()\n     * 第二种：当A的栈顶元素为当前栈中的最小元素，即等于栈B的栈顶元素\n     *        则不仅要A.pop(),而且为了保证A,B栈中最小元素的同步性\n     *        B栈也要执行出栈操作\n     */\n    public void pop() {\n        if(A.pop().equals(B.peek())){\n            B.pop();\n        }\n    }\n\n    /**\n     * 正常获取A的栈顶元素\n     * @return\n     */\n    public int top() {\n        return A.peek();\n    }\n\n    /**\n     * 获取A栈的最小元素，即B栈的栈顶元素\n     * @return\n     */\n    public int min() {\n        return B.peek();\n    }\n}</code></pre>","blogGoods":0,"blogId":"1253331349566234624","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hp12AMy2MAAAaZr2Bc1U568.jpg","blogRead":4,"blogRemark":"剑指offer----之包含min函数的栈---LeetCode155","blogTitle":"剑指offer----之包含min函数的栈---LeetCode155","createdTime":"2020-04-23 22:34:13","typeName":"LeetCode","updateTime":"2020-04-23 23:50:51"},{"blogCollection":0,"blogComment":0,"blogContent":"<h3><strong>晚上九点多，坐在床上，面前摆放着电脑，屏幕显示的是LeetCode中的《剑指offer》的题解</strong></h3>\n<h3><strong>此时的我毫无睡意，当然，这并不是因为解出一道题的喜悦冲淡了我的睡意</strong></h3>\n<h3><strong>相反的，这是一种难以言明的心情，包含着对自己无知的羞愧，也包含着别人面对如此无知的自己也能给出耐心回应的感动</strong></h3>\n<h3><strong>人有时或许就是这样，刻意的举动会让人心生防备，但是无意的善举却能温润人心</strong></h3>\n<h3><strong>别人无意的一个回答，一个小举动，一句肯定的话</strong></h3>\n<h3><strong>殊不知却能为对方赋予无穷无尽的能量</strong></h3>\n<h3><strong>将这一天的疲惫和劳累都消除</strong></h3>\n<h3><strong>赠人玫瑰，手有余香</strong></h3>\n<h3><strong>我一直抱着这样的一种心态，或许我无法做到赠人玫瑰，但是我会尽量将自己的善意展现给别人</strong></h3>\n<h3><strong>也许他刚刚好正处于某个难关，而你又刚刚好是他难关之初的引导者</strong></h3>\n<h3><strong>一句话，或许对于你来说只是人生中微不足道的几秒钟</strong></h3>\n<h3><strong>而对他来说，或许可能是多年之后回忆起来也能嘴角上扬的美好岁月</strong></h3>\n<h3><strong>想起前段时间一部剧里面的话，在这里也送给屏幕前的你：愿你永怀善意，清澈明朗</strong></h3>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1253326423486144512","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hosWANYd2AAHQzo49lBU641.jpg","blogRead":3,"blogRemark":"2020-4-23有感","blogTitle":"2020-4-23有感","createdTime":"2020-04-23 22:14:38","typeName":"随心日记","updateTime":"2020-04-25 21:22:30"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，顺时针打印矩阵</strong></h2>\n<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>\n<p>示例 1：</p>\n<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br />输出：[1,2,3,6,9,8,7,4,5]<br />示例 2：</p>\n<p>输入：matrix =&nbsp;[[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br />输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p>\n<p>限制：</p>\n<p>0 &lt;= matrix.length &lt;= 100<br />0 &lt;= matrix[i].length&nbsp;&lt;= 100</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;模拟顺时针打印的这种循环结构：设置四个边界条件，l,r,t,b。按照从左往右，从上往下，从右往左，从下网往上的顺序依次读取矩阵的元素，并且每一次都判断边界是否相遇，直到将整个矩阵元素都加入到数组中即可。</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 设置四个边界值，分别为left=0,right=matrix[0].length-1,top=0,bottom=matrix.length-1\n     * 顺时针顺序即先从左到右，再从上到下，再从右向左，再从下向上，每一次执行都要判断边界值\n     * @param matrix\n     * @return\n     */\n    public static int[] spiralOrder(int[][] matrix) {\n        if(matrix.length==0){\n            return new int[0];\n        }\n        int l = 0;\n        int r=matrix[0].length-1;\n        int t=0;\n        int b=matrix.length-1;\n        int x=0;\n        int[] res = new int[(r+1)*(b+1)];\n        while(true){\n            //从左向右\n            for(int i=l;i&lt;=r;i++){\n                res[x++]=matrix[t][i];\n            }\n            if(++t&gt;b) {\n                break;\n            }\n            //从上向下\n            for(int i=t;i&lt;=b;i++){\n                res[x++] = matrix[i][r];\n            }\n            if(--r&lt;l){\n                break;\n            }\n            //从右向左\n            for(int i=r;i&gt;=l;i--){\n                res[x++] = matrix[b][i];\n            }\n            if(--b&lt;t){\n                break;\n            }\n            //从下往上\n            for(int i=b;i&gt;=t;i--){\n                res[x++] = matrix[i][l];\n            }\n            if(++l&gt;r){\n                break;\n            }\n        }\n        return res;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1253250557729087488","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hXB2ASIQwAAAaZr2Bc1U016.jpg","blogRead":0,"blogRemark":"剑指offer-----之顺时针打印矩阵----LeetCode54","blogTitle":"剑指offer-----之顺时针打印矩阵----LeetCode54","createdTime":"2020-04-23 17:13:11","typeName":"LeetCode","updateTime":"2020-04-23 17:13:11"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，对称的二叉树</strong></h2>\n<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>\n<p>例如，二叉树&nbsp;[1,2,2,3,4,4,3] 是对称的。</p>\n<p>&nbsp; &nbsp; 1<br />&nbsp; &nbsp;/ \\<br />&nbsp; 2 &nbsp; 2<br />&nbsp;/ \\ / \\<br />3 &nbsp;4 4 &nbsp;3<br />但是下面这个&nbsp;[1,2,2,null,3,null,3] 则不是镜像对称的:</p>\n<p>&nbsp; &nbsp; 1<br />&nbsp; &nbsp;/ \\<br />&nbsp; 2 &nbsp; 2<br />&nbsp; &nbsp;\\ &nbsp; \\<br />&nbsp; &nbsp;3 &nbsp; &nbsp;3</p>\n<p>示例 1：</p>\n<p>输入：root = [1,2,2,3,4,4,3]<br />输出：true<br />示例 2：</p>\n<p>输入：root = [1,2,2,null,3,null,3]<br />输出：false</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>递归法：从对称的二叉树中我们可以找到如下规律</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果一个二叉树是对称的，则每一个节点的左右子树也是对称的,因此是递归的</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 设L = root.left，R=root.right，则满足L.left.val = R.right.val;L.right.val=R.left.val;</strong></p>\n<pre class=\"language-java\"><code>public boolean isSymmetric(TreeNode root) {\n        return  root==null?true:recur(root.left,root.right);\n    }\n    public boolean recur(TreeNode L,TreeNode R){\n        if(L==null&amp;&amp;R==null){\n            return true;\n        }\n        if(L==null||R==null||L.val!=R.val){\n            return false;\n        }\n        return recur(L.left,R.right)&amp;&amp;recur(L.right,R.left);\n    }</code></pre>","blogGoods":0,"blogId":"1252992659794968576","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6ga--AKQdvAAAaZr2Bc1U862.jpg","blogRead":1,"blogRemark":"剑指offer----之对称的二叉树----LeetCode101","blogTitle":"剑指offer----之对称的二叉树----LeetCode101","createdTime":"2020-04-23 00:08:23","typeName":"LeetCode","updateTime":"2020-04-23 00:12:33"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，二叉树镜像</strong></h2>\n<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>\n<p>例如输入：</p>\n<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; 2 &nbsp; &nbsp; 7<br />&nbsp;/ \\ &nbsp; / \\<br />1 &nbsp; 3 6 &nbsp; 9<br />镜像输出：</p>\n<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; 7 &nbsp; &nbsp; 2<br />&nbsp;/ \\ &nbsp; / \\<br />9 &nbsp; 6 3&nbsp; &nbsp;1</p>\n<p>示例 1：</p>\n<p>输入：root = [4,2,7,1,3,6,9]<br />输出：[4,7,2,9,6,3,1]</p>\n<p>限制：</p>\n<p>0 &lt;= 节点个数 &lt;= 1000</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;递归法：即递归的去交换根节点的左右子树，直到根节点为叶子节点</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用递归的方法，交换根节点的左子树和右子树\n     * 递归出口为，根节点为叶子节点\n     * @param root\n     * @return\n     */\n    public TreeNode mirrorTree(TreeNode root) {\n        TreeNode center = root;\n        if(center!=null){\n            TreeNode temp = center.left;\n            center.left = center.right;\n            center.right = temp;\n            mirrorTree(center.left);\n            mirrorTree(center.right);\n        }\n        return root;\n    }</code></pre>","blogGoods":0,"blogId":"1252985443281027072","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6gZTWABF55AAAaZr2Bc1U678.jpg","blogRead":0,"blogRemark":"剑指offer----之二叉树的镜像----LeetCode226","blogTitle":"剑指offer----之二叉树的镜像----LeetCode226","createdTime":"2020-04-22 23:39:43","typeName":"LeetCode","updateTime":"2020-04-22 23:39:43"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，合并两个有序链表</strong></h2>\n<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>\n<p>示例1：</p>\n<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br />输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br />限制：</p>\n<p>0 &lt;= 链表长度 &lt;= 1000</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>伪头节点法：即创建一个伪头节点head和一个用于辅助的节点cur</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法：如果l1.val&lt;=l2.val,就让cur指向l1，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l1指向其next</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果l1.val&gt;l2.val,就让cur指向l2，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l2指向其next</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;直到l1和l2有一个为空为止，让cur指向剩余的一个非空链表即可，若两个链表的长度为M,N则时间复杂度为O(M+N)</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用四节点，一个伪头节点，一个当前节点cur，已经链表的两个节点l1,l2\n     * 每次比较l1,l2节点的val大小，将小的节点连接到当前节点cur上即可\n     * 直到l1,l2有一个空，则将剩余的一个非空链表连接到cur尾部即可\n     * @param l1\n     * @param l2\n     * @return\n     */\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode head;\n        ListNode cur;\n        head = cur = new ListNode(0);\n        while(l1!=null&amp;&amp;l2!=null){\n            if(l1.val&lt;=l2.val){\n                cur.next = l1;\n                cur = cur.next;\n                l1 = l1.next;\n            }else{\n                cur.next = l2;\n                cur = cur.next;\n                l2 = l2.next;\n            }\n        }\n        if(l1!=null){\n            cur.next = l1;\n        }\n        if(l2!=null){\n            cur.next = l2;\n        }\n        return head.next;\n    }</code></pre>","blogGoods":0,"blogId":"1252980258446000128","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6gYGWAe-MZAAAaZr2Bc1U550.jpg","blogRead":0,"blogRemark":"剑指offer----之合并有序链表---LeetCode21","blogTitle":"剑指offer----之合并有序链表---LeetCode21","createdTime":"2020-04-22 23:19:06","typeName":"LeetCode","updateTime":"2020-04-22 23:19:06"}],"pageSize":15,"params":{},"sortColumn":"created_time","sortMethod":"DESC","totalCount":53,"totalPage":4},"msg":"操作成功!"}
2020-04-26 23:48:53.589 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /music/listFront
2020-04-26 23:48:53.589 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:48:53.590 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:48:53.591 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.MusicController.getMusicList
2020-04-26 23:48:53.591 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:48:53.622 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /link/list
2020-04-26 23:48:53.623 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:48:53.623 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:48:53.623 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.LinkController.getLinkList
2020-04-26 23:48:53.623 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:48:53.685 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 96
2020-04-26 23:48:53.686 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"artist":"周深","cover":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMh2AFeEFAAAZaWcYmAM180.jpg","id":1,"lrc":"[00:00.37]周深 - 直破穹苍 (《斗破苍穹》动画第三季主题曲)\n[00:02.79]作词：冥凰\n[00:03.86]作曲：李建衡\n[00:05.19]编曲：崔博源、李建衡\n[00:07.13]人声录制：徐威@上海V-Studio\n[00:09.23]监唱：徐威@上海V-Studio\n[00:11.38]混音：周天澈@Studio21A\n[00:24.13]有没有想过 穿越这片沙漠\n[00:32.21]前方是什么\n[00:35.16]是就此陨落\n[00:37.97]还是抓牢命运脉搏\n[00:45.38]他曾经 爱过 恨过 痛过\n[00:51.07]直到望见远处那抹焰火\n[00:56.73]也许这 是祸 是过 是错\n[01:02.41]仍不害怕 去烧灼\n[01:08.50]管那六合八荒 斗一场\n[01:14.06]焰分噬浪谁能抗\n[01:19.28]漫却这漫漫险关 莫登攀\n[01:24.88]他欲乘风 直破穹苍\n[01:43.04]太多的纠葛 太多悲欢离合\n[01:51.39]要人太执着\n[01:54.21]该如何选择\n[01:57.02]才能看清是非漩涡\n[02:04.58]他曾经 哭过 泪过 笑过\n[02:10.16]直到紧握手心那抹焰火\n[02:15.77]走遍这 荒山 大漠 湖泊\n[02:21.49]仍不退缩 去冲破\n[02:27.44]管那龙潭虎穴 斗一场\n[02:32.72]生死福祸也跌宕\n[02:38.28]漫却他太多如果 都过往\n[02:43.86]还来惊诧 满堂\n[02:50.00]管那六合八荒 斗一场\n[02:55.22]焰分噬浪谁能抗\n[03:00.85]漫却这漫漫险关 莫登攀\n[03:06.51]他欲乘风 直破穹苍","name":"直破苍穹","url":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMlWAC1FrAr8ypaThmW479.flac"},{"artist":"冷鸢","cover":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMnWAa32EAABwmk6a5Cs834.jpg","id":2,"lrc":"你是信的开头诗的内容\n童话的结尾\n你是理所当然的奇迹\n你是月色真美\n你是圣诞老人送给我\n好孩子的礼物\n你是三千美丽世界里\n我的一瓢水\n所以让我再靠近一点点\n因为你太温暖\n我会再变得坚强一点点\n因为你太柔软\n交换无名指金色的契约\n给彼此岁月\n说好从今以后都牵着手\n因为要走很远\n你是我万水千山的冒险\n要找的标记点\n你是分割我人生的线\n又将它们相连\n你是前世千次的回眸\n虔诚牵的手\n你是其余所有的一切\n是我的世界\n所以请你再闪亮一点点\n尽管我太平凡\n我会再变得柔软一点点\n因为你太敏感\n交换无名指金色的契约\n给彼此岁月\n说好从今以后都牵着手\n不管要走多远\n让我再靠近一点点\n因为你太温暖\n我会再变得坚强一点点\n因为你太柔软\n交换无名指金色的契约\n给彼此岁月\n说好从今以后都牵着手\n因为要走很远","name":"勾指起誓","url":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMomAGXdvAHZQ_9pwL9c866.mp3"}],"msg":"操作成功!"}
2020-04-26 23:48:53.715 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 336
2020-04-26 23:48:53.715 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1248605157059497984","blogRead":27,"blogTitle":"面试（二）------之JAVA基础篇","createdTime":"2020-04-10 13:34:02","typeName":"java面试篇"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1247745014683947008","blogRead":21,"blogTitle":"博客开发总结（一）-----之数据库设计篇","createdTime":"2020-04-08 04:36:07","typeName":"博客开发和维护总结"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1248224512563068928","blogRead":17,"blogTitle":"面试（一）------之JVM篇","createdTime":"2020-04-09 12:21:30","typeName":"java面试篇"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1249742755949817856","blogRead":17,"blogTitle":"面试（三）------之并发编程篇（下）","createdTime":"2020-04-13 16:54:26","typeName":"java面试篇"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1250622112591376384","blogRead":8,"blogTitle":"面试（六）------之网络与负载均衡","createdTime":"2020-04-16 03:08:42","typeName":"java面试篇"}],"msg":"操作成功!"}
2020-04-26 23:48:53.720 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 98
2020-04-26 23:48:53.721 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"createdTime":"2020-04-08 02:11:26","linkId":1,"linkName":"百度","linkUrl":"www.baidu.com","updateTime":"2020-04-08 02:11:26","version":1},{"createdTime":"2020-04-18 21:39:52","linkId":2,"linkName":"CSDN","linkUrl":"https://www.csdn.net/","updateTime":"2020-04-18 21:39:52","version":1}],"msg":"操作成功!"}
2020-04-26 23:48:54.218 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 839
2020-04-26 23:48:54.219 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":53,"msg":"操作成功!"}
2020-04-26 23:49:08.965 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /user/login
2020-04-26 23:49:08.966 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:49:08.966 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:49:08.966 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.UserController.login
2020-04-26 23:49:08.966 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[User(userId=null, username=admin, password=123456, name=null, sex=null, header=null, nickname=null, userEmail=null, createdTime=null, updateTime=null, version=null, deleted=null)]
2020-04-26 23:49:09.057 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 92
2020-04-26 23:49:09.060 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"user":{"header":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NWkaAJPVvAANwwcjPp-g88.jpeg","name":"","nickname":"小屋","password":"","sex":1,"userEmail":"570857634@qq.com","userId":1,"username":"admin"},"token":"A88F5F371A972B95D12E530F129DFABD"},"msg":"操作成功!"}
2020-04-26 23:49:09.465 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /rotation-picture/listFront
2020-04-26 23:49:09.466 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:49:09.466 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:49:09.466 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.RotationPictureController.getRotationPictureListFront
2020-04-26 23:49:09.467 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:49:09.558 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 93
2020-04-26 23:49:09.558 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"createdTime":"2020-04-09 13:31:20","enable":1,"rotationId":4,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PI6aAZIz1AASCO4hlpJI295.jpg"},{"createdTime":"2020-04-09 13:37:02","enable":1,"rotationId":9,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJPyAbm8fAAG9gfO8lxE28.jpeg"},{"createdTime":"2020-04-09 13:41:30","enable":1,"rotationId":10,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJgeAeG8wAAS2pjJC5QU547.jpg"},{"createdTime":"2020-04-09 13:41:38","enable":1,"rotationId":11,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhGAQFZbAAP2OOBWb6k310.jpg"},{"createdTime":"2020-04-09 13:41:50","enable":1,"rotationId":12,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhyABMZCAAG7doyXiM8109.jpg"},{"createdTime":"2020-04-09 13:41:59","enable":1,"rotationId":13,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJiWAL7BoAARW3_O3ISw651.jpg"}],"msg":"操作成功!"}
2020-04-26 23:49:09.775 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/list
2020-04-26 23:49:09.776 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:49:09.777 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:49:09.777 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getBlogList
2020-04-26 23:49:09.777 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Page(currentPage=1, pageSize=15, totalPage=0, totalCount=0, list=[], params={}, sortColumn=created_time, sortMethod=DESC)]
2020-04-26 23:49:09.783 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /admin/getInfo
2020-04-26 23:49:09.783 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listFront
2020-04-26 23:49:09.783 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/recommendRead
2020-04-26 23:49:09.783 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /blog/getTotal
2020-04-26 23:49:09.784 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:49:09.784 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:49:09.784 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:49:09.784 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:49:09.784 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:49:09.784 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:49:09.784 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:49:09.784 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:49:09.785 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeLists
2020-04-26 23:49:09.785 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.recommendRead
2020-04-26 23:49:09.785 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.BlogController.getTotal
2020-04-26 23:49:09.785 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.AdminController.getInfo
2020-04-26 23:49:09.785 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:49:09.785 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:49:09.785 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:49:09.785 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:49:09.865 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 82
2020-04-26 23:49:09.865 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 82
2020-04-26 23:49:09.866 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"header":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMSKACehsAACHOzTvceE295.jpg","id":1,"name":"小屋","signature":"时光好不经用，转眼已是半生","username":"admin"},"msg":"操作成功!"}
2020-04-26 23:49:09.866 INFO  [http-nio-1000-exec-4]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1248605157059497984","blogRead":27,"blogTitle":"面试（二）------之JAVA基础篇","createdTime":"2020-04-10 13:34:02","typeName":"java面试篇"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1247745014683947008","blogRead":21,"blogTitle":"博客开发总结（一）-----之数据库设计篇","createdTime":"2020-04-08 04:36:07","typeName":"博客开发和维护总结"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1248224512563068928","blogRead":17,"blogTitle":"面试（一）------之JVM篇","createdTime":"2020-04-09 12:21:30","typeName":"java面试篇"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1249742755949817856","blogRead":17,"blogTitle":"面试（三）------之并发编程篇（下）","createdTime":"2020-04-13 16:54:26","typeName":"java面试篇"},{"blogCollection":0,"blogComment":0,"blogGoods":0,"blogId":"1250622112591376384","blogRead":8,"blogTitle":"面试（六）------之网络与负载均衡","createdTime":"2020-04-16 03:08:42","typeName":"java面试篇"}],"msg":"操作成功!"}
2020-04-26 23:49:09.871 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 88
2020-04-26 23:49:09.871 INFO  [http-nio-1000-exec-5]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":53,"msg":"操作成功!"}
2020-04-26 23:49:09.878 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 95
2020-04-26 23:49:09.880 INFO  [http-nio-1000-exec-7]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":1,"typeName":"Linux"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":2,"typeName":"Docker"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"SpringBoot"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":4,"typeName":"Mybatis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":5,"typeName":"爬虫"},{"deleted":0,"enable":1,"typeBlogCount":4,"typeId":6,"typeName":"博客开发和维护总结"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":7,"typeName":"CSS"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"JavaScript"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Vue"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":10,"typeName":"随笔"},{"deleted":0,"enable":1,"typeBlogCount":16,"typeId":11,"typeName":"java面试篇"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":13,"typeName":"JDK源码阅读"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":14,"typeName":"redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":15,"typeName":"MongoDB"},{"deleted":0,"enable":1,"typeBlogCount":28,"typeId":16,"typeName":"LeetCode"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":17,"typeName":"随心日记"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":18,"typeName":"计算机网络"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":19,"typeName":"操作系统"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":20,"typeName":"数据结构"}],"msg":"操作成功!"}
2020-04-26 23:49:09.995 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /music/listFront
2020-04-26 23:49:09.995 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:49:09.996 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:49:09.997 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.MusicController.getMusicList
2020-04-26 23:49:09.997 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:49:10.079 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 84
2020-04-26 23:49:10.080 INFO  [http-nio-1000-exec-9]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"artist":"周深","cover":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMh2AFeEFAAAZaWcYmAM180.jpg","id":1,"lrc":"[00:00.37]周深 - 直破穹苍 (《斗破苍穹》动画第三季主题曲)\n[00:02.79]作词：冥凰\n[00:03.86]作曲：李建衡\n[00:05.19]编曲：崔博源、李建衡\n[00:07.13]人声录制：徐威@上海V-Studio\n[00:09.23]监唱：徐威@上海V-Studio\n[00:11.38]混音：周天澈@Studio21A\n[00:24.13]有没有想过 穿越这片沙漠\n[00:32.21]前方是什么\n[00:35.16]是就此陨落\n[00:37.97]还是抓牢命运脉搏\n[00:45.38]他曾经 爱过 恨过 痛过\n[00:51.07]直到望见远处那抹焰火\n[00:56.73]也许这 是祸 是过 是错\n[01:02.41]仍不害怕 去烧灼\n[01:08.50]管那六合八荒 斗一场\n[01:14.06]焰分噬浪谁能抗\n[01:19.28]漫却这漫漫险关 莫登攀\n[01:24.88]他欲乘风 直破穹苍\n[01:43.04]太多的纠葛 太多悲欢离合\n[01:51.39]要人太执着\n[01:54.21]该如何选择\n[01:57.02]才能看清是非漩涡\n[02:04.58]他曾经 哭过 泪过 笑过\n[02:10.16]直到紧握手心那抹焰火\n[02:15.77]走遍这 荒山 大漠 湖泊\n[02:21.49]仍不退缩 去冲破\n[02:27.44]管那龙潭虎穴 斗一场\n[02:32.72]生死福祸也跌宕\n[02:38.28]漫却他太多如果 都过往\n[02:43.86]还来惊诧 满堂\n[02:50.00]管那六合八荒 斗一场\n[02:55.22]焰分噬浪谁能抗\n[03:00.85]漫却这漫漫险关 莫登攀\n[03:06.51]他欲乘风 直破穹苍","name":"直破苍穹","url":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMlWAC1FrAr8ypaThmW479.flac"},{"artist":"冷鸢","cover":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMnWAa32EAABwmk6a5Cs834.jpg","id":2,"lrc":"你是信的开头诗的内容\n童话的结尾\n你是理所当然的奇迹\n你是月色真美\n你是圣诞老人送给我\n好孩子的礼物\n你是三千美丽世界里\n我的一瓢水\n所以让我再靠近一点点\n因为你太温暖\n我会再变得坚强一点点\n因为你太柔软\n交换无名指金色的契约\n给彼此岁月\n说好从今以后都牵着手\n因为要走很远\n你是我万水千山的冒险\n要找的标记点\n你是分割我人生的线\n又将它们相连\n你是前世千次的回眸\n虔诚牵的手\n你是其余所有的一切\n是我的世界\n所以请你再闪亮一点点\n尽管我太平凡\n我会再变得柔软一点点\n因为你太敏感\n交换无名指金色的契约\n给彼此岁月\n说好从今以后都牵着手\n不管要走多远\n让我再靠近一点点\n因为你太温暖\n我会再变得坚强一点点\n因为你太柔软\n交换无名指金色的契约\n给彼此岁月\n说好从今以后都牵着手\n因为要走很远","name":"勾指起誓","url":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMomAGXdvAHZQ_9pwL9c866.mp3"}],"msg":"操作成功!"}
2020-04-26 23:49:10.322 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /link/list
2020-04-26 23:49:10.322 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:49:10.323 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:49:10.323 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.LinkController.getLinkList
2020-04-26 23:49:10.323 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:49:10.411 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 89
2020-04-26 23:49:10.412 INFO  [http-nio-1000-exec-8]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"createdTime":"2020-04-08 02:11:26","linkId":1,"linkName":"百度","linkUrl":"www.baidu.com","updateTime":"2020-04-08 02:11:26","version":1},{"createdTime":"2020-04-18 21:39:52","linkId":2,"linkName":"CSDN","linkUrl":"https://www.csdn.net/","updateTime":"2020-04-18 21:39:52","version":1}],"msg":"操作成功!"}
2020-04-26 23:49:10.715 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 940
2020-04-26 23:49:10.716 INFO  [http-nio-1000-exec-3]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"currentPage":1,"index":0,"list":[{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，0~n-1中缺失的数字</strong></h2>\n<p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>\n<p>示例 1:</p>\n<p>输入: [0,1,3]<br />输出: 2<br />示例&nbsp;2:</p>\n<p>输入: [0,1,2,3,4,5,6,7,9]<br />输出: 8</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主能想到的并且写出来的方法有：使用map存储数组中的所有元素，然后遍历0-n-1找出不在map中的元素。此种方法时间复杂度O（N），空间复杂度O（N）-----垃圾</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 统计0-n-1所有数字的数字和，再统计数组中所有数字的数字和，两和只差即为所求数字，时间复杂度O（N），空间复杂度O（1）-----垃圾</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;最优解法（二分查找法）：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;通常来说，我们使用二分查找法是查找一个存在于数组中的元素，但是本题需要求不在数组中的一个元素，因此到这很多人就会迷惑，不知道该怎么求了。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;但是我们首先要搞明白二分查找法的本质是什么：1，并不局限于仅仅查找存在于数组中的元素；2，二分查找的本质是对数组根据mid中间值在某一条件上进行二分（例如：通常的num[mid]&gt;target或者nums[mid]&lt;target进行左右切分）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;因此明白这一点，就好解决问题了。拿到这道题，使用二分，我们首先想到的应该是寻找根据mid中间值进行二分的条件</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;审题：题目中提及数组为递增数组，而且0-n-1内的n个数字有一个不在数组中，则不在的这个数字之前的数字满足nums[i]=i即元素本身等于数组下标，而之后的数字nums[i]!=i,所以这就是进行二分的条件了</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 二分查找法\n     * 算法思想：二分查找法的本质是能够有一个条件将数组根据mid中间值进行左右切分\n     * 所以我们想到二分查找法之后，首先需要做的是找出切分数组的条件\n     * 题目中给出了数组是一个递增数组，且0-n-1内的n个数字有一个不在这个长度为n-1的数组内\n     * 因此，不在的这个元素其左边元素必有数组下标值等于元素本身即nums[i]=i\n     * 而不在的这个元素的右边必有nums[i]!=i\n     * 所以根据此条件进行划分数组即可\n     * @param nums\n     * @return\n     */\n    public static int missingNumber(int[] nums) {\n        int low = 0;\n        int high = nums.length-1;\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]==mid){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        return low;\n    }</code></pre>","blogGoods":0,"blogId":"1254063045920022528","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kUM-AON88AAAaZr2Bc1U903.jpg","blogRead":0,"blogRemark":"剑指offer----0~n-1中缺失的数字","blogTitle":"剑指offer----0~n-1中缺失的数字","createdTime":"2020-04-25 23:01:44","typeName":"LeetCode","updateTime":"2020-04-25 23:01:44"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，在排序数组中查找数字I</strong></h2>\n<p>统计一个数字在排序数组中出现的次数。</p>\n<p>示例 1:</p>\n<p>输入: nums = [5,7,7,8,8,10], target = 8<br />输出: 2<br />示例&nbsp;2:</p>\n<p>输入: nums = [5,7,7,8,8,10], target = 6<br />输出: 0</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解法一：直接遍历统计，时间复杂度为O（N）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 遍历数组\n     * 找到第一个与目标元素相等的元素，res+1\n     * 然后往后找到第一个与目标元素不相等的元素,返回res即可\n     * 时间复杂度为O(N)\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static int search(int[] nums, int target) {\n        int res = 0;\n        for (int num : nums) {\n            if(num==target){\n                res++;\n            }\n        }\n        return res;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>解法二：二分法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：利用二分法查找数字在排序数组中的左边界Left和右边界Right.如下，如果要寻找数组中的8，则其左边界为left=2,有边界right=5.所以出现次数为right-left-1.时间复杂度为O（logN）</strong></p>\n<table style=\"width: 20%; border-collapse: collapse; margin-left: auto; margin-right: auto;\" border=\"1\" cellpadding=\"5\">\n<tbody>\n<tr>\n<td style=\"width: 16.6667%;\">5</td>\n<td style=\"width: 16.6667%;\">7</td>\n<td style=\"width: 16.6667%;\">7</td>\n<td style=\"width: 16.6667%;\">8</td>\n<td style=\"width: 16.6667%;\">8</td>\n<td style=\"width: 16.6667%;\">10</td>\n</tr>\n</tbody>\n</table>\n<pre class=\"language-java\"><code>    /**\n     * 二分查找法\n     * 时间复杂度为O（logN）\n     * @param nums\n     * @param target\n     * @return\n     */\n    public static int search2(int[] nums, int target){\n        int low = 0;\n        int high = nums.length-1;\n        int left,right;\n        left = right = 0;\n        //一次二分\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]&lt;=target){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        right = low;\n\n        low = 0;\n        high = nums.length -1;\n        //二次二分\n        while(low&lt;=high){\n            int mid = (low+high)/2;\n            if(nums[mid]&lt;target){\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        left = high;\n        return right -left -1;\n    }</code></pre>","blogGoods":0,"blogId":"1254055163115724800","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kSXiAYRyFAAAaZr2Bc1U379.jpg","blogRead":0,"blogRemark":"剑指offer----在排序数组中查找数字I----LeetCode34","blogTitle":"剑指offer----在排序数组中查找数字I----LeetCode34","createdTime":"2020-04-25 22:30:24","typeName":"LeetCode","updateTime":"2020-04-25 22:30:24"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，两个链表的第一个公共节点</strong></h2>\n<p><strong><img src=\"https://images-cdn.shimo.im/Wd1NC8pveQYp9iIL.png__thumbnail\" alt=\"示例图\" width=\"742\" height=\"241\" /></strong></p>\n<p><strong>这是我从官方截下的一张图，也是有些人疑惑的地方，因为官方这张图给出的公共节点为8，而大多数人看到这张图，认为公共节点应该是1.</strong></p>\n<p><strong>但是实际上这里的公共节点不仅要节点的value相等，同时还需要节点的地址相等。从图中可以看出两个1节点虽然值相等，但是地址却不同，因而不是公共节点</strong></p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解法一：双指针</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：初始化两个指针p1=headA,p2=headB</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;分别遍历两个链表，求出两个链表的长度l1,l2</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;然后重置p1,p2指针指向头节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;让长链表的指针先走多的步数（l1-l2或者l2-l1）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;然后让两个指针同时走，直到两者相遇，即找到公共节点</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;解疑：弄清楚第一个value相等的节点和指针相遇的节点，这两种节点是不同的，指针相遇的节点，不仅包含value相等，同时地址也相等。（如图中的8）；而第一个value相等的节点则可能并不在同一个地址，因此不一定是公共节点</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法\n     * @param headA\n     * @param headB\n     * @return\n     */\n    public static ListNode getIntersectionNode2(ListNode headA, ListNode headB){\n        ListNode p1 =headA;\n        ListNode p2 = headB;\n        int l1 = 0;\n        int l2 = 0;\n        //计算链表1的长度\n        while(p1!=null){\n            l1++;\n            p1 = p1.next;\n        }\n        //计算链表2的长度\n        while(p2!=null){\n            l2++;\n            p2 = p2.next;\n        }\n        p1 = headA;\n        p2 = headB;\n        //让长链表指针先走长的步数\n        if(l1&gt;l2){\n            for (int i = 0; i &lt; l1-l2; i++) {\n                p1 = p1.next;\n            }\n        }else{\n            for (int i = 0; i &lt; l2-l1; i++) {\n                p2 = p2.next;\n            }\n        }\n        //然后让两个指针同时走，直到相遇\n        while(p1!=p2){\n            p1 = p1.next;\n            p2 = p2.next;\n        }\n        return p1;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;解法二（大神解法）：丘比特相遇法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;利用两个指针p1=headA,p2=headB,让两个指针同时走，</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果p1先走到底，就将p1置为headB，</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果p2,先走到底，就将p2置为headA,</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;当两个指针相遇的时候，他们就相爱了（当然是找到公共节点了）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 双指针法p1=headA,p2=headB\n     * 思想是：两个节点同时从各自的链表出发\n     * p1走到末尾时，回到headB的头部\n     * p2走到末尾时，回到headA的头部\n     * 两个指针相遇的时候，即使要找的公共节点\n     * @param headA\n     * @param headB\n     * @return\n     */\n    public static ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode p1 = headA;\n        ListNode p2 = headB;\n        while(p1!=p2){\n            p1 = (p1==null)?headB:p1.next;\n            p2 = (p2==null)?headA:p2.next;\n        }\n        return p1;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1253992797703364608","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6kD2OADD3mAAAaZr2Bc1U709.jpg","blogRead":0,"blogRemark":"剑指offer----之两个链表的第一个公共节点----LeetCode160","blogTitle":"剑指offer----之两个链表的第一个公共节点----LeetCode160","createdTime":"2020-04-25 18:22:35","typeName":"LeetCode","updateTime":"2020-04-25 18:22:35"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，第一个只出现一次的字符</strong></h2>\n<p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。</p>\n<p>示例:</p>\n<p>s = \"abaccdeff\"<br />返回 \"b\"</p>\n<p>s = \"\" <br />返回 \" \"</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主现在发现，做一道算法题的时候，最重要的一步就是读题，审题，在草稿纸上写下自己的思路（当然那种望眼欲穿的大佬除外）。然后才开始动笔，对于IT人来说，真的，多将时间花费在思考上面，而不是无意义的重复搬砖。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;题目分析：看到这道题，抓住两个关键字：第一个，只出现一次。什么意思呢，例如\"abaccdeff\"，其中只出现一次的字符有'b','d','e'三个，然后在三个字符中第一个出现在字符串中的是'b'，因此本题的答案是'b'.</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法分析：根据题目分析，我们最直观的解法应该是，先找出字符串中只出现一次的字符，然后再找出只出现一次字符中，第一个在字符串中出现的。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;所以我们需要做两件事，一是统计字符串中各个字符的出现次数，并且记录；二，统计完毕后，找出第一个出现次数为1的字符，返回即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;因此我们既要存字符，还要存字符对应的出现次数，所以理所当然我们选择map集合。当然对于本题而言，因为求第一个出现一次的字符，所以我们更好的是可以使用LinkedHashMap。这样免去最后的一次遍历字符串</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;下面提供两种解法：三种解法都是使用map集合，但是略有不同</strong></p>\n<p><strong>LinkedHashMap：（这是博主写的，代码冗余，这里用来和大神的写法做比较，警醒自己）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 用LinkedHashMap\n     * 思想：遍历字符串，如果map为空或者map中不含当前字符，则将其存入map\n     * 如果map中已经含有当前字符，则从map中移除\n     * 最终map中只剩出现一次的字符\n     * 返货map中的第一个即可\n     * @param s\n     * @return\n     */\n    public static char firstUniqChar(String s) {\n        Map&lt;Character,Integer&gt;map = new LinkedHashMap&lt;&gt;();\n        for (int i = 0; i &lt; s.length(); i++) {\n            char ch = s.charAt(i);\n            if(map.isEmpty()||!map.containsKey(ch)){\n                map.put(ch,1);\n            }else{\n                Integer val = map.get(ch);\n                map.put(ch,++val);\n            }\n        }\n        //返回map中第一个元素即可\n        Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entries = map.entrySet();\n        for (Map.Entry&lt;Character, Integer&gt; entry : entries) {\n            if(entry.getValue()==1){\n                return entry.getKey();\n            }\n        }\n        return ' ';\n    }</code></pre>\n<p><strong>HashMap（大神解法）：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 哈希表法\n     * @param s\n     * @return\n     */\n    public char firstUniqChar2(String s) {\n        Map&lt;Character,Boolean&gt; map = new HashMap&lt;&gt;();\n        char[] chars = s.toCharArray();\n        for (char ch : chars) {\n            map.put(ch,!map.containsKey(ch));\n        }\n        for (char ch : chars) {\n            if(map.get(ch)){\n                return ch;\n            }\n        }\n        return ' ';\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;分析：首先，这里提供了两种解法，一种为LinkedHashMap，一种为HashMap，这两种解法的不同之处就在于最后获取值的时候，LinkedHashMap获取最终值是遍历LinkedHashMap的entrySet，但是HashMap获取最终值是遍历原字符串。因而当数据庞大的时候，显然使用LinkedHashMap性能更高。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;然后，再分析一下这两种解法不另外一个不同之处，没错！就是大神的解法中使用map存放key对应的value值是Boolean型！（<span style=\"background-color: #ffcc00;\">这个真的是神一般的存在</span>），既省去了计算次数的麻烦，同时最后取的时候也不需要判断次数。wc！同一种解法，为什么天差地别！</strong></p>","blogGoods":0,"blogId":"1253956468789600256","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6j7Y6ACrySAAAaZr2Bc1U825.jpg","blogRead":0,"blogRemark":"剑指offer----第一次只出现一次的字符","blogTitle":"剑指offer----第一次只出现一次的字符","createdTime":"2020-04-25 15:58:14","typeName":"LeetCode","updateTime":"2020-04-25 15:58:14"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，连续子数组的最大和</strong></h2>\n<p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>\n<p>要求时间复杂度为O(n)。</p>\n<p>示例1:</p>\n<p>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br />输出: 6<br />解释:&nbsp;连续子数组&nbsp;[4,-1,2,1] 的和最大，为&nbsp;6。</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;看到这道题，最简单的想法肯定是求出所有连续子数组的值，然后进行比较，找出最大的即可。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;但是随后会想到既然要找出所有的子数组，那么我们可以使用分治的思想，因为分治的分过程即可以得到所有子序列</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;随后，再深一步，既然可以分治的思想，分的过程即是递归的过程，而且子数组的最大值依赖与前一子数组，所以可以想到使用动态规划</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法思想：设dp[i]为以nums[i]为结尾的最大子数组和，初始值dp[0] = nums[0]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;遍历数组，如果dp[i-1]&gt;=0。则说明前面的最大子数组对当前子数组有增益效果，所以dp[i] = dp[i-1]+nums[i]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果dp[i-1]&lt;0。说明前面的最大子数组对当前子数组有夫负效果，还不如nums[i]本身，所以dp[i]=nums[i]</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;博主的这样的写法：时间复杂度为O（N），空间复杂度也为O（N），但是实际上不需要使用dp数组，使用nums原数组就行，所以可以减小空间复杂度为O（1）</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 动态规划\n     * 算法思想：因为求的是连续子数组的最大和\n     * 所以我们可以设dp[i]为以nums[i]结尾的最大连续子数组\n     * 如果dp[i]&lt;=nums[i],dp[i]=nums[i]\n     * 如果dp[i]&gt;nums[i],则dp[i]=dp[i]+nums[i]\n     * @param nums\n     * @return\n     */\n    public static int maxSubArray(int[] nums) {\n        int[] dp  = new int[nums.length];\n        dp[0] = nums[0];\n        int res = nums[0];\n        for (int i = 1; i &lt; nums.length; i++) {\n            if(dp[i-1]&lt;0){\n                dp[i] = nums[i];\n            }else{\n                dp[i] = dp[i-1]+nums[i];\n            }\n            res = Math.max(res,dp[i]);\n        }\n        return res;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>","blogGoods":0,"blogId":"1253938714590175232","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6j3QSACLxRAAAaZr2Bc1U017.jpg","blogRead":0,"blogRemark":"剑指offer---连续子数组的最大和---LeetCode53","blogTitle":"剑指offer---连续子数组的最大和---LeetCode53","createdTime":"2020-04-25 14:47:41","typeName":"LeetCode","updateTime":"2020-04-25 14:47:41"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，最小的k个数</strong></h2>\n<p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>\n<p>示例 1：</p>\n<p>输入：arr = [3,2,1], k = 2<br />输出：[1,2] 或者 [2,1]<br />示例 2：</p>\n<p>输入：arr = [0,1,2,1], k = 1<br />输出：[0]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;1,可以采用快排的思想，将原数组按照升序排序，然后取出前k个数即可，时间复杂度为O（NlogN）。但是其实跟API中的sort方法好像差别不大</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 对原数组升序排序，然后取前k个元素\n     * @param arr\n     * @param k\n     * @return\n     */\n    public static int[] getLeastNumbers(int[] arr, int k) {\n        quickSort(arr,0,arr.length-1);\n        int[] result = new int[k];\n        for (int i = 0; i &lt; k; i++) {\n            result[i] = arr[i];\n        }\n        return result;\n    }\n\n    /**\n     * 快排\n     * @param nums\n     * @param low\n     * @param high\n     */\n    public static void quickSort(int[] nums,int low,int high){\n        int base = nums[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //先从右向左找到第一个小于基准元素的元素\n            while(L&lt;R&amp;&amp;nums[R]&gt;=base){\n                R--;\n            }\n            if(nums[R]&lt;base){\n                swap(nums,L,R);\n            }\n            //再从左向右找到第一个大于基准元素的元素\n            while(L&lt;R&amp;&amp;nums[L]&lt;=base){\n                L++;\n            }\n            if(nums[L]&gt;base){\n                swap(nums,L,R);\n            }\n        }\n        //左递归\n        if(L&gt;low){\n            quickSort(nums,low,L-1);\n        }\n        //右递归\n        if(high&gt;R){\n            quickSort(nums,R+1,high);\n        }\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>2，堆排序：</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;先讲解一下堆排序：堆排序是一种完全二叉树的结构，常见的存在两种堆结构，小根堆（即满足arr[2i+1]&gt;=arr[i]&amp;&amp;arr[2i+2]&gt;=arr[i]），大根堆（即满足arr[2i+1]&lt;=arr[i]&amp;&amp;arr[2i+2]&lt;=arr[i]）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;基本算法思想：第一步，初始化堆，即堆初始化为大根堆或者小根堆（这里我们简称调整堆）；第二步，将堆顶元素与堆的末尾元素进行交换，然后重新调整堆。在java中堆通常用来实现优先级队列PriorityQueue(默认的采用小根堆，若想使用大根堆，需要在创建时实现comparator)</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;使用情况：这里以java中的优先级队列为例，堆的使用情况不能按照堆名断章取义，例如小根堆实际上是将元素升序存放，因为在算法第二步中将堆顶元素与末尾元素进行交换，然后重新调整，交换的堆顶元素为最小元素，也是最先从堆中进入队列的。所以小根堆适用于TOPk大的算法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;相反的，大根堆适用于TOPk小的算法，下面分别给出小根堆和大根堆的算法：</strong></p>\n<p><strong>小根堆：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 堆排序---小根堆\n     * @param nums\n     */\n    public static void HeapSort(int[] nums){\n        //先初始化堆\n        for (int i = nums.length/2-1; i &gt;=0 ; i--) {\n            adjustHeap(nums,i,nums.length);\n        }\n        //交换堆顶与末尾节点+重新调整为小根堆\n        for (int i = nums.length-1; i &gt;0; i--) {\n            //先交换\n            swap(nums,0,i);\n            //再调整\n            adjustHeap(nums,0,i);\n        }\n    }\n\n    /**\n     * 调整为小根堆\n     * @param nums\n     * @param i\n     * @param length\n     */\n    public static void adjustHeap(int[] nums,int i,int length){\n        int temp = nums[i];\n        for (int j = 2*i+1; j &lt; length; j=2*j+1) {\n            //找出左右节点中的最小值\n            if(j+1&lt;length&amp;&amp;nums[j]&gt;nums[j+1]){\n                j++;\n            }\n            if(nums[j]&lt;temp){\n                nums[i] = nums[j];\n                i = j;\n            }\n        }\n        nums[i] = temp;\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p><strong>大根堆：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 堆排序---大根堆\n     * @param nums\n     */\n    public static void heapSort(int[] nums){\n\n        //初始化堆的过程\n        for (int i = nums.length/2-1; i &gt;=0; i--) {\n            adjustHeap(nums,i,nums.length);\n        }\n        //调整+交换堆顶和末尾的元素\n        for (int i = nums.length-1; i &gt;0; i--) {\n            //先交换，再重新调整\n            swap(nums,0,i);\n            adjustHeap(nums,0,i);\n        }\n    }\n\n    /**\n     * 调整大顶堆的过程\n     * @param nums\n     * @param i\n     * @param length\n     */\n    public static void adjustHeap(int[] nums,int i,int length){\n        int temp = nums[i];\n        for (int j = 2*i+1; j &lt; length; j=2*j+1) {\n            //找出左右节点中的最大值\n            if(j+1&lt;length&amp;&amp;nums[j]&lt;nums[j+1]){\n                j++;\n            }\n            if(nums[j]&gt;temp){\n                nums[i] = nums[j];\n                i = j;\n            }\n        }\n        nums[i] = temp;\n    }\n\n    /**\n     * 交换元素\n     * @param nums\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>本题利用大根堆解法，且使用java中自带的优先级队列PriorityQueue：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用堆数据结构，java中的优先级队列对应着最小堆\n     * 实现其comparator即可\n     * @param arr\n     * @param k\n     * @return\n     */\n    public static int[] getLeastNumbers2(int[] arr, int k){\n        Queue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(k,(v1,v2)-&gt;v2-v1);\n        for (int i : arr) {\n            if(heap.isEmpty()||heap.size()&lt;k||i&lt;heap.peek()){\n                heap.offer(i);\n            }\n            if(heap.size()&gt;k){\n                heap.poll();\n            }\n        }\n        int[] result = new int[k];\n        int j = 0;\n        for (Integer val : heap) {\n            result[j++] = val;\n        }\n        return result;\n    }</code></pre>","blogGoods":0,"blogId":"1253874832811089920","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6joYWAF3oqAAAaZr2Bc1U671.jpg","blogRead":2,"blogRemark":"剑指offer----之最小的k个数","blogTitle":"剑指offer----之最小的k个数","createdTime":"2020-04-25 10:33:50","typeName":"LeetCode","updateTime":"2020-04-25 11:53:15"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，数组中出现次数超过一半的元素---即众数</strong></h2>\n<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>\n<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>\n<p>示例&nbsp;1:</p>\n<p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br />输出: 2</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>方法有三：哈希表统计法，数组排序法，摩尔投票法</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;哈希统计法：时间复杂度O（N），空间复杂度O（N）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 博主刚开始看到这道题的时候，首先想到的是哈希表统计法，因为博主想的是要找到众数，那么肯定得统计每个数字的出现次数，然后按照次数比较。</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 单单是想到这些，用了map集合之后发现还是不行，因为即便用map集合统计出了每个数字和其对应的出现次数之后，你会发现没有办法按照出现的次数进行比较并且得到次数最多的数字（众数</strong><strong>）</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 然后，就又审了一遍题目，结果发现了一个本题很关键的点，（<span style=\"background-color: #ffcc00;\">数组中有一个数字出现的次数超过数组长度的一半</span>），也就是说数组中有且仅有一个数字的出现次数会超过数组长度的一半（别笑博主笨，我是真的刚开始没反应过来）</strong></p>\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 那么我为什么要把数组中的所有元素和其次数全部存放进入map集合，然后再取次数进行比较呢？我为什么不在将元素和其次数存入集合的过程中判断次数是否已经超过数组长度的一半了呢？如果超过一半了，那它肯定是众数了呀！</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 思路：根据题意需要找出两个东西，一是多素元素，二是多素元素的出现次数\n     * 所以我们首先想到的是采用map集合\n     * 然后遍历数组，如果元素不存在与集合中，我们就将其加入map，value置为1\n     * 如果元素存在于map中，则我们取出其value将其加1与数组长度的一半做比较\n     * 如果大于数组长度一半，直接返回该元素即可\n     * 小于数组长度一半，则将其value加1存入map覆盖原有的值即可\n     *\n     * @param nums\n     * @return\n     */\n    public static int majorityElement(int[] nums) {\n        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(nums.length);\n        for (int num : nums) {\n            if(!map.containsKey(num)){\n                map.put(num,1);\n            }else{\n                Integer val = map.get(num);\n                if(++val&gt;nums.length/2){\n                    return num;\n                }else{\n                    map.put(num,val);\n                }\n            }\n        }\n        throw new RuntimeException(\"\");\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>数组排序法：由题可知，数组众必然存在一个多数元素，且出现次数超过数组长度的一半。所以我们可以对原数组进行排序，然后取数组中间的元素即可。（我擦，我当时看到这个，就在想，好简单，这个思路，但是我为什么没想到，对，因为我没有仔细的分析题目，超过一半看见没）。既然进行排序，那么我们可以选择快排，这样时间复杂度就是O（NlogN），空间复杂度O（1）.</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 数组排序法，因为多数元素的出现次数超过数组长度一半，\n     * 所以我们可以先对其进行排序，采用快排，时间复杂度O（NlogN）\n     * 然后取数组中点元素即可\n     * @param nums\n     * @return\n     */\n    public static int majorityElement2(int[] nums){\n        quickSort(nums,0,nums.length-1);\n        return nums[nums.length/2];\n    }\n\n    /**\n     * 快排\n     * @param nums\n     * @param low\n     * @param high\n     */\n    public static void quickSort(int[] nums,int low,int high){\n        int base = nums[low];\n        int L = low;\n        int R = high;\n        while(L&lt;R){\n            //从右向左找到第一个比基准元素小的元素\n            while(L&lt;R&amp;&amp;nums[R]&gt;=base){\n                R--;\n            }\n            if(nums[R]&lt;base){\n                swap(nums,L,R);\n            }\n            //从左向右找到第一个比基准元素大的元素\n            while(L&lt;R&amp;&amp;nums[L]&lt;=base){\n                L++;\n            }\n            if(nums[L]&gt;base){\n                swap(nums,L,R);\n            }\n        }\n        //左递归\n        if(L&gt;low){\n            quickSort(nums,low,L-1);\n        }\n        //右递归\n        if(high&gt;R){\n            quickSort(nums,R+1,high);\n        }\n    }\n\n    public static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }</code></pre>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>摩尔投票法（我将其称为大佬解法）：大概的意思就是采用正负抵消的方法，设置一个投票变量votes，初始设置为0；设置一个本题中的众数变量x，初始设置为数组首元素。然后遍历数组，判断跟设置的众数变量是否相等，如果相等将votes加一，如果不相等，则重置votes为0，且将x设置为数组下一个元素。本题众因为已经声明了肯定存在众数，所以不需要进行验证，但是如果没有声明的话，需要验证，下列代码众添加了验证：</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 摩尔投票法\n     * @param nums\n     */\n    public static int majorityElement3(int[] nums){\n        int votes = 0;\n        int x = nums[0];\n        int count = 0;\n        for (int num : nums) {\n            if(votes==0){\n                x = num;\n            }\n            votes+=(num==x)?1:-1;\n        }\n        //验证数组众是否存在众数\n        for (int num : nums) {\n            if(num==x){\n                count++;\n            }\n        }\n        return count&gt;nums.length/2?x:0;\n    }</code></pre>","blogGoods":0,"blogId":"1253674617332162560","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6i5v-AUh39AAAaZr2Bc1U885.jpg","blogRead":0,"blogRemark":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","blogTitle":"剑指offer----之数组众出现次数超过数组长度一半的元素----LeetCode169","createdTime":"2020-04-24 21:18:14","typeName":"LeetCode","updateTime":"2020-04-24 21:18:14"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，从上到下打印二叉树-2</strong></h2>\n<p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>\n<p>例如:<br />给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>\n<p>3<br />/ \\<br />9 20<br />/ \\<br />15 7<br />返回其层次遍历结果：</p>\n<p>[<br />[3],<br />[9,20],<br />[15,7]<br />]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;BFS（广度优先搜索）：层次遍历</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * BFS\n     * @param root\n     * @return\n     */\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {\n        if (root == null) {\n            return new ArrayList&lt;&gt;(0);\n        }\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();\n        TreeNode current;\n        while (!queue.isEmpty()) {\n            List&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();\n            for (int i = queue.size(); i &gt; 0; i--) {\n                current = queue.poll();\n                arrayList.add(current.val);\n                if (current.left != null) {\n                    queue.add(current.left);\n                }\n                if (current.right != null) {\n                    queue.add(current.right);\n                }\n            }\n            list.add(arrayList);\n        }\n        return list;\n    }</code></pre>","blogGoods":0,"blogId":"1253350612905598976","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6huUyATZJ_AAAaZr2Bc1U363.jpg","blogRead":1,"blogRemark":"剑指offer----之从上到下打印二叉树----LeetCode102","blogTitle":"剑指offer----之从上到下打印二叉树----LeetCode102","createdTime":"2020-04-23 23:50:45","typeName":"LeetCode","updateTime":"2020-04-23 23:50:57"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，从上打印二叉树-1</strong></h2>\n<p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>\n<p>例如:<br />给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>\n<p>3<br />/ \\<br />9 20<br />/ \\<br />15 7<br />返回：</p>\n<p>[3,9,20,15,7]</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;BFS（广度优先搜索）：也即是二叉树的层次遍历，代码和注意事项看代码注释</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 二叉树的层次遍历\n     * 这里是将层次遍历的结果存储在数组中\n     * 但是因为二叉树的节点个数并不知道\n     * 所以不能使用数组直接进行存储，因为无法初始化数组的大小\n     * 所以可以想到使用容量能自动扩充的list集合\n     * 然后再根据list集合的size来初始化数组的大小\n     * 并且将list元素赋值到数组中\n     * @param root\n     * @return\n     */\n    public static int[] levelOrder(TreeNode root) {\n        if(root==null){\n            return new int[0];\n        }\n        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n        TreeNode current;\n        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n        while(!queue.isEmpty()){\n            current = queue.poll();\n            list.add(current.val);\n            if(current.left!=null){\n                queue.add(current.left);\n            }\n            if(current.right!=null){\n                queue.add(current.right);\n            }\n        }\n        int[] result = new int[list.size()];\n        for (int i = 0; i &lt; list.size(); i++) {\n            result[i] = list.get(i);\n        }\n        return result;\n    }</code></pre>","blogGoods":0,"blogId":"1253346228108894208","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6htTeAUHGlAAAaZr2Bc1U102.jpg","blogRead":0,"blogRemark":"剑指offer----之从上到下打印二叉树","blogTitle":"剑指offer----之从上到下打印二叉树","createdTime":"2020-04-23 23:33:20","typeName":"LeetCode","updateTime":"2020-04-23 23:33:20"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，包含min函数的栈</strong></h2>\n<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>\n<p>&nbsp;</p>\n<p>示例:</p>\n<p>MinStack minStack = new MinStack();<br />minStack.push(-2);<br />minStack.push(0);<br />minStack.push(-3);<br />minStack.min(); --&gt; 返回 -3.<br />minStack.pop();<br />minStack.top(); --&gt; 返回 0.<br />minStack.min(); --&gt; 返回 -2.</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>&nbsp;辅助栈法：即初始化两个栈A,B</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;A栈用于实现基本的push(),pop(),top()的正常逻辑</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;B栈用来存放A栈中的非严格降序元素（这个我也理解不了，看代码就知道是存放什么的啦），代码中的方法注释很清楚</strong></p>\n<pre class=\"language-java\"><code>public class MinStack {\n    /** initialize your data structure here. */\n    Stack&lt;Integer&gt; A,B;\n\n    public MinStack() {\n        A = new Stack&lt;&gt;();\n        B = new Stack&lt;&gt;();\n    }\n\n    /**\n     * 入栈操作，元素先入A栈\n     * 如果B栈为空或者B栈的栈顶元素大于待入栈元素，则B栈也执行入栈操作\n     * @param x\n     */\n    public void push(int x) {\n        A.add(x);\n        if(B.isEmpty()||B.peek()&gt;=x){\n            B.add(x);\n        }\n    }\n\n    /**\n     * 这段代码优点巧妙\n     * 注意这里使用的A.pop()而不是A.peek()\n     * 所以这里实际上是分为两种情况的\n     * 第一种：当A的栈顶元素不为当前栈中的最小元素，即不等于栈B的栈顶元素\n     *         则只进行栈A的出栈操作，即A.pop()\n     * 第二种：当A的栈顶元素为当前栈中的最小元素，即等于栈B的栈顶元素\n     *        则不仅要A.pop(),而且为了保证A,B栈中最小元素的同步性\n     *        B栈也要执行出栈操作\n     */\n    public void pop() {\n        if(A.pop().equals(B.peek())){\n            B.pop();\n        }\n    }\n\n    /**\n     * 正常获取A的栈顶元素\n     * @return\n     */\n    public int top() {\n        return A.peek();\n    }\n\n    /**\n     * 获取A栈的最小元素，即B栈的栈顶元素\n     * @return\n     */\n    public int min() {\n        return B.peek();\n    }\n}</code></pre>","blogGoods":0,"blogId":"1253331349566234624","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hp12AMy2MAAAaZr2Bc1U568.jpg","blogRead":4,"blogRemark":"剑指offer----之包含min函数的栈---LeetCode155","blogTitle":"剑指offer----之包含min函数的栈---LeetCode155","createdTime":"2020-04-23 22:34:13","typeName":"LeetCode","updateTime":"2020-04-23 23:50:51"},{"blogCollection":0,"blogComment":0,"blogContent":"<h3><strong>晚上九点多，坐在床上，面前摆放着电脑，屏幕显示的是LeetCode中的《剑指offer》的题解</strong></h3>\n<h3><strong>此时的我毫无睡意，当然，这并不是因为解出一道题的喜悦冲淡了我的睡意</strong></h3>\n<h3><strong>相反的，这是一种难以言明的心情，包含着对自己无知的羞愧，也包含着别人面对如此无知的自己也能给出耐心回应的感动</strong></h3>\n<h3><strong>人有时或许就是这样，刻意的举动会让人心生防备，但是无意的善举却能温润人心</strong></h3>\n<h3><strong>别人无意的一个回答，一个小举动，一句肯定的话</strong></h3>\n<h3><strong>殊不知却能为对方赋予无穷无尽的能量</strong></h3>\n<h3><strong>将这一天的疲惫和劳累都消除</strong></h3>\n<h3><strong>赠人玫瑰，手有余香</strong></h3>\n<h3><strong>我一直抱着这样的一种心态，或许我无法做到赠人玫瑰，但是我会尽量将自己的善意展现给别人</strong></h3>\n<h3><strong>也许他刚刚好正处于某个难关，而你又刚刚好是他难关之初的引导者</strong></h3>\n<h3><strong>一句话，或许对于你来说只是人生中微不足道的几秒钟</strong></h3>\n<h3><strong>而对他来说，或许可能是多年之后回忆起来也能嘴角上扬的美好岁月</strong></h3>\n<h3><strong>想起前段时间一部剧里面的话，在这里也送给屏幕前的你：愿你永怀善意，清澈明朗</strong></h3>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1253326423486144512","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hosWANYd2AAHQzo49lBU641.jpg","blogRead":3,"blogRemark":"2020-4-23有感","blogTitle":"2020-4-23有感","createdTime":"2020-04-23 22:14:38","typeName":"随心日记","updateTime":"2020-04-25 21:22:30"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，顺时针打印矩阵</strong></h2>\n<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>\n<p>示例 1：</p>\n<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br />输出：[1,2,3,6,9,8,7,4,5]<br />示例 2：</p>\n<p>输入：matrix =&nbsp;[[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br />输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p>\n<p>限制：</p>\n<p>0 &lt;= matrix.length &lt;= 100<br />0 &lt;= matrix[i].length&nbsp;&lt;= 100</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;模拟顺时针打印的这种循环结构：设置四个边界条件，l,r,t,b。按照从左往右，从上往下，从右往左，从下网往上的顺序依次读取矩阵的元素，并且每一次都判断边界是否相遇，直到将整个矩阵元素都加入到数组中即可。</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 设置四个边界值，分别为left=0,right=matrix[0].length-1,top=0,bottom=matrix.length-1\n     * 顺时针顺序即先从左到右，再从上到下，再从右向左，再从下向上，每一次执行都要判断边界值\n     * @param matrix\n     * @return\n     */\n    public static int[] spiralOrder(int[][] matrix) {\n        if(matrix.length==0){\n            return new int[0];\n        }\n        int l = 0;\n        int r=matrix[0].length-1;\n        int t=0;\n        int b=matrix.length-1;\n        int x=0;\n        int[] res = new int[(r+1)*(b+1)];\n        while(true){\n            //从左向右\n            for(int i=l;i&lt;=r;i++){\n                res[x++]=matrix[t][i];\n            }\n            if(++t&gt;b) {\n                break;\n            }\n            //从上向下\n            for(int i=t;i&lt;=b;i++){\n                res[x++] = matrix[i][r];\n            }\n            if(--r&lt;l){\n                break;\n            }\n            //从右向左\n            for(int i=r;i&gt;=l;i--){\n                res[x++] = matrix[b][i];\n            }\n            if(--b&lt;t){\n                break;\n            }\n            //从下往上\n            for(int i=b;i&gt;=t;i--){\n                res[x++] = matrix[i][l];\n            }\n            if(++l&gt;r){\n                break;\n            }\n        }\n        return res;\n    }</code></pre>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</strong></p>\n<p>&nbsp;</p>","blogGoods":0,"blogId":"1253250557729087488","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6hXB2ASIQwAAAaZr2Bc1U016.jpg","blogRead":0,"blogRemark":"剑指offer-----之顺时针打印矩阵----LeetCode54","blogTitle":"剑指offer-----之顺时针打印矩阵----LeetCode54","createdTime":"2020-04-23 17:13:11","typeName":"LeetCode","updateTime":"2020-04-23 17:13:11"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，对称的二叉树</strong></h2>\n<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>\n<p>例如，二叉树&nbsp;[1,2,2,3,4,4,3] 是对称的。</p>\n<p>&nbsp; &nbsp; 1<br />&nbsp; &nbsp;/ \\<br />&nbsp; 2 &nbsp; 2<br />&nbsp;/ \\ / \\<br />3 &nbsp;4 4 &nbsp;3<br />但是下面这个&nbsp;[1,2,2,null,3,null,3] 则不是镜像对称的:</p>\n<p>&nbsp; &nbsp; 1<br />&nbsp; &nbsp;/ \\<br />&nbsp; 2 &nbsp; 2<br />&nbsp; &nbsp;\\ &nbsp; \\<br />&nbsp; &nbsp;3 &nbsp; &nbsp;3</p>\n<p>示例 1：</p>\n<p>输入：root = [1,2,2,3,4,4,3]<br />输出：true<br />示例 2：</p>\n<p>输入：root = [1,2,2,null,3,null,3]<br />输出：false</p>\n<h2>二，题解</h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<strong>递归法：从对称的二叉树中我们可以找到如下规律</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 如果一个二叉树是对称的，则每一个节点的左右子树也是对称的,因此是递归的</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 设L = root.left，R=root.right，则满足L.left.val = R.right.val;L.right.val=R.left.val;</strong></p>\n<pre class=\"language-java\"><code>public boolean isSymmetric(TreeNode root) {\n        return  root==null?true:recur(root.left,root.right);\n    }\n    public boolean recur(TreeNode L,TreeNode R){\n        if(L==null&amp;&amp;R==null){\n            return true;\n        }\n        if(L==null||R==null||L.val!=R.val){\n            return false;\n        }\n        return recur(L.left,R.right)&amp;&amp;recur(L.right,R.left);\n    }</code></pre>","blogGoods":0,"blogId":"1252992659794968576","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6ga--AKQdvAAAaZr2Bc1U862.jpg","blogRead":1,"blogRemark":"剑指offer----之对称的二叉树----LeetCode101","blogTitle":"剑指offer----之对称的二叉树----LeetCode101","createdTime":"2020-04-23 00:08:23","typeName":"LeetCode","updateTime":"2020-04-23 00:12:33"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，二叉树镜像</strong></h2>\n<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>\n<p>例如输入：</p>\n<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; 2 &nbsp; &nbsp; 7<br />&nbsp;/ \\ &nbsp; / \\<br />1 &nbsp; 3 6 &nbsp; 9<br />镜像输出：</p>\n<p>&nbsp; &nbsp; &nbsp;4<br />&nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; 7 &nbsp; &nbsp; 2<br />&nbsp;/ \\ &nbsp; / \\<br />9 &nbsp; 6 3&nbsp; &nbsp;1</p>\n<p>示例 1：</p>\n<p>输入：root = [4,2,7,1,3,6,9]<br />输出：[4,7,2,9,6,3,1]</p>\n<p>限制：</p>\n<p>0 &lt;= 节点个数 &lt;= 1000</p>\n<h2><strong>二，题解</strong></h2>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;递归法：即递归的去交换根节点的左右子树，直到根节点为叶子节点</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用递归的方法，交换根节点的左子树和右子树\n     * 递归出口为，根节点为叶子节点\n     * @param root\n     * @return\n     */\n    public TreeNode mirrorTree(TreeNode root) {\n        TreeNode center = root;\n        if(center!=null){\n            TreeNode temp = center.left;\n            center.left = center.right;\n            center.right = temp;\n            mirrorTree(center.left);\n            mirrorTree(center.right);\n        }\n        return root;\n    }</code></pre>","blogGoods":0,"blogId":"1252985443281027072","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6gZTWABF55AAAaZr2Bc1U678.jpg","blogRead":0,"blogRemark":"剑指offer----之二叉树的镜像----LeetCode226","blogTitle":"剑指offer----之二叉树的镜像----LeetCode226","createdTime":"2020-04-22 23:39:43","typeName":"LeetCode","updateTime":"2020-04-22 23:39:43"},{"blogCollection":0,"blogComment":0,"blogContent":"<h2><strong>一，合并两个有序链表</strong></h2>\n<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>\n<p>示例1：</p>\n<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br />输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br />限制：</p>\n<p>0 &lt;= 链表长度 &lt;= 1000</p>\n<h2><strong>二，题解</strong></h2>\n<p>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;<strong>伪头节点法：即创建一个伪头节点head和一个用于辅助的节点cur</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;算法：如果l1.val&lt;=l2.val,就让cur指向l1，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l1指向其next</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;如果l1.val&gt;l2.val,就让cur指向l2，并且让cur指向cur.next，即保证cur始终指向尾节点，然后让l2指向其next</strong></p>\n<p><strong>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;直到l1和l2有一个为空为止，让cur指向剩余的一个非空链表即可，若两个链表的长度为M,N则时间复杂度为O(M+N)</strong></p>\n<pre class=\"language-java\"><code>    /**\n     * 使用四节点，一个伪头节点，一个当前节点cur，已经链表的两个节点l1,l2\n     * 每次比较l1,l2节点的val大小，将小的节点连接到当前节点cur上即可\n     * 直到l1,l2有一个空，则将剩余的一个非空链表连接到cur尾部即可\n     * @param l1\n     * @param l2\n     * @return\n     */\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode head;\n        ListNode cur;\n        head = cur = new ListNode(0);\n        while(l1!=null&amp;&amp;l2!=null){\n            if(l1.val&lt;=l2.val){\n                cur.next = l1;\n                cur = cur.next;\n                l1 = l1.next;\n            }else{\n                cur.next = l2;\n                cur = cur.next;\n                l2 = l2.next;\n            }\n        }\n        if(l1!=null){\n            cur.next = l1;\n        }\n        if(l2!=null){\n            cur.next = l2;\n        }\n        return head.next;\n    }</code></pre>","blogGoods":0,"blogId":"1252980258446000128","blogImage":"http://121.199.34.159/group1/M00/00/01/rBD3pF6gYGWAe-MZAAAaZr2Bc1U550.jpg","blogRead":0,"blogRemark":"剑指offer----之合并有序链表---LeetCode21","blogTitle":"剑指offer----之合并有序链表---LeetCode21","createdTime":"2020-04-22 23:19:06","typeName":"LeetCode","updateTime":"2020-04-22 23:19:06"}],"pageSize":15,"params":{},"sortColumn":"created_time","sortMethod":"DESC","totalCount":53,"totalPage":4},"msg":"操作成功!"}
2020-04-26 23:50:30.739 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /admin/login
2020-04-26 23:50:30.739 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : POST
2020-04-26 23:50:30.740 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:50:30.740 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.AdminController.login
2020-04-26 23:50:30.740 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[Admin(id=null, name=null, header=null, signature=null, comment=null, username=admin, password=admin)]
2020-04-26 23:50:30.825 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 86
2020-04-26 23:50:30.826 INFO  [http-nio-1000-exec-10]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"token":"4DF089C65923E85120156E1432DAFC6A"},"msg":"操作成功!"}
2020-04-26 23:50:30.988 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /admin/info
2020-04-26 23:50:30.988 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:50:30.989 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:50:30.989 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.AdminController.getAdminInfo
2020-04-26 23:50:30.989 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:50:30.989 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 1
2020-04-26 23:50:30.989 INFO  [http-nio-1000-exec-1]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":{"header":"http://121.199.34.159/group1/M00/00/00/rBD3pF6NMSKACehsAACHOzTvceE295.jpg","name":"小屋","password":"","signature":"时光好不经用，转眼已是半生","username":"admin"},"msg":"操作成功!"}
2020-04-26 23:50:31.251 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /type/listFront
2020-04-26 23:50:31.252 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:50:31.252 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:50:31.252 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.TypeController.getTypeLists
2020-04-26 23:50:31.252 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:50:31.346 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 95
2020-04-26 23:50:31.347 INFO  [http-nio-1000-exec-2]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":1,"typeName":"Linux"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":2,"typeName":"Docker"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":3,"typeName":"SpringBoot"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":4,"typeName":"Mybatis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":5,"typeName":"爬虫"},{"deleted":0,"enable":1,"typeBlogCount":4,"typeId":6,"typeName":"博客开发和维护总结"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":7,"typeName":"CSS"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":8,"typeName":"JavaScript"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":9,"typeName":"Vue"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":10,"typeName":"随笔"},{"deleted":0,"enable":1,"typeBlogCount":16,"typeId":11,"typeName":"java面试篇"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":13,"typeName":"JDK源码阅读"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":14,"typeName":"redis"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":15,"typeName":"MongoDB"},{"deleted":0,"enable":1,"typeBlogCount":28,"typeId":16,"typeName":"LeetCode"},{"deleted":0,"enable":1,"typeBlogCount":1,"typeId":17,"typeName":"随心日记"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":18,"typeName":"计算机网络"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":19,"typeName":"操作系统"},{"deleted":0,"enable":1,"typeBlogCount":0,"typeId":20,"typeName":"数据结构"}],"msg":"操作成功!"}
2020-04-26 23:50:31.553 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:110 -请求地址 : /rotation-picture/list
2020-04-26 23:50:31.553 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:111 -请求方式 : GET
2020-04-26 23:50:31.553 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:114 -IP : 127.0.0.1
2020-04-26 23:50:31.553 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:116 -方法 : com.wcj.controller.RotationPictureController.getRotationPictureList
2020-04-26 23:50:31.554 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.printRequestLog:118 -请求参数：[]
2020-04-26 23:50:31.638 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAround:65 -耗时 : 85
2020-04-26 23:50:31.638 INFO  [http-nio-1000-exec-6]com.wcj.aspect.LogAspect.doAfterReturning:79 -返回值:{"code":20000,"data":[{"createdTime":"2020-04-09 13:31:20","enable":1,"rotationId":4,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PI6aAZIz1AASCO4hlpJI295.jpg"},{"createdTime":"2020-04-09 13:37:02","enable":1,"rotationId":9,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJPyAbm8fAAG9gfO8lxE28.jpeg"},{"createdTime":"2020-04-09 13:41:30","enable":1,"rotationId":10,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJgeAeG8wAAS2pjJC5QU547.jpg"},{"createdTime":"2020-04-09 13:41:38","enable":1,"rotationId":11,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhGAQFZbAAP2OOBWb6k310.jpg"},{"createdTime":"2020-04-09 13:41:50","enable":1,"rotationId":12,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJhyABMZCAAG7doyXiM8109.jpg"},{"createdTime":"2020-04-09 13:41:59","enable":1,"rotationId":13,"rotationUrl":"http://121.199.34.159/group1/M00/00/00/rBD3pF6PJiWAL7BoAARW3_O3ISw651.jpg"}],"msg":"操作成功!"}
